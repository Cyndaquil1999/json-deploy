diff --git a/Dockerfile b/Dockerfile
index 9f91b950..34c25f8e 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,4 +1,4 @@
-FROM denoland/deno:alpine-1.14.1
+FROM denoland/deno:alpine-1.16.0
 WORKDIR /app
 
 # Install wait utility
diff --git a/README.md b/README.md
index d3097753..950464a3 100644
--- a/README.md
+++ b/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 [![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)](https://deno-postgres.com)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.13.0/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.14.0/mod.ts)
 [![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)](LICENSE)
 
 A lightweight PostgreSQL driver for Deno focused on user experience
@@ -58,8 +58,10 @@ For more examples visit the documentation available at
 
 Sadly, establishing a TLS connection in the way Postgres requires it isn't
 possible without the `Deno.startTls` API, which is currently marked as unstable.
-This is a situation that will be solved once this API is stabilized, however I
-don't have an estimated time of when that might happen.
+
+At least that was the situation before Deno 1.16, which stabilized the required
+API making it possible to use the library without requiring `--unstable`. Users
+are urged to upgrade to Deno 1.16 or above to enjoy this feature
 
 ## Documentation
 
@@ -148,18 +150,21 @@ a local testing environment, as shown in the following steps:
 
 ## Deno compatibility
 
-Due to a not intended breaking change in Deno 1.9.0, two versions of
-`deno-postgres` require a specific version of Deno in order to work correctly,
-the following is a compatibility table that ranges from Deno 1.8 to Deno 1.9 and
-above indicating possible compatibility problems
+Due to breaking changes introduced in the unstable APIs `deno-postgres` uses,
+there has been some fragmentation regarding what versions of Deno can be used
+alongside the library
+
+This situation will become more stable as `std` and `deno-postgres` approach 1.0
 
 | Deno version  | Min driver version | Max driver version |
 | ------------- | ------------------ | ------------------ |
 | 1.8.x         | 0.5.0              | 0.10.0             |
 | 1.9.0         | 0.11.0             | 0.11.1             |
 | 1.9.1 and up  | 0.11.2             | 0.11.3             |
-| 1.11.0 and up | 0.12.0             | 0.13.0             |
-| 1.14.x        | 0.13.0             |                    |
+| 1.11.0 and up | 0.12.0             | 0.12.0             |
+| 1.14.0 and up | 0.13.0             | 0.13.0             |
+| 1.15.0        | 0.13.0             |                    |
+| 1.16.0        | 0.14.0             |                    |
 
 ## Contributing guidelines
 
diff --git a/connection/connection.ts b/connection/connection.ts
index 456a97d4..11951058 100644
--- a/connection/connection.ts
+++ b/connection/connection.ts
@@ -227,7 +227,7 @@ export class Connection {
 
   async #createTlsConnection(
     connection: Deno.Conn,
-    options: { hostname: string; certFile?: string },
+    options: { hostname: string; caCerts: string[] },
   ) {
     if ("startTls" in Deno) {
       // @ts-ignore This API should be available on unstable
@@ -272,7 +272,7 @@ export class Connection {
       tls: {
         enabled: tls_enabled,
         enforce: tls_enforced,
-        caFile,
+        caCertificates,
       },
     } = this.#connection_params;
 
@@ -294,7 +294,7 @@ export class Connection {
         try {
           await this.#createTlsConnection(this.#conn, {
             hostname,
-            certFile: caFile,
+            caCerts: caCertificates,
           });
           this.#tls = true;
         } catch (e) {
diff --git a/connection/connection_params.ts b/connection/connection_params.ts
index ca0d59fd..e10d2336 100644
--- a/connection/connection_params.ts
+++ b/connection/connection_params.ts
@@ -47,19 +47,26 @@ export interface TLSOptions {
   /**
    * If TLS support is enabled or not. If the server requires TLS,
    * the connection will fail.
+   *
+   * Default: `true`
    */
   enabled: boolean;
   /**
    * This will force the connection to run over TLS
    * If the server doesn't support TLS, the connection will fail
    *
-   * default: `false`
+   * Default: `false`
    */
   enforce: boolean;
   /**
-   * A custom CA file to use for the TLS connection to the server.
+   * A list of root certificates that will be used in addition to the default
+   * root certificates to verify the server's certificate.
+   *
+   * Must be in PEM format.
+   *
+   * Default: `[]`
    */
-  caFile?: string;
+  caCertificates: string[];
 }
 
 export interface ClientOptions {
@@ -135,7 +142,7 @@ function parseOptionsFromDsn(connString: string): ClientOptions {
     );
   }
 
-  let tls: TLSOptions = { enabled: true, enforce: false };
+  let tls: TLSOptions = { enabled: true, enforce: false, caCertificates: [] };
   if (dsn.params.sslmode) {
     const sslmode = dsn.params.sslmode;
     delete dsn.params.sslmode;
@@ -147,11 +154,11 @@ function parseOptionsFromDsn(connString: string): ClientOptions {
     }
 
     if (sslmode === "require") {
-      tls = { enabled: true, enforce: true };
+      tls = { enabled: true, enforce: true, caCertificates: [] };
     }
 
     if (sslmode === "disable") {
-      tls = { enabled: false, enforce: false };
+      tls = { enabled: false, enforce: false, caCertificates: [] };
     }
   }
 
@@ -172,6 +179,7 @@ const DEFAULT_OPTIONS: Omit<ClientConfiguration, "database" | "user"> = {
   tls: {
     enabled: true,
     enforce: false,
+    caCertificates: [],
   },
 };
 
@@ -233,7 +241,7 @@ export function createParams(
     tls: {
       enabled: tls_enabled,
       enforce: tls_enforced,
-      caFile: params?.tls?.caFile,
+      caCertificates: params?.tls?.caCertificates ?? [],
     },
     user: params.user ?? pgEnv.user,
   };
diff --git a/deps.ts b/deps.ts
index 233bb1a0..a1bc6d6f 100644
--- a/deps.ts
+++ b/deps.ts
@@ -1,11 +1,12 @@
+export * as base64 from "https://deno.land/std@0.114.0/encoding/base64.ts";
+export * as date from "https://deno.land/std@0.114.0/datetime/mod.ts";
 export {
   BufReader,
   BufWriter,
-} from "https://deno.land/std@0.108.0/io/bufio.ts";
-export { copy } from "https://deno.land/std@0.108.0/bytes/mod.ts";
-export { createHash } from "https://deno.land/std@0.108.0/hash/mod.ts";
-export { HmacSha256 } from "https://deno.land/std@0.108.0/hash/sha256.ts";
-export * as base64 from "https://deno.land/std@0.108.0/encoding/base64.ts";
-export { deferred, delay } from "https://deno.land/std@0.108.0/async/mod.ts";
-export type { Deferred } from "https://deno.land/std@0.108.0/async/mod.ts";
-export { bold, yellow } from "https://deno.land/std@0.108.0/fmt/colors.ts";
+} from "https://deno.land/std@0.114.0/io/buffer.ts";
+export { copy } from "https://deno.land/std@0.114.0/bytes/mod.ts";
+export { createHash } from "https://deno.land/std@0.114.0/hash/mod.ts";
+export { HmacSha256 } from "https://deno.land/std@0.114.0/hash/sha256.ts";
+export { deferred, delay } from "https://deno.land/std@0.114.0/async/mod.ts";
+export type { Deferred } from "https://deno.land/std@0.114.0/async/mod.ts";
+export { bold, yellow } from "https://deno.land/std@0.114.0/fmt/colors.ts";
diff --git a/docs/README.md b/docs/README.md
index d6d7e84e..c0e98e73 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 ![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.13.0/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.14.0/mod.ts)
 ![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)
 
 `deno-postgres` is a lightweight PostgreSQL driver for Deno focused on user
@@ -60,7 +60,7 @@ config = {
 
 // Alternatively you can use a connection string
 config =
-  "postgres://user:password@localhost:5432/test?application_name=my_custom_app&sslmode=required";
+  "postgres://user:password@localhost:5432/test?application_name=my_custom_app&sslmode=require";
 
 const client = new Client(config);
 await client.connect();
@@ -199,10 +199,10 @@ There is a miriad of factors you have to take into account when using a
 certificate to encrypt your connection that, if not taken care of, can render
 your certificate invalid.
 
-When using a self signed certificate, make sure to specify the path to the CA
-certificate in the `tls.caFile` option when creating the Postgres `Client`, or
-using the `--cert` option when starting Deno. The latter approach only works for
-Deno 1.12.2 or later.
+When using a self signed certificate, make sure to specify the PEM encoded CA
+certificate in the `tls.caCertificates` option when creating the Postgres
+`Client` (Deno 1.15.0 later), or using the `--cert` option when starting Deno
+(Deno 1.12.2 or later).
 
 TLS can be disabled from your server by editing your `postgresql.conf` file and
 setting the `ssl` option to `off`, or in the driver side by using the "disabled"
diff --git a/query/decode.ts b/query/decode.ts
index b33ee839..c8a1f7f0 100644
--- a/query/decode.ts
+++ b/query/decode.ts
@@ -111,7 +111,7 @@ function decodeText(value: Uint8Array, typeOid: number): any {
     case Oid.text_array:
     case Oid.time_array:
     case Oid.timetz_array:
-    case Oid.uuid_varchar:
+    case Oid.uuid_array:
     case Oid.varchar_array:
       return decodeStringArray(strValue);
     case Oid.int2:
diff --git a/query/decoders.ts b/query/decoders.ts
index b9906bba..cbe33e95 100644
--- a/query/decoders.ts
+++ b/query/decoders.ts
@@ -1,3 +1,4 @@
+import { date } from "../deps.ts";
 import { parseArray } from "./array_parser.ts";
 import {
   Box,
@@ -16,7 +17,6 @@ import {
 // Copyright (c) Ben Drucker <bvdrucker@gmail.com> (bendrucker.me). MIT License.
 const BACKSLASH_BYTE_VALUE = 92;
 const BC_RE = /BC$/;
-const DATE_RE = /^(\d{1,})-(\d{2})-(\d{2})$/;
 const DATETIME_RE =
   /^(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?/;
 const HEX = 16;
@@ -127,23 +127,7 @@ export function decodeDate(dateStr: string): Date | number {
     return Number(-Infinity);
   }
 
-  const matches = DATE_RE.exec(dateStr);
-
-  if (!matches) {
-    throw new Error(`"${dateStr}" could not be parsed to date`);
-  }
-
-  const year = parseInt(matches[1], 10);
-  // remember JS dates are 0-based
-  const month = parseInt(matches[2], 10) - 1;
-  const day = parseInt(matches[3], 10);
-  const date = new Date(year, month, day);
-  // use `setUTCFullYear` because if date is from first
-  // century `Date`'s compatibility for millenium bug
-  // would set it as 19XX
-  date.setUTCFullYear(year);
-
-  return date;
+  return date.parse(dateStr, "yyyy-MM-dd");
 }
 
 export function decodeDateArray(value: string) {
diff --git a/query/oid.ts b/query/oid.ts
index 1c754427..29fc63e5 100644
--- a/query/oid.ts
+++ b/query/oid.ts
@@ -128,7 +128,7 @@ export const Oid = {
   _pg_auth_members: 2843,
   _txid_snapshot_0: 2949,
   uuid: 2950,
-  uuid_varchar: 2951,
+  uuid_array: 2951,
   _txid_snapshot_1: 2970,
   _fdw_handler: 3115,
   _pg_lsn_0: 3220,
diff --git a/query/query.ts b/query/query.ts
index a7097d9b..3cc31d85 100644
--- a/query/query.ts
+++ b/query/query.ts
@@ -50,16 +50,25 @@ export interface QueryConfig {
   text: string;
 }
 
+// TODO
+// Support multiple case options
 export interface QueryObjectConfig extends QueryConfig {
   /**
-   * This parameter superseeds query column names
-   *
-   * When specified, this names will be asigned to the results
-   * of the query in the order they were provided
+   * Enabling camelcase will transform any snake case field names coming from the database into camel case ones
    *
-   * Fields must be unique and be in the range of (a-zA-Z0-9_), otherwise the query will throw before execution
+   * Ex: `SELECT 1 AS my_field` will return `{ myField: 1 }`
    *
+   * This won't have any effect if you explicitly set the field names with the `fields` parameter
+   */
+  camelcase?: boolean;
+  /**
+   * This parameter supersedes query column names coming from the databases in the order they were provided.
+   * Fields must be unique and be in the range of (a-zA-Z0-9_), otherwise the query will throw before execution.
    * A field can not start with a number, just like JavaScript variables
+   *
+   * This setting overrides the camelcase option
+   *
+   * Ex: `SELECT 'A', 'B' AS my_field` with fields `["field_1", "field_2"]` will return `{ field_1: "A", field_2: "B" }`
    */
   fields?: string[];
 }
@@ -146,6 +155,22 @@ export class QueryArrayResult<T extends Array<unknown> = Array<unknown>>
   }
 }
 
+function snakecaseToCamelcase(input: string) {
+  return input
+    .split("_")
+    .reduce(
+      (res, word, i) =>
+        i === 0
+          ? word.toLowerCase()
+          : `${res}${word.charAt(0).toUpperCase()}${
+            word
+              .substr(1)
+              .toLowerCase()
+          }`,
+      "",
+    );
+}
+
 export class QueryObjectResult<
   T = Record<string, unknown>,
 > extends QueryResult {
@@ -175,7 +200,12 @@ export class QueryObjectResult<
 
         // Find the field name provided by the user
         // default to database provided name
-        const name = this.query.fields?.[index] ?? column.name;
+        let name = this.query.fields?.[index];
+        if (name === undefined) {
+          name = this.query.camelcase
+            ? snakecaseToCamelcase(column.name)
+            : column.name;
+        }
 
         if (raw_value === null) {
           row[name] = null;
@@ -194,10 +224,10 @@ export class QueryObjectResult<
 
 export class Query<T extends ResultType> {
   public args: EncodedArg[];
+  public camelcase?: boolean;
   public fields?: string[];
   public result_type: ResultType;
   public text: string;
-
   constructor(config: QueryObjectConfig, result_type: T);
   constructor(text: string, result_type: T, ...args: unknown[]);
   constructor(
@@ -213,30 +243,32 @@ export class Query<T extends ResultType> {
     } else {
       const {
         fields,
+        camelcase,
         ...query_config
       } = config_or_text;
 
       // Check that the fields passed are valid and can be used to map
       // the result of the query
       if (fields) {
-        const clean_fields = fields.filter((field) =>
+        const fields_are_clean = fields.every((field) =>
           /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(field)
         );
-        if (fields.length !== clean_fields.length) {
+        if (!fields_are_clean) {
           throw new TypeError(
             "The fields provided for the query must contain only letters and underscores",
           );
         }
 
-        if ((new Set(clean_fields)).size !== clean_fields.length) {
+        if (new Set(fields).size !== fields.length) {
           throw new TypeError(
             "The fields provided for the query must be unique",
           );
         }
 
-        this.fields = clean_fields;
+        this.fields = fields;
       }
 
+      this.camelcase = camelcase;
       config = query_config;
     }
     this.text = config.text;
diff --git a/tests/config.ts b/tests/config.ts
index efef8ed1..1f93c740 100644
--- a/tests/config.ts
+++ b/tests/config.ts
@@ -1,5 +1,4 @@
 import { ClientOptions } from "../connection/connection_params.ts";
-import { fromFileUrl } from "./test_deps.ts";
 
 type ConfigFileConnection = Pick<
   ClientOptions,
@@ -38,7 +37,11 @@ const config = Deno.env.get("DENO_POSTGRES_DEVELOPMENT") === "true"
   : config_file.ci;
 
 const enabled_tls = {
-  caFile: fromFileUrl(new URL("../docker/certs/ca.crt", import.meta.url)),
+  caCertificates: [
+    Deno.readTextFileSync(
+      new URL("../docker/certs/ca.crt", import.meta.url),
+    ),
+  ],
   enabled: true,
   enforce: true,
 };
diff --git a/tests/data_types_test.ts b/tests/data_types_test.ts
index e51a1750..5652bd29 100644
--- a/tests/data_types_test.ts
+++ b/tests/data_types_test.ts
@@ -1,4 +1,4 @@
-import { assertEquals, base64, formatDate, parseDate } from "./test_deps.ts";
+import { assertEquals, base64, date } from "./test_deps.ts";
 import { getMainConfiguration } from "./config.ts";
 import { generateSimpleClientTest } from "./helpers.ts";
 import {
@@ -42,7 +42,8 @@ function randomBase64(): string {
   );
 }
 
-const timezone = new Date().toTimeString().slice(12, 17);
+const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
+const timezone_utc = new Date().toTimeString().slice(12, 17);
 
 const testClient = generateSimpleClientTest(getMainConfiguration());
 
@@ -813,7 +814,7 @@ Deno.test(
   "timetz",
   testClient(async (client) => {
     const result = await client.queryArray<[string]>(
-      `SELECT '01:01:01${timezone}'::TIMETZ`,
+      `SELECT '01:01:01${timezone_utc}'::TIMETZ`,
     );
 
     assertEquals(result.rows[0][0].slice(0, 8), "01:01:01");
@@ -824,7 +825,7 @@ Deno.test(
   "timetz array",
   testClient(async (client) => {
     const result = await client.queryArray<[string]>(
-      `SELECT ARRAY['01:01:01${timezone}'::TIMETZ]`,
+      `SELECT ARRAY['01:01:01${timezone_utc}'::TIMETZ]`,
     );
 
     assertEquals(typeof result.rows[0][0][0], "string");
@@ -922,6 +923,7 @@ Deno.test(
 Deno.test(
   "date",
   testClient(async (client) => {
+    await client.queryArray(`SET SESSION TIMEZONE TO '${timezone}'`);
     const date_text = "2020-01-01";
 
     const result = await client.queryArray<[Timestamp, Timestamp]>(
@@ -930,7 +932,7 @@ Deno.test(
     );
 
     assertEquals(result.rows[0], [
-      parseDate(date_text, "yyyy-MM-dd"),
+      date.parse(date_text, "yyyy-MM-dd"),
       Infinity,
     ]);
   }),
@@ -939,7 +941,8 @@ Deno.test(
 Deno.test(
   "date array",
   testClient(async (client) => {
-    const dates = ["2020-01-01", formatDate(new Date(), "yyyy-MM-dd")];
+    await client.queryArray(`SET SESSION TIMEZONE TO '${timezone}'`);
+    const dates = ["2020-01-01", date.format(new Date(), "yyyy-MM-dd")];
 
     const result = await client.queryArray<[Timestamp, Timestamp]>(
       "SELECT ARRAY[$1::DATE, $2]",
@@ -948,7 +951,7 @@ Deno.test(
 
     assertEquals(
       result.rows[0][0],
-      dates.map((date) => parseDate(date, "yyyy-MM-dd")),
+      dates.map((d) => date.parse(d, "yyyy-MM-dd")),
     );
   }),
 );
diff --git a/tests/query_client_test.ts b/tests/query_client_test.ts
index d33a7a02..193cd7b9 100644
--- a/tests/query_client_test.ts
+++ b/tests/query_client_test.ts
@@ -489,7 +489,47 @@ testClient("Query array with template string", async function (generateClient) {
 });
 
 testClient(
-  "Object query are mapped to user provided fields",
+  "Object query field names aren't transformed when camelcase is disabled",
+  async function (generateClient) {
+    const client = await generateClient();
+    const record = {
+      pos_x: "100",
+      pos_y: "200",
+      prefix_name_suffix: "square",
+    };
+
+    const { rows: result } = await client.queryObject({
+      args: [record.pos_x, record.pos_y, record.prefix_name_suffix],
+      camelcase: false,
+      text: "SELECT $1 AS POS_X, $2 AS POS_Y, $3 AS PREFIX_NAME_SUFFIX",
+    });
+
+    assertEquals(result[0], record);
+  },
+);
+
+testClient(
+  "Object query field names are transformed when camelcase is enabled",
+  async function (generateClient) {
+    const client = await generateClient();
+    const record = {
+      posX: "100",
+      posY: "200",
+      prefixNameSuffix: "point",
+    };
+
+    const { rows: result } = await client.queryObject({
+      args: [record.posX, record.posY, record.prefixNameSuffix],
+      camelcase: true,
+      text: "SELECT $1 AS POS_X, $2 AS POS_Y, $3 AS PREFIX_NAME_SUFFIX",
+    });
+
+    assertEquals(result[0], record);
+  },
+);
+
+testClient(
+  "Object query result is mapped to explicit fields",
   async function (generateClient) {
     const client = await generateClient();
 
@@ -503,7 +543,25 @@ testClient(
 );
 
 testClient(
-  "Object query throws if user provided fields aren't unique",
+  "Object query explicit fields override camelcase",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    const record = { field_1: "A", field_2: "B", field_3: "C" };
+
+    const { rows: result } = await client.queryObject({
+      args: [record.field_1, record.field_2, record.field_3],
+      camelcase: true,
+      fields: ["field_1", "field_2", "field_3"],
+      text: "SELECT $1 AS POS_X, $2 AS POS_Y, $3 AS PREFIX_NAME_SUFFIX",
+    });
+
+    assertEquals(result[0], record);
+  },
+);
+
+testClient(
+  "Object query throws if explicit fields aren't unique",
   async function (generateClient) {
     const client = await generateClient();
 
@@ -520,9 +578,8 @@ testClient(
   },
 );
 
-// Regression test
 testClient(
-  "Object query doesn't throw provided fields only have one letter",
+  "Object query doesn't throw when explicit fields only have one letter",
   async function (generateClient) {
     const client = await generateClient();
 
@@ -550,7 +607,7 @@ testClient(
 );
 
 testClient(
-  "Object query throws if user provided fields aren't valid",
+  "Object query throws if explicit fields aren't valid",
   async function (generateClient) {
     const client = await generateClient();
 
@@ -590,7 +647,7 @@ testClient(
 );
 
 testClient(
-  "Object query throws if result columns don't match the user provided fields",
+  "Object query throws if result columns don't match explicit fields",
   async function (generateClient) {
     const client = await generateClient();
 
diff --git a/tests/test_deps.ts b/tests/test_deps.ts
index 1d29db67..f19dab91 100644
--- a/tests/test_deps.ts
+++ b/tests/test_deps.ts
@@ -6,9 +6,5 @@ export {
   assertObjectMatch,
   assertThrows,
   assertThrowsAsync,
-} from "https://deno.land/std@0.108.0/testing/asserts.ts";
-export {
-  format as formatDate,
-  parse as parseDate,
-} from "https://deno.land/std@0.108.0/datetime/mod.ts";
-export { fromFileUrl } from "https://deno.land/std@0.108.0/path/mod.ts";
+} from "https://deno.land/std@0.114.0/testing/asserts.ts";
+export { fromFileUrl } from "https://deno.land/std@0.114.0/path/mod.ts";
