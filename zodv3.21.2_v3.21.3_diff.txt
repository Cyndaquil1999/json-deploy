diff --git a/.github/workflows/release-canary.yml b/.github/workflows/release-canary.yml
index 55f3704fd..61ece30e3 100644
--- a/.github/workflows/release-canary.yml
+++ b/.github/workflows/release-canary.yml
@@ -6,7 +6,7 @@ on:
     branches:
       - "master"
     paths:
-      - "src"
+      - "src/**"
       - ".github/workflows/release-canary.yml"
 jobs:
   build_and_publish:
diff --git a/README.md b/README.md
index d0f0bd4f6..ec988f6ee 100644
--- a/README.md
+++ b/README.md
@@ -2394,6 +2394,58 @@ z.string()
 
 The `.pipe()` method returns a `ZodPipeline` instance.
 
+#### You can use `.pipe()` to fix common issues with `z.coerce`.
+
+You can constrain the input to types that work well with your chosen coercion. Then use `.pipe()` to apply the coercion.
+
+without constrained input:
+```ts
+const toDate = z.coerce.date()
+
+// works intuitively
+console.log(toDate.safeParse('2023-01-01').success) // true
+
+// might not be what you want
+console.log(toDate.safeParse(null).success) // true
+```
+
+with constrained input:
+```ts
+const datelike = z.union([z.number(), z.string(), z.date()])
+const datelikeToDate = datelike.pipe(z.coerce.date())
+
+// still works intuitively
+console.log(datelikeToDate.safeParse('2023-01-01').success) // true
+
+// more likely what you want
+console.log(datelikeToDate.safeParse(null).success) // false
+```
+
+You can also use this technique to avoid coercions that throw uncaught errors.
+
+without constrained input:
+```ts
+const toBigInt = z.coerce.bigint()
+
+// works intuitively
+console.log( toBigInt.safeParse( '42' ) ) // true
+
+// probably not what you want
+console.log( toBigInt.safeParse( null ) ) // throws uncaught error
+```
+
+with constrained input:
+```ts
+const toNumber = z.number().or( z.string() ).pipe( z.coerce.number() )
+const toBigInt = z.bigint().or( toNumber ).pipe( z.coerce.bigint() )
+
+// still works intuitively
+console.log( toBigInt.safeParse( '42' ).success ) // true
+
+// error handled by zod, more likely what you want
+console.log( toBigInt.safeParse( null ).success ) // false
+```
+
 ## Guides and concepts
 
 ### Type inference
diff --git a/deno/lib/README.md b/deno/lib/README.md
index d0f0bd4f6..ec988f6ee 100644
--- a/deno/lib/README.md
+++ b/deno/lib/README.md
@@ -2394,6 +2394,58 @@ z.string()
 
 The `.pipe()` method returns a `ZodPipeline` instance.
 
+#### You can use `.pipe()` to fix common issues with `z.coerce`.
+
+You can constrain the input to types that work well with your chosen coercion. Then use `.pipe()` to apply the coercion.
+
+without constrained input:
+```ts
+const toDate = z.coerce.date()
+
+// works intuitively
+console.log(toDate.safeParse('2023-01-01').success) // true
+
+// might not be what you want
+console.log(toDate.safeParse(null).success) // true
+```
+
+with constrained input:
+```ts
+const datelike = z.union([z.number(), z.string(), z.date()])
+const datelikeToDate = datelike.pipe(z.coerce.date())
+
+// still works intuitively
+console.log(datelikeToDate.safeParse('2023-01-01').success) // true
+
+// more likely what you want
+console.log(datelikeToDate.safeParse(null).success) // false
+```
+
+You can also use this technique to avoid coercions that throw uncaught errors.
+
+without constrained input:
+```ts
+const toBigInt = z.coerce.bigint()
+
+// works intuitively
+console.log( toBigInt.safeParse( '42' ) ) // true
+
+// probably not what you want
+console.log( toBigInt.safeParse( null ) ) // throws uncaught error
+```
+
+with constrained input:
+```ts
+const toNumber = z.number().or( z.string() ).pipe( z.coerce.number() )
+const toBigInt = z.bigint().or( toNumber ).pipe( z.coerce.bigint() )
+
+// still works intuitively
+console.log( toBigInt.safeParse( '42' ).success ) // true
+
+// error handled by zod, more likely what you want
+console.log( toBigInt.safeParse( null ).success ) // false
+```
+
 ## Guides and concepts
 
 ### Type inference
diff --git a/deno/lib/__tests__/catch.test.ts b/deno/lib/__tests__/catch.test.ts
index 935c39681..f8ea89911 100644
--- a/deno/lib/__tests__/catch.test.ts
+++ b/deno/lib/__tests__/catch.test.ts
@@ -222,8 +222,6 @@ test("catch error", () => {
 
 test("ctx.input", () => {
   const schema = z.string().catch((ctx) => {
-    console.log(ctx.input);
-    console.log(ctx.error);
     return String(ctx.input);
   });
 
diff --git a/deno/lib/__tests__/partials.test.ts b/deno/lib/__tests__/partials.test.ts
index 06fb29ba8..1825753a9 100644
--- a/deno/lib/__tests__/partials.test.ts
+++ b/deno/lib/__tests__/partials.test.ts
@@ -185,20 +185,6 @@ test("required with mask", () => {
   expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);
 });
 
-test("required with mask containing a nonexistent key", () => {
-  const object = z.object({
-    name: z.string(),
-    age: z.number().optional(),
-    field: z.string().optional().default("asdf"),
-    country: z.string().optional(),
-  });
-  object.required({
-    age: true,
-    // @ts-expect-error should not accept unexpected keys.
-    doesntExist: true,
-  });
-});
-
 test("required with mask -- ignore falsy values", () => {
   const object = z.object({
     name: z.string(),
@@ -256,21 +242,6 @@ test("partial with mask -- ignore falsy values", async () => {
   await masked.parseAsync({ country: "US" });
 });
 
-test("partial with mask containing a nonexistent key", () => {
-  const object = z.object({
-    name: z.string(),
-    age: z.number().optional(),
-    field: z.string().optional().default("asdf"),
-    country: z.string().optional(),
-  });
-
-  object.partial({
-    age: true,
-    // @ts-expect-error should not accept unexpected keys.
-    doesntExist: true,
-  });
-});
-
 test("deeppartial array", () => {
   const schema = z.object({ array: z.string().array().min(42) }).deepPartial();
 
diff --git a/deno/lib/__tests__/pickomit.test.ts b/deno/lib/__tests__/pickomit.test.ts
index ef2f9c399..f89b01253 100644
--- a/deno/lib/__tests__/pickomit.test.ts
+++ b/deno/lib/__tests__/pickomit.test.ts
@@ -94,33 +94,3 @@ test("nonstrict parsing - fail", () => {
   const bad = () => laxfish.parse({ whatever: "asdf" } as any);
   expect(bad).toThrow();
 });
-
-test("pick a nonexistent key", () => {
-  const schema = z.object({
-    a: z.string(),
-    b: z.number(),
-  });
-
-  const pickedSchema = schema.pick({
-    a: true,
-    // @ts-expect-error should not accept unexpected keys.
-    doesntExist: true,
-  });
-
-  pickedSchema.parse({
-    a: "value",
-  });
-});
-
-test("omit a nonexistent key", () => {
-  const schema = z.object({
-    a: z.string(),
-    b: z.number(),
-  });
-
-  schema.omit({
-    a: true,
-    // @ts-expect-error should not accept unexpected keys.
-    doesntExist: true,
-  });
-});
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index f61e449a3..7b3ee92cb 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -2182,8 +2182,6 @@ export type SomeZodObject = ZodObject<
   ZodTypeAny
 >;
 
-export type objectKeyMask<Obj> = { [k in keyof Obj]?: true };
-
 export type noUnrecognized<Obj extends object, Shape extends object> = {
   [k in keyof Obj]: k extends keyof Shape ? Obj[k] : never;
 };
@@ -2550,8 +2548,8 @@ export class ZodObject<
     }) as any;
   }
 
-  pick<Mask extends objectKeyMask<T>>(
-    mask: noUnrecognized<Mask, T>
+  pick<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
   ): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall> {
     const shape: any = {};
 
@@ -2567,8 +2565,8 @@ export class ZodObject<
     }) as any;
   }
 
-  omit<Mask extends objectKeyMask<T>>(
-    mask: noUnrecognized<Mask, objectKeyMask<T>>
+  omit<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
   ): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall> {
     const shape: any = {};
 
@@ -2596,8 +2594,8 @@ export class ZodObject<
     UnknownKeys,
     Catchall
   >;
-  partial<Mask extends objectKeyMask<T>>(
-    mask: noUnrecognized<Mask, objectKeyMask<T>>
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
   ): ZodObject<
     objectUtil.noNever<{
       [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
@@ -2629,8 +2627,8 @@ export class ZodObject<
     UnknownKeys,
     Catchall
   >;
-  required<Mask extends objectKeyMask<T>>(
-    mask: noUnrecognized<Mask, objectKeyMask<T>>
+  required<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
   ): ZodObject<
     objectUtil.noNever<{
       [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
@@ -4305,10 +4303,7 @@ export class ZodEffects<
           path: ctx.path,
           parent: ctx,
         });
-        // if (base.status === "aborted") return INVALID;
-        // if (base.status === "dirty") {
-        //   return { status: "dirty", value: base.value };
-        // }
+
         if (!isValid(base)) return base;
 
         const result = effect.transform(base.value, checkCtx);
@@ -4324,10 +4319,7 @@ export class ZodEffects<
           ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
           .then((base) => {
             if (!isValid(base)) return base;
-            // if (base.status === "aborted") return INVALID;
-            // if (base.status === "dirty") {
-            //   return { status: "dirty", value: base.value };
-            // }
+
             return Promise.resolve(effect.transform(base.value, checkCtx)).then(
               (result) => ({ status: status.value, value: result })
             );
diff --git a/package.json b/package.json
index e57bdae93..9a44f634a 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.21.2",
+  "version": "3.21.3",
   "author": "Colin McDonnell <colin@colinhacks.com>",
   "repository": {
     "type": "git",
diff --git a/playground.ts b/playground.ts
index d17b18eb4..b22662a96 100644
--- a/playground.ts
+++ b/playground.ts
@@ -1,2 +1,18 @@
 import { z } from "./src";
 z;
+
+const baseCategorySchema = z.object({
+  name: z.string().brand("CategoryName"),
+});
+
+type CategoryInput = z.input<typeof baseCategorySchema> & {
+  subcategories: CategoryInput[];
+};
+type CategoryOutput = z.output<typeof baseCategorySchema> & {
+  subcategories: CategoryOutput[];
+};
+
+const categorySchema: z.ZodType<CategoryOutput, any, CategoryInput> =
+  baseCategorySchema.extend({
+    subcategories: z.lazy(() => categorySchema.array()),
+  });
diff --git a/src/__tests__/catch.test.ts b/src/__tests__/catch.test.ts
index 4586e4742..ae0ebe0a4 100644
--- a/src/__tests__/catch.test.ts
+++ b/src/__tests__/catch.test.ts
@@ -221,8 +221,6 @@ test("catch error", () => {
 
 test("ctx.input", () => {
   const schema = z.string().catch((ctx) => {
-    console.log(ctx.input);
-    console.log(ctx.error);
     return String(ctx.input);
   });
 
diff --git a/src/__tests__/partials.test.ts b/src/__tests__/partials.test.ts
index d716b4471..3186c9f97 100644
--- a/src/__tests__/partials.test.ts
+++ b/src/__tests__/partials.test.ts
@@ -184,20 +184,6 @@ test("required with mask", () => {
   expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);
 });
 
-test("required with mask containing a nonexistent key", () => {
-  const object = z.object({
-    name: z.string(),
-    age: z.number().optional(),
-    field: z.string().optional().default("asdf"),
-    country: z.string().optional(),
-  });
-  object.required({
-    age: true,
-    // @ts-expect-error should not accept unexpected keys.
-    doesntExist: true,
-  });
-});
-
 test("required with mask -- ignore falsy values", () => {
   const object = z.object({
     name: z.string(),
@@ -255,21 +241,6 @@ test("partial with mask -- ignore falsy values", async () => {
   await masked.parseAsync({ country: "US" });
 });
 
-test("partial with mask containing a nonexistent key", () => {
-  const object = z.object({
-    name: z.string(),
-    age: z.number().optional(),
-    field: z.string().optional().default("asdf"),
-    country: z.string().optional(),
-  });
-
-  object.partial({
-    age: true,
-    // @ts-expect-error should not accept unexpected keys.
-    doesntExist: true,
-  });
-});
-
 test("deeppartial array", () => {
   const schema = z.object({ array: z.string().array().min(42) }).deepPartial();
 
diff --git a/src/__tests__/pickomit.test.ts b/src/__tests__/pickomit.test.ts
index 06465d843..d1432c85d 100644
--- a/src/__tests__/pickomit.test.ts
+++ b/src/__tests__/pickomit.test.ts
@@ -93,33 +93,3 @@ test("nonstrict parsing - fail", () => {
   const bad = () => laxfish.parse({ whatever: "asdf" } as any);
   expect(bad).toThrow();
 });
-
-test("pick a nonexistent key", () => {
-  const schema = z.object({
-    a: z.string(),
-    b: z.number(),
-  });
-
-  const pickedSchema = schema.pick({
-    a: true,
-    // @ts-expect-error should not accept unexpected keys.
-    doesntExist: true,
-  });
-
-  pickedSchema.parse({
-    a: "value",
-  });
-});
-
-test("omit a nonexistent key", () => {
-  const schema = z.object({
-    a: z.string(),
-    b: z.number(),
-  });
-
-  schema.omit({
-    a: true,
-    // @ts-expect-error should not accept unexpected keys.
-    doesntExist: true,
-  });
-});
diff --git a/src/types.ts b/src/types.ts
index 1336383ca..81c2dcde5 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -2182,8 +2182,6 @@ export type SomeZodObject = ZodObject<
   ZodTypeAny
 >;
 
-export type objectKeyMask<Obj> = { [k in keyof Obj]?: true };
-
 export type noUnrecognized<Obj extends object, Shape extends object> = {
   [k in keyof Obj]: k extends keyof Shape ? Obj[k] : never;
 };
@@ -2550,8 +2548,8 @@ export class ZodObject<
     }) as any;
   }
 
-  pick<Mask extends objectKeyMask<T>>(
-    mask: noUnrecognized<Mask, T>
+  pick<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
   ): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall> {
     const shape: any = {};
 
@@ -2567,8 +2565,8 @@ export class ZodObject<
     }) as any;
   }
 
-  omit<Mask extends objectKeyMask<T>>(
-    mask: noUnrecognized<Mask, objectKeyMask<T>>
+  omit<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
   ): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall> {
     const shape: any = {};
 
@@ -2596,8 +2594,8 @@ export class ZodObject<
     UnknownKeys,
     Catchall
   >;
-  partial<Mask extends objectKeyMask<T>>(
-    mask: noUnrecognized<Mask, objectKeyMask<T>>
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
   ): ZodObject<
     objectUtil.noNever<{
       [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
@@ -2629,8 +2627,8 @@ export class ZodObject<
     UnknownKeys,
     Catchall
   >;
-  required<Mask extends objectKeyMask<T>>(
-    mask: noUnrecognized<Mask, objectKeyMask<T>>
+  required<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
   ): ZodObject<
     objectUtil.noNever<{
       [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
@@ -4305,10 +4303,7 @@ export class ZodEffects<
           path: ctx.path,
           parent: ctx,
         });
-        // if (base.status === "aborted") return INVALID;
-        // if (base.status === "dirty") {
-        //   return { status: "dirty", value: base.value };
-        // }
+
         if (!isValid(base)) return base;
 
         const result = effect.transform(base.value, checkCtx);
@@ -4324,10 +4319,7 @@ export class ZodEffects<
           ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
           .then((base) => {
             if (!isValid(base)) return base;
-            // if (base.status === "aborted") return INVALID;
-            // if (base.status === "dirty") {
-            //   return { status: "dirty", value: base.value };
-            // }
+
             return Promise.resolve(effect.transform(base.value, checkCtx)).then(
               (result) => ({ status: status.value, value: result })
             );
