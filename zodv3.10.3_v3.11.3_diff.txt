diff --git a/.prettierrc.yaml b/.prettierrc.yaml
new file mode 100644
index 000000000..ac66545cb
--- /dev/null
+++ b/.prettierrc.yaml
@@ -0,0 +1,5 @@
+# .prettierrc or .prettierrc.yaml
+trailingComma: "es5"
+tabWidth: 2
+semi: true
+singleQuote: false
diff --git a/README.md b/README.md
index 74e39285a..3ef8b5058 100644
--- a/README.md
+++ b/README.md
@@ -209,14 +209,18 @@ npm install zod
 
 There are a growing number of tools that are built atop or support Zod natively! If you've built a tool or library on top of Zod, tell me about it [on Twitter](https://twitter.com/colinhacks) or [start a Discussion](https://github.com/colinhacks/zod/discussions). I'll add it below and tweet it out.
 
-- [`tRPC`](https://github.com/trpc/trpc): Build end-to-end typesafe APIs without GraphQL
+- [`tRPC`](https://github.com/trpc/trpc): Build end-to-end typesafe APIs without GraphQL.
 - [`ts-to-zod`](https://github.com/fabien0102/ts-to-zod): Convert TypeScript definitions into Zod schemas.
+- [`@anatine/zod-openapi`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-openapi): Converts a Zod schema to an OpenAPI v3.x `SchemaObject`.
+- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/Marak/Faker.js).
+- [`@anatine/zod-nestjs`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-nestjs): Helper methods for using Zod in a NestJS project.
 - [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.
 - [`zod-fast-check`](https://github.com/DavidTimms/zod-fast-check): Generate `fast-check` arbitraries from Zod schemas.
 - [`zod-endpoints`](https://github.com/flock-community/zod-endpoints): Contract-first strictly typed endpoints with Zod. OpenAPI compatible.
-- [`express-zod-api`](https://github.com/RobinTail/express-zod-api): Build Express-based APIs with I/O schema validation and custom middlewares
+- [`express-zod-api`](https://github.com/RobinTail/express-zod-api): Build Express-based APIs with I/O schema validation and custom middlewares.
 - [`zod-to-json-schema`](https://github.com/StefanTerdell/zod-to-json-schema): Convert your Zod schemas into [JSON Schemas](https://json-schema.org/).
 - [`json-to-zod`](https://github.com/rsinohara/json-to-zod): Convert JSON objects into Zod schemas. Use it live [here](https://rsinohara.github.io/json-to-zod-react/).
+- [`zod-dto`](https://github.com/kbkk/abitia/tree/master/packages/zod-dto): Generate Nest.js DTOs from a Zod schema.
 
 ### Form integrations
 
@@ -521,7 +525,7 @@ You can make any schema optional with `z.optional()`:
 const schema = z.optional(z.string());
 
 schema.parse(undefined); // => returns undefined
-type A = z.infer<typeof A>; // string | undefined
+type A = z.infer<typeof schema>; // string | undefined
 ```
 
 You can make an existing schema optional with the `.optional()` method:
@@ -530,7 +534,7 @@ You can make an existing schema optional with the `.optional()` method:
 const user = z.object({
   username: z.string().optional(),
 });
-type C = z.infer<typeof C>; // { username?: string | undefined };
+type C = z.infer<typeof user>; // { username?: string | undefined };
 ```
 
 #### `.unwrap`
@@ -1430,6 +1434,32 @@ You can add as many issues as you like. If `ctx.addIssue` is NOT called during t
 
 Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` you can create any issue of any code. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).
 
+#### Abort early
+
+By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to _abort early_ to prevent later refinements from being executed. To achieve this, pass the `fatal` flag to `ctx.addIssue`:
+
+```ts
+const Strings = z
+  .number()
+  .superRefine((val, ctx) => {
+    if (val < 10) {
+      ctx.addIssue({
+        code: z.ZodIssueCode.custom,
+        message: "foo",
+        fatal: true,
+      });
+    }
+  })
+  .superRefine((val, ctx) => {
+    if (val !== " ") {
+      ctx.addIssue({
+        code: z.ZodIssueCode.custom,
+        message: "bar",
+      });
+    }
+  });
+```
+
 ### `.transform`
 
 To transform data after parsing, use the `transform` method.
diff --git a/README_ZH.md b/README_ZH.md
index 310fab088..9dfcbbcca 100644
--- a/README_ZH.md
+++ b/README_ZH.md
@@ -634,7 +634,7 @@ const stringOrNumber = z.string().or(z.number());
 const schema = z.optional(z.string());
 
 schema.parse(undefined); // => returns undefined
-type A = z.infer<typeof A>; // string | undefined
+type A = z.infer<typeof schema>; // string | undefined
 ```
 
 你可以用`.optional()`方法使一个现有的模式成为可选的:
@@ -643,7 +643,7 @@ type A = z.infer<typeof A>; // string | undefined
 const user = z.object({
   username: z.string().optional(),
 });
-type C = z.infer<typeof C>; // { username?: string | undefined };
+type C = z.infer<typeof user>; // { username?: string | undefined };
 ```
 
 #### `.unwrap`
diff --git a/coverage.svg b/coverage.svg
index 256dcafe3..d77838c30 100644
--- a/coverage.svg
+++ b/coverage.svg
@@ -1 +1 @@
-<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 94.53%"><title>Coverage: 94.53%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#4c1"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">94.53%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">94.53%</text></g></svg>
\ No newline at end of file
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 95.79%"><title>Coverage: 95.79%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#4c1"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">95.79%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">95.79%</text></g></svg>
\ No newline at end of file
diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index b232a5796..02e66e57f 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -17,15 +17,6 @@ export const ZodIssueCode = util.arrayToEnum([
   "not_multiple_of",
 ]);
 
-export const FATAL_CODES = [
-  ZodIssueCode.invalid_type,
-  ZodIssueCode.invalid_date,
-  ZodIssueCode.invalid_intersection_types,
-  ZodIssueCode.invalid_return_type,
-  ZodIssueCode.invalid_arguments,
-  ZodIssueCode.invalid_enum_value,
-];
-
 export type ZodIssueCode = keyof typeof ZodIssueCode;
 
 export type ZodIssueBase = {
@@ -128,16 +119,15 @@ export const quotelessJson = (obj: any) => {
   return json.replace(/"([^"]+)":/g, "$1:");
 };
 
-export type ZodFormattedError<T> = { _errors: string[] } & (T extends [
-  any,
-  ...any
-]
+export type ZodFormattedError<T> = {
+  _errors: string[];
+} & (T extends [any, ...any[]]
   ? { [K in keyof T]?: ZodFormattedError<T[K]> }
   : T extends any[]
   ? ZodFormattedError<T[number]>[]
   : T extends object
   ? { [K in keyof T]?: ZodFormattedError<T[K]> }
-  : { _errors: string[] });
+  : unknown);
 
 export class ZodError<T = any> extends Error {
   issues: ZodIssue[] = [];
@@ -257,6 +247,7 @@ type stripPath<T extends object> = T extends any
 
 export type IssueData = stripPath<ZodIssueOptionalMessage> & {
   path?: (string | number)[];
+  fatal?: boolean;
 };
 export type MakeErrorData = IssueData;
 
diff --git a/deno/lib/__tests__/error.test.ts b/deno/lib/__tests__/error.test.ts
index f0768963c..5df1f76ee 100644
--- a/deno/lib/__tests__/error.test.ts
+++ b/deno/lib/__tests__/error.test.ts
@@ -285,6 +285,7 @@ test("formatting", () => {
   expect(result2.success).toEqual(false);
   if (!result1.success) {
     const error = result1.error.format();
+
     expect(error._errors).toEqual([]);
     expect(error.inner?._errors).toEqual([]);
     // expect(error.inner?.name?._errors).toEqual(["Invalid input"]);
diff --git a/deno/lib/__tests__/refine.test.ts b/deno/lib/__tests__/refine.test.ts
index 6069f77d7..f2da2c820 100644
--- a/deno/lib/__tests__/refine.test.ts
+++ b/deno/lib/__tests__/refine.test.ts
@@ -155,3 +155,30 @@ test("chained refinements", () => {
   expect(r2.success).toEqual(false);
   if (!r2.success) expect(r2.error.issues.length).toEqual(2);
 });
+
+test("fatal superRefine", () => {
+  const Strings = z
+    .string()
+    .superRefine((val, ctx) => {
+      if (val === "") {
+        ctx.addIssue({
+          code: z.ZodIssueCode.custom,
+          message: "foo",
+          fatal: true,
+        });
+      }
+    })
+    .superRefine((val, ctx) => {
+      if (val !== " ") {
+        ctx.addIssue({
+          code: z.ZodIssueCode.custom,
+          message: "bar",
+        });
+      }
+    });
+
+  const result = Strings.safeParse("");
+
+  expect(result.success).toEqual(false);
+  if (!result.success) expect(result.error.issues.length).toEqual(1);
+});
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index d7a1fdb24..889723997 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -1,4 +1,3 @@
-import { FATAL_CODES } from "./index.ts";
 import { errorUtil } from "./helpers/errorUtil.ts";
 import {
   addIssueToContext,
@@ -115,7 +114,10 @@ export abstract class ZodType<
 
   _processInputParams(
     input: ParseInput
-  ): { status: ParseStatus; ctx: ParseContext } {
+  ): {
+    status: ParseStatus;
+    ctx: ParseContext;
+  } {
     return {
       status: new ParseStatus(),
       ctx: {
@@ -217,7 +219,7 @@ export abstract class ZodType<
   refine<Func extends (arg: Output) => any>(
     check: Func,
     message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
-  ): ZodEffects<this> {
+  ): ZodEffects<this, Output, Input> {
     const getIssueProperties: any = (val: Output) => {
       if (typeof message === "string" || typeof message === "undefined") {
         return { message };
@@ -256,7 +258,7 @@ export abstract class ZodType<
   refinement(
     check: (arg: Output) => any,
     refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
-  ): ZodEffects<this> {
+  ): ZodEffects<this, Output, Input> {
     return this._refinement((val, ctx) => {
       if (!check(val)) {
         ctx.addIssue(
@@ -273,7 +275,7 @@ export abstract class ZodType<
 
   _refinement(
     refinement: RefinementEffect<Output>["refinement"]
-  ): ZodEffects<this> {
+  ): ZodEffects<this, Output, Input> {
     return new ZodEffects({
       schema: this,
       typeName: ZodFirstPartyTypeKind.ZodEffects,
@@ -2905,7 +2907,7 @@ export class ZodEffects<
       const checkCtx: RefinementCtx = {
         addIssue: (arg: IssueData) => {
           addIssueToContext(ctx, arg);
-          if (FATAL_CODES.includes(arg.code)) {
+          if (arg.fatal) {
             status.abort();
           } else {
             status.dirty();
diff --git a/package.json b/package.json
index 000500c88..a9b4f151b 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.10.3",
+  "version": "3.11.2",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./lib/index.d.ts",
diff --git a/src/ZodError.ts b/src/ZodError.ts
index bea079456..5d187ec0e 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -17,15 +17,6 @@ export const ZodIssueCode = util.arrayToEnum([
   "not_multiple_of",
 ]);
 
-export const FATAL_CODES = [
-  ZodIssueCode.invalid_type,
-  ZodIssueCode.invalid_date,
-  ZodIssueCode.invalid_intersection_types,
-  ZodIssueCode.invalid_return_type,
-  ZodIssueCode.invalid_arguments,
-  ZodIssueCode.invalid_enum_value,
-];
-
 export type ZodIssueCode = keyof typeof ZodIssueCode;
 
 export type ZodIssueBase = {
@@ -128,16 +119,15 @@ export const quotelessJson = (obj: any) => {
   return json.replace(/"([^"]+)":/g, "$1:");
 };
 
-export type ZodFormattedError<T> = { _errors: string[] } & (T extends [
-  any,
-  ...any
-]
+export type ZodFormattedError<T> = {
+  _errors: string[];
+} & (T extends [any, ...any[]]
   ? { [K in keyof T]?: ZodFormattedError<T[K]> }
   : T extends any[]
   ? ZodFormattedError<T[number]>[]
   : T extends object
   ? { [K in keyof T]?: ZodFormattedError<T[K]> }
-  : { _errors: string[] });
+  : unknown);
 
 export class ZodError<T = any> extends Error {
   issues: ZodIssue[] = [];
@@ -257,6 +247,7 @@ type stripPath<T extends object> = T extends any
 
 export type IssueData = stripPath<ZodIssueOptionalMessage> & {
   path?: (string | number)[];
+  fatal?: boolean;
 };
 export type MakeErrorData = IssueData;
 
diff --git a/src/__tests__/error.test.ts b/src/__tests__/error.test.ts
index cf5a0ba1c..5bc649808 100644
--- a/src/__tests__/error.test.ts
+++ b/src/__tests__/error.test.ts
@@ -284,6 +284,7 @@ test("formatting", () => {
   expect(result2.success).toEqual(false);
   if (!result1.success) {
     const error = result1.error.format();
+
     expect(error._errors).toEqual([]);
     expect(error.inner?._errors).toEqual([]);
     // expect(error.inner?.name?._errors).toEqual(["Invalid input"]);
diff --git a/src/__tests__/refine.test.ts b/src/__tests__/refine.test.ts
index 512f4f85d..d54b0fbb1 100644
--- a/src/__tests__/refine.test.ts
+++ b/src/__tests__/refine.test.ts
@@ -154,3 +154,30 @@ test("chained refinements", () => {
   expect(r2.success).toEqual(false);
   if (!r2.success) expect(r2.error.issues.length).toEqual(2);
 });
+
+test("fatal superRefine", () => {
+  const Strings = z
+    .string()
+    .superRefine((val, ctx) => {
+      if (val === "") {
+        ctx.addIssue({
+          code: z.ZodIssueCode.custom,
+          message: "foo",
+          fatal: true,
+        });
+      }
+    })
+    .superRefine((val, ctx) => {
+      if (val !== " ") {
+        ctx.addIssue({
+          code: z.ZodIssueCode.custom,
+          message: "bar",
+        });
+      }
+    });
+
+  const result = Strings.safeParse("");
+
+  expect(result.success).toEqual(false);
+  if (!result.success) expect(result.error.issues.length).toEqual(1);
+});
diff --git a/src/types.ts b/src/types.ts
index 078c64b70..be5a030b0 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -1,4 +1,3 @@
-import { FATAL_CODES } from ".";
 import { errorUtil } from "./helpers/errorUtil";
 import {
   addIssueToContext,
@@ -115,7 +114,10 @@ export abstract class ZodType<
 
   _processInputParams(
     input: ParseInput
-  ): { status: ParseStatus; ctx: ParseContext } {
+  ): {
+    status: ParseStatus;
+    ctx: ParseContext;
+  } {
     return {
       status: new ParseStatus(),
       ctx: {
@@ -217,7 +219,7 @@ export abstract class ZodType<
   refine<Func extends (arg: Output) => any>(
     check: Func,
     message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
-  ): ZodEffects<this> {
+  ): ZodEffects<this, Output, Input> {
     const getIssueProperties: any = (val: Output) => {
       if (typeof message === "string" || typeof message === "undefined") {
         return { message };
@@ -256,7 +258,7 @@ export abstract class ZodType<
   refinement(
     check: (arg: Output) => any,
     refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
-  ): ZodEffects<this> {
+  ): ZodEffects<this, Output, Input> {
     return this._refinement((val, ctx) => {
       if (!check(val)) {
         ctx.addIssue(
@@ -273,7 +275,7 @@ export abstract class ZodType<
 
   _refinement(
     refinement: RefinementEffect<Output>["refinement"]
-  ): ZodEffects<this> {
+  ): ZodEffects<this, Output, Input> {
     return new ZodEffects({
       schema: this,
       typeName: ZodFirstPartyTypeKind.ZodEffects,
@@ -2905,7 +2907,7 @@ export class ZodEffects<
       const checkCtx: RefinementCtx = {
         addIssue: (arg: IssueData) => {
           addIssueToContext(ctx, arg);
-          if (FATAL_CODES.includes(arg.code)) {
+          if (arg.fatal) {
             status.abort();
           } else {
             status.dirty();
