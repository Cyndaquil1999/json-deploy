diff --git a/.github/workflows/test.yml b/.github/workflows/test.yml
index 2f2744596..0e6e5c217 100644
--- a/.github/workflows/test.yml
+++ b/.github/workflows/test.yml
@@ -14,7 +14,7 @@ jobs:
     strategy:
       matrix:
         node: ["18"]
-        typescript: ["4.5", "4.6", "4.7", "4.8", "4.9"]
+        typescript: ["4.5", "4.6", "4.7", "4.8", "4.9", "5.0"]
     name: Test with TypeScript ${{ matrix.typescript }} on Node ${{ matrix.node }}
     steps:
       - uses: actions/checkout@v2
@@ -26,7 +26,6 @@ jobs:
       - run: yarn build
       - run: yarn test
 
-
   test-deno:
     runs-on: ubuntu-latest
     strategy:
diff --git a/.gitignore b/.gitignore
index 2693009b4..943316dea 100644
--- a/.gitignore
+++ b/.gitignore
@@ -11,3 +11,4 @@ deno/lib/playground.ts
 .eslintcache
 workspace.code-workspace
 .netlify
+bun.lockb
diff --git a/ERROR_HANDLING.md b/ERROR_HANDLING.md
index 5bd9de3b0..027176d45 100644
--- a/ERROR_HANDLING.md
+++ b/ERROR_HANDLING.md
@@ -95,7 +95,7 @@ const person = z.object({
   address: z.object({
     line1: z.string(),
     zipCode: z.number().min(10000), // American 5-digit code
-  }),
+  }).strict(); // do not allow unrecognized keys
 });
 ```
 
diff --git a/README.md b/README.md
index ec988f6ee..d913ed9b4 100644
--- a/README.md
+++ b/README.md
@@ -45,20 +45,32 @@
 
 #### Go to [zod.js.org](https://zod.js.org) >> -->
 
+- [Table of contents](#table-of-contents)
 - [Introduction](#introduction)
   - [Sponsors](#sponsors)
+    - [Gold](#gold)
+    - [Silver](#silver)
+    - [Bronze](#bronze)
   - [Ecosystem](#ecosystem)
+    - [Resources](#resources)
+    - [API libraries](#api-libraries)
+    - [Form integrations](#form-integrations)
+    - [Zod to X](#zod-to-x)
+    - [X to Zod](#x-to-zod)
+    - [Mocking](#mocking)
+    - [Powered by Zod](#powered-by-zod)
+    - [Utilities for Zod](#utilities-for-zod)
 - [Installation](#installation)
   - [Requirements](#requirements)
-  - [Node/npm](#from-npm-nodebun)
-  - [Deno](#from-denolandx-deno)
+  - [From `npm` (Node/Bun)](#from-npm-nodebun)
+  - [From `deno.land/x` (Deno)](#from-denolandx-deno)
 - [Basic usage](#basic-usage)
 - [Primitives](#primitives)
 - [Coercion for primitives](#coercion-for-primitives)
 - [Literals](#literals)
 - [Strings](#strings)
-  - [Datetime](#datetime-validation)
-  - [IP](#ip-address-validation)
+  - [ISO datetimes](#iso-datetimes)
+  - [IP addresses](#ip-addresses)
 - [Numbers](#numbers)
 - [BigInts](#bigints)
 - [NaNs](#nans)
@@ -69,59 +81,75 @@
 - [Optionals](#optionals)
 - [Nullables](#nullables)
 - [Objects](#objects)
-  - [.shape](#shape)
-  - [.keyof](#keyof)
-  - [.extend](#extend)
-  - [.merge](#merge)
-  - [.pick/.omit](#pickomit)
-  - [.partial](#partial)
-  - [.deepPartial](#deepPartial)
-  - [.passthrough](#passthrough)
-  - [.strict](#strict)
-  - [.strip](#strip)
-  - [.catchall](#catchall)
+  - [`.shape`](#shape)
+  - [`.keyof`](#keyof)
+  - [`.extend`](#extend)
+  - [`.merge`](#merge)
+  - [`.pick/.omit`](#pickomit)
+  - [`.partial`](#partial)
+  - [`.deepPartial`](#deeppartial)
+  - [`.required`](#required)
+  - [`.passthrough`](#passthrough)
+  - [`.strict`](#strict)
+  - [`.strip`](#strip)
+  - [`.catchall`](#catchall)
 - [Arrays](#arrays)
-  - [.element](#element)
-  - [.nonempty](#nonempty)
-  - [.min/.max/.length](#minmaxlength)
+  - [`.element`](#element)
+  - [`.nonempty`](#nonempty)
+  - [`.min/.max/.length`](#minmaxlength)
 - [Tuples](#tuples)
 - [Unions](#unions)
-- [Discriminated Unions](#discriminated-unions)
+- [Discriminated unions](#discriminated-unions)
 - [Records](#records)
+  - [Record key type](#record-key-type)
 - [Maps](#maps)
 - [Sets](#sets)
 - [Intersections](#intersections)
 - [Recursive types](#recursive-types)
+  - [ZodType with ZodEffects](#zodtype-with-zodeffects)
   - [JSON type](#json-type)
-  - [Cyclical data](#cyclical-objects)
+  - [Cyclical objects](#cyclical-objects)
 - [Promises](#promises)
 - [Instanceof](#instanceof)
 - [Functions](#functions)
 - [Preprocess](#preprocess)
-- [Custom](#custom-schemas)
+- [Custom schemas](#custom-schemas)
 - [Schema methods](#schema-methods)
-  - [.parse](#parse)
-  - [.parseAsync](#parseasync)
-  - [.safeParse](#safeparse)
-  - [.safeParseAsync](#safeparseasync)
-  - [.refine](#refine)
-  - [.superRefine](#superRefine)
-  - [.transform](#transform)
-  - [.default](#default)
-  - [.describe](#describe)
-  - [.catch](#catch)
-  - [.optional](#optional)
-  - [.nullable](#nullable)
-  - [.nullish](#nullish)
-  - [.array](#array)
-  - [.promise](#promise)
-  - [.or](#or)
-  - [.and](#and)
-  - [.brand](#brand)
-  - [.pipe](#pipe)
+  - [`.parse`](#parse)
+  - [`.parseAsync`](#parseasync)
+  - [`.safeParse`](#safeparse)
+  - [`.safeParseAsync`](#safeparseasync)
+  - [`.refine`](#refine)
+    - [Arguments](#arguments)
+    - [Customize error path](#customize-error-path)
+    - [Asynchronous refinements](#asynchronous-refinements)
+    - [Relationship to transforms](#relationship-to-transforms)
+  - [`.superRefine`](#superrefine)
+    - [Abort early](#abort-early)
+    - [Type refinements](#type-refinements)
+  - [`.transform`](#transform)
+    - [Chaining order](#chaining-order)
+    - [Validating during transform](#validating-during-transform)
+    - [Relationship to refinements](#relationship-to-refinements)
+    - [Async transforms](#async-transforms)
+  - [`.default`](#default)
+  - [`.describe`](#describe)
+  - [`.catch`](#catch)
+  - [`.optional`](#optional)
+  - [`.nullable`](#nullable)
+  - [`.nullish`](#nullish)
+  - [`.array`](#array)
+  - [`.promise`](#promise)
+  - [`.or`](#or)
+  - [`.and`](#and)
+  - [`.brand`](#brand)
+  - [`.readonly`](#readonly)
+  - [`.pipe`](#pipe)
+    - [You can use `.pipe()` to fix common issues with `z.coerce`.](#you-can-use-pipe-to-fix-common-issues-with-zcoerce)
 - [Guides and concepts](#guides-and-concepts)
   - [Type inference](#type-inference)
   - [Writing generic functions](#writing-generic-functions)
+    - [Constraining allowable inputs](#constraining-allowable-inputs)
   - [Error handling](#error-handling)
   - [Error formatting](#error-formatting)
 - [Comparison](#comparison)
@@ -129,10 +157,9 @@
   - [Yup](#yup)
   - [io-ts](#io-ts)
   - [Runtypes](#runtypes)
+  - [Ow](#ow)
 - [Changelog](#changelog)
 
-<!-- **Zod 2 is coming! Follow [@colinhacks](https://twitter.com/colinhacks) to stay updated and discuss the future of Zod.** -->
-
 ## Introduction
 
 Zod is a TypeScript-first schema declaration and validation library. I'm using the term "schema" to broadly refer to any data type, from a simple `string` to a complex nested object.
@@ -206,7 +233,7 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
       <a href="https://proxy.com">proxy.com</a>
     </td>
   </tr>
-    <tr>
+  <tr>
     <td align="center">
       <a href="https://trigger.dev/">
         <img src="https://avatars.githubusercontent.com/u/95297378?s=200&v=4" width="200px;" alt="Trigger.dev logo" />
@@ -215,16 +242,33 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
       <b>Trigger.dev</b>
       <br />
       <a href="https://trigger.dev">trigger.dev</a>
+      <br/>
+      <p>Effortless automation for developers.</p>
     </td>
-    <!-- <td align="center">
-      <a href="https://proxy.com/">
-        <img src="https://avatars.githubusercontent.com/u/14321439?s=200&v=4" width="200px;" alt="Proxy logo" />
+    <td align="center">
+      <a href="https://transloadit.com/">
+        <img src="https://avatars.githubusercontent.com/u/125754?s=200&v=4" width="200px;" alt="Transloadit logo" />
       </a>
       <br />
-      <b>Proxy</b>
+      <b>Transloadit</b>
       <br />
-      <a href="https://proxy.com">proxy.com</a>
-    </td> -->
+      <a href="https://transloadit.com">transloadit.com</a>
+      <br/>
+      <p>Simple file processing for developers.</p>
+    </td>
+  </tr>
+  <tr>
+    <td align="center">
+      <a href="https://infisical.com">
+        <img src="https://avatars.githubusercontent.com/u/107880645?s=200&v=4" width="200px;" alt="Infisical logo" />
+      </a>
+      <br />
+      <b>Infisical</b>
+      <br />
+      <a href="https://infisical.com">infisical.com</a>
+      <br/>
+      <p>Open-source platform for secret<br/>management: sync secrets across your<br/>team/infrastructure and prevent secret leaks.</p>
+    </td>
   </tr>
 </table>
 
@@ -362,7 +406,7 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
     </td>
   </tr>
   <tr>
-  <td align="center">
+    <td align="center">
       <a href="https://learnwithjason.dev">
         <img src="https://avatars.githubusercontent.com/u/66575486?s=200&v=4" width="100px;" alt="Learn with Jason logo"/>
       </a>
@@ -382,17 +426,16 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
       <a href="https://ill.inc/">ill.inc</a>
       <br />
     </td>
-    <!-- <td align="center">
-      <a href="https://www.avanawallet.com/">
-        <img src="https://avatars.githubusercontent.com/u/105452197?s=200&v=4" width="100px;" alt="Avana Wallet logo"/>
+     <td align="center">
+      <a href="https://www.masterborn.com/career?utm_source=github&utm_medium=referral&utm_campaign=zodsponsoring">
+        <img src="https://avatars.githubusercontent.com/u/48984031?s=200&v=4" width="100px;" alt="MasterBorn logo"/>
       </a>
       <br />
-      <b>Avana Wallet</b>
+      <b>MasterBorn</b>
       <br/>
-      <a href="https://www.avanawallet.com/">avanawallet.com</a><br/>
-      <span>Solana non-custodial wallet</span>
+      <a href="https://www.masterborn.com/career?utm_source=github&utm_medium=referral&utm_campaign=zodsponsoring">masterborn.com</a>
       <br />
-    </td> -->
+    </td>
   </tr>
 </table>
 
@@ -413,9 +456,12 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`domain-functions`](https://github.com/SeasonedSoftware/domain-functions/): Decouple your business logic from your framework using composable functions. With first-class type inference from end to end powered by Zod schemas.
 - [`@zodios/core`](https://github.com/ecyrbe/zodios): A typescript API client with runtime and compile time validation backed by axios and zod.
 - [`express-zod-api`](https://github.com/RobinTail/express-zod-api): Build Express-based APIs with I/O schema validation and custom middlewares.
+- [`tapiduck`](https://github.com/sumukhbarve/monoduck/blob/main/src/tapiduck/README.md): End-to-end typesafe JSON APIs with Zod and Express; a bit like tRPC, but simpler.
+- [`koa-zod-router`](https://github.com/JakeFenley/koa-zod-router): Create typesafe routes in Koa with I/O validation using Zod.
 
 #### Form integrations
 
+- [`conform`](https://conform.guide/api/zod): A progressive enhancement first form validation library for Remix and React Router
 - [`react-hook-form`](https://github.com/react-hook-form/resolvers#zod): A first-party Zod resolver for React Hook Form.
 - [`zod-validation-error`](https://github.com/causaly/zod-validation-error): Generate user-friendly error messages from `ZodError`s.
 - [`zod-formik-adapter`](https://github.com/robertLichtnow/zod-formik-adapter): A community-maintained Formik adapter for Zod.
@@ -426,6 +472,9 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`zod-i18n-map`](https://github.com/aiji42/zod-i18n): Useful for translating Zod error messages.
 - [`@modular-forms/solid`](https://github.com/fabian-hiller/modular-forms): Modular form library for SolidJS that supports Zod for validation.
 - [`houseform`](https://github.com/crutchcorn/houseform/): A React form library that uses Zod for validation.
+- [`sveltekit-superforms`](https://github.com/ciscoheat/sveltekit-superforms): Supercharged form library for SvelteKit with Zod validation.
+- [`mobx-zod-form`](https://github.com/MonoidDev/mobx-zod-form): Data-first form builder based on MobX & Zod.
+- [`@vee-validate/zod`](https://github.com/logaretm/vee-validate/tree/main/packages/zod): Form library for Vue.js with Zod schema validation.
 
 #### Zod to X
 
@@ -437,6 +486,8 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`fastify-type-provider-zod`](https://github.com/turkerdev/fastify-type-provider-zod): Create Fastify type providers from Zod schemas.
 - [`zod-to-openapi`](https://github.com/asteasolutions/zod-to-openapi): Generate full OpenAPI (Swagger) docs from Zod, including schemas, endpoints & parameters.
 - [`nestjs-graphql-zod`](https://github.com/incetarik/nestjs-graphql-zod): Generates NestJS GraphQL model classes from Zod schemas. Provides GraphQL method decorators working with Zod schemas.
+- [`zod-openapi`](https://github.com/samchungy/zod-openapi): Create full OpenAPI v3.x documentation from Zod schemas.
+- [`fastify-zod-openapi`](https://github.com/samchungy/fastify-zod-openapi): Fastify type provider, validation, serialization and @fastify/swagger support for Zod schemas.
 
 #### X to Zod
 
@@ -455,9 +506,13 @@ There are a growing number of tools that are built atop or support Zod natively!
 
 - [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/faker-js/faker).
 - [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.
+- [`zod-fixture`](https://github.com/timdeschryver/zod-fixture): Use your zod schemas to automate the generation of non-relevant test fixtures in a deterministic way.
+- [`zocker`](https://zocker.sigrist.dev): Generate plausible mock-data from your schemas.
+- [`zodock`](https://github.com/ItMaga/zodock) Generate mock data based on Zod schemas.
 
 #### Powered by Zod
 
+- [`freerstore`](https://github.com/JacobWeisenburger/freerstore): Firestore cost optimizer.
 - [`slonik`](https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference): Node.js Postgres client with strong Zod integration.
 - [`soly`](https://github.com/mdbetancourt/soly): Create CLI applications with zod.
 - [`zod-xlsx`](https://github.com/sidwebworks/zod-xlsx): A xlsx based resource validator using Zod schemas.
@@ -494,6 +549,15 @@ bun add zod           # bun
 pnpm add zod          # pnpm
 ```
 
+Zod also publishes a canary version on every commit. To install the canary:
+
+```sh
+npm install zod@canary       # npm
+yarn add zod@canary          # yarn
+bun add zod@canary           # bun
+pnpm add zod@canary          # pnpm
+```
+
 ### From `deno.land/x` (Deno)
 
 Unlike Node, Deno relies on direct URL imports instead of a package manager like NPM. Zod is available on [deno.land/x](https://deno.land/x). The latest version can be imported like so:
@@ -618,7 +682,7 @@ z.coerce.boolean().parse(null); // => false
 
 ## Literals
 
-Literal schemas represent a [literal type](https://www.typescriptlang.org/docs/handbook/literal-types.html), like `"hello world"` or `5`.
+Literal schemas represent a [literal type](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types), like `"hello world"` or `5`.
 
 ```ts
 const tuna = z.literal("tuna");
@@ -966,7 +1030,7 @@ FruitEnum.parse("Cantaloupe"); // fails
 
 **Const enums**
 
-The `.nativeEnum()` function works for `as const` objects as well. ⚠️ `as const` required TypeScript 3.4+!
+The `.nativeEnum()` function works for `as const` objects as well. ⚠️ `as const` requires TypeScript 3.4+!
 
 ```ts
 const Fruits = {
@@ -1137,13 +1201,13 @@ type NoIDRecipe = z.infer<typeof NoIDRecipe>;
 
 ### `.partial`
 
-Inspired by the built-in TypeScript utility type [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt), the `.partial` method makes all properties optional.
+Inspired by the built-in TypeScript utility type [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype), the `.partial` method makes all properties optional.
 
 Starting from this object:
 
 ```ts
 const user = z.object({
-  email: z.string()
+  email: z.string(),
   username: z.string(),
 });
 // { email: string; username: string }
@@ -1207,10 +1271,12 @@ Contrary to the `.partial` method, the `.required` method makes all properties r
 Starting from this object:
 
 ```ts
-const user = z.object({
-  email: z.string()
-  username: z.string(),
-}).partial();
+const user = z
+  .object({
+    email: z.string(),
+    username: z.string(),
+  })
+  .partial();
 // { email?: string | undefined; username?: string | undefined }
 ```
 
@@ -1464,6 +1530,12 @@ type NumberCache = z.infer<typeof NumberCache>;
 This is particularly useful for storing or caching items by ID.
 
 ```ts
+const userSchema = z.object({ name: z.string() });
+const userStoreSchema = z.record(userSchema);
+
+type UserStore = z.infer<typeof userStoreSchema>;
+// => type UserStore = { [ x: string ]: { name: string } }
+
 const userStore: UserStore = {};
 
 userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
@@ -2292,7 +2364,7 @@ A convenience method that returns a "nullish" version of a schema. Nullish schem
 const nullishString = z.string().nullish(); // string | null | undefined
 
 // equivalent to
-z.string().optional().nullable();
+z.string().nullable().optional();
 ```
 
 ### `.array`
@@ -2382,7 +2454,38 @@ type Cat = z.infer<typeof Cat>;
 
 Note that branded types do not affect the runtime result of `.parse`. It is a static-only construct.
 
-### `.pipe()`
+### `.readonly`
+
+`.readonly() => ZodReadonly<this>`
+
+This method returns a `ZodReadonly` schema instance that parses the input using the base schema, then calls `Object.freeze()` on the result. The inferred type is also marked as `readonly`.
+
+```ts
+const schema = z.object({ name: string }).readonly();
+type schema = z.infer<typeof schema>;
+// Readonly<{name: string}>
+
+const result = schema.parse({ name: "fido" });
+result.name = "simba"; // error
+```
+
+The inferred type uses TypeScript's built-in readonly types when relevant.
+
+```ts
+z.array(z.string()).readonly();
+// readonly string[]
+
+z.tuple([z.string(), z.number()]).readonly();
+// readonly [string, number]
+
+z.map(z.string(), z.date()).readonly();
+// ReadonlyMap<string, Date>
+
+z.set(z.string()).readonly();
+// ReadonlySet<Promise<string>>
+```
+
+### `.pipe`
 
 Schemas can be chained into validation "pipelines". It's useful for easily validating the result after a `.transform()`:
 
@@ -2399,51 +2502,55 @@ The `.pipe()` method returns a `ZodPipeline` instance.
 You can constrain the input to types that work well with your chosen coercion. Then use `.pipe()` to apply the coercion.
 
 without constrained input:
+
 ```ts
-const toDate = z.coerce.date()
+const toDate = z.coerce.date();
 
 // works intuitively
-console.log(toDate.safeParse('2023-01-01').success) // true
+console.log(toDate.safeParse("2023-01-01").success); // true
 
 // might not be what you want
-console.log(toDate.safeParse(null).success) // true
+console.log(toDate.safeParse(null).success); // true
 ```
 
 with constrained input:
+
 ```ts
-const datelike = z.union([z.number(), z.string(), z.date()])
-const datelikeToDate = datelike.pipe(z.coerce.date())
+const datelike = z.union([z.number(), z.string(), z.date()]);
+const datelikeToDate = datelike.pipe(z.coerce.date());
 
 // still works intuitively
-console.log(datelikeToDate.safeParse('2023-01-01').success) // true
+console.log(datelikeToDate.safeParse("2023-01-01").success); // true
 
 // more likely what you want
-console.log(datelikeToDate.safeParse(null).success) // false
+console.log(datelikeToDate.safeParse(null).success); // false
 ```
 
 You can also use this technique to avoid coercions that throw uncaught errors.
 
 without constrained input:
+
 ```ts
-const toBigInt = z.coerce.bigint()
+const toBigInt = z.coerce.bigint();
 
 // works intuitively
-console.log( toBigInt.safeParse( '42' ) ) // true
+console.log(toBigInt.safeParse("42")); // true
 
 // probably not what you want
-console.log( toBigInt.safeParse( null ) ) // throws uncaught error
+console.log(toBigInt.safeParse(null)); // throws uncaught error
 ```
 
 with constrained input:
+
 ```ts
-const toNumber = z.number().or( z.string() ).pipe( z.coerce.number() )
-const toBigInt = z.bigint().or( toNumber ).pipe( z.coerce.bigint() )
+const toNumber = z.number().or(z.string()).pipe(z.coerce.number());
+const toBigInt = z.bigint().or(toNumber).pipe(z.coerce.bigint());
 
 // still works intuitively
-console.log( toBigInt.safeParse( '42' ).success ) // true
+console.log(toBigInt.safeParse("42").success); // true
 
 // error handled by zod, more likely what you want
-console.log( toBigInt.safeParse( null ).success ) // false
+console.log(toBigInt.safeParse(null).success); // false
 ```
 
 ## Guides and concepts
@@ -2654,7 +2761,6 @@ Yup is a full-featured library that was implemented first in vanilla JS, and lat
 
 - Supports casting and transforms
 - All object fields are optional by default
-- Missing object methods: (partial, deepPartial)
 <!-- - Missing nonempty arrays with proper typing (`[T, ...T[]]`) -->
 - Missing promise schemas
 - Missing function schemas
@@ -2717,7 +2823,7 @@ This more declarative API makes schema definitions vastly more concise.
 
 [https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes)
 
-Good type inference support, but limited options for object type masking (no `.pick` , `.omit` , `.extend` , etc.). No support for `Record` s (their `Record` is equivalent to Zod's `object` ). They DO support readonly types, which Zod does not.
+Good type inference support. They DO support readonly types, which Zod does not.
 
 - Supports "pattern matching": computed properties that distribute over unions
 - Supports readonly types
diff --git a/README_ZH.md b/README_ZH.md
index 08d9e5fc8..f8878f292 100644
--- a/README_ZH.md
+++ b/README_ZH.md
@@ -280,7 +280,6 @@ Zod 被设计成对开发者尽可能友好。其目的是消除重复的类型
 
 _要在这里看到你的名字 + Twitter + 網站 , 请在[Freelancer](https://github.com/sponsors/colinhacks) 或 [Consultancy](https://github.com/sponsors/colinhacks)赞助 Zod ._
 
-
 # 生态系统
 
 有越来越多的工具是建立在 Zod 之上或原生支持 Zod 的! 如果你在 Zod 的基础上建立了一个工具或库，请在[Twitter](https://twitter.com/colinhacks) 或者 [Discussion](https://github.com/colinhacks/zod/discussions)上告诉我。我会在下面添加，并在推特上发布。
@@ -292,8 +291,9 @@ _要在这里看到你的名字 + Twitter + 網站 , 请在[Freelancer](https://
 - [`zod-fast-check`](https://github.com/DavidTimms/zod-fast-check): 从 Zod 模式中生成 `fast-check` 的任意数据。
 - [`zod-endpoints`](https://github.com/flock-community/zod-endpoints): 约定优先的严格类型的端点与 Zod。兼容 OpenAPI。
 - [`express-zod-api`](https://github.com/RobinTail/express-zod-api): 用 I/O 模式验证和自定义中间件构建基于 Express 的 API 服务
-- [`zod-i18n-map`](https://github.com/aiji42/zod-i18n): 有助于翻译zod错误信息。
-
+- [`zod-i18n-map`](https://github.com/aiji42/zod-i18n): 有助于翻译 zod 错误信息。
+- [`mobx-zod-form`](https://github.com/MonoidDev/mobx-zod-form): 以数据为中心的表格构建工具，基于 MobX 和 Zod。
+- [`zodock`](https://github.com/ItMaga/zodock): 基於 Zod 模式生成模擬數據。
 
 # 安装
 
@@ -314,6 +314,7 @@ _要在这里看到你的名字 + Twitter + 網站 , 请在[Freelancer](https://
 ```
 
 ### 从`npm`(Node/Bun)安装
+
 ```sh
 npm install zod
 yarn add zod          # yarn
@@ -323,7 +324,8 @@ pnpm add zod          # pnpm
 
 ### 从`deno.land/x` (Deno)安装
 
-和Node不同，Demo依靠一个直接的URL导入而非像npm这样的包管理器。可以这样导入最新版本的Zod:
+和 Node 不同，Demo 依靠一个直接的 URL 导入而非像 npm 这样的包管理器。可以这样导入最新版本的 Zod:
+
 ```ts
 import { z } from "https://deno.land/x/zod/mod.ts";
 ```
@@ -334,8 +336,7 @@ import { z } from "https://deno.land/x/zod/mod.ts";
 import { z } from "https://deno.land/x/zod@v3.16.1/mod.ts";
 ```
 
-> README的剩余部分假定你是直接通过npm安装的`zod`包。
-
+> README 的剩余部分假定你是直接通过 npm 安装的`zod`包。
 
 # 基本用法
 
@@ -575,7 +576,7 @@ type NoIDRecipe = z.infer<typeof NoIDRecipe>;
 
 ### `.partial`
 
-受 TypeScript 内置的实用类型[Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt)的启发, `.partial` 方法使所有属性都是可选的。
+受 TypeScript 内置的实用类型[Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)的启发, `.partial` 方法使所有属性都是可选的。
 
 从这个对象开始:
 
@@ -844,6 +845,12 @@ type NumberCache = z.infer<typeof NumberCache>;
 这对于按 ID 存储或缓存项目特别有用。
 
 ```ts
+const userSchema = z.object({ name: z.string() });
+const userStoreSchema = z.record(userSchema);
+
+type UserStore = z.infer<typeof userStoreSchema>;
+// => type UserStore = { [ x: string ]: { name: string } }
+
 const userStore: UserStore = {};
 
 userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
@@ -929,6 +936,13 @@ const FishEnum = z.enum(fish);
 
 在这种情况下，Zod 无法推断出各个枚举元素；相反，推断出的类型将是 `string` 而不是`'Salmon'|'Tuna'|'Trout'`。
 
+另一种可行的方式是使用`as const`，这样 Zod 就可以推断出正确的类型。
+
+```ts
+const VALUES = ["Salmon", "Tuna", "Trout"] as const;
+const FishEnum = z.enum(VALUES);
+```
+
 **自动补全**
 
 为了获得 Zod 枚举的自动完成，请使用你的模式的`.enum`属性:
@@ -1609,7 +1623,7 @@ z.nullable(z.string());
 const nullishString = z.string().nullish(); // string | null | undefined
 
 // equivalent to
-z.string().optional().nullable();
+z.string().nullable().optional();
 ```
 
 ### `.array`
diff --git a/configs/babel-jest.config.json b/configs/babel-jest.config.json
new file mode 100644
index 000000000..f46b627de
--- /dev/null
+++ b/configs/babel-jest.config.json
@@ -0,0 +1,10 @@
+{
+  "rootDir": "..",
+  "testRegex": "src/.*\\.test\\.ts$",
+  "transform": {
+    "^.+\\.tsx?$": ["babel-jest", { "configFile": "./configs/babel.config.js" }]
+  },
+  "modulePathIgnorePatterns": ["language-server", "__vitest__"],
+  "moduleFileExtensions": ["ts", "tsx", "js", "jsx", "json", "node"],
+  "coverageReporters": ["json-summary", "text", "lcov"]
+}
diff --git a/configs/babel.config.js b/configs/babel.config.js
new file mode 100644
index 000000000..dd242dc90
--- /dev/null
+++ b/configs/babel.config.js
@@ -0,0 +1,6 @@
+module.exports = {
+  presets: [
+    ["@babel/preset-env", { targets: { node: "current" } }],
+    "@babel/preset-typescript",
+  ],
+};
diff --git a/configs/jest.config.json b/configs/jest.config.json
new file mode 100644
index 000000000..096278dcf
--- /dev/null
+++ b/configs/jest.config.json
@@ -0,0 +1,10 @@
+{
+  "rootDir": "..",
+  "transform": {
+    "^.+\\.tsx?$": "ts-jest"
+  },
+  "testRegex": "src/.*\\.test\\.ts$",
+  "modulePathIgnorePatterns": ["language-server", "__vitest__"],
+  "moduleFileExtensions": ["ts", "tsx", "js", "jsx", "json", "node"],
+  "coverageReporters": ["json-summary", "text", "lcov"]
+}
diff --git a/rollup.config.js b/configs/rollup.config.js
similarity index 91%
rename from rollup.config.js
rename to configs/rollup.config.js
index 1ccb37057..8f2090d33 100644
--- a/rollup.config.js
+++ b/configs/rollup.config.js
@@ -21,7 +21,7 @@ export default [
     ],
     plugins: [
       typescript({
-        tsconfig: "tsconfig.esm.json",
+        tsconfig: "./configs/tsconfig.esm.json",
         sourceMap: false,
       }),
     ],
diff --git a/configs/swc-jest.config.json b/configs/swc-jest.config.json
new file mode 100644
index 000000000..dd44db1f8
--- /dev/null
+++ b/configs/swc-jest.config.json
@@ -0,0 +1,10 @@
+{
+  "rootDir": "..",
+  "transform": {
+    "^.+\\.(t|j)sx?$": "@swc/jest"
+  },
+  "testRegex": "src/.*\\.test\\.ts$",
+  "modulePathIgnorePatterns": ["language-server", "__vitest__"],
+  "moduleFileExtensions": ["ts", "tsx", "js", "jsx", "json", "node"],
+  "coverageReporters": ["json-summary", "text", "lcov"]
+}
diff --git a/configs/ts-jest.config.json b/configs/ts-jest.config.json
new file mode 100644
index 000000000..096278dcf
--- /dev/null
+++ b/configs/ts-jest.config.json
@@ -0,0 +1,10 @@
+{
+  "rootDir": "..",
+  "transform": {
+    "^.+\\.tsx?$": "ts-jest"
+  },
+  "testRegex": "src/.*\\.test\\.ts$",
+  "modulePathIgnorePatterns": ["language-server", "__vitest__"],
+  "moduleFileExtensions": ["ts", "tsx", "js", "jsx", "json", "node"],
+  "coverageReporters": ["json-summary", "text", "lcov"]
+}
diff --git a/tsconfig.base.json b/configs/tsconfig.base.json
similarity index 73%
rename from tsconfig.base.json
rename to configs/tsconfig.base.json
index 374e5ad04..073703ed4 100644
--- a/tsconfig.base.json
+++ b/configs/tsconfig.base.json
@@ -1,12 +1,6 @@
 {
   "compilerOptions": {
-    "lib": [
-      "es5",
-      "es6",
-      "es7",
-      "esnext",
-      "dom"
-    ],
+    "lib": ["es5", "es6", "es7", "esnext", "dom"],
     "target": "es2018",
     "removeComments": false,
     "esModuleInterop": true,
@@ -22,9 +16,5 @@
     "downlevelIteration": true,
     "isolatedModules": true
   },
-  "include": [
-    "./src/**/*",
-    "playground.ts",
-    "./.eslintrc.js"
-  ]
-}
\ No newline at end of file
+  "include": ["../src/**/*", "../playground.ts", "../.eslintrc.js"]
+}
diff --git a/tsconfig.cjs.json b/configs/tsconfig.cjs.json
similarity index 69%
rename from tsconfig.cjs.json
rename to configs/tsconfig.cjs.json
index 9a393fdf8..32729f179 100644
--- a/tsconfig.cjs.json
+++ b/configs/tsconfig.cjs.json
@@ -2,14 +2,11 @@
   "extends": "./tsconfig.base.json",
   "compilerOptions": {
     "module": "commonjs",
-    "outDir": "lib",
+    "outDir": "../lib",
     "declaration": true,
     "declarationMap": false,
     "sourceMap": false,
     "removeComments": true
   },
-  "exclude": [
-    "./src/**/__tests__",
-    "playground.ts"
-  ]
-}
\ No newline at end of file
+  "exclude": ["../src/**/__tests__", "../playground.ts"]
+}
diff --git a/tsconfig.esm.json b/configs/tsconfig.esm.json
similarity index 73%
rename from tsconfig.esm.json
rename to configs/tsconfig.esm.json
index 6d2fc8ef1..b5c23f25a 100644
--- a/tsconfig.esm.json
+++ b/configs/tsconfig.esm.json
@@ -7,8 +7,5 @@
     "declarationMap": false,
     "sourceMap": false
   },
-  "exclude": [
-    "./src/**/__tests__",
-    "./src/playground.ts"
-  ]
+  "exclude": ["../src/**/__tests__", "../src/playground.ts"]
 }
diff --git a/tsconfig.test.json b/configs/tsconfig.test.json
similarity index 83%
rename from tsconfig.test.json
rename to configs/tsconfig.test.json
index 625604ecc..1a9fe2c6d 100644
--- a/tsconfig.test.json
+++ b/configs/tsconfig.test.json
@@ -6,7 +6,8 @@
     "target": "es5",
     "declaration": true,
     "declarationMap": false,
-    "sourceMap": false
+    "sourceMap": false,
+    "noEmit": true
   },
   "exclude": []
 }
diff --git a/tsconfig.types.json b/configs/tsconfig.types.json
similarity index 60%
rename from tsconfig.types.json
rename to configs/tsconfig.types.json
index ff811649d..83aec7b76 100644
--- a/tsconfig.types.json
+++ b/configs/tsconfig.types.json
@@ -1,13 +1,10 @@
 {
   "extends": "./tsconfig.base.json",
   "compilerOptions": {
-    "outDir": "./lib/types",
+    "outDir": "../lib/types",
     "declaration": true,
     "declarationMap": true,
     "emitDeclarationOnly": true
   },
-  "exclude": [
-    "./src/**/__tests__",
-    "./src/playground.ts"
-  ]
+  "exclude": ["../src/**/__tests__", "../src/playground.ts"]
 }
diff --git a/configs/vitest.config.ts b/configs/vitest.config.ts
new file mode 100644
index 000000000..a9671f849
--- /dev/null
+++ b/configs/vitest.config.ts
@@ -0,0 +1,12 @@
+import { defineConfig } from "vitest/config";
+
+export default defineConfig({
+  test: {
+    alias: {
+      "@jest/globals": "vitest",
+    },
+    include: ["src/**/*.test.ts"],
+    isolate: false,
+    watch: false,
+  },
+});
diff --git a/deno/build.mjs b/deno-build.mjs
similarity index 95%
rename from deno/build.mjs
rename to deno-build.mjs
index dfb4ac192..9e0b39a9d 100644
--- a/deno/build.mjs
+++ b/deno-build.mjs
@@ -25,8 +25,8 @@ const denoLibRoot = join(projectRoot, "deno", "lib");
 
 const skipList = [
   join(nodeSrcRoot, "__tests__", "object-in-es5-env.test.ts"),
-  join(nodeSrcRoot, "__tests__", "languageServerFeatures.test.ts"),
-  join(nodeSrcRoot, "__tests__", "languageServerFeatures.source.ts"),
+  join(nodeSrcRoot, "__tests__", "language-server.test.ts"),
+  join(nodeSrcRoot, "__tests__", "language-server.source.ts"),
 ];
 const walkAndBuild = (/** @type string */ dir) => {
   for (const entry of readdirSync(join(nodeSrcRoot, dir), {
diff --git a/deno/lib/README.md b/deno/lib/README.md
index ec988f6ee..d913ed9b4 100644
--- a/deno/lib/README.md
+++ b/deno/lib/README.md
@@ -45,20 +45,32 @@
 
 #### Go to [zod.js.org](https://zod.js.org) >> -->
 
+- [Table of contents](#table-of-contents)
 - [Introduction](#introduction)
   - [Sponsors](#sponsors)
+    - [Gold](#gold)
+    - [Silver](#silver)
+    - [Bronze](#bronze)
   - [Ecosystem](#ecosystem)
+    - [Resources](#resources)
+    - [API libraries](#api-libraries)
+    - [Form integrations](#form-integrations)
+    - [Zod to X](#zod-to-x)
+    - [X to Zod](#x-to-zod)
+    - [Mocking](#mocking)
+    - [Powered by Zod](#powered-by-zod)
+    - [Utilities for Zod](#utilities-for-zod)
 - [Installation](#installation)
   - [Requirements](#requirements)
-  - [Node/npm](#from-npm-nodebun)
-  - [Deno](#from-denolandx-deno)
+  - [From `npm` (Node/Bun)](#from-npm-nodebun)
+  - [From `deno.land/x` (Deno)](#from-denolandx-deno)
 - [Basic usage](#basic-usage)
 - [Primitives](#primitives)
 - [Coercion for primitives](#coercion-for-primitives)
 - [Literals](#literals)
 - [Strings](#strings)
-  - [Datetime](#datetime-validation)
-  - [IP](#ip-address-validation)
+  - [ISO datetimes](#iso-datetimes)
+  - [IP addresses](#ip-addresses)
 - [Numbers](#numbers)
 - [BigInts](#bigints)
 - [NaNs](#nans)
@@ -69,59 +81,75 @@
 - [Optionals](#optionals)
 - [Nullables](#nullables)
 - [Objects](#objects)
-  - [.shape](#shape)
-  - [.keyof](#keyof)
-  - [.extend](#extend)
-  - [.merge](#merge)
-  - [.pick/.omit](#pickomit)
-  - [.partial](#partial)
-  - [.deepPartial](#deepPartial)
-  - [.passthrough](#passthrough)
-  - [.strict](#strict)
-  - [.strip](#strip)
-  - [.catchall](#catchall)
+  - [`.shape`](#shape)
+  - [`.keyof`](#keyof)
+  - [`.extend`](#extend)
+  - [`.merge`](#merge)
+  - [`.pick/.omit`](#pickomit)
+  - [`.partial`](#partial)
+  - [`.deepPartial`](#deeppartial)
+  - [`.required`](#required)
+  - [`.passthrough`](#passthrough)
+  - [`.strict`](#strict)
+  - [`.strip`](#strip)
+  - [`.catchall`](#catchall)
 - [Arrays](#arrays)
-  - [.element](#element)
-  - [.nonempty](#nonempty)
-  - [.min/.max/.length](#minmaxlength)
+  - [`.element`](#element)
+  - [`.nonempty`](#nonempty)
+  - [`.min/.max/.length`](#minmaxlength)
 - [Tuples](#tuples)
 - [Unions](#unions)
-- [Discriminated Unions](#discriminated-unions)
+- [Discriminated unions](#discriminated-unions)
 - [Records](#records)
+  - [Record key type](#record-key-type)
 - [Maps](#maps)
 - [Sets](#sets)
 - [Intersections](#intersections)
 - [Recursive types](#recursive-types)
+  - [ZodType with ZodEffects](#zodtype-with-zodeffects)
   - [JSON type](#json-type)
-  - [Cyclical data](#cyclical-objects)
+  - [Cyclical objects](#cyclical-objects)
 - [Promises](#promises)
 - [Instanceof](#instanceof)
 - [Functions](#functions)
 - [Preprocess](#preprocess)
-- [Custom](#custom-schemas)
+- [Custom schemas](#custom-schemas)
 - [Schema methods](#schema-methods)
-  - [.parse](#parse)
-  - [.parseAsync](#parseasync)
-  - [.safeParse](#safeparse)
-  - [.safeParseAsync](#safeparseasync)
-  - [.refine](#refine)
-  - [.superRefine](#superRefine)
-  - [.transform](#transform)
-  - [.default](#default)
-  - [.describe](#describe)
-  - [.catch](#catch)
-  - [.optional](#optional)
-  - [.nullable](#nullable)
-  - [.nullish](#nullish)
-  - [.array](#array)
-  - [.promise](#promise)
-  - [.or](#or)
-  - [.and](#and)
-  - [.brand](#brand)
-  - [.pipe](#pipe)
+  - [`.parse`](#parse)
+  - [`.parseAsync`](#parseasync)
+  - [`.safeParse`](#safeparse)
+  - [`.safeParseAsync`](#safeparseasync)
+  - [`.refine`](#refine)
+    - [Arguments](#arguments)
+    - [Customize error path](#customize-error-path)
+    - [Asynchronous refinements](#asynchronous-refinements)
+    - [Relationship to transforms](#relationship-to-transforms)
+  - [`.superRefine`](#superrefine)
+    - [Abort early](#abort-early)
+    - [Type refinements](#type-refinements)
+  - [`.transform`](#transform)
+    - [Chaining order](#chaining-order)
+    - [Validating during transform](#validating-during-transform)
+    - [Relationship to refinements](#relationship-to-refinements)
+    - [Async transforms](#async-transforms)
+  - [`.default`](#default)
+  - [`.describe`](#describe)
+  - [`.catch`](#catch)
+  - [`.optional`](#optional)
+  - [`.nullable`](#nullable)
+  - [`.nullish`](#nullish)
+  - [`.array`](#array)
+  - [`.promise`](#promise)
+  - [`.or`](#or)
+  - [`.and`](#and)
+  - [`.brand`](#brand)
+  - [`.readonly`](#readonly)
+  - [`.pipe`](#pipe)
+    - [You can use `.pipe()` to fix common issues with `z.coerce`.](#you-can-use-pipe-to-fix-common-issues-with-zcoerce)
 - [Guides and concepts](#guides-and-concepts)
   - [Type inference](#type-inference)
   - [Writing generic functions](#writing-generic-functions)
+    - [Constraining allowable inputs](#constraining-allowable-inputs)
   - [Error handling](#error-handling)
   - [Error formatting](#error-formatting)
 - [Comparison](#comparison)
@@ -129,10 +157,9 @@
   - [Yup](#yup)
   - [io-ts](#io-ts)
   - [Runtypes](#runtypes)
+  - [Ow](#ow)
 - [Changelog](#changelog)
 
-<!-- **Zod 2 is coming! Follow [@colinhacks](https://twitter.com/colinhacks) to stay updated and discuss the future of Zod.** -->
-
 ## Introduction
 
 Zod is a TypeScript-first schema declaration and validation library. I'm using the term "schema" to broadly refer to any data type, from a simple `string` to a complex nested object.
@@ -206,7 +233,7 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
       <a href="https://proxy.com">proxy.com</a>
     </td>
   </tr>
-    <tr>
+  <tr>
     <td align="center">
       <a href="https://trigger.dev/">
         <img src="https://avatars.githubusercontent.com/u/95297378?s=200&v=4" width="200px;" alt="Trigger.dev logo" />
@@ -215,16 +242,33 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
       <b>Trigger.dev</b>
       <br />
       <a href="https://trigger.dev">trigger.dev</a>
+      <br/>
+      <p>Effortless automation for developers.</p>
     </td>
-    <!-- <td align="center">
-      <a href="https://proxy.com/">
-        <img src="https://avatars.githubusercontent.com/u/14321439?s=200&v=4" width="200px;" alt="Proxy logo" />
+    <td align="center">
+      <a href="https://transloadit.com/">
+        <img src="https://avatars.githubusercontent.com/u/125754?s=200&v=4" width="200px;" alt="Transloadit logo" />
       </a>
       <br />
-      <b>Proxy</b>
+      <b>Transloadit</b>
       <br />
-      <a href="https://proxy.com">proxy.com</a>
-    </td> -->
+      <a href="https://transloadit.com">transloadit.com</a>
+      <br/>
+      <p>Simple file processing for developers.</p>
+    </td>
+  </tr>
+  <tr>
+    <td align="center">
+      <a href="https://infisical.com">
+        <img src="https://avatars.githubusercontent.com/u/107880645?s=200&v=4" width="200px;" alt="Infisical logo" />
+      </a>
+      <br />
+      <b>Infisical</b>
+      <br />
+      <a href="https://infisical.com">infisical.com</a>
+      <br/>
+      <p>Open-source platform for secret<br/>management: sync secrets across your<br/>team/infrastructure and prevent secret leaks.</p>
+    </td>
   </tr>
 </table>
 
@@ -362,7 +406,7 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
     </td>
   </tr>
   <tr>
-  <td align="center">
+    <td align="center">
       <a href="https://learnwithjason.dev">
         <img src="https://avatars.githubusercontent.com/u/66575486?s=200&v=4" width="100px;" alt="Learn with Jason logo"/>
       </a>
@@ -382,17 +426,16 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
       <a href="https://ill.inc/">ill.inc</a>
       <br />
     </td>
-    <!-- <td align="center">
-      <a href="https://www.avanawallet.com/">
-        <img src="https://avatars.githubusercontent.com/u/105452197?s=200&v=4" width="100px;" alt="Avana Wallet logo"/>
+     <td align="center">
+      <a href="https://www.masterborn.com/career?utm_source=github&utm_medium=referral&utm_campaign=zodsponsoring">
+        <img src="https://avatars.githubusercontent.com/u/48984031?s=200&v=4" width="100px;" alt="MasterBorn logo"/>
       </a>
       <br />
-      <b>Avana Wallet</b>
+      <b>MasterBorn</b>
       <br/>
-      <a href="https://www.avanawallet.com/">avanawallet.com</a><br/>
-      <span>Solana non-custodial wallet</span>
+      <a href="https://www.masterborn.com/career?utm_source=github&utm_medium=referral&utm_campaign=zodsponsoring">masterborn.com</a>
       <br />
-    </td> -->
+    </td>
   </tr>
 </table>
 
@@ -413,9 +456,12 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`domain-functions`](https://github.com/SeasonedSoftware/domain-functions/): Decouple your business logic from your framework using composable functions. With first-class type inference from end to end powered by Zod schemas.
 - [`@zodios/core`](https://github.com/ecyrbe/zodios): A typescript API client with runtime and compile time validation backed by axios and zod.
 - [`express-zod-api`](https://github.com/RobinTail/express-zod-api): Build Express-based APIs with I/O schema validation and custom middlewares.
+- [`tapiduck`](https://github.com/sumukhbarve/monoduck/blob/main/src/tapiduck/README.md): End-to-end typesafe JSON APIs with Zod and Express; a bit like tRPC, but simpler.
+- [`koa-zod-router`](https://github.com/JakeFenley/koa-zod-router): Create typesafe routes in Koa with I/O validation using Zod.
 
 #### Form integrations
 
+- [`conform`](https://conform.guide/api/zod): A progressive enhancement first form validation library for Remix and React Router
 - [`react-hook-form`](https://github.com/react-hook-form/resolvers#zod): A first-party Zod resolver for React Hook Form.
 - [`zod-validation-error`](https://github.com/causaly/zod-validation-error): Generate user-friendly error messages from `ZodError`s.
 - [`zod-formik-adapter`](https://github.com/robertLichtnow/zod-formik-adapter): A community-maintained Formik adapter for Zod.
@@ -426,6 +472,9 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`zod-i18n-map`](https://github.com/aiji42/zod-i18n): Useful for translating Zod error messages.
 - [`@modular-forms/solid`](https://github.com/fabian-hiller/modular-forms): Modular form library for SolidJS that supports Zod for validation.
 - [`houseform`](https://github.com/crutchcorn/houseform/): A React form library that uses Zod for validation.
+- [`sveltekit-superforms`](https://github.com/ciscoheat/sveltekit-superforms): Supercharged form library for SvelteKit with Zod validation.
+- [`mobx-zod-form`](https://github.com/MonoidDev/mobx-zod-form): Data-first form builder based on MobX & Zod.
+- [`@vee-validate/zod`](https://github.com/logaretm/vee-validate/tree/main/packages/zod): Form library for Vue.js with Zod schema validation.
 
 #### Zod to X
 
@@ -437,6 +486,8 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`fastify-type-provider-zod`](https://github.com/turkerdev/fastify-type-provider-zod): Create Fastify type providers from Zod schemas.
 - [`zod-to-openapi`](https://github.com/asteasolutions/zod-to-openapi): Generate full OpenAPI (Swagger) docs from Zod, including schemas, endpoints & parameters.
 - [`nestjs-graphql-zod`](https://github.com/incetarik/nestjs-graphql-zod): Generates NestJS GraphQL model classes from Zod schemas. Provides GraphQL method decorators working with Zod schemas.
+- [`zod-openapi`](https://github.com/samchungy/zod-openapi): Create full OpenAPI v3.x documentation from Zod schemas.
+- [`fastify-zod-openapi`](https://github.com/samchungy/fastify-zod-openapi): Fastify type provider, validation, serialization and @fastify/swagger support for Zod schemas.
 
 #### X to Zod
 
@@ -455,9 +506,13 @@ There are a growing number of tools that are built atop or support Zod natively!
 
 - [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/faker-js/faker).
 - [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.
+- [`zod-fixture`](https://github.com/timdeschryver/zod-fixture): Use your zod schemas to automate the generation of non-relevant test fixtures in a deterministic way.
+- [`zocker`](https://zocker.sigrist.dev): Generate plausible mock-data from your schemas.
+- [`zodock`](https://github.com/ItMaga/zodock) Generate mock data based on Zod schemas.
 
 #### Powered by Zod
 
+- [`freerstore`](https://github.com/JacobWeisenburger/freerstore): Firestore cost optimizer.
 - [`slonik`](https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference): Node.js Postgres client with strong Zod integration.
 - [`soly`](https://github.com/mdbetancourt/soly): Create CLI applications with zod.
 - [`zod-xlsx`](https://github.com/sidwebworks/zod-xlsx): A xlsx based resource validator using Zod schemas.
@@ -494,6 +549,15 @@ bun add zod           # bun
 pnpm add zod          # pnpm
 ```
 
+Zod also publishes a canary version on every commit. To install the canary:
+
+```sh
+npm install zod@canary       # npm
+yarn add zod@canary          # yarn
+bun add zod@canary           # bun
+pnpm add zod@canary          # pnpm
+```
+
 ### From `deno.land/x` (Deno)
 
 Unlike Node, Deno relies on direct URL imports instead of a package manager like NPM. Zod is available on [deno.land/x](https://deno.land/x). The latest version can be imported like so:
@@ -618,7 +682,7 @@ z.coerce.boolean().parse(null); // => false
 
 ## Literals
 
-Literal schemas represent a [literal type](https://www.typescriptlang.org/docs/handbook/literal-types.html), like `"hello world"` or `5`.
+Literal schemas represent a [literal type](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types), like `"hello world"` or `5`.
 
 ```ts
 const tuna = z.literal("tuna");
@@ -966,7 +1030,7 @@ FruitEnum.parse("Cantaloupe"); // fails
 
 **Const enums**
 
-The `.nativeEnum()` function works for `as const` objects as well. ⚠️ `as const` required TypeScript 3.4+!
+The `.nativeEnum()` function works for `as const` objects as well. ⚠️ `as const` requires TypeScript 3.4+!
 
 ```ts
 const Fruits = {
@@ -1137,13 +1201,13 @@ type NoIDRecipe = z.infer<typeof NoIDRecipe>;
 
 ### `.partial`
 
-Inspired by the built-in TypeScript utility type [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt), the `.partial` method makes all properties optional.
+Inspired by the built-in TypeScript utility type [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype), the `.partial` method makes all properties optional.
 
 Starting from this object:
 
 ```ts
 const user = z.object({
-  email: z.string()
+  email: z.string(),
   username: z.string(),
 });
 // { email: string; username: string }
@@ -1207,10 +1271,12 @@ Contrary to the `.partial` method, the `.required` method makes all properties r
 Starting from this object:
 
 ```ts
-const user = z.object({
-  email: z.string()
-  username: z.string(),
-}).partial();
+const user = z
+  .object({
+    email: z.string(),
+    username: z.string(),
+  })
+  .partial();
 // { email?: string | undefined; username?: string | undefined }
 ```
 
@@ -1464,6 +1530,12 @@ type NumberCache = z.infer<typeof NumberCache>;
 This is particularly useful for storing or caching items by ID.
 
 ```ts
+const userSchema = z.object({ name: z.string() });
+const userStoreSchema = z.record(userSchema);
+
+type UserStore = z.infer<typeof userStoreSchema>;
+// => type UserStore = { [ x: string ]: { name: string } }
+
 const userStore: UserStore = {};
 
 userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
@@ -2292,7 +2364,7 @@ A convenience method that returns a "nullish" version of a schema. Nullish schem
 const nullishString = z.string().nullish(); // string | null | undefined
 
 // equivalent to
-z.string().optional().nullable();
+z.string().nullable().optional();
 ```
 
 ### `.array`
@@ -2382,7 +2454,38 @@ type Cat = z.infer<typeof Cat>;
 
 Note that branded types do not affect the runtime result of `.parse`. It is a static-only construct.
 
-### `.pipe()`
+### `.readonly`
+
+`.readonly() => ZodReadonly<this>`
+
+This method returns a `ZodReadonly` schema instance that parses the input using the base schema, then calls `Object.freeze()` on the result. The inferred type is also marked as `readonly`.
+
+```ts
+const schema = z.object({ name: string }).readonly();
+type schema = z.infer<typeof schema>;
+// Readonly<{name: string}>
+
+const result = schema.parse({ name: "fido" });
+result.name = "simba"; // error
+```
+
+The inferred type uses TypeScript's built-in readonly types when relevant.
+
+```ts
+z.array(z.string()).readonly();
+// readonly string[]
+
+z.tuple([z.string(), z.number()]).readonly();
+// readonly [string, number]
+
+z.map(z.string(), z.date()).readonly();
+// ReadonlyMap<string, Date>
+
+z.set(z.string()).readonly();
+// ReadonlySet<Promise<string>>
+```
+
+### `.pipe`
 
 Schemas can be chained into validation "pipelines". It's useful for easily validating the result after a `.transform()`:
 
@@ -2399,51 +2502,55 @@ The `.pipe()` method returns a `ZodPipeline` instance.
 You can constrain the input to types that work well with your chosen coercion. Then use `.pipe()` to apply the coercion.
 
 without constrained input:
+
 ```ts
-const toDate = z.coerce.date()
+const toDate = z.coerce.date();
 
 // works intuitively
-console.log(toDate.safeParse('2023-01-01').success) // true
+console.log(toDate.safeParse("2023-01-01").success); // true
 
 // might not be what you want
-console.log(toDate.safeParse(null).success) // true
+console.log(toDate.safeParse(null).success); // true
 ```
 
 with constrained input:
+
 ```ts
-const datelike = z.union([z.number(), z.string(), z.date()])
-const datelikeToDate = datelike.pipe(z.coerce.date())
+const datelike = z.union([z.number(), z.string(), z.date()]);
+const datelikeToDate = datelike.pipe(z.coerce.date());
 
 // still works intuitively
-console.log(datelikeToDate.safeParse('2023-01-01').success) // true
+console.log(datelikeToDate.safeParse("2023-01-01").success); // true
 
 // more likely what you want
-console.log(datelikeToDate.safeParse(null).success) // false
+console.log(datelikeToDate.safeParse(null).success); // false
 ```
 
 You can also use this technique to avoid coercions that throw uncaught errors.
 
 without constrained input:
+
 ```ts
-const toBigInt = z.coerce.bigint()
+const toBigInt = z.coerce.bigint();
 
 // works intuitively
-console.log( toBigInt.safeParse( '42' ) ) // true
+console.log(toBigInt.safeParse("42")); // true
 
 // probably not what you want
-console.log( toBigInt.safeParse( null ) ) // throws uncaught error
+console.log(toBigInt.safeParse(null)); // throws uncaught error
 ```
 
 with constrained input:
+
 ```ts
-const toNumber = z.number().or( z.string() ).pipe( z.coerce.number() )
-const toBigInt = z.bigint().or( toNumber ).pipe( z.coerce.bigint() )
+const toNumber = z.number().or(z.string()).pipe(z.coerce.number());
+const toBigInt = z.bigint().or(toNumber).pipe(z.coerce.bigint());
 
 // still works intuitively
-console.log( toBigInt.safeParse( '42' ).success ) // true
+console.log(toBigInt.safeParse("42").success); // true
 
 // error handled by zod, more likely what you want
-console.log( toBigInt.safeParse( null ).success ) // false
+console.log(toBigInt.safeParse(null).success); // false
 ```
 
 ## Guides and concepts
@@ -2654,7 +2761,6 @@ Yup is a full-featured library that was implemented first in vanilla JS, and lat
 
 - Supports casting and transforms
 - All object fields are optional by default
-- Missing object methods: (partial, deepPartial)
 <!-- - Missing nonempty arrays with proper typing (`[T, ...T[]]`) -->
 - Missing promise schemas
 - Missing function schemas
@@ -2717,7 +2823,7 @@ This more declarative API makes schema definitions vastly more concise.
 
 [https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes)
 
-Good type inference support, but limited options for object type masking (no `.pick` , `.omit` , `.extend` , etc.). No support for `Record` s (their `Record` is equivalent to Zod's `object` ). They DO support readonly types, which Zod does not.
+Good type inference support. They DO support readonly types, which Zod does not.
 
 - Supports "pattern matching": computed properties that distribute over unions
 - Supports readonly types
diff --git a/deno/lib/__tests__/coerce.test.ts b/deno/lib/__tests__/coerce.test.ts
index 6acc5249b..fd3868225 100644
--- a/deno/lib/__tests__/coerce.test.ts
+++ b/deno/lib/__tests__/coerce.test.ts
@@ -35,21 +35,21 @@ test("number coercion", () => {
   expect(schema.parse("-12")).toEqual(-12);
   expect(schema.parse("3.14")).toEqual(3.14);
   expect(schema.parse("")).toEqual(0);
-  expect(() => schema.parse("NOT_A_NUMBER")).toThrow; // z.ZodError
+  expect(() => schema.parse("NOT_A_NUMBER")).toThrow(); // z.ZodError
   expect(schema.parse(12)).toEqual(12);
   expect(schema.parse(0)).toEqual(0);
   expect(schema.parse(-12)).toEqual(-12);
   expect(schema.parse(3.14)).toEqual(3.14);
   expect(schema.parse(BigInt(15))).toEqual(15);
-  expect(() => schema.parse(NaN)).toThrow; // z.ZodError
+  expect(() => schema.parse(NaN)).toThrow(); // z.ZodError
   expect(schema.parse(Infinity)).toEqual(Infinity);
   expect(schema.parse(-Infinity)).toEqual(-Infinity);
   expect(schema.parse(true)).toEqual(1);
   expect(schema.parse(false)).toEqual(0);
   expect(schema.parse(null)).toEqual(0);
-  expect(() => schema.parse(undefined)).toThrow; // z.ZodError
-  expect(() => schema.parse({ hello: "world!" })).toThrow; // z.ZodError
-  expect(() => schema.parse(["item", "another_item"])).toThrow; // z.ZodError
+  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError
+  expect(() => schema.parse({ hello: "world!" })).toThrow(); // z.ZodError
+  expect(() => schema.parse(["item", "another_item"])).toThrow(); // z.ZodError
   expect(schema.parse([])).toEqual(0);
   expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);
 });
@@ -84,23 +84,23 @@ test("bigint coercion", () => {
   expect(schema.parse("5")).toEqual(BigInt(5));
   expect(schema.parse("0")).toEqual(BigInt(0));
   expect(schema.parse("-5")).toEqual(BigInt(-5));
-  expect(() => schema.parse("3.14")).toThrow; // not a z.ZodError!
+  expect(() => schema.parse("3.14")).toThrow(); // not a z.ZodError!
   expect(schema.parse("")).toEqual(BigInt(0));
-  expect(() => schema.parse("NOT_A_NUMBER")).toThrow; // not a z.ZodError!
+  expect(() => schema.parse("NOT_A_NUMBER")).toThrow(); // not a z.ZodError!
   expect(schema.parse(5)).toEqual(BigInt(5));
   expect(schema.parse(0)).toEqual(BigInt(0));
   expect(schema.parse(-5)).toEqual(BigInt(-5));
-  expect(() => schema.parse(3.14)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(3.14)).toThrow(); // not a z.ZodError!
   expect(schema.parse(BigInt(5))).toEqual(BigInt(5));
-  expect(() => schema.parse(NaN)).toThrow; // not a z.ZodError!
-  expect(() => schema.parse(Infinity)).toThrow; // not a z.ZodError!
-  expect(() => schema.parse(-Infinity)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(NaN)).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse(Infinity)).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse(-Infinity)).toThrow(); // not a z.ZodError!
   expect(schema.parse(true)).toEqual(BigInt(1));
   expect(schema.parse(false)).toEqual(BigInt(0));
-  expect(() => schema.parse(null)).toThrow; // not a z.ZodError!
-  expect(() => schema.parse(undefined)).toThrow; // not a z.ZodError!
-  expect(() => schema.parse({ hello: "world!" })).toThrow; // not a z.ZodError!
-  expect(() => schema.parse(["item", "another_item"])).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(null)).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse(undefined)).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse({ hello: "world!" })).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse(["item", "another_item"])).toThrow(); // not a z.ZodError!
   expect(schema.parse([])).toEqual(BigInt(0));
   expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));
 });
@@ -111,25 +111,26 @@ test("date coercion", () => {
   expect(schema.parse(new Date().toISOString())).toBeInstanceOf(Date);
   expect(schema.parse(new Date().toUTCString())).toBeInstanceOf(Date);
   expect(schema.parse("5")).toBeInstanceOf(Date);
-  expect(schema.parse("0")).toBeInstanceOf(Date);
-  expect(schema.parse("-5")).toBeInstanceOf(Date);
-  expect(schema.parse("3.14")).toBeInstanceOf(Date);
-  expect(() => schema.parse("")).toThrow; // z.ZodError
-  expect(() => schema.parse("NOT_A_DATE")).toThrow; // z.ZodError
+  expect(schema.parse("2000-01-01")).toBeInstanceOf(Date);
+  // expect(schema.parse("0")).toBeInstanceOf(Date);
+  // expect(schema.parse("-5")).toBeInstanceOf(Date);
+  // expect(schema.parse("3.14")).toBeInstanceOf(Date);
+  expect(() => schema.parse("")).toThrow(); // z.ZodError
+  expect(() => schema.parse("NOT_A_DATE")).toThrow(); // z.ZodError
   expect(schema.parse(5)).toBeInstanceOf(Date);
   expect(schema.parse(0)).toBeInstanceOf(Date);
   expect(schema.parse(-5)).toBeInstanceOf(Date);
   expect(schema.parse(3.14)).toBeInstanceOf(Date);
-  expect(() => schema.parse(BigInt(5))).toThrow; // not a z.ZodError!
-  expect(() => schema.parse(NaN)).toThrow; // z.ZodError
-  expect(() => schema.parse(Infinity)).toThrow; // z.ZodError
-  expect(() => schema.parse(-Infinity)).toThrow; // z.ZodError
+  expect(() => schema.parse(BigInt(5))).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse(NaN)).toThrow(); // z.ZodError
+  expect(() => schema.parse(Infinity)).toThrow(); // z.ZodError
+  expect(() => schema.parse(-Infinity)).toThrow(); // z.ZodError
   expect(schema.parse(true)).toBeInstanceOf(Date);
   expect(schema.parse(false)).toBeInstanceOf(Date);
   expect(schema.parse(null)).toBeInstanceOf(Date);
-  expect(() => schema.parse(undefined)).toThrow; // z.ZodError
-  expect(() => schema.parse({ hello: "world!" })).toThrow; // z.ZodError
-  expect(() => schema.parse(["item", "another_item"])).toThrow; // z.ZodError
-  expect(() => schema.parse([])).toThrow; // z.ZodError
+  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError
+  expect(() => schema.parse({ hello: "world!" })).toThrow(); // z.ZodError
+  expect(() => schema.parse(["item", "another_item"])).toThrow(); // z.ZodError
+  expect(() => schema.parse([])).toThrow(); // z.ZodError
   expect(schema.parse(new Date())).toBeInstanceOf(Date);
 });
diff --git a/deno/lib/__tests__/custom.test.ts b/deno/lib/__tests__/custom.test.ts
index ff8b9577c..a19233ecf 100644
--- a/deno/lib/__tests__/custom.test.ts
+++ b/deno/lib/__tests__/custom.test.ts
@@ -15,5 +15,5 @@ test("string params", () => {
   const result = example1.safeParse(1234);
   expect(result.success).toEqual(false);
   // @ts-ignore
-  expect(JSON.stringify(result.error)).toContain("customerr");
+  expect(JSON.stringify(result.error).includes("customerr")).toEqual(true);
 });
diff --git a/deno/lib/__tests__/discriminatedUnions.test.ts b/deno/lib/__tests__/discriminated-unions.test.ts
similarity index 100%
rename from deno/lib/__tests__/discriminatedUnions.test.ts
rename to deno/lib/__tests__/discriminated-unions.test.ts
diff --git a/deno/lib/__tests__/primitive.test.ts b/deno/lib/__tests__/primitive.test.ts
index d3f7d0f92..5815f765e 100644
--- a/deno/lib/__tests__/primitive.test.ts
+++ b/deno/lib/__tests__/primitive.test.ts
@@ -448,7 +448,7 @@ test("get literal value", () => {
   expect(literalStringSchema.value).toEqual("asdf");
 });
 
-test("optional convenience methd", () => {
+test("optional convenience method", () => {
   z.ostring().parse(undefined);
   z.onumber().parse(undefined);
   z.oboolean().parse(undefined);
diff --git a/deno/lib/__tests__/readonly.test.ts b/deno/lib/__tests__/readonly.test.ts
new file mode 100644
index 000000000..27d2e0c9c
--- /dev/null
+++ b/deno/lib/__tests__/readonly.test.ts
@@ -0,0 +1,205 @@
+// @ts-ignore TS6133
+import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
+const test = Deno.test;
+
+import { util } from "../helpers/util.ts";
+import * as z from "../index.ts";
+
+enum testEnum {
+  A,
+  B,
+}
+
+const schemas = [
+  z.string().readonly(),
+  z.number().readonly(),
+  z.nan().readonly(),
+  z.bigint().readonly(),
+  z.boolean().readonly(),
+  z.date().readonly(),
+  z.undefined().readonly(),
+  z.null().readonly(),
+  z.any().readonly(),
+  z.unknown().readonly(),
+  z.void().readonly(),
+  z.function().args(z.string(), z.number()).readonly(),
+
+  z.array(z.string()).readonly(),
+  z.tuple([z.string(), z.number()]).readonly(),
+  z.map(z.string(), z.date()).readonly(),
+  z.set(z.promise(z.string())).readonly(),
+  z.record(z.string()).readonly(),
+  z.record(z.string(), z.number()).readonly(),
+  z.object({ a: z.string(), 1: z.number() }).readonly(),
+  z.nativeEnum(testEnum).readonly(),
+  z.promise(z.string()).readonly(),
+] as const;
+
+test("flat inference", () => {
+  util.assertEqual<z.infer<(typeof schemas)[0]>, string>(true);
+  util.assertEqual<z.infer<(typeof schemas)[1]>, number>(true);
+  util.assertEqual<z.infer<(typeof schemas)[2]>, number>(true);
+  util.assertEqual<z.infer<(typeof schemas)[3]>, bigint>(true);
+  util.assertEqual<z.infer<(typeof schemas)[4]>, boolean>(true);
+  util.assertEqual<z.infer<(typeof schemas)[5]>, Date>(true);
+  util.assertEqual<z.infer<(typeof schemas)[6]>, undefined>(true);
+  util.assertEqual<z.infer<(typeof schemas)[7]>, null>(true);
+  util.assertEqual<z.infer<(typeof schemas)[8]>, any>(true);
+  util.assertEqual<z.infer<(typeof schemas)[9]>, Readonly<unknown>>(true);
+  util.assertEqual<z.infer<(typeof schemas)[10]>, void>(true);
+  util.assertEqual<
+    z.infer<(typeof schemas)[11]>,
+    (args_0: string, args_1: number, ...args_2: unknown[]) => unknown
+  >(true);
+  util.assertEqual<z.infer<(typeof schemas)[12]>, readonly string[]>(true);
+
+  util.assertEqual<z.infer<(typeof schemas)[13]>, readonly [string, number]>(
+    true
+  );
+  util.assertEqual<z.infer<(typeof schemas)[14]>, ReadonlyMap<string, Date>>(
+    true
+  );
+  util.assertEqual<z.infer<(typeof schemas)[15]>, ReadonlySet<Promise<string>>>(
+    true
+  );
+  util.assertEqual<
+    z.infer<(typeof schemas)[16]>,
+    Readonly<Record<string, string>>
+  >(true);
+  util.assertEqual<
+    z.infer<(typeof schemas)[17]>,
+    Readonly<Record<string, number>>
+  >(true);
+  util.assertEqual<
+    z.infer<(typeof schemas)[18]>,
+    { readonly a: string; readonly 1: number }
+  >(true);
+  util.assertEqual<z.infer<(typeof schemas)[19]>, Readonly<testEnum>>(true);
+  util.assertEqual<z.infer<(typeof schemas)[20]>, Promise<string>>(true);
+});
+
+// test("deep inference", () => {
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[0]>, string>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[1]>, number>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[2]>, number>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[3]>, bigint>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[4]>, boolean>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[5]>, Date>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[6]>, undefined>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[7]>, null>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[8]>, any>(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[9]>,
+//     Readonly<unknown>
+//   >(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[10]>, void>(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[11]>,
+//     (args_0: string, args_1: number, ...args_2: unknown[]) => unknown
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[12]>,
+//     readonly string[]
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[13]>,
+//     readonly [string, number]
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[14]>,
+//     ReadonlyMap<string, Date>
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[15]>,
+//     ReadonlySet<Promise<string>>
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[16]>,
+//     Readonly<Record<string, string>>
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[17]>,
+//     Readonly<Record<string, number>>
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[18]>,
+//     { readonly a: string; readonly 1: number }
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[19]>,
+//     Readonly<testEnum>
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[20]>,
+//     Promise<string>
+//   >(true);
+
+//   util.assertEqual<
+//     z.infer<typeof crazyDeepReadonlySchema>,
+//     ReadonlyMap<
+//       ReadonlySet<readonly [string, number]>,
+//       {
+//         readonly a: {
+//           readonly [x: string]: readonly any[];
+//         };
+//         readonly b: {
+//           readonly c: {
+//             readonly d: {
+//               readonly e: {
+//                 readonly f: {
+//                   readonly g?: {};
+//                 };
+//               };
+//             };
+//           };
+//         };
+//       }
+//     >
+//   >(true);
+// });
+
+test("object freezing", () => {
+  expect(Object.isFrozen(z.array(z.string()).readonly().parse(["a"]))).toBe(
+    true
+  );
+  expect(
+    Object.isFrozen(
+      z.tuple([z.string(), z.number()]).readonly().parse(["a", 1])
+    )
+  ).toBe(true);
+  expect(
+    Object.isFrozen(
+      z
+        .map(z.string(), z.date())
+        .readonly()
+        .parse(new Map([["a", new Date()]]))
+    )
+  ).toBe(true);
+  expect(
+    Object.isFrozen(
+      z
+        .set(z.promise(z.string()))
+        .readonly()
+        .parse(new Set([Promise.resolve("a")]))
+    )
+  ).toBe(true);
+  expect(
+    Object.isFrozen(z.record(z.string()).readonly().parse({ a: "b" }))
+  ).toBe(true);
+  expect(
+    Object.isFrozen(z.record(z.string(), z.number()).readonly().parse({ a: 1 }))
+  ).toBe(true);
+  expect(
+    Object.isFrozen(
+      z
+        .object({ a: z.string(), 1: z.number() })
+        .readonly()
+        .parse({ a: "b", 1: 2 })
+    )
+  ).toBe(true);
+  expect(
+    Object.isFrozen(
+      z.promise(z.string()).readonly().parse(Promise.resolve("a"))
+    )
+  ).toBe(true);
+});
diff --git a/deno/lib/__tests__/record.test.ts b/deno/lib/__tests__/record.test.ts
index b79d97c20..ecb698af9 100644
--- a/deno/lib/__tests__/record.test.ts
+++ b/deno/lib/__tests__/record.test.ts
@@ -134,3 +134,40 @@ test("key and value getters", () => {
   rec.valueSchema.parse(1234);
   rec.element.parse(1234);
 });
+
+test("is not vulnerable to prototype pollution", async () => {
+  const rec = z.record(
+    z.object({
+      a: z.string(),
+    })
+  );
+
+  const data = JSON.parse(`
+    {
+      "__proto__": {
+        "a": "evil"
+      },
+      "b": {
+        "a": "good"
+      }
+    }
+  `);
+
+  const obj1 = rec.parse(data);
+  expect(obj1.a).toBeUndefined();
+
+  const obj2 = rec.safeParse(data);
+  expect(obj2.success).toBe(true);
+  if (obj2.success) {
+    expect(obj2.data.a).toBeUndefined();
+  }
+
+  const obj3 = await rec.parseAsync(data);
+  expect(obj3.a).toBeUndefined();
+
+  const obj4 = await rec.safeParseAsync(data);
+  expect(obj4.success).toBe(true);
+  if (obj4.success) {
+    expect(obj4.data.a).toBeUndefined();
+  }
+});
diff --git a/deno/lib/__tests__/refine.test.ts b/deno/lib/__tests__/refine.test.ts
index 07b380c14..f505fdbb7 100644
--- a/deno/lib/__tests__/refine.test.ts
+++ b/deno/lib/__tests__/refine.test.ts
@@ -156,6 +156,35 @@ test("superRefine", () => {
   Strings.parse(["asfd", "qwer"]);
 });
 
+test("superRefine async", async () => {
+  const Strings = z.array(z.string()).superRefine(async (val, ctx) => {
+    if (val.length > 3) {
+      ctx.addIssue({
+        code: z.ZodIssueCode.too_big,
+        maximum: 3,
+        type: "array",
+        inclusive: true,
+        exact: true,
+        message: "Too many items 😡",
+      });
+    }
+
+    if (val.length !== new Set(val).size) {
+      ctx.addIssue({
+        code: z.ZodIssueCode.custom,
+        message: `No duplicates allowed.`,
+      });
+    }
+  });
+
+  const result = await Strings.safeParseAsync(["asfd", "asfd", "asfd", "asfd"]);
+
+  expect(result.success).toEqual(false);
+  if (!result.success) expect(result.error.issues.length).toEqual(2);
+
+  Strings.parseAsync(["asfd", "qwer"]);
+});
+
 test("superRefine - type narrowing", () => {
   type NarrowType = { type: string; age: number };
   const schema = z
diff --git a/deno/lib/__tests__/string.test.ts b/deno/lib/__tests__/string.test.ts
index b1959eac4..e067a1c81 100644
--- a/deno/lib/__tests__/string.test.ts
+++ b/deno/lib/__tests__/string.test.ts
@@ -39,60 +39,92 @@ test("failing validations", () => {
 });
 
 test("email validations", () => {
-  const email = z.string().email();
-  email.parse("mojojojo@example.com");
-  expect(() => email.parse("asdf")).toThrow();
-  expect(() => email.parse("@lkjasdf.com")).toThrow();
-  expect(() => email.parse("asdf@sdf.")).toThrow();
-  expect(() => email.parse("asdf@asdf.com-")).toThrow();
-  expect(() => email.parse("asdf@-asdf.com")).toThrow();
-  expect(() => email.parse("asdf@-a(sdf.com")).toThrow();
-  expect(() => email.parse("asdf@-asdf.com(")).toThrow();
-  expect(() =>
-    email.parse("pawan.anand@%9y83&#$%R&#$%R&%#$R%%^^%5rw3ewe.d.d.aaaa.wef.co")
-  ).toThrow();
-});
-
-test("more email validations", () => {
   const validEmails = [
+    `email@domain.com`,
+    `firstname.lastname@domain.com`,
+    `email@subdomain.domain.com`,
+    `firstname+lastname@domain.com`,
+    `1234567890@domain.com`,
+    `email@domain-one.com`,
+    `_______@domain.com`,
+    `email@domain.name`,
+    `email@domain.co.jp`,
+    `firstname-lastname@domain.com`,
     `very.common@example.com`,
     `disposable.style.email.with+symbol@example.com`,
     `other.email-with-hyphen@example.com`,
     `fully-qualified-domain@example.com`,
     `user.name+tag+sorting@example.com`,
     `x@example.com`,
+    `mojojojo@asdf.example.com`,
     `example-indeed@strange-example.com`,
-    `test/test@test.com`,
     `example@s.example`,
-    `" "@example.org`,
-    `"john..doe"@example.org`,
-    `mailhost!username@example.org`,
-    `"very.(),:;<>[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com`,
-    `user%example.com@example.org`,
     `user-@example.org`,
-    `postmaster@[123.123.123.123]`,
     `user@my-example.com`,
     `a@b.cd`,
     `work+user@mail.com`,
+    `tom@test.te-st.com`,
+    `something@subdomain.domain-with-hyphens.tld`,
+    `francois@etu.inp-n7.fr`,
+  ];
+  const invalidEmails = [
+    // no "printable characters"
+    // `user%example.com@example.org`,
+    // `mailhost!username@example.org`,
+    // `test/test@test.com`,
+
+    // double @
+    `francois@@etu.inp-n7.fr`,
+    // do not support quotes
+    `"email"@domain.com`,
+    `"e asdf sadf ?<>ail"@domain.com`,
+    `" "@example.org`,
+    `"john..doe"@example.org`,
+    `"very.(),:;<>[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com`,
+
+    // do not support IPv4
+    `email@123.123.123.123`,
+    `email@[123.123.123.123]`,
+    `postmaster@123.123.123.123`,
     `user@[68.185.127.196]`,
     `ipv4@[85.129.96.247]`,
     `valid@[79.208.229.53]`,
     `valid@[255.255.255.255]`,
     `valid@[255.0.55.2]`,
     `valid@[255.0.55.2]`,
+
+    // do not support ipv6
     `hgrebert0@[IPv6:4dc8:ac7:ce79:8878:1290:6098:5c50:1f25]`,
     `bshapiro4@[IPv6:3669:c709:e981:4884:59a3:75d1:166b:9ae]`,
     `jsmith@[IPv6:2001:db8::1]`,
     `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:7334]`,
     `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:192.168.1.1]`,
-  ];
-  const invalidEmails = [
+
+    // microsoft test cases
+    `plainaddress`,
+    `#@%^%#$@#$@#.com`,
+    `@domain.com`,
+    `Joe Smith &lt;email@domain.com&gt;`,
+    `email.domain.com`,
+    `email@domain@domain.com`,
+    `.email@domain.com`,
+    `email.@domain.com`,
+    `email..email@domain.com`,
+    `あいうえお@domain.com`,
+    `email@domain.com (Joe Smith)`,
+    `email@domain`,
+    `email@-domain.com`,
+    `email@111.222.333.44444`,
+    `email@domain..com`,
     `Abc.example.com`,
     `A@b@c@example.com`,
+    `colin..hacks@domain.com`,
     `a"b(c)d,e:f;g<h>i[j\k]l@example.com`,
     `just"not"right@example.com`,
     `this is"not\allowed@example.com`,
     `this\ still\"not\\allowed@example.com`,
+
+    // random
     `i_like_underscore@but_its_not_allowed_in_this_part.example.com`,
     `QA[icon]CHOCOLATE[icon]@test.com`,
     `invalid@-start.com`,
@@ -113,15 +145,19 @@ test("more email validations", () => {
     `mlivesay3@[9952:143f:b4df:2179:49a1:5e82:b92e:6b6]`,
     `gbacher0@[IPv6:bc37:4d3f:5048:2e26:37cc:248e:df8e:2f7f:af]`,
     `invalid@[IPv6:5348:4ed3:5d38:67fb:e9b:acd2:c13:192.168.256.1]`,
+    `test@.com`,
   ];
   const emailSchema = z.string().email();
+
   expect(
-    validEmails.every((email) => emailSchema.safeParse(email).success)
+    validEmails.every((email) => {
+      return emailSchema.safeParse(email).success;
+    })
   ).toBe(true);
   expect(
-    invalidEmails.every(
-      (email) => emailSchema.safeParse(email).success === false
-    )
+    invalidEmails.every((email) => {
+      return emailSchema.safeParse(email).success === false;
+    })
   ).toBe(true);
 });
 
@@ -172,6 +208,7 @@ test("emoji validations", () => {
 test("uuid", () => {
   const uuid = z.string().uuid("custom error");
   uuid.parse("9491d710-3185-4e06-bea0-6a2f275345e0");
+  uuid.parse("d89e7b01-7598-ed11-9d7a-0022489382fd"); // new sequential id
   uuid.parse("00000000-0000-0000-0000-000000000000");
   uuid.parse("b3ce60f8-e8b9-40f5-1150-172ede56ff74"); // Variant 0 - RFC 4122: Reserved, NCS backward compatibility
   uuid.parse("92e76bf9-28b3-4730-cd7f-cb6bc51f8c09"); // Variant 2 - RFC 4122: Reserved, Microsoft Corporation backward compatibility
diff --git a/deno/lib/__tests__/transformer.test.ts b/deno/lib/__tests__/transformer.test.ts
index 818aa49cb..0fe586aa7 100644
--- a/deno/lib/__tests__/transformer.test.ts
+++ b/deno/lib/__tests__/transformer.test.ts
@@ -212,6 +212,73 @@ test("async preprocess", async () => {
   expect(value).toEqual(["asdf"]);
 });
 
+test("preprocess ctx.addIssue with parse", () => {
+  expect(() => {
+    z.preprocess((data, ctx) => {
+      ctx?.addIssue({
+        code: "custom",
+        message: `${data} is not one of our allowed strings`,
+      });
+      return data;
+    }, z.string()).parse("asdf");
+  }).toThrow(
+    JSON.stringify(
+      [
+        {
+          code: "custom",
+          message: "asdf is not one of our allowed strings",
+          path: [],
+        },
+      ],
+      null,
+      2
+    )
+  );
+});
+
+test("preprocess ctx.addIssue with parseAsync", async () => {
+  const result = await z
+    .preprocess((data, ctx) => {
+      ctx?.addIssue({
+        code: "custom",
+        message: `${data} is not one of our allowed strings`,
+      });
+      return data;
+    }, z.string())
+    .safeParseAsync("asdf");
+
+  expect(JSON.parse(JSON.stringify(result))).toEqual({
+    success: false,
+    error: {
+      issues: [
+        {
+          code: "custom",
+          message: "asdf is not one of our allowed strings",
+          path: [],
+        },
+      ],
+      name: "ZodError",
+    },
+  });
+});
+
+test("z.NEVER in preprocess", async () => {
+  const foo = z.preprocess((val, ctx) => {
+    if (!val) {
+      ctx?.addIssue({ code: z.ZodIssueCode.custom, message: "bad" });
+      return z.NEVER;
+    }
+    return val;
+  }, z.number());
+
+  type foo = z.infer<typeof foo>;
+  util.assertEqual<foo, number>(true);
+  const arg = foo.safeParse(undefined);
+  if (!arg.success) {
+    expect(arg.error.issues[0].message).toEqual("bad");
+  }
+});
+
 test("short circuit on dirty", () => {
   const schema = z
     .string()
diff --git a/deno/lib/helpers/parseUtil.ts b/deno/lib/helpers/parseUtil.ts
index 68e7df6bc..a4311a972 100644
--- a/deno/lib/helpers/parseUtil.ts
+++ b/deno/lib/helpers/parseUtil.ts
@@ -136,7 +136,10 @@ export class ParseStatus {
       if (key.status === "dirty") status.dirty();
       if (value.status === "dirty") status.dirty();
 
-      if (typeof value.value !== "undefined" || pair.alwaysSet) {
+      if (
+        key.value !== "__proto__" &&
+        (typeof value.value !== "undefined" || pair.alwaysSet)
+      ) {
         finalObject[key.value] = value.value;
       }
     }
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 8606ba0ba..0740927fa 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -371,10 +371,10 @@ export abstract class ZodType<
     refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput
   ): ZodEffects<this, RefinedOutput, Input>;
   superRefine(
-    refinement: (arg: Output, ctx: RefinementCtx) => void
+    refinement: (arg: Output, ctx: RefinementCtx) => void | Promise<void>
   ): ZodEffects<this, Output, Input>;
   superRefine(
-    refinement: (arg: Output, ctx: RefinementCtx) => unknown
+    refinement: (arg: Output, ctx: RefinementCtx) => unknown | Promise<unknown>
   ): ZodEffects<this, Output, Input> {
     return this._refinement(refinement);
   }
@@ -402,6 +402,7 @@ export abstract class ZodType<
     this.catch = this.catch.bind(this);
     this.describe = this.describe.bind(this);
     this.pipe = this.pipe.bind(this);
+    this.readonly = this.readonly.bind(this);
     this.isNullable = this.isNullable.bind(this);
     this.isOptional = this.isOptional.bind(this);
   }
@@ -489,6 +490,9 @@ export abstract class ZodType<
   pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T> {
     return ZodPipeline.create(this, target);
   }
+  readonly(): ZodReadonly<this> {
+    return ZodReadonly.create(this);
+  }
 
   isOptional(): boolean {
     return this.safeParse(undefined).success;
@@ -541,17 +545,27 @@ export interface ZodStringDef extends ZodTypeDef {
 const cuidRegex = /^c[^\s-]{8,}$/i;
 const cuid2Regex = /^[a-z][a-z0-9]*$/;
 const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
+// const uuidRegex =
+//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
 const uuidRegex =
-  /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+  /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
 // from https://stackoverflow.com/a/46181/1550155
 // old version: too slow, didn't support unicode
 // const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
 //old email regex
 // const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
 // eslint-disable-next-line
-
+// const emailRegex =
+//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
+// const emailRegex =
+//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
+// const emailRegex =
+//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
 const emailRegex =
-  /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
+  /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
+// const emailRegex =
+//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
+
 // from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
 const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
 
@@ -3431,6 +3445,12 @@ export class ZodMap<
   ZodMapDef<Key, Value>,
   Map<Key["_input"], Value["_input"]>
 > {
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
   _parse(input: ParseInput): ParseReturnType<this["_output"]> {
     const { status, ctx } = this._processInputParams(input);
     if (ctx.parsedType !== ZodParsedType.map) {
@@ -3947,12 +3967,15 @@ function createZodEnum<U extends string, T extends [U, ...U[]]>(
   values: T,
   params?: RawCreateParams
 ): ZodEnum<T>;
-function createZodEnum(values: any, params?: RawCreateParams) {
+function createZodEnum(
+  values: [string, ...string[]],
+  params?: RawCreateParams
+) {
   return new ZodEnum({
-    values: values as any,
+    values,
     typeName: ZodFirstPartyTypeKind.ZodEnum,
     ...processCreateParams(params),
-  }) as any;
+  });
 }
 
 export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
@@ -4172,7 +4195,10 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
 //////////////////////////////////////////////
 
 export type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
-export type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;
+export type SuperRefinement<T> = (
+  arg: T,
+  ctx: RefinementCtx
+) => void | Promise<void>;
 
 export type RefinementEffect<T> = {
   type: "refinement";
@@ -4184,7 +4210,7 @@ export type TransformEffect<T> = {
 };
 export type PreprocessEffect<T> = {
   type: "preprocess";
-  transform: (arg: T) => any;
+  transform: (arg: T, ctx: RefinementCtx) => any;
 };
 export type Effect<T> =
   | RefinementEffect<T>
@@ -4218,8 +4244,30 @@ export class ZodEffects<
 
     const effect = this._def.effect || null;
 
+    const checkCtx: RefinementCtx = {
+      addIssue: (arg: IssueData) => {
+        addIssueToContext(ctx, arg);
+        if (arg.fatal) {
+          status.abort();
+        } else {
+          status.dirty();
+        }
+      },
+      get path() {
+        return ctx.path;
+      },
+    };
+
+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
     if (effect.type === "preprocess") {
-      const processed = effect.transform(ctx.data);
+      const processed = effect.transform(ctx.data, checkCtx);
+      if (ctx.common.issues.length) {
+        return {
+          status: "dirty",
+          value: ctx.data,
+        };
+      }
 
       if (ctx.common.async) {
         return Promise.resolve(processed).then((processed) => {
@@ -4237,22 +4285,6 @@ export class ZodEffects<
         });
       }
     }
-
-    const checkCtx: RefinementCtx = {
-      addIssue: (arg: IssueData) => {
-        addIssueToContext(ctx, arg);
-        if (arg.fatal) {
-          status.abort();
-        } else {
-          status.dirty();
-        }
-      },
-      get path() {
-        return ctx.path;
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
     if (effect.type === "refinement") {
       const executeRefinement = (
         acc: unknown
@@ -4344,7 +4376,7 @@ export class ZodEffects<
   };
 
   static createWithPreprocess = <I extends ZodTypeAny>(
-    preprocess: (arg: unknown) => unknown,
+    preprocess: (arg: unknown, ctx: RefinementCtx) => unknown,
     schema: I,
     params?: RawCreateParams
   ): ZodEffects<I, I["_output"], unknown> => {
@@ -4740,6 +4772,72 @@ export class ZodPipeline<
   }
 }
 
+///////////////////////////////////////////
+///////////////////////////////////////////
+//////////                       //////////
+//////////      ZodReadonly      //////////
+//////////                       //////////
+///////////////////////////////////////////
+///////////////////////////////////////////
+type BuiltIn =
+  | (((...args: any[]) => any) | (new (...args: any[]) => any))
+  | { readonly [Symbol.toStringTag]: string }
+  | Date
+  | Error
+  | Generator
+  | Promise<unknown>
+  | RegExp;
+
+type MakeReadonly<T> = T extends Map<infer K, infer V>
+  ? ReadonlyMap<K, V>
+  : T extends Set<infer V>
+  ? ReadonlySet<V>
+  : T extends [infer Head, ...infer Tail]
+  ? readonly [Head, ...Tail]
+  : T extends Array<infer V>
+  ? ReadonlyArray<V>
+  : T extends BuiltIn
+  ? T
+  : Readonly<T>;
+
+export interface ZodReadonlyDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  innerType: T;
+  typeName: ZodFirstPartyTypeKind.ZodReadonly;
+}
+
+export class ZodReadonly<T extends ZodTypeAny> extends ZodType<
+  MakeReadonly<T["_output"]>,
+  ZodReadonlyDef<T>,
+  T["_input"]
+> {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const result = this._def.innerType._parse(input);
+    if (isValid(result)) {
+      result.value = Object.freeze(result.value);
+    }
+    return result;
+  }
+
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodReadonly<T> => {
+    return new ZodReadonly({
+      innerType: type,
+      typeName: ZodFirstPartyTypeKind.ZodReadonly,
+      ...processCreateParams(params),
+    }) as any;
+  };
+}
+
+////////////////////////////////////////
+////////////////////////////////////////
+//////////                    //////////
+//////////      z.custom      //////////
+//////////                    //////////
+////////////////////////////////////////
+////////////////////////////////////////
 type CustomParams = CustomErrorParams & { fatal?: boolean };
 export const custom = <T>(
   check?: (data: unknown) => any,
@@ -4815,6 +4913,7 @@ export enum ZodFirstPartyTypeKind {
   ZodPromise = "ZodPromise",
   ZodBranded = "ZodBranded",
   ZodPipeline = "ZodPipeline",
+  ZodReadonly = "ZodReadonly",
 }
 export type ZodFirstPartySchemaTypes =
   | ZodString
@@ -4852,8 +4951,7 @@ export type ZodFirstPartySchemaTypes =
   | ZodBranded<any, any>
   | ZodPipeline<any, any>;
 
-// new approach that works for abstract classes
-// but requires TS 4.4+
+// requires TS 4.4+
 abstract class Class {
   constructor(..._: any[]) {}
 }
diff --git a/index.html b/index.html
index daae856cd..e63d1eee0 100644
--- a/index.html
+++ b/index.html
@@ -246,6 +246,7 @@
           "https://twitter.com/colinhacks",
           "https://trpc.io/",
           "https://zod.dev/",
+          "https://deno.land/x/zod",
         ],
       };
     </script>
@@ -256,5 +257,6 @@
           .prepend(document.querySelector(".theme-btn"));
       });
     </script>
+    <script src="https://www.unpkg.com/zod/lib/index.umd.js"></script>
   </body>
 </html>
diff --git a/jest.config.json b/jest.config.json
index 936e972f8..8051d1085 100644
--- a/jest.config.json
+++ b/jest.config.json
@@ -4,6 +4,7 @@
     "^.+\\.tsx?$": "ts-jest"
   },
   "testRegex": "src/.*\\.test\\.ts$",
+  "modulePathIgnorePatterns": ["language-server", "__vitest__"],
   "moduleFileExtensions": ["ts", "tsx", "js", "jsx", "json", "node"],
   "coverageReporters": ["json-summary", "text", "lcov"]
 }
diff --git a/package.json b/package.json
index 2f47ce4fb..040f511f7 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.21.4",
+  "version": "3.22.0",
   "author": "Colin McDonnell <colin@colinhacks.com>",
   "repository": {
     "type": "git",
@@ -9,12 +9,18 @@
   "main": "./lib/index.js",
   "module": "./lib/index.mjs",
   "devDependencies": {
+    "@babel/core": "^7.22.5",
+    "@babel/preset-env": "^7.22.5",
+    "@babel/preset-typescript": "^7.22.5",
     "@rollup/plugin-typescript": "^8.2.0",
+    "@swc/core": "^1.3.66",
+    "@swc/jest": "^0.2.26",
     "@types/benchmark": "^2.1.0",
     "@types/jest": "^29.2.2",
     "@types/node": "14",
     "@typescript-eslint/eslint-plugin": "^5.15.0",
     "@typescript-eslint/parser": "^5.15.0",
+    "babel-jest": "^29.5.0",
     "benchmark": "^2.1.4",
     "dependency-cruiser": "^9.19.0",
     "eslint": "^8.11.0",
@@ -30,18 +36,19 @@
     "prettier": "^2.6.0",
     "pretty-quick": "^3.1.3",
     "rollup": "^2.70.1",
-    "ts-jest": "^29.0.3",
+    "ts-jest": "^29.1.0",
     "ts-morph": "^14.0.0",
     "ts-node": "^10.9.1",
     "tslib": "^2.3.1",
     "tsx": "^3.8.0",
-    "typescript": "~4.5.0"
+    "typescript": "~4.5.0",
+    "vitest": "^0.32.2"
   },
   "exports": {
     ".": {
+      "types": "./index.d.ts",
       "require": "./lib/index.js",
-      "import": "./lib/index.mjs",
-      "types": "./index.d.ts"
+      "import": "./lib/index.mjs"
     },
     "./package.json": "./package.json",
     "./locales/*": "./lib/locales/*"
@@ -68,25 +75,32 @@
     "src/*.ts": [
       "eslint --cache --fix",
       "prettier --ignore-unknown --write"
+    ],
+    "*.md": [
+      "prettier --ignore-unknown --write"
     ]
   },
   "scripts": {
-    "prettier:check": "prettier --check src/**/*.ts deno/lib/**/*.ts --no-error-on-unmatched-pattern",
-    "prettier:fix": "prettier --write src/**/*.ts deno/lib/**/*.ts --ignore-unknown --no-error-on-unmatched-pattern",
+    "prettier:check": "prettier --check src/**/*.ts deno/lib/**/*.ts *.md --no-error-on-unmatched-pattern",
+    "prettier:fix": "prettier --write src/**/*.ts deno/lib/**/*.ts *.md --ignore-unknown --no-error-on-unmatched-pattern",
     "lint:check": "eslint --cache --ext .ts ./src",
     "lint:fix": "eslint --cache --fix --ext .ts ./src",
     "check": "yarn lint:check && yarn prettier:check",
     "fix": "yarn lint:fix && yarn prettier:fix",
     "clean": "rm -rf lib/* deno/lib/*",
     "build": "yarn run clean && npm run build:cjs && npm run build:esm && npm run build:deno",
-    "build:deno": "node ./deno/build.mjs && cp ./README.md ./deno/lib",
-    "build:esm": "rollup --config rollup.config.js",
-    "build:cjs": "tsc -p tsconfig.cjs.json",
-    "build:types": "tsc -p tsconfig.types.json",
-    "build:test": "tsc -p tsconfig.test.json",
-    "rollup": "rollup --config rollup.config.js",
-    "test:watch": "jest --watch",
-    "test": "jest --coverage",
+    "build:deno": "node ./deno-build.mjs && cp ./README.md ./deno/lib",
+    "build:esm": "rollup --config ./configs/rollup.config.js",
+    "build:cjs": "tsc -p ./configs/tsconfig.cjs.json",
+    "build:types": "tsc -p ./configs/tsconfig.types.json",
+    "build:test": "tsc -p ./configs/tsconfig.test.json",
+    "test:watch": "yarn test:ts-jest --watch",
+    "test": "yarn test:ts-jest",
+    "test:babel": "jest --coverage --config ./configs/babel-jest.config.json",
+    "test:bun": "bun test",
+    "test:vitest": "npx vitest --config ./configs/vitest.config.ts",
+    "test:ts-jest": "npx jest --config ./configs/ts-jest.config.json",
+    "test:swc": "npx jest --config ./configs/swc-jest.config.json",
     "test:deno": "cd deno && deno test",
     "prepublishOnly": "npm run test && npm run build && npm run build:deno",
     "play": "nodemon -e ts -w . -x tsx playground.ts",
diff --git a/playground.ts b/playground.ts
index d17b18eb4..4e01473b6 100644
--- a/playground.ts
+++ b/playground.ts
@@ -1,2 +1,3 @@
 import { z } from "./src";
+
 z;
diff --git a/src/__tests__/coerce.test.ts b/src/__tests__/coerce.test.ts
index 79d91d1fc..3a8b99c17 100644
--- a/src/__tests__/coerce.test.ts
+++ b/src/__tests__/coerce.test.ts
@@ -34,21 +34,21 @@ test("number coercion", () => {
   expect(schema.parse("-12")).toEqual(-12);
   expect(schema.parse("3.14")).toEqual(3.14);
   expect(schema.parse("")).toEqual(0);
-  expect(() => schema.parse("NOT_A_NUMBER")).toThrow; // z.ZodError
+  expect(() => schema.parse("NOT_A_NUMBER")).toThrow(); // z.ZodError
   expect(schema.parse(12)).toEqual(12);
   expect(schema.parse(0)).toEqual(0);
   expect(schema.parse(-12)).toEqual(-12);
   expect(schema.parse(3.14)).toEqual(3.14);
   expect(schema.parse(BigInt(15))).toEqual(15);
-  expect(() => schema.parse(NaN)).toThrow; // z.ZodError
+  expect(() => schema.parse(NaN)).toThrow(); // z.ZodError
   expect(schema.parse(Infinity)).toEqual(Infinity);
   expect(schema.parse(-Infinity)).toEqual(-Infinity);
   expect(schema.parse(true)).toEqual(1);
   expect(schema.parse(false)).toEqual(0);
   expect(schema.parse(null)).toEqual(0);
-  expect(() => schema.parse(undefined)).toThrow; // z.ZodError
-  expect(() => schema.parse({ hello: "world!" })).toThrow; // z.ZodError
-  expect(() => schema.parse(["item", "another_item"])).toThrow; // z.ZodError
+  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError
+  expect(() => schema.parse({ hello: "world!" })).toThrow(); // z.ZodError
+  expect(() => schema.parse(["item", "another_item"])).toThrow(); // z.ZodError
   expect(schema.parse([])).toEqual(0);
   expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);
 });
@@ -83,23 +83,23 @@ test("bigint coercion", () => {
   expect(schema.parse("5")).toEqual(BigInt(5));
   expect(schema.parse("0")).toEqual(BigInt(0));
   expect(schema.parse("-5")).toEqual(BigInt(-5));
-  expect(() => schema.parse("3.14")).toThrow; // not a z.ZodError!
+  expect(() => schema.parse("3.14")).toThrow(); // not a z.ZodError!
   expect(schema.parse("")).toEqual(BigInt(0));
-  expect(() => schema.parse("NOT_A_NUMBER")).toThrow; // not a z.ZodError!
+  expect(() => schema.parse("NOT_A_NUMBER")).toThrow(); // not a z.ZodError!
   expect(schema.parse(5)).toEqual(BigInt(5));
   expect(schema.parse(0)).toEqual(BigInt(0));
   expect(schema.parse(-5)).toEqual(BigInt(-5));
-  expect(() => schema.parse(3.14)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(3.14)).toThrow(); // not a z.ZodError!
   expect(schema.parse(BigInt(5))).toEqual(BigInt(5));
-  expect(() => schema.parse(NaN)).toThrow; // not a z.ZodError!
-  expect(() => schema.parse(Infinity)).toThrow; // not a z.ZodError!
-  expect(() => schema.parse(-Infinity)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(NaN)).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse(Infinity)).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse(-Infinity)).toThrow(); // not a z.ZodError!
   expect(schema.parse(true)).toEqual(BigInt(1));
   expect(schema.parse(false)).toEqual(BigInt(0));
-  expect(() => schema.parse(null)).toThrow; // not a z.ZodError!
-  expect(() => schema.parse(undefined)).toThrow; // not a z.ZodError!
-  expect(() => schema.parse({ hello: "world!" })).toThrow; // not a z.ZodError!
-  expect(() => schema.parse(["item", "another_item"])).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(null)).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse(undefined)).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse({ hello: "world!" })).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse(["item", "another_item"])).toThrow(); // not a z.ZodError!
   expect(schema.parse([])).toEqual(BigInt(0));
   expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));
 });
@@ -110,25 +110,26 @@ test("date coercion", () => {
   expect(schema.parse(new Date().toISOString())).toBeInstanceOf(Date);
   expect(schema.parse(new Date().toUTCString())).toBeInstanceOf(Date);
   expect(schema.parse("5")).toBeInstanceOf(Date);
-  expect(schema.parse("0")).toBeInstanceOf(Date);
-  expect(schema.parse("-5")).toBeInstanceOf(Date);
-  expect(schema.parse("3.14")).toBeInstanceOf(Date);
-  expect(() => schema.parse("")).toThrow; // z.ZodError
-  expect(() => schema.parse("NOT_A_DATE")).toThrow; // z.ZodError
+  expect(schema.parse("2000-01-01")).toBeInstanceOf(Date);
+  // expect(schema.parse("0")).toBeInstanceOf(Date);
+  // expect(schema.parse("-5")).toBeInstanceOf(Date);
+  // expect(schema.parse("3.14")).toBeInstanceOf(Date);
+  expect(() => schema.parse("")).toThrow(); // z.ZodError
+  expect(() => schema.parse("NOT_A_DATE")).toThrow(); // z.ZodError
   expect(schema.parse(5)).toBeInstanceOf(Date);
   expect(schema.parse(0)).toBeInstanceOf(Date);
   expect(schema.parse(-5)).toBeInstanceOf(Date);
   expect(schema.parse(3.14)).toBeInstanceOf(Date);
-  expect(() => schema.parse(BigInt(5))).toThrow; // not a z.ZodError!
-  expect(() => schema.parse(NaN)).toThrow; // z.ZodError
-  expect(() => schema.parse(Infinity)).toThrow; // z.ZodError
-  expect(() => schema.parse(-Infinity)).toThrow; // z.ZodError
+  expect(() => schema.parse(BigInt(5))).toThrow(); // not a z.ZodError!
+  expect(() => schema.parse(NaN)).toThrow(); // z.ZodError
+  expect(() => schema.parse(Infinity)).toThrow(); // z.ZodError
+  expect(() => schema.parse(-Infinity)).toThrow(); // z.ZodError
   expect(schema.parse(true)).toBeInstanceOf(Date);
   expect(schema.parse(false)).toBeInstanceOf(Date);
   expect(schema.parse(null)).toBeInstanceOf(Date);
-  expect(() => schema.parse(undefined)).toThrow; // z.ZodError
-  expect(() => schema.parse({ hello: "world!" })).toThrow; // z.ZodError
-  expect(() => schema.parse(["item", "another_item"])).toThrow; // z.ZodError
-  expect(() => schema.parse([])).toThrow; // z.ZodError
+  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError
+  expect(() => schema.parse({ hello: "world!" })).toThrow(); // z.ZodError
+  expect(() => schema.parse(["item", "another_item"])).toThrow(); // z.ZodError
+  expect(() => schema.parse([])).toThrow(); // z.ZodError
   expect(schema.parse(new Date())).toBeInstanceOf(Date);
 });
diff --git a/src/__tests__/custom.test.ts b/src/__tests__/custom.test.ts
index 7292a87a6..0fb9ca46c 100644
--- a/src/__tests__/custom.test.ts
+++ b/src/__tests__/custom.test.ts
@@ -14,5 +14,5 @@ test("string params", () => {
   const result = example1.safeParse(1234);
   expect(result.success).toEqual(false);
   // @ts-ignore
-  expect(JSON.stringify(result.error)).toContain("customerr");
+  expect(JSON.stringify(result.error).includes("customerr")).toEqual(true);
 });
diff --git a/src/__tests__/discriminatedUnions.test.ts b/src/__tests__/discriminated-unions.test.ts
similarity index 100%
rename from src/__tests__/discriminatedUnions.test.ts
rename to src/__tests__/discriminated-unions.test.ts
diff --git a/src/__tests__/languageServerFeatures.source.ts b/src/__tests__/language-server.source.ts
similarity index 100%
rename from src/__tests__/languageServerFeatures.source.ts
rename to src/__tests__/language-server.source.ts
diff --git a/src/__tests__/language-server.test.ts b/src/__tests__/language-server.test.ts
new file mode 100644
index 000000000..fb5c647e5
--- /dev/null
+++ b/src/__tests__/language-server.test.ts
@@ -0,0 +1,208 @@
+// @ts-ignore TS6133
+import { describe, expect, test } from "@jest/globals";
+// import path from "path";
+// import { Node, Project, SyntaxKind } from "ts-morph";
+
+// import { filePath } from "./language-server.source";
+
+// The following tool is helpful for understanding the TypeScript AST associated with these tests:
+// https://ts-ast-viewer.com/ (just copy the contents of language-server.source into the viewer)
+
+test("", () => {});
+// describe("Executing Go To Definition (and therefore Find Usages and Rename Refactoring) using an IDE works on inferred object properties", () => {
+//   // Compile file developmentEnvironment.source
+//   const project = new Project({
+//     tsConfigFilePath: path.join(__dirname, "..", "..", "tsconfig.json"),
+//     skipAddingFilesFromTsConfig: true,
+//   });
+//   const sourceFile = project.addSourceFileAtPath(filePath);
+
+//   test("works for object properties inferred from z.object()", () => {
+//     // Find usage of Test.f1 property
+//     const instanceVariable =
+//       sourceFile.getVariableDeclarationOrThrow("instanceOfTest");
+//     const propertyBeingAssigned = getPropertyBeingAssigned(
+//       instanceVariable,
+//       "f1"
+//     );
+
+//     // Find definition of Test.f1 property
+//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
+//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
+//       SyntaxKind.VariableDeclaration
+//     );
+
+//     // Assert that find definition returned the Zod definition of Test
+//     expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
+//     expect(parentOfProperty?.getName()).toEqual("Test");
+//   });
+
+//   // test("works for first object properties inferred from z.object().merge()", () => {
+//   //   // Find usage of TestMerge.f1 property
+//   //   const instanceVariable = sourceFile.getVariableDeclarationOrThrow(
+//   //     "instanceOfTestMerge"
+//   //   );
+//   //   const propertyBeingAssigned = getPropertyBeingAssigned(
+//   //     instanceVariable,
+//   //     "f1"
+//   //   );
+
+//   //   // Find definition of TestMerge.f1 property
+//   //   const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
+//   //   const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
+//   //     SyntaxKind.VariableDeclaration
+//   //   );
+
+//   //   // Assert that find definition returned the Zod definition of Test
+//   //   expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
+//   //   expect(parentOfProperty?.getName()).toEqual("Test");
+//   // });
+
+//   // test("works for second object properties inferred from z.object().merge()", () => {
+//   //   // Find usage of TestMerge.f2 property
+//   //   const instanceVariable = sourceFile.getVariableDeclarationOrThrow(
+//   //     "instanceOfTestMerge"
+//   //   );
+//   //   const propertyBeingAssigned = getPropertyBeingAssigned(
+//   //     instanceVariable,
+//   //     "f2"
+//   //   );
+
+//   //   // Find definition of TestMerge.f2 property
+//   //   const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
+//   //   const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
+//   //     SyntaxKind.VariableDeclaration
+//   //   );
+
+//   //   // Assert that find definition returned the Zod definition of TestMerge
+//   //   expect(definitionOfProperty?.getText()).toEqual(
+//   //     "f2: z.string().optional()"
+//   //   );
+//   //   expect(parentOfProperty?.getName()).toEqual("TestMerge");
+//   // });
+
+//   test("works for first object properties inferred from z.union()", () => {
+//     // Find usage of TestUnion.f1 property
+//     const instanceVariable = sourceFile.getVariableDeclarationOrThrow(
+//       "instanceOfTestUnion"
+//     );
+//     const propertyBeingAssigned = getPropertyBeingAssigned(
+//       instanceVariable,
+//       "f1"
+//     );
+
+//     // Find definition of TestUnion.f1 property
+//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
+//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
+//       SyntaxKind.VariableDeclaration
+//     );
+
+//     // Assert that find definition returned the Zod definition of Test
+//     expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
+//     expect(parentOfProperty?.getName()).toEqual("Test");
+//   });
+
+//   test("works for second object properties inferred from z.union()", () => {
+//     // Find usage of TestUnion.f2 property
+//     const instanceVariable = sourceFile.getVariableDeclarationOrThrow(
+//       "instanceOfTestUnion"
+//     );
+//     const propertyBeingAssigned = getPropertyBeingAssigned(
+//       instanceVariable,
+//       "f2"
+//     );
+
+//     // Find definition of TestUnion.f2 property
+//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
+//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
+//       SyntaxKind.VariableDeclaration
+//     );
+
+//     // Assert that find definition returned the Zod definition of TestUnion
+//     expect(definitionOfProperty?.getText()).toEqual(
+//       "f2: z.string().optional()"
+//     );
+//     expect(parentOfProperty?.getName()).toEqual("TestUnion");
+//   });
+
+//   test("works for object properties inferred from z.object().partial()", () => {
+//     // Find usage of TestPartial.f1 property
+//     const instanceVariable = sourceFile.getVariableDeclarationOrThrow(
+//       "instanceOfTestPartial"
+//     );
+//     const propertyBeingAssigned = getPropertyBeingAssigned(
+//       instanceVariable,
+//       "f1"
+//     );
+
+//     // Find definition of TestPartial.f1 property
+//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
+//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
+//       SyntaxKind.VariableDeclaration
+//     );
+
+//     // Assert that find definition returned the Zod definition of Test
+//     expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
+//     expect(parentOfProperty?.getName()).toEqual("Test");
+//   });
+
+//   test("works for object properties inferred from z.object().pick()", () => {
+//     // Find usage of TestPick.f1 property
+//     const instanceVariable =
+//       sourceFile.getVariableDeclarationOrThrow("instanceOfTestPick");
+//     const propertyBeingAssigned = getPropertyBeingAssigned(
+//       instanceVariable,
+//       "f1"
+//     );
+
+//     // Find definition of TestPick.f1 property
+//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
+//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
+//       SyntaxKind.VariableDeclaration
+//     );
+
+//     // Assert that find definition returned the Zod definition of Test
+//     expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
+//     expect(parentOfProperty?.getName()).toEqual("Test");
+//   });
+
+//   test("works for object properties inferred from z.object().omit()", () => {
+//     // Find usage of TestOmit.f1 property
+//     const instanceVariable =
+//       sourceFile.getVariableDeclarationOrThrow("instanceOfTestOmit");
+//     const propertyBeingAssigned = getPropertyBeingAssigned(
+//       instanceVariable,
+//       "f1"
+//     );
+
+//     // Find definition of TestOmit.f1 property
+//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
+//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
+//       SyntaxKind.VariableDeclaration
+//     );
+
+//     // Assert that find definition returned the Zod definition of Test
+//     expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
+//     expect(parentOfProperty?.getName()).toEqual("Test");
+//   });
+// });
+
+// const getPropertyBeingAssigned = (node: Node, name: string) => {
+//   const propertyAssignment = node.forEachDescendant((descendent) =>
+//     Node.isPropertyAssignment(descendent) && descendent.getName() == name
+//       ? descendent
+//       : undefined
+//   );
+
+//   if (propertyAssignment == null)
+//     fail(`Could not find property assignment with name ${name}`);
+
+//   const propertyLiteral = propertyAssignment.getFirstDescendantByKind(
+//     SyntaxKind.Identifier
+//   );
+
+//   if (propertyLiteral == null)
+//     fail(`Could not find property literal with name ${name}`);
+
+//   return propertyLiteral;
+// };
diff --git a/src/__tests__/languageServerFeatures.test.ts b/src/__tests__/languageServerFeatures.test.ts
deleted file mode 100644
index 499d25d3f..000000000
--- a/src/__tests__/languageServerFeatures.test.ts
+++ /dev/null
@@ -1,207 +0,0 @@
-// @ts-ignore TS6133
-import { expect, fit } from "@jest/globals";
-import path from "path";
-import { Node, Project, SyntaxKind } from "ts-morph";
-
-import { filePath } from "./languageServerFeatures.source";
-
-// The following tool is helpful for understanding the TypeScript AST associated with these tests:
-// https://ts-ast-viewer.com/ (just copy the contents of languageServerFeatures.source into the viewer)
-
-describe("Executing Go To Definition (and therefore Find Usages and Rename Refactoring) using an IDE works on inferred object properties", () => {
-  // Compile file developmentEnvironment.source
-  const project = new Project({
-    tsConfigFilePath: path.join(__dirname, "..", "..", "tsconfig.json"),
-    skipAddingFilesFromTsConfig: true,
-  });
-  const sourceFile = project.addSourceFileAtPath(filePath);
-
-  test("works for object properties inferred from z.object()", () => {
-    // Find usage of Test.f1 property
-    const instanceVariable =
-      sourceFile.getVariableDeclarationOrThrow("instanceOfTest");
-    const propertyBeingAssigned = getPropertyBeingAssigned(
-      instanceVariable,
-      "f1"
-    );
-
-    // Find definition of Test.f1 property
-    const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
-    const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
-      SyntaxKind.VariableDeclaration
-    );
-
-    // Assert that find definition returned the Zod definition of Test
-    expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
-    expect(parentOfProperty?.getName()).toEqual("Test");
-  });
-
-  // test("works for first object properties inferred from z.object().merge()", () => {
-  //   // Find usage of TestMerge.f1 property
-  //   const instanceVariable = sourceFile.getVariableDeclarationOrThrow(
-  //     "instanceOfTestMerge"
-  //   );
-  //   const propertyBeingAssigned = getPropertyBeingAssigned(
-  //     instanceVariable,
-  //     "f1"
-  //   );
-
-  //   // Find definition of TestMerge.f1 property
-  //   const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
-  //   const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
-  //     SyntaxKind.VariableDeclaration
-  //   );
-
-  //   // Assert that find definition returned the Zod definition of Test
-  //   expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
-  //   expect(parentOfProperty?.getName()).toEqual("Test");
-  // });
-
-  // test("works for second object properties inferred from z.object().merge()", () => {
-  //   // Find usage of TestMerge.f2 property
-  //   const instanceVariable = sourceFile.getVariableDeclarationOrThrow(
-  //     "instanceOfTestMerge"
-  //   );
-  //   const propertyBeingAssigned = getPropertyBeingAssigned(
-  //     instanceVariable,
-  //     "f2"
-  //   );
-
-  //   // Find definition of TestMerge.f2 property
-  //   const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
-  //   const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
-  //     SyntaxKind.VariableDeclaration
-  //   );
-
-  //   // Assert that find definition returned the Zod definition of TestMerge
-  //   expect(definitionOfProperty?.getText()).toEqual(
-  //     "f2: z.string().optional()"
-  //   );
-  //   expect(parentOfProperty?.getName()).toEqual("TestMerge");
-  // });
-
-  test("works for first object properties inferred from z.union()", () => {
-    // Find usage of TestUnion.f1 property
-    const instanceVariable = sourceFile.getVariableDeclarationOrThrow(
-      "instanceOfTestUnion"
-    );
-    const propertyBeingAssigned = getPropertyBeingAssigned(
-      instanceVariable,
-      "f1"
-    );
-
-    // Find definition of TestUnion.f1 property
-    const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
-    const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
-      SyntaxKind.VariableDeclaration
-    );
-
-    // Assert that find definition returned the Zod definition of Test
-    expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
-    expect(parentOfProperty?.getName()).toEqual("Test");
-  });
-
-  test("works for second object properties inferred from z.union()", () => {
-    // Find usage of TestUnion.f2 property
-    const instanceVariable = sourceFile.getVariableDeclarationOrThrow(
-      "instanceOfTestUnion"
-    );
-    const propertyBeingAssigned = getPropertyBeingAssigned(
-      instanceVariable,
-      "f2"
-    );
-
-    // Find definition of TestUnion.f2 property
-    const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
-    const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
-      SyntaxKind.VariableDeclaration
-    );
-
-    // Assert that find definition returned the Zod definition of TestUnion
-    expect(definitionOfProperty?.getText()).toEqual(
-      "f2: z.string().optional()"
-    );
-    expect(parentOfProperty?.getName()).toEqual("TestUnion");
-  });
-
-  test("works for object properties inferred from z.object().partial()", () => {
-    // Find usage of TestPartial.f1 property
-    const instanceVariable = sourceFile.getVariableDeclarationOrThrow(
-      "instanceOfTestPartial"
-    );
-    const propertyBeingAssigned = getPropertyBeingAssigned(
-      instanceVariable,
-      "f1"
-    );
-
-    // Find definition of TestPartial.f1 property
-    const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
-    const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
-      SyntaxKind.VariableDeclaration
-    );
-
-    // Assert that find definition returned the Zod definition of Test
-    expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
-    expect(parentOfProperty?.getName()).toEqual("Test");
-  });
-
-  test("works for object properties inferred from z.object().pick()", () => {
-    // Find usage of TestPick.f1 property
-    const instanceVariable =
-      sourceFile.getVariableDeclarationOrThrow("instanceOfTestPick");
-    const propertyBeingAssigned = getPropertyBeingAssigned(
-      instanceVariable,
-      "f1"
-    );
-
-    // Find definition of TestPick.f1 property
-    const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
-    const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
-      SyntaxKind.VariableDeclaration
-    );
-
-    // Assert that find definition returned the Zod definition of Test
-    expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
-    expect(parentOfProperty?.getName()).toEqual("Test");
-  });
-
-  test("works for object properties inferred from z.object().omit()", () => {
-    // Find usage of TestOmit.f1 property
-    const instanceVariable =
-      sourceFile.getVariableDeclarationOrThrow("instanceOfTestOmit");
-    const propertyBeingAssigned = getPropertyBeingAssigned(
-      instanceVariable,
-      "f1"
-    );
-
-    // Find definition of TestOmit.f1 property
-    const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];
-    const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(
-      SyntaxKind.VariableDeclaration
-    );
-
-    // Assert that find definition returned the Zod definition of Test
-    expect(definitionOfProperty?.getText()).toEqual("f1: z.number()");
-    expect(parentOfProperty?.getName()).toEqual("Test");
-  });
-});
-
-const getPropertyBeingAssigned = (node: Node, name: string) => {
-  const propertyAssignment = node.forEachDescendant((descendent) =>
-    Node.isPropertyAssignment(descendent) && descendent.getName() == name
-      ? descendent
-      : undefined
-  );
-
-  if (propertyAssignment == null)
-    fail(`Could not find property assignment with name ${name}`);
-
-  const propertyLiteral = propertyAssignment.getFirstDescendantByKind(
-    SyntaxKind.Identifier
-  );
-
-  if (propertyLiteral == null)
-    fail(`Could not find property literal with name ${name}`);
-
-  return propertyLiteral;
-};
diff --git a/src/__tests__/primitive.test.ts b/src/__tests__/primitive.test.ts
index 28c11e713..cd1c4f5fc 100644
--- a/src/__tests__/primitive.test.ts
+++ b/src/__tests__/primitive.test.ts
@@ -447,7 +447,7 @@ test("get literal value", () => {
   expect(literalStringSchema.value).toEqual("asdf");
 });
 
-test("optional convenience methd", () => {
+test("optional convenience method", () => {
   z.ostring().parse(undefined);
   z.onumber().parse(undefined);
   z.oboolean().parse(undefined);
diff --git a/src/__tests__/readonly.test.ts b/src/__tests__/readonly.test.ts
new file mode 100644
index 000000000..3007a6fac
--- /dev/null
+++ b/src/__tests__/readonly.test.ts
@@ -0,0 +1,204 @@
+// @ts-ignore TS6133
+import { test, expect } from "@jest/globals";
+
+import { util } from "../helpers/util";
+import * as z from "../index";
+
+enum testEnum {
+  A,
+  B,
+}
+
+const schemas = [
+  z.string().readonly(),
+  z.number().readonly(),
+  z.nan().readonly(),
+  z.bigint().readonly(),
+  z.boolean().readonly(),
+  z.date().readonly(),
+  z.undefined().readonly(),
+  z.null().readonly(),
+  z.any().readonly(),
+  z.unknown().readonly(),
+  z.void().readonly(),
+  z.function().args(z.string(), z.number()).readonly(),
+
+  z.array(z.string()).readonly(),
+  z.tuple([z.string(), z.number()]).readonly(),
+  z.map(z.string(), z.date()).readonly(),
+  z.set(z.promise(z.string())).readonly(),
+  z.record(z.string()).readonly(),
+  z.record(z.string(), z.number()).readonly(),
+  z.object({ a: z.string(), 1: z.number() }).readonly(),
+  z.nativeEnum(testEnum).readonly(),
+  z.promise(z.string()).readonly(),
+] as const;
+
+test("flat inference", () => {
+  util.assertEqual<z.infer<(typeof schemas)[0]>, string>(true);
+  util.assertEqual<z.infer<(typeof schemas)[1]>, number>(true);
+  util.assertEqual<z.infer<(typeof schemas)[2]>, number>(true);
+  util.assertEqual<z.infer<(typeof schemas)[3]>, bigint>(true);
+  util.assertEqual<z.infer<(typeof schemas)[4]>, boolean>(true);
+  util.assertEqual<z.infer<(typeof schemas)[5]>, Date>(true);
+  util.assertEqual<z.infer<(typeof schemas)[6]>, undefined>(true);
+  util.assertEqual<z.infer<(typeof schemas)[7]>, null>(true);
+  util.assertEqual<z.infer<(typeof schemas)[8]>, any>(true);
+  util.assertEqual<z.infer<(typeof schemas)[9]>, Readonly<unknown>>(true);
+  util.assertEqual<z.infer<(typeof schemas)[10]>, void>(true);
+  util.assertEqual<
+    z.infer<(typeof schemas)[11]>,
+    (args_0: string, args_1: number, ...args_2: unknown[]) => unknown
+  >(true);
+  util.assertEqual<z.infer<(typeof schemas)[12]>, readonly string[]>(true);
+
+  util.assertEqual<z.infer<(typeof schemas)[13]>, readonly [string, number]>(
+    true
+  );
+  util.assertEqual<z.infer<(typeof schemas)[14]>, ReadonlyMap<string, Date>>(
+    true
+  );
+  util.assertEqual<z.infer<(typeof schemas)[15]>, ReadonlySet<Promise<string>>>(
+    true
+  );
+  util.assertEqual<
+    z.infer<(typeof schemas)[16]>,
+    Readonly<Record<string, string>>
+  >(true);
+  util.assertEqual<
+    z.infer<(typeof schemas)[17]>,
+    Readonly<Record<string, number>>
+  >(true);
+  util.assertEqual<
+    z.infer<(typeof schemas)[18]>,
+    { readonly a: string; readonly 1: number }
+  >(true);
+  util.assertEqual<z.infer<(typeof schemas)[19]>, Readonly<testEnum>>(true);
+  util.assertEqual<z.infer<(typeof schemas)[20]>, Promise<string>>(true);
+});
+
+// test("deep inference", () => {
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[0]>, string>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[1]>, number>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[2]>, number>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[3]>, bigint>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[4]>, boolean>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[5]>, Date>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[6]>, undefined>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[7]>, null>(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[8]>, any>(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[9]>,
+//     Readonly<unknown>
+//   >(true);
+//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[10]>, void>(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[11]>,
+//     (args_0: string, args_1: number, ...args_2: unknown[]) => unknown
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[12]>,
+//     readonly string[]
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[13]>,
+//     readonly [string, number]
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[14]>,
+//     ReadonlyMap<string, Date>
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[15]>,
+//     ReadonlySet<Promise<string>>
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[16]>,
+//     Readonly<Record<string, string>>
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[17]>,
+//     Readonly<Record<string, number>>
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[18]>,
+//     { readonly a: string; readonly 1: number }
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[19]>,
+//     Readonly<testEnum>
+//   >(true);
+//   util.assertEqual<
+//     z.infer<(typeof deepReadonlySchemas_0)[20]>,
+//     Promise<string>
+//   >(true);
+
+//   util.assertEqual<
+//     z.infer<typeof crazyDeepReadonlySchema>,
+//     ReadonlyMap<
+//       ReadonlySet<readonly [string, number]>,
+//       {
+//         readonly a: {
+//           readonly [x: string]: readonly any[];
+//         };
+//         readonly b: {
+//           readonly c: {
+//             readonly d: {
+//               readonly e: {
+//                 readonly f: {
+//                   readonly g?: {};
+//                 };
+//               };
+//             };
+//           };
+//         };
+//       }
+//     >
+//   >(true);
+// });
+
+test("object freezing", () => {
+  expect(Object.isFrozen(z.array(z.string()).readonly().parse(["a"]))).toBe(
+    true
+  );
+  expect(
+    Object.isFrozen(
+      z.tuple([z.string(), z.number()]).readonly().parse(["a", 1])
+    )
+  ).toBe(true);
+  expect(
+    Object.isFrozen(
+      z
+        .map(z.string(), z.date())
+        .readonly()
+        .parse(new Map([["a", new Date()]]))
+    )
+  ).toBe(true);
+  expect(
+    Object.isFrozen(
+      z
+        .set(z.promise(z.string()))
+        .readonly()
+        .parse(new Set([Promise.resolve("a")]))
+    )
+  ).toBe(true);
+  expect(
+    Object.isFrozen(z.record(z.string()).readonly().parse({ a: "b" }))
+  ).toBe(true);
+  expect(
+    Object.isFrozen(z.record(z.string(), z.number()).readonly().parse({ a: 1 }))
+  ).toBe(true);
+  expect(
+    Object.isFrozen(
+      z
+        .object({ a: z.string(), 1: z.number() })
+        .readonly()
+        .parse({ a: "b", 1: 2 })
+    )
+  ).toBe(true);
+  expect(
+    Object.isFrozen(
+      z.promise(z.string()).readonly().parse(Promise.resolve("a"))
+    )
+  ).toBe(true);
+});
diff --git a/src/__tests__/record.test.ts b/src/__tests__/record.test.ts
index c3b744e73..7a773c748 100644
--- a/src/__tests__/record.test.ts
+++ b/src/__tests__/record.test.ts
@@ -133,3 +133,40 @@ test("key and value getters", () => {
   rec.valueSchema.parse(1234);
   rec.element.parse(1234);
 });
+
+test("is not vulnerable to prototype pollution", async () => {
+  const rec = z.record(
+    z.object({
+      a: z.string(),
+    })
+  );
+
+  const data = JSON.parse(`
+    {
+      "__proto__": {
+        "a": "evil"
+      },
+      "b": {
+        "a": "good"
+      }
+    }
+  `);
+
+  const obj1 = rec.parse(data);
+  expect(obj1.a).toBeUndefined();
+
+  const obj2 = rec.safeParse(data);
+  expect(obj2.success).toBe(true);
+  if (obj2.success) {
+    expect(obj2.data.a).toBeUndefined();
+  }
+
+  const obj3 = await rec.parseAsync(data);
+  expect(obj3.a).toBeUndefined();
+
+  const obj4 = await rec.safeParseAsync(data);
+  expect(obj4.success).toBe(true);
+  if (obj4.success) {
+    expect(obj4.data.a).toBeUndefined();
+  }
+});
diff --git a/src/__tests__/refine.test.ts b/src/__tests__/refine.test.ts
index 98036c73f..4d03439ba 100644
--- a/src/__tests__/refine.test.ts
+++ b/src/__tests__/refine.test.ts
@@ -155,6 +155,35 @@ test("superRefine", () => {
   Strings.parse(["asfd", "qwer"]);
 });
 
+test("superRefine async", async () => {
+  const Strings = z.array(z.string()).superRefine(async (val, ctx) => {
+    if (val.length > 3) {
+      ctx.addIssue({
+        code: z.ZodIssueCode.too_big,
+        maximum: 3,
+        type: "array",
+        inclusive: true,
+        exact: true,
+        message: "Too many items 😡",
+      });
+    }
+
+    if (val.length !== new Set(val).size) {
+      ctx.addIssue({
+        code: z.ZodIssueCode.custom,
+        message: `No duplicates allowed.`,
+      });
+    }
+  });
+
+  const result = await Strings.safeParseAsync(["asfd", "asfd", "asfd", "asfd"]);
+
+  expect(result.success).toEqual(false);
+  if (!result.success) expect(result.error.issues.length).toEqual(2);
+
+  Strings.parseAsync(["asfd", "qwer"]);
+});
+
 test("superRefine - type narrowing", () => {
   type NarrowType = { type: string; age: number };
   const schema = z
diff --git a/src/__tests__/string.test.ts b/src/__tests__/string.test.ts
index 51343a918..b84f080fc 100644
--- a/src/__tests__/string.test.ts
+++ b/src/__tests__/string.test.ts
@@ -38,60 +38,92 @@ test("failing validations", () => {
 });
 
 test("email validations", () => {
-  const email = z.string().email();
-  email.parse("mojojojo@example.com");
-  expect(() => email.parse("asdf")).toThrow();
-  expect(() => email.parse("@lkjasdf.com")).toThrow();
-  expect(() => email.parse("asdf@sdf.")).toThrow();
-  expect(() => email.parse("asdf@asdf.com-")).toThrow();
-  expect(() => email.parse("asdf@-asdf.com")).toThrow();
-  expect(() => email.parse("asdf@-a(sdf.com")).toThrow();
-  expect(() => email.parse("asdf@-asdf.com(")).toThrow();
-  expect(() =>
-    email.parse("pawan.anand@%9y83&#$%R&#$%R&%#$R%%^^%5rw3ewe.d.d.aaaa.wef.co")
-  ).toThrow();
-});
-
-test("more email validations", () => {
   const validEmails = [
+    `email@domain.com`,
+    `firstname.lastname@domain.com`,
+    `email@subdomain.domain.com`,
+    `firstname+lastname@domain.com`,
+    `1234567890@domain.com`,
+    `email@domain-one.com`,
+    `_______@domain.com`,
+    `email@domain.name`,
+    `email@domain.co.jp`,
+    `firstname-lastname@domain.com`,
     `very.common@example.com`,
     `disposable.style.email.with+symbol@example.com`,
     `other.email-with-hyphen@example.com`,
     `fully-qualified-domain@example.com`,
     `user.name+tag+sorting@example.com`,
     `x@example.com`,
+    `mojojojo@asdf.example.com`,
     `example-indeed@strange-example.com`,
-    `test/test@test.com`,
     `example@s.example`,
-    `" "@example.org`,
-    `"john..doe"@example.org`,
-    `mailhost!username@example.org`,
-    `"very.(),:;<>[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com`,
-    `user%example.com@example.org`,
     `user-@example.org`,
-    `postmaster@[123.123.123.123]`,
     `user@my-example.com`,
     `a@b.cd`,
     `work+user@mail.com`,
+    `tom@test.te-st.com`,
+    `something@subdomain.domain-with-hyphens.tld`,
+    `francois@etu.inp-n7.fr`,
+  ];
+  const invalidEmails = [
+    // no "printable characters"
+    // `user%example.com@example.org`,
+    // `mailhost!username@example.org`,
+    // `test/test@test.com`,
+
+    // double @
+    `francois@@etu.inp-n7.fr`,
+    // do not support quotes
+    `"email"@domain.com`,
+    `"e asdf sadf ?<>ail"@domain.com`,
+    `" "@example.org`,
+    `"john..doe"@example.org`,
+    `"very.(),:;<>[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com`,
+
+    // do not support IPv4
+    `email@123.123.123.123`,
+    `email@[123.123.123.123]`,
+    `postmaster@123.123.123.123`,
     `user@[68.185.127.196]`,
     `ipv4@[85.129.96.247]`,
     `valid@[79.208.229.53]`,
     `valid@[255.255.255.255]`,
     `valid@[255.0.55.2]`,
     `valid@[255.0.55.2]`,
+
+    // do not support ipv6
     `hgrebert0@[IPv6:4dc8:ac7:ce79:8878:1290:6098:5c50:1f25]`,
     `bshapiro4@[IPv6:3669:c709:e981:4884:59a3:75d1:166b:9ae]`,
     `jsmith@[IPv6:2001:db8::1]`,
     `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:7334]`,
     `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:192.168.1.1]`,
-  ];
-  const invalidEmails = [
+
+    // microsoft test cases
+    `plainaddress`,
+    `#@%^%#$@#$@#.com`,
+    `@domain.com`,
+    `Joe Smith &lt;email@domain.com&gt;`,
+    `email.domain.com`,
+    `email@domain@domain.com`,
+    `.email@domain.com`,
+    `email.@domain.com`,
+    `email..email@domain.com`,
+    `あいうえお@domain.com`,
+    `email@domain.com (Joe Smith)`,
+    `email@domain`,
+    `email@-domain.com`,
+    `email@111.222.333.44444`,
+    `email@domain..com`,
     `Abc.example.com`,
     `A@b@c@example.com`,
+    `colin..hacks@domain.com`,
     `a"b(c)d,e:f;g<h>i[j\k]l@example.com`,
     `just"not"right@example.com`,
     `this is"not\allowed@example.com`,
     `this\ still\"not\\allowed@example.com`,
+
+    // random
     `i_like_underscore@but_its_not_allowed_in_this_part.example.com`,
     `QA[icon]CHOCOLATE[icon]@test.com`,
     `invalid@-start.com`,
@@ -112,15 +144,19 @@ test("more email validations", () => {
     `mlivesay3@[9952:143f:b4df:2179:49a1:5e82:b92e:6b6]`,
     `gbacher0@[IPv6:bc37:4d3f:5048:2e26:37cc:248e:df8e:2f7f:af]`,
     `invalid@[IPv6:5348:4ed3:5d38:67fb:e9b:acd2:c13:192.168.256.1]`,
+    `test@.com`,
   ];
   const emailSchema = z.string().email();
+
   expect(
-    validEmails.every((email) => emailSchema.safeParse(email).success)
+    validEmails.every((email) => {
+      return emailSchema.safeParse(email).success;
+    })
   ).toBe(true);
   expect(
-    invalidEmails.every(
-      (email) => emailSchema.safeParse(email).success === false
-    )
+    invalidEmails.every((email) => {
+      return emailSchema.safeParse(email).success === false;
+    })
   ).toBe(true);
 });
 
@@ -171,6 +207,7 @@ test("emoji validations", () => {
 test("uuid", () => {
   const uuid = z.string().uuid("custom error");
   uuid.parse("9491d710-3185-4e06-bea0-6a2f275345e0");
+  uuid.parse("d89e7b01-7598-ed11-9d7a-0022489382fd"); // new sequential id
   uuid.parse("00000000-0000-0000-0000-000000000000");
   uuid.parse("b3ce60f8-e8b9-40f5-1150-172ede56ff74"); // Variant 0 - RFC 4122: Reserved, NCS backward compatibility
   uuid.parse("92e76bf9-28b3-4730-cd7f-cb6bc51f8c09"); // Variant 2 - RFC 4122: Reserved, Microsoft Corporation backward compatibility
diff --git a/src/__tests__/transformer.test.ts b/src/__tests__/transformer.test.ts
index 8e1f2a598..5cf606c84 100644
--- a/src/__tests__/transformer.test.ts
+++ b/src/__tests__/transformer.test.ts
@@ -211,6 +211,73 @@ test("async preprocess", async () => {
   expect(value).toEqual(["asdf"]);
 });
 
+test("preprocess ctx.addIssue with parse", () => {
+  expect(() => {
+    z.preprocess((data, ctx) => {
+      ctx?.addIssue({
+        code: "custom",
+        message: `${data} is not one of our allowed strings`,
+      });
+      return data;
+    }, z.string()).parse("asdf");
+  }).toThrow(
+    JSON.stringify(
+      [
+        {
+          code: "custom",
+          message: "asdf is not one of our allowed strings",
+          path: [],
+        },
+      ],
+      null,
+      2
+    )
+  );
+});
+
+test("preprocess ctx.addIssue with parseAsync", async () => {
+  const result = await z
+    .preprocess((data, ctx) => {
+      ctx?.addIssue({
+        code: "custom",
+        message: `${data} is not one of our allowed strings`,
+      });
+      return data;
+    }, z.string())
+    .safeParseAsync("asdf");
+
+  expect(JSON.parse(JSON.stringify(result))).toEqual({
+    success: false,
+    error: {
+      issues: [
+        {
+          code: "custom",
+          message: "asdf is not one of our allowed strings",
+          path: [],
+        },
+      ],
+      name: "ZodError",
+    },
+  });
+});
+
+test("z.NEVER in preprocess", async () => {
+  const foo = z.preprocess((val, ctx) => {
+    if (!val) {
+      ctx?.addIssue({ code: z.ZodIssueCode.custom, message: "bad" });
+      return z.NEVER;
+    }
+    return val;
+  }, z.number());
+
+  type foo = z.infer<typeof foo>;
+  util.assertEqual<foo, number>(true);
+  const arg = foo.safeParse(undefined);
+  if (!arg.success) {
+    expect(arg.error.issues[0].message).toEqual("bad");
+  }
+});
+
 test("short circuit on dirty", () => {
   const schema = z
     .string()
diff --git a/src/helpers/parseUtil.ts b/src/helpers/parseUtil.ts
index eb6690ef8..3a278b999 100644
--- a/src/helpers/parseUtil.ts
+++ b/src/helpers/parseUtil.ts
@@ -136,7 +136,10 @@ export class ParseStatus {
       if (key.status === "dirty") status.dirty();
       if (value.status === "dirty") status.dirty();
 
-      if (typeof value.value !== "undefined" || pair.alwaysSet) {
+      if (
+        key.value !== "__proto__" &&
+        (typeof value.value !== "undefined" || pair.alwaysSet)
+      ) {
         finalObject[key.value] = value.value;
       }
     }
diff --git a/src/types.ts b/src/types.ts
index 5a99d04b9..81a5e9f8a 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -371,10 +371,10 @@ export abstract class ZodType<
     refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput
   ): ZodEffects<this, RefinedOutput, Input>;
   superRefine(
-    refinement: (arg: Output, ctx: RefinementCtx) => void
+    refinement: (arg: Output, ctx: RefinementCtx) => void | Promise<void>
   ): ZodEffects<this, Output, Input>;
   superRefine(
-    refinement: (arg: Output, ctx: RefinementCtx) => unknown
+    refinement: (arg: Output, ctx: RefinementCtx) => unknown | Promise<unknown>
   ): ZodEffects<this, Output, Input> {
     return this._refinement(refinement);
   }
@@ -402,6 +402,7 @@ export abstract class ZodType<
     this.catch = this.catch.bind(this);
     this.describe = this.describe.bind(this);
     this.pipe = this.pipe.bind(this);
+    this.readonly = this.readonly.bind(this);
     this.isNullable = this.isNullable.bind(this);
     this.isOptional = this.isOptional.bind(this);
   }
@@ -489,6 +490,9 @@ export abstract class ZodType<
   pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T> {
     return ZodPipeline.create(this, target);
   }
+  readonly(): ZodReadonly<this> {
+    return ZodReadonly.create(this);
+  }
 
   isOptional(): boolean {
     return this.safeParse(undefined).success;
@@ -541,17 +545,27 @@ export interface ZodStringDef extends ZodTypeDef {
 const cuidRegex = /^c[^\s-]{8,}$/i;
 const cuid2Regex = /^[a-z][a-z0-9]*$/;
 const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
+// const uuidRegex =
+//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
 const uuidRegex =
-  /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+  /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
 // from https://stackoverflow.com/a/46181/1550155
 // old version: too slow, didn't support unicode
 // const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
 //old email regex
 // const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
 // eslint-disable-next-line
-
+// const emailRegex =
+//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
+// const emailRegex =
+//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
+// const emailRegex =
+//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
 const emailRegex =
-  /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
+  /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
+// const emailRegex =
+//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
+
 // from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
 const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
 
@@ -3431,6 +3445,12 @@ export class ZodMap<
   ZodMapDef<Key, Value>,
   Map<Key["_input"], Value["_input"]>
 > {
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
   _parse(input: ParseInput): ParseReturnType<this["_output"]> {
     const { status, ctx } = this._processInputParams(input);
     if (ctx.parsedType !== ZodParsedType.map) {
@@ -3947,12 +3967,15 @@ function createZodEnum<U extends string, T extends [U, ...U[]]>(
   values: T,
   params?: RawCreateParams
 ): ZodEnum<T>;
-function createZodEnum(values: any, params?: RawCreateParams) {
+function createZodEnum(
+  values: [string, ...string[]],
+  params?: RawCreateParams
+) {
   return new ZodEnum({
-    values: values as any,
+    values,
     typeName: ZodFirstPartyTypeKind.ZodEnum,
     ...processCreateParams(params),
-  }) as any;
+  });
 }
 
 export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
@@ -4172,7 +4195,10 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
 //////////////////////////////////////////////
 
 export type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
-export type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;
+export type SuperRefinement<T> = (
+  arg: T,
+  ctx: RefinementCtx
+) => void | Promise<void>;
 
 export type RefinementEffect<T> = {
   type: "refinement";
@@ -4184,7 +4210,7 @@ export type TransformEffect<T> = {
 };
 export type PreprocessEffect<T> = {
   type: "preprocess";
-  transform: (arg: T) => any;
+  transform: (arg: T, ctx: RefinementCtx) => any;
 };
 export type Effect<T> =
   | RefinementEffect<T>
@@ -4218,8 +4244,30 @@ export class ZodEffects<
 
     const effect = this._def.effect || null;
 
+    const checkCtx: RefinementCtx = {
+      addIssue: (arg: IssueData) => {
+        addIssueToContext(ctx, arg);
+        if (arg.fatal) {
+          status.abort();
+        } else {
+          status.dirty();
+        }
+      },
+      get path() {
+        return ctx.path;
+      },
+    };
+
+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
     if (effect.type === "preprocess") {
-      const processed = effect.transform(ctx.data);
+      const processed = effect.transform(ctx.data, checkCtx);
+      if (ctx.common.issues.length) {
+        return {
+          status: "dirty",
+          value: ctx.data,
+        };
+      }
 
       if (ctx.common.async) {
         return Promise.resolve(processed).then((processed) => {
@@ -4237,22 +4285,6 @@ export class ZodEffects<
         });
       }
     }
-
-    const checkCtx: RefinementCtx = {
-      addIssue: (arg: IssueData) => {
-        addIssueToContext(ctx, arg);
-        if (arg.fatal) {
-          status.abort();
-        } else {
-          status.dirty();
-        }
-      },
-      get path() {
-        return ctx.path;
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
     if (effect.type === "refinement") {
       const executeRefinement = (
         acc: unknown
@@ -4344,7 +4376,7 @@ export class ZodEffects<
   };
 
   static createWithPreprocess = <I extends ZodTypeAny>(
-    preprocess: (arg: unknown) => unknown,
+    preprocess: (arg: unknown, ctx: RefinementCtx) => unknown,
     schema: I,
     params?: RawCreateParams
   ): ZodEffects<I, I["_output"], unknown> => {
@@ -4740,6 +4772,72 @@ export class ZodPipeline<
   }
 }
 
+///////////////////////////////////////////
+///////////////////////////////////////////
+//////////                       //////////
+//////////      ZodReadonly      //////////
+//////////                       //////////
+///////////////////////////////////////////
+///////////////////////////////////////////
+type BuiltIn =
+  | (((...args: any[]) => any) | (new (...args: any[]) => any))
+  | { readonly [Symbol.toStringTag]: string }
+  | Date
+  | Error
+  | Generator
+  | Promise<unknown>
+  | RegExp;
+
+type MakeReadonly<T> = T extends Map<infer K, infer V>
+  ? ReadonlyMap<K, V>
+  : T extends Set<infer V>
+  ? ReadonlySet<V>
+  : T extends [infer Head, ...infer Tail]
+  ? readonly [Head, ...Tail]
+  : T extends Array<infer V>
+  ? ReadonlyArray<V>
+  : T extends BuiltIn
+  ? T
+  : Readonly<T>;
+
+export interface ZodReadonlyDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  innerType: T;
+  typeName: ZodFirstPartyTypeKind.ZodReadonly;
+}
+
+export class ZodReadonly<T extends ZodTypeAny> extends ZodType<
+  MakeReadonly<T["_output"]>,
+  ZodReadonlyDef<T>,
+  T["_input"]
+> {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const result = this._def.innerType._parse(input);
+    if (isValid(result)) {
+      result.value = Object.freeze(result.value);
+    }
+    return result;
+  }
+
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodReadonly<T> => {
+    return new ZodReadonly({
+      innerType: type,
+      typeName: ZodFirstPartyTypeKind.ZodReadonly,
+      ...processCreateParams(params),
+    }) as any;
+  };
+}
+
+////////////////////////////////////////
+////////////////////////////////////////
+//////////                    //////////
+//////////      z.custom      //////////
+//////////                    //////////
+////////////////////////////////////////
+////////////////////////////////////////
 type CustomParams = CustomErrorParams & { fatal?: boolean };
 export const custom = <T>(
   check?: (data: unknown) => any,
@@ -4815,6 +4913,7 @@ export enum ZodFirstPartyTypeKind {
   ZodPromise = "ZodPromise",
   ZodBranded = "ZodBranded",
   ZodPipeline = "ZodPipeline",
+  ZodReadonly = "ZodReadonly",
 }
 export type ZodFirstPartySchemaTypes =
   | ZodString
@@ -4852,8 +4951,7 @@ export type ZodFirstPartySchemaTypes =
   | ZodBranded<any, any>
   | ZodPipeline<any, any>;
 
-// new approach that works for abstract classes
-// but requires TS 4.4+
+// requires TS 4.4+
 abstract class Class {
   constructor(..._: any[]) {}
 }
diff --git a/tsconfig.json b/tsconfig.json
index ffcbb9477..aead72af7 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -1,3 +1,6 @@
 {
-  "extends": "./tsconfig.base.json"
+  "extends": "./configs/tsconfig.base.json",
+  "compilerOptions": {
+    "outDir": "../lib"
+  }
 }
