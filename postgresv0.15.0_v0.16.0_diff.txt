diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 5621f8d9..89d128fd 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -12,13 +12,13 @@ jobs:
       - name: Setup Deno
         uses: denoland/setup-deno@v1
         with:
-          deno-version: 1.16.0
+          deno-version: 1.17.3
       
       - name: Format
         run: deno fmt --check
       
       - name: Lint
-        run: deno lint --config=deno.json
+        run: deno lint
 
       - name: Documentation tests
         run: deno test --doc client.ts mod.ts pool.ts client/ connection/ query/ utils/
diff --git a/Dockerfile b/Dockerfile
index ccb349b0..d86fddd5 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,4 +1,4 @@
-FROM denoland/deno:alpine-1.16.0
+FROM denoland/deno:alpine-1.17.3
 WORKDIR /app
 
 # Install wait utility
diff --git a/README.md b/README.md
index 5ce37a27..67bc9268 100644
--- a/README.md
+++ b/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 [![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)](https://deno-postgres.com)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.15.0/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.16.0/mod.ts)
 [![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)](LICENSE)
 
 A lightweight PostgreSQL driver for Deno focused on user experience
@@ -15,8 +15,8 @@ A lightweight PostgreSQL driver for Deno focused on user experience
 ## Example
 
 ```ts
-// deno run --allow-net --allow-read --unstable mod.ts
-import { Client } from "https://deno.land/x/postgres/mod.ts";
+// deno run --allow-net --allow-read mod.ts
+import { Client } from "https://deno.land/x/postgres@v0.16.0/mod.ts";
 
 const client = new Client({
   user: "user",
@@ -54,15 +54,6 @@ await client.end();
 For more examples visit the documentation available at
 [https://deno-postgres.com/](https://deno-postgres.com/)
 
-## Why do I need unstable to connect using TLS?
-
-Sadly, establishing a TLS connection in the way Postgres requires it isn't
-possible without the `Deno.startTls` API, which is currently marked as unstable.
-
-At least that was the situation before Deno 1.16, which stabilized the required
-API making it possible to use the library without requiring `--unstable`. Users
-are urged to upgrade to Deno 1.16 or above to enjoy this feature
-
 ## Documentation
 
 The documentation is available on the deno-postgres website
@@ -164,7 +155,8 @@ This situation will become more stable as `std` and `deno-postgres` approach 1.0
 | 1.11.0 and up | 0.12.0             | 0.12.0             |
 | 1.14.0 and up | 0.13.0             | 0.13.0             |
 | 1.15.0        | 0.13.0             |                    |
-| 1.16.0        | 0.14.0             |                    |
+| 1.16.0        | 0.14.0             | 0.14.3             |
+| 1.17.0        | 0.15.0             |                    |
 
 ## Contributing guidelines
 
@@ -174,9 +166,9 @@ When contributing to repository make sure to:
 2. All public interfaces must be typed and have a corresponding JS block
    explaining their usage
 3. All code must pass the format and lint checks enforced by `deno fmt` and
-   `deno lint --config=deno.json` respectively. The build will not pass the
-   tests if these conditions are not met. Ignore rules will be accepted in the
-   code base when their respective justification is given in a comment
+   `deno lint` respectively. The build will not pass the tests if these
+   conditions are not met. Ignore rules will be accepted in the code base when
+   their respective justification is given in a comment
 4. All features and fixes must have a corresponding test added in order to be
    accepted
 
diff --git a/client.ts b/client.ts
index 48bbc80d..7bbc97e9 100644
--- a/client.ts
+++ b/client.ts
@@ -1,22 +1,22 @@
 import { Connection } from "./connection/connection.ts";
 import {
-  ClientConfiguration,
-  ClientOptions,
-  ConnectionString,
+  type ClientConfiguration,
+  type ClientOptions,
+  type ConnectionString,
   createParams,
 } from "./connection/connection_params.ts";
 import {
   Query,
-  QueryArguments,
-  QueryArrayResult,
-  QueryObjectOptions,
-  QueryObjectResult,
-  QueryOptions,
-  QueryResult,
+  type QueryArguments,
+  type QueryArrayResult,
+  type QueryObjectOptions,
+  type QueryObjectResult,
+  type QueryOptions,
+  type QueryResult,
   ResultType,
   templateStringToQuery,
 } from "./query/query.ts";
-import { Transaction, TransactionOptions } from "./query/transaction.ts";
+import { Transaction, type TransactionOptions } from "./query/transaction.ts";
 import { isTemplateString } from "./utils/utils.ts";
 
 export interface Session {
@@ -233,16 +233,16 @@ export abstract class QueryClient {
     this.#terminated = true;
   }
 
-  #executeQuery<T extends Array<unknown>>(
+  async #executeQuery<T extends Array<unknown>>(
     _query: Query<ResultType.ARRAY>,
   ): Promise<QueryArrayResult<T>>;
-  #executeQuery<T>(
+  async #executeQuery<T>(
     _query: Query<ResultType.OBJECT>,
   ): Promise<QueryObjectResult<T>>;
-  #executeQuery(
+  async #executeQuery(
     query: Query<ResultType>,
   ): Promise<QueryResult> {
-    return this.#connection.query(query);
+    return await this.#connection.query(query);
   }
 
   /**
@@ -280,18 +280,18 @@ export abstract class QueryClient {
    * const {rows} = await my_client.queryArray<[number, string]>`SELECT ID, NAME FROM CLIENTS WHERE ID = ${id}`;
    * ```
    */
-  queryArray<T extends Array<unknown>>(
+  async queryArray<T extends Array<unknown>>(
     query: string,
     args?: QueryArguments,
   ): Promise<QueryArrayResult<T>>;
-  queryArray<T extends Array<unknown>>(
+  async queryArray<T extends Array<unknown>>(
     config: QueryOptions,
   ): Promise<QueryArrayResult<T>>;
-  queryArray<T extends Array<unknown>>(
+  async queryArray<T extends Array<unknown>>(
     strings: TemplateStringsArray,
     ...args: unknown[]
   ): Promise<QueryArrayResult<T>>;
-  queryArray<T extends Array<unknown> = Array<unknown>>(
+  async queryArray<T extends Array<unknown> = Array<unknown>>(
     query_template_or_config: TemplateStringsArray | string | QueryOptions,
     ...args: unknown[] | [QueryArguments | undefined]
   ): Promise<QueryArrayResult<T>> {
@@ -320,7 +320,7 @@ export abstract class QueryClient {
       query = new Query(query_template_or_config, ResultType.ARRAY);
     }
 
-    return this.#executeQuery(query);
+    return await this.#executeQuery(query);
   }
 
   /**
@@ -382,18 +382,18 @@ export abstract class QueryClient {
    * const { rows } = await my_client.queryObject<{id: number, name: string}>`SELECT ID, NAME FROM CLIENTS WHERE ID = ${id}`;
    * ```
    */
-  queryObject<T>(
+  async queryObject<T>(
     query: string,
     args?: QueryArguments,
   ): Promise<QueryObjectResult<T>>;
-  queryObject<T>(
+  async queryObject<T>(
     config: QueryObjectOptions,
   ): Promise<QueryObjectResult<T>>;
-  queryObject<T>(
+  async queryObject<T>(
     query: TemplateStringsArray,
     ...args: unknown[]
   ): Promise<QueryObjectResult<T>>;
-  queryObject<
+  async queryObject<
     T = Record<string, unknown>,
   >(
     query_template_or_config:
@@ -430,7 +430,7 @@ export abstract class QueryClient {
       );
     }
 
-    return this.#executeQuery<T>(query);
+    return await this.#executeQuery<T>(query);
   }
 
   protected resetSessionMetadata() {
@@ -451,7 +451,7 @@ export abstract class QueryClient {
  * await client.end();
  * ```
  *
- * A client will execute all their queries in a sequencial fashion,
+ * A client will execute all their queries in a sequential fashion,
  * for concurrency capabilities check out connection pools
  *
  * ```ts
diff --git a/client/error.ts b/client/error.ts
index 5b11bd66..70d3786c 100644
--- a/client/error.ts
+++ b/client/error.ts
@@ -1,4 +1,4 @@
-import type { Notice } from "../connection/message.ts";
+import { type Notice } from "../connection/message.ts";
 
 export class ConnectionError extends Error {
   constructor(message?: string) {
@@ -8,8 +8,8 @@ export class ConnectionError extends Error {
 }
 
 export class ConnectionParamsError extends Error {
-  constructor(message: string) {
-    super(message);
+  constructor(message: string, cause?: Error) {
+    super(message, { cause });
     this.name = "ConnectionParamsError";
   }
 }
@@ -24,15 +24,14 @@ export class PostgresError extends Error {
   }
 }
 
-// TODO
-// Use error cause once it's added to JavaScript
 export class TransactionError extends Error {
   constructor(
     transaction_name: string,
-    public cause: PostgresError,
+    cause: PostgresError,
   ) {
     super(
-      `The transaction "${transaction_name}" has been aborted due to \`${cause}\`. Check the "cause" property to get more details`,
+      `The transaction "${transaction_name}" has been aborted`,
+      { cause },
     );
     this.name = "TransactionError";
   }
diff --git a/connection/connection.ts b/connection/connection.ts
index 6843a99f..b6212b2a 100644
--- a/connection/connection.ts
+++ b/connection/connection.ts
@@ -26,13 +26,20 @@
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-import { bold, BufReader, BufWriter, joinPath, yellow } from "../deps.ts";
+import {
+  bold,
+  BufReader,
+  BufWriter,
+  delay,
+  joinPath,
+  yellow,
+} from "../deps.ts";
 import { DeferredStack } from "../utils/deferred.ts";
 import { getSocketName, readUInt32BE } from "../utils/utils.ts";
 import { PacketWriter } from "./packet.ts";
 import {
   Message,
-  Notice,
+  type Notice,
   parseBackendKeyMessage,
   parseCommandCompleteMessage,
   parseNoticeMessage,
@@ -40,13 +47,13 @@ import {
   parseRowDescriptionMessage,
 } from "./message.ts";
 import {
-  Query,
+  type Query,
   QueryArrayResult,
   QueryObjectResult,
-  QueryResult,
+  type QueryResult,
   ResultType,
 } from "../query/query.ts";
-import { ClientConfiguration } from "./connection_params.ts";
+import { type ClientConfiguration } from "./connection_params.ts";
 import * as scram from "./scram.ts";
 import {
   ConnectionError,
@@ -196,21 +203,29 @@ export class Connection {
     }
   }
 
+  /** https://www.postgresql.org/docs/14/protocol-flow.html#id-1.10.5.7.3 */
   async #sendStartupMessage(): Promise<Message> {
     const writer = this.#packetWriter;
     writer.clear();
+
     // protocol version - 3.0, written as
     writer.addInt16(3).addInt16(0);
-    const connParams = this.#connection_params;
+    // explicitly set utf-8 encoding
+    writer.addCString("client_encoding").addCString("'utf-8'");
+
     // TODO: recognize other parameters
-    writer.addCString("user").addCString(connParams.user);
-    writer.addCString("database").addCString(connParams.database);
+    writer.addCString("user").addCString(this.#connection_params.user);
+    writer.addCString("database").addCString(this.#connection_params.database);
     writer.addCString("application_name").addCString(
-      connParams.applicationName,
+      this.#connection_params.applicationName,
+    );
+    // The database expects options in the --key=value
+    writer.addCString("options").addCString(
+      Object.entries(this.#connection_params.options).map(([key, value]) =>
+        `--${key}=${value}`
+      ).join(" "),
     );
 
-    // eplicitly set utf-8 encoding
-    writer.addCString("client_encoding").addCString("'utf-8'");
     // terminator after all parameters were writter
     writer.addCString("");
 
@@ -270,18 +285,9 @@ export class Connection {
     connection: Deno.Conn,
     options: { hostname: string; caCerts: string[] },
   ) {
-    // TODO
-    // Remove unstable check on 1.17.0
-    if ("startTls" in Deno) {
-      // @ts-ignore This API should be available on unstable
-      this.#conn = await Deno.startTls(connection, options);
-      this.#bufWriter = new BufWriter(this.#conn);
-      this.#bufReader = new BufReader(this.#conn);
-    } else {
-      throw new Error(
-        "You need to execute Deno with the `--unstable` argument in order to stablish a TLS connection",
-      );
-    }
+    this.#conn = await Deno.startTls(connection, options);
+    this.#bufWriter = new BufWriter(this.#conn);
+    this.#bufReader = new BufReader(this.#conn);
   }
 
   #resetConnectionMetadata() {
@@ -462,10 +468,23 @@ export class Connection {
         error = e;
       }
     } else {
-      // If the reconnection attempts are set to zero the client won't attempt to
-      // reconnect, but it won't error either, this "no reconnections" behavior
-      // should be handled wherever the reconnection is requested
+      let interval =
+        typeof this.#connection_params.connection.interval === "number"
+          ? this.#connection_params.connection.interval
+          : 0;
       while (reconnection_attempts < max_reconnections) {
+        // Don't wait for the interval on the first connection
+        if (reconnection_attempts > 0) {
+          if (
+            typeof this.#connection_params.connection.interval === "function"
+          ) {
+            interval = this.#connection_params.connection.interval(interval);
+          }
+
+          if (interval > 0) {
+            await delay(interval);
+          }
+        }
         try {
           await this.#startup();
           break;
diff --git a/connection/connection_params.ts b/connection/connection_params.ts
index 9205ac5f..d9a3fb82 100644
--- a/connection/connection_params.ts
+++ b/connection/connection_params.ts
@@ -12,6 +12,7 @@ import { fromFileUrl, isAbsolute } from "../deps.ts";
  * - application_name
  * - dbname
  * - host
+ * - options
  * - password
  * - port
  * - sslmode
@@ -27,12 +28,13 @@ export type ConnectionString = string;
  */
 function getPgEnv(): ClientOptions {
   return {
+    applicationName: Deno.env.get("PGAPPNAME"),
     database: Deno.env.get("PGDATABASE"),
     hostname: Deno.env.get("PGHOST"),
+    options: Deno.env.get("PGOPTIONS"),
+    password: Deno.env.get("PGPASSWORD"),
     port: Deno.env.get("PGPORT"),
     user: Deno.env.get("PGUSER"),
-    password: Deno.env.get("PGPASSWORD"),
-    applicationName: Deno.env.get("PGAPPNAME"),
   };
 }
 
@@ -46,9 +48,23 @@ export interface ConnectionOptions {
    * default: `1`
    */
   attempts: number;
+  /**
+   * The time to wait before attempting each reconnection (in milliseconds)
+   *
+   * You can provide a fixed number or a function to call each time the
+   * connection is attempted. By default, the interval will be a function
+   * with an exponential backoff increasing by 500 milliseconds
+   */
+  interval: number | ((previous_interval: number) => number);
 }
 
-type TLSModes = "disable" | "prefer" | "require";
+/** https://www.postgresql.org/docs/14/libpq-ssl.html#LIBPQ-SSL-PROTECTION */
+type TLSModes =
+  | "disable"
+  | "prefer"
+  | "require"
+  | "verify-ca"
+  | "verify-full";
 
 // TODO
 // Refactor enabled and enforce into one single option for 1.0
@@ -84,6 +100,7 @@ export interface ClientOptions {
   database?: string;
   hostname?: string;
   host_type?: "tcp" | "socket";
+  options?: string | Record<string, string>;
   password?: string;
   port?: string | number;
   tls?: Partial<TLSOptions>;
@@ -96,6 +113,7 @@ export interface ClientConfiguration {
   database: string;
   hostname: string;
   host_type: "tcp" | "socket";
+  options: Record<string, string>;
   password?: string;
   port: number;
   tls: TLSOptions;
@@ -152,21 +170,67 @@ interface PostgresUri {
   dbname?: string;
   driver: string;
   host?: string;
+  options?: string;
   password?: string;
   port?: string;
   sslmode?: TLSModes;
   user?: string;
 }
 
-function parseOptionsFromUri(connString: string): ClientOptions {
+function parseOptionsArgument(options: string): Record<string, string> {
+  const args = options.split(" ");
+
+  const transformed_args = [];
+  for (let x = 0; x < args.length; x++) {
+    if (/^-\w/.test(args[x])) {
+      if (args[x] === "-c") {
+        if (args[x + 1] === undefined) {
+          throw new Error(
+            `No provided value for "${args[x]}" in options parameter`,
+          );
+        }
+
+        // Skip next iteration
+        transformed_args.push(args[x + 1]);
+        x++;
+      } else {
+        throw new Error(
+          `Argument "${args[x]}" is not supported in options parameter`,
+        );
+      }
+    } else if (/^--\w/.test(args[x])) {
+      transformed_args.push(args[x].slice(2));
+    } else {
+      throw new Error(
+        `Value "${args[x]}" is not a valid options argument`,
+      );
+    }
+  }
+
+  return transformed_args.reduce((options, x) => {
+    if (!/.+=.+/.test(x)) {
+      throw new Error(`Value "${x}" is not a valid options argument`);
+    }
+
+    const key = x.slice(0, x.indexOf("="));
+    const value = x.slice(x.indexOf("=") + 1);
+
+    options[key] = value;
+
+    return options;
+  }, {} as Record<string, string>);
+}
+
+function parseOptionsFromUri(connection_string: string): ClientOptions {
   let postgres_uri: PostgresUri;
   try {
-    const uri = parseConnectionUri(connString);
+    const uri = parseConnectionUri(connection_string);
     postgres_uri = {
       application_name: uri.params.application_name,
       dbname: uri.path || uri.params.dbname,
       driver: uri.driver,
       host: uri.host || uri.params.host,
+      options: uri.params.options,
       password: uri.password || uri.params.password,
       port: uri.port || uri.params.port,
       // Compatibility with JDBC, not standard
@@ -177,10 +241,9 @@ function parseOptionsFromUri(connString: string): ClientOptions {
       user: uri.user || uri.params.user,
     };
   } catch (e) {
-    // TODO
-    // Use error cause
     throw new ConnectionParamsError(
-      `Could not parse the connection string due to ${e}`,
+      `Could not parse the connection string`,
+      e,
     );
   }
 
@@ -195,6 +258,10 @@ function parseOptionsFromUri(connString: string): ClientOptions {
     ? (isAbsolute(postgres_uri.host) ? "socket" : "tcp")
     : "socket";
 
+  const options = postgres_uri.options
+    ? parseOptionsArgument(postgres_uri.options)
+    : {};
+
   let tls: TLSOptions | undefined;
   switch (postgres_uri.sslmode) {
     case undefined: {
@@ -208,13 +275,15 @@ function parseOptionsFromUri(connString: string): ClientOptions {
       tls = { enabled: true, enforce: false, caCertificates: [] };
       break;
     }
-    case "require": {
+    case "require":
+    case "verify-ca":
+    case "verify-full": {
       tls = { enabled: true, enforce: true, caCertificates: [] };
       break;
     }
     default: {
       throw new ConnectionParamsError(
-        `Supplied DSN has invalid sslmode '${postgres_uri.sslmode}'. Only 'disable', 'require', and 'prefer' are supported`,
+        `Supplied DSN has invalid sslmode '${postgres_uri.sslmode}'`,
       );
     }
   }
@@ -224,6 +293,7 @@ function parseOptionsFromUri(connString: string): ClientOptions {
     database: postgres_uri.dbname,
     hostname: postgres_uri.host,
     host_type,
+    options,
     password: postgres_uri.password,
     port: postgres_uri.port,
     tls,
@@ -237,10 +307,12 @@ const DEFAULT_OPTIONS:
     applicationName: "deno_postgres",
     connection: {
       attempts: 1,
+      interval: (previous_interval) => previous_interval + 500,
     },
     host: "127.0.0.1",
     socket: "/tmp",
     host_type: "socket",
+    options: {},
     port: 5432,
     tls: {
       enabled: true,
@@ -296,16 +368,36 @@ export function createParams(
         host = socket;
       }
     } catch (e) {
-      // TODO
-      // Add error cause
       throw new ConnectionParamsError(
-        `Could not parse host "${socket}" due to "${e}"`,
+        `Could not parse host "${socket}"`,
+        e,
       );
     }
   } else {
     host = provided_host ?? DEFAULT_OPTIONS.host;
   }
 
+  const provided_options = params.options ?? pgEnv.options;
+
+  let options: Record<string, string>;
+  if (provided_options) {
+    if (typeof provided_options === "string") {
+      options = parseOptionsArgument(provided_options);
+    } else {
+      options = provided_options;
+    }
+  } else {
+    options = {};
+  }
+
+  for (const key in options) {
+    if (!/^\w+$/.test(key)) {
+      throw new Error(`The "${key}" key in the options argument is invalid`);
+    }
+
+    options[key] = options[key].replaceAll(" ", "\\ ");
+  }
+
   let port: number;
   if (params.port) {
     port = Number(params.port);
@@ -342,10 +434,13 @@ export function createParams(
     connection: {
       attempts: params?.connection?.attempts ??
         DEFAULT_OPTIONS.connection.attempts,
+      interval: params?.connection?.interval ??
+        DEFAULT_OPTIONS.connection.interval,
     },
     database: params.database ?? pgEnv.database,
     hostname: host,
     host_type,
+    options,
     password: params.password ?? pgEnv.password,
     port,
     tls: {
diff --git a/deno.json b/deno.json
deleted file mode 100644
index 6580b1a6..00000000
--- a/deno.json
+++ /dev/null
@@ -1,9 +0,0 @@
-{
-  "lint": {
-    "rules": {
-      "exclude": [
-        "camelcase"
-      ]
-    }
-  }
-}
diff --git a/deps.ts b/deps.ts
index c07efe31..f22f0426 100644
--- a/deps.ts
+++ b/deps.ts
@@ -1,17 +1,20 @@
-export * as base64 from "https://deno.land/std@0.114.0/encoding/base64.ts";
-export * as hex from "https://deno.land/std@0.114.0/encoding/hex.ts";
-export * as date from "https://deno.land/std@0.114.0/datetime/mod.ts";
+export * as base64 from "https://deno.land/std@0.141.0/encoding/base64.ts";
+export * as hex from "https://deno.land/std@0.141.0/encoding/hex.ts";
+export * as date from "https://deno.land/std@0.141.0/datetime/mod.ts";
 export {
   BufReader,
   BufWriter,
-} from "https://deno.land/std@0.114.0/io/buffer.ts";
-export { copy } from "https://deno.land/std@0.114.0/bytes/mod.ts";
-export { crypto } from "https://deno.land/std@0.114.0/crypto/mod.ts";
-export { deferred, delay } from "https://deno.land/std@0.114.0/async/mod.ts";
-export type { Deferred } from "https://deno.land/std@0.114.0/async/mod.ts";
-export { bold, yellow } from "https://deno.land/std@0.114.0/fmt/colors.ts";
+} from "https://deno.land/std@0.141.0/io/buffer.ts";
+export { copy } from "https://deno.land/std@0.141.0/bytes/mod.ts";
+export { crypto } from "https://deno.land/std@0.141.0/crypto/mod.ts";
+export {
+  type Deferred,
+  deferred,
+  delay,
+} from "https://deno.land/std@0.141.0/async/mod.ts";
+export { bold, yellow } from "https://deno.land/std@0.141.0/fmt/colors.ts";
 export {
   fromFileUrl,
   isAbsolute,
   join as joinPath,
-} from "https://deno.land/std@0.114.0/path/mod.ts";
+} from "https://deno.land/std@0.141.0/path/mod.ts";
diff --git a/docker-compose.yml b/docker-compose.yml
index fce86127..94e483c3 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -23,7 +23,7 @@ services:
   postgres_clear:
     # Clear authentication was removed after Postgres 9
     image: postgres:9
-    hostname: postgres
+    hostname: postgres_clear
     environment:
       <<: *database-env
     volumes:
@@ -35,7 +35,7 @@ services:
 
   postgres_md5:
     image: postgres:14
-    hostname: postgres
+    hostname: postgres_md5
     environment:
       <<: *database-env
     volumes:
diff --git a/docker/postgres_clear/init/initialize_test_server.sh b/docker/postgres_clear/init/initialize_test_server.sh
old mode 100644
new mode 100755
diff --git a/docker/postgres_md5/init/initialize_test_server.sh b/docker/postgres_md5/init/initialize_test_server.sh
old mode 100644
new mode 100755
diff --git a/docker/postgres_scram/init/initialize_test_server.sh b/docker/postgres_scram/init/initialize_test_server.sh
old mode 100644
new mode 100755
diff --git a/docs/README.md b/docs/README.md
index 87f7be66..a25e18cb 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 ![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.15.0/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.16.0/mod.ts)
 ![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)
 
 `deno-postgres` is a lightweight PostgreSQL driver for Deno focused on user
@@ -11,7 +11,7 @@ experience. It provides abstractions for most common operations such as typed
 queries, prepared statements, connection pools and transactions.
 
 ```ts
-import { Client } from "https://deno.land/x/postgres@v0.15.0/mod.ts";
+import { Client } from "https://deno.land/x/postgres@v0.16.0/mod.ts";
 
 const client = new Client({
   user: "user",
@@ -38,7 +38,7 @@ All `deno-postgres` clients provide the following options to authenticate and
 manage your connections
 
 ```ts
-import { Client } from "https://deno.land/x/postgres@v0.15.0/mod.ts";
+import { Client } from "https://deno.land/x/postgres@v0.16.0/mod.ts";
 
 let config;
 
@@ -52,6 +52,9 @@ config = {
   hostname: "localhost",
   host_type: "tcp",
   password: "password",
+  options: {
+    "max_index_keys": "32",
+  },
   port: 5432,
   user: "user",
   tls: {
@@ -75,6 +78,8 @@ the database name and your user, the rest of them have sensible defaults to save
 up time when configuring your connection, such as the following:
 
 - connection.attempts: "1"
+- connection.interval: Exponential backoff increasing the time by 500 ms on
+  every reconnection
 - hostname: If host_type is set to TCP, it will be "127.0.0.1". Otherwise, it
   will default to the "/tmp" folder to look for a socket connection
 - host_type: "socket", unless a host is manually specified
@@ -108,13 +113,19 @@ of search parameters such as the following:
 - host: If host is not specified in the url, this will be taken instead
 - password: If password is not specified in the url, this will be taken instead
 - port: If port is not specified in the url, this will be taken instead
+- options: This parameter can be used by other database engines usable through
+  the Postgres protocol (such as Cockroachdb for example) to send additional
+  values for connection (ej: options=--cluster=your_cluster_name)
 - sslmode: Allows you to specify the tls configuration for your client, the
   allowed values are the following:
-  - disable: Skip TLS connection altogether
-  - prefer: Attempt to stablish a TLS connection, default to unencrypted if the
-    negotiation fails
+
+  - verify-full: Same behaviour as `require`
+  - verify-ca: Same behaviour as `require`
   - require: Attempt to stablish a TLS connection, abort the connection if the
     negotiation fails
+  - prefer: Attempt to stablish a TLS connection, default to unencrypted if the
+    negotiation fails
+  - disable: Skip TLS connection altogether
 - user: If user is not specified in the url, this will be taken instead
 
 #### Password encoding
@@ -186,12 +197,32 @@ try {
 }
 ```
 
-Your initial connection will also be affected by this setting, in a slightly
+Your initial connection will also be affected by this setting in a slightly
 different manner than already active errored connections. If you fail to connect
 to your database in the first attempt, the client will keep trying to connect as
 many times as requested, meaning that if your attempt configuration is three,
 your total first-connection-attempts will ammount to four.
 
+Additionally you can set an interval before each reconnection by using the
+`interval` parameter. This can be either a plane number or a function where the
+developer receives the previous interval and returns the new one, making it easy
+to implement exponential backoff (Note: the initial interval for this function
+is always gonna be zero)
+
+```ts
+// Eg: A client that increases the reconnection time by multiplying the previous interval by 2
+const client = new Client({
+  connection: {
+    attempts: 0,
+    interval: (prev_interval) => {
+      // Initial interval is always gonna be zero
+      if (prev_interval === 0) return 2;
+      return prev_interval * 2;
+    },
+  },
+});
+```
+
 ### Unix socket connection
 
 On Unix systems, it's possible to connect to your database through IPC sockets
@@ -348,7 +379,7 @@ consistency with other PostgreSQL clients out there (see
 https://www.postgresql.org/docs/14/libpq-envars.html)
 
 ```ts
-// PGUSER=user PGPASSWORD=admin PGDATABASE=test deno run --allow-net --allow-env --unstable database.js
+// PGUSER=user PGPASSWORD=admin PGDATABASE=test deno run --allow-net --allow-env database.js
 import { Client } from "https://deno.land/x/postgres/mod.ts";
 
 const client = new Client();
@@ -593,7 +624,7 @@ arguments object
 
 Even thought the previous call is already pretty simple, it can be simplified
 even further by the use of template strings, offering all the benefits of
-prepared statements with a nice and clear syntaxis for your queries
+prepared statements with a nice and clear syntax for your queries
 
 ```ts
 {
@@ -1245,7 +1276,7 @@ const transaction = client.createTransaction(
 await transaction.savepoint("undo");
 await transaction.queryArray`TRUNCATE TABLE DONT_DELETE_ME`; // Oops, wrong table
 await transaction.rollback("undo"); // Truncate is rolled back, transaction continues
-await transaction.end();
+// Ongoing transaction operations here
 ```
 
 If we intended to rollback all changes but still continue in the current
@@ -1258,5 +1289,6 @@ await transaction.queryArray`INSERT INTO DONT_DELETE_ME VALUES (1)`;
 await transaction.queryArray`TRUNCATE TABLE DONT_DELETE_ME`;
 await transaction.rollback({ chain: true }); // All changes get undone
 await transaction.queryArray`INSERT INTO DONT_DELETE_ME VALUES (2)`; // Still inside the transaction
-await transaction.end();
+await transaction.commit();
+// Transaction ends, client gets unlocked
 ```
diff --git a/pool.ts b/pool.ts
index 0c2a6edd..3488e799 100644
--- a/pool.ts
+++ b/pool.ts
@@ -1,8 +1,8 @@
 import { PoolClient } from "./client.ts";
 import {
-  ClientConfiguration,
-  ClientOptions,
-  ConnectionString,
+  type ClientConfiguration,
+  type ClientOptions,
+  type ConnectionString,
   createParams,
 } from "./connection/connection_params.ts";
 import { DeferredAccessStack } from "./utils/deferred.ts";
@@ -44,7 +44,7 @@ import { DeferredAccessStack } from "./utils/deferred.ts";
  * // Connection is created here, will be available from now on
  * const client_1 = await pool.connect();
  * await client_1.queryArray`SELECT 1`;
- * await client_1.release();
+ * client_1.release();
  *
  * // Same connection as before, will be reused instead of starting a new one
  * const client_2 = await pool.connect();
@@ -53,8 +53,8 @@ import { DeferredAccessStack } from "./utils/deferred.ts";
  * // New connection, since previous one is still in use
  * // There will be two open connections available from now on
  * const client_3 = await pool.connect();
- * await client_2.release();
- * await client_3.release();
+ * client_2.release();
+ * client_3.release();
  * ```
  */
 export class Pool {
@@ -157,7 +157,7 @@ export class Pool {
    * await pool.end();
    * const client = await pool.connect();
    * await client.queryArray`SELECT 1`; // Works!
-   * await client.release();
+   * client.release();
    * ```
    */
   async end(): Promise<void> {
diff --git a/query/decoders.ts b/query/decoders.ts
index cbe33e95..3199e844 100644
--- a/query/decoders.ts
+++ b/query/decoders.ts
@@ -1,6 +1,6 @@
 import { date } from "../deps.ts";
 import { parseArray } from "./array_parser.ts";
-import {
+import type {
   Box,
   Circle,
   Float8,
diff --git a/query/encode.ts b/query/encode.ts
index 6a6b8172..66866e4f 100644
--- a/query/encode.ts
+++ b/query/encode.ts
@@ -60,7 +60,8 @@ function encodeArray(array: Array<unknown>): string {
     } else if (Array.isArray(element)) {
       encodedArray += encodeArray(element);
     } else if (element instanceof Uint8Array) {
-      // TODO: it should be encoded as bytea?
+      // TODO
+      // Should it be encoded as bytea?
       throw new Error("Can't encode array of buffers.");
     } else {
       const encodedElement = encodeArgument(element);
diff --git a/query/query.ts b/query/query.ts
index 5c3f755b..4a442c01 100644
--- a/query/query.ts
+++ b/query/query.ts
@@ -1,6 +1,6 @@
-import { encodeArgument, EncodedArg } from "./encode.ts";
-import { Column, decode } from "./decode.ts";
-import { Notice } from "../connection/message.ts";
+import { encodeArgument, type EncodedArg } from "./encode.ts";
+import { type Column, decode } from "./decode.ts";
+import { type Notice } from "../connection/message.ts";
 
 // TODO
 // Limit the type of parameters that can be passed
diff --git a/query/transaction.ts b/query/transaction.ts
index 99b0cb92..137f249a 100644
--- a/query/transaction.ts
+++ b/query/transaction.ts
@@ -1,12 +1,12 @@
-import type { QueryClient } from "../client.ts";
+import { type QueryClient } from "../client.ts";
 import {
   Query,
-  QueryArguments,
-  QueryArrayResult,
-  QueryObjectOptions,
-  QueryObjectResult,
-  QueryOptions,
-  QueryResult,
+  type QueryArguments,
+  type QueryArrayResult,
+  type QueryObjectOptions,
+  type QueryObjectResult,
+  type QueryOptions,
+  type QueryResult,
   ResultType,
   templateStringToQuery,
 } from "./query.ts";
@@ -240,6 +240,9 @@ export class Transaction {
     this.#updateClientLock(this.name);
   }
 
+  /** Should not commit the same transaction twice. */
+  #committed = false;
+
   /**
    * The commit method will make permanent all changes made to the database in the
    * current transaction and end the current transaction
@@ -277,13 +280,16 @@ export class Transaction {
 
     const chain = options?.chain ?? false;
 
-    try {
-      await this.queryArray(`COMMIT ${chain ? "AND CHAIN" : ""}`);
-    } catch (e) {
-      if (e instanceof PostgresError) {
-        throw new TransactionError(this.name, e);
-      } else {
-        throw e;
+    if (!this.#committed) {
+      this.#committed = true;
+      try {
+        await this.queryArray(`COMMIT ${chain ? "AND CHAIN" : ""}`);
+      } catch (e) {
+        if (e instanceof PostgresError) {
+          throw new TransactionError(this.name, e);
+        } else {
+          throw e;
+        }
       }
     }
 
@@ -397,7 +403,7 @@ export class Transaction {
       query = new Query(
         query_template_or_config,
         ResultType.ARRAY,
-        args as QueryArguments | undefined,
+        args[0] as QueryArguments | undefined,
       );
     } else if (isTemplateString(query_template_or_config)) {
       query = templateStringToQuery(
diff --git a/tests/config.ts b/tests/config.ts
index 0eb8d6dc..d2569146 100644
--- a/tests/config.ts
+++ b/tests/config.ts
@@ -1,4 +1,5 @@
 import { ClientConfiguration } from "../connection/connection_params.ts";
+import config_file1 from "./config.json" assert { type: "json" };
 
 type TcpConfiguration = Omit<ClientConfiguration, "connection"> & {
   host_type: "tcp";
@@ -7,54 +8,18 @@ type SocketConfiguration = Omit<ClientConfiguration, "connection" | "tls"> & {
   host_type: "socket";
 };
 
-type ConfigFileConnection =
-  & Pick<
-    ClientConfiguration,
-    "applicationName" | "database" | "hostname" | "password" | "port"
-  >
-  & {
-    socket: string;
-  };
-
-type Clear = ConfigFileConnection & {
-  users: {
-    clear: string;
-    socket: string;
-  };
-};
-
-type Classic = ConfigFileConnection & {
-  users: {
-    main: string;
-    md5: string;
-    socket: string;
-    tls_only: string;
-  };
-};
-
-type Scram = ConfigFileConnection & {
-  users: {
-    scram: string;
-    socket: string;
-  };
-};
-
-interface EnvironmentConfig {
-  postgres_clear: Clear;
-  postgres_md5: Classic;
-  postgres_scram: Scram;
+let DEV_MODE: string | undefined;
+try {
+  DEV_MODE = Deno.env.get("DENO_POSTGRES_DEVELOPMENT");
+} catch (e) {
+  if (e instanceof Deno.errors.PermissionDenied) {
+    throw new Error(
+      "You need to provide ENV access in order to run the test suite",
+    );
+  }
+  throw e;
 }
-
-const config_file: {
-  ci: EnvironmentConfig;
-  local: EnvironmentConfig;
-} = JSON.parse(
-  await Deno.readTextFile(new URL("./config.json", import.meta.url)),
-);
-
-const config = Deno.env.get("DENO_POSTGRES_DEVELOPMENT") === "true"
-  ? config_file.local
-  : config_file.ci;
+const config = DEV_MODE === "true" ? config_file1.local : config_file1.ci;
 
 const enabled_tls = {
   caCertificates: [
@@ -80,6 +45,7 @@ export const getClearConfiguration = (
     database: config.postgres_clear.database,
     host_type: "tcp",
     hostname: config.postgres_clear.hostname,
+    options: {},
     password: config.postgres_clear.password,
     port: config.postgres_clear.port,
     tls: tls ? enabled_tls : disabled_tls,
@@ -93,6 +59,7 @@ export const getClearSocketConfiguration = (): SocketConfiguration => {
     database: config.postgres_clear.database,
     host_type: "socket",
     hostname: config.postgres_clear.socket,
+    options: {},
     password: config.postgres_clear.password,
     port: config.postgres_clear.port,
     user: config.postgres_clear.users.socket,
@@ -106,6 +73,7 @@ export const getMainConfiguration = (): TcpConfiguration => {
     database: config.postgres_md5.database,
     hostname: config.postgres_md5.hostname,
     host_type: "tcp",
+    options: {},
     password: config.postgres_md5.password,
     port: config.postgres_md5.port,
     tls: enabled_tls,
@@ -119,6 +87,7 @@ export const getMd5Configuration = (tls: boolean): TcpConfiguration => {
     database: config.postgres_md5.database,
     hostname: config.postgres_md5.hostname,
     host_type: "tcp",
+    options: {},
     password: config.postgres_md5.password,
     port: config.postgres_md5.port,
     tls: tls ? enabled_tls : disabled_tls,
@@ -132,6 +101,7 @@ export const getMd5SocketConfiguration = (): SocketConfiguration => {
     database: config.postgres_md5.database,
     hostname: config.postgres_md5.socket,
     host_type: "socket",
+    options: {},
     password: config.postgres_md5.password,
     port: config.postgres_md5.port,
     user: config.postgres_md5.users.socket,
@@ -144,6 +114,7 @@ export const getScramConfiguration = (tls: boolean): TcpConfiguration => {
     database: config.postgres_scram.database,
     hostname: config.postgres_scram.hostname,
     host_type: "tcp",
+    options: {},
     password: config.postgres_scram.password,
     port: config.postgres_scram.port,
     tls: tls ? enabled_tls : disabled_tls,
@@ -157,6 +128,7 @@ export const getScramSocketConfiguration = (): SocketConfiguration => {
     database: config.postgres_scram.database,
     hostname: config.postgres_scram.socket,
     host_type: "socket",
+    options: {},
     password: config.postgres_scram.password,
     port: config.postgres_scram.port,
     user: config.postgres_scram.users.socket,
@@ -169,6 +141,7 @@ export const getTlsOnlyConfiguration = (): TcpConfiguration => {
     database: config.postgres_md5.database,
     hostname: config.postgres_md5.hostname,
     host_type: "tcp",
+    options: {},
     password: config.postgres_md5.password,
     port: config.postgres_md5.port,
     tls: enabled_tls,
diff --git a/tests/connection_params_test.ts b/tests/connection_params_test.ts
index 6a4fab98..44b69aea 100644
--- a/tests/connection_params_test.ts
+++ b/tests/connection_params_test.ts
@@ -1,7 +1,10 @@
 import { assertEquals, assertThrows, fromFileUrl } from "./test_deps.ts";
 import { createParams } from "../connection/connection_params.ts";
 import { ConnectionParamsError } from "../client/error.ts";
-import { has_env_access } from "./constants.ts";
+
+function setEnv(env: string, value?: string) {
+  value ? Deno.env.set(env, value) : Deno.env.delete(env);
+}
 
 /**
  * This function is ment to be used as a container for env based tests.
@@ -10,51 +13,43 @@ import { has_env_access } from "./constants.ts";
  *
  * It can only be used in tests that run with env permissions
  */
-const withEnv = (env: {
-  database: string;
-  host: string;
-  user: string;
-  port: string;
-}, fn: () => void) => {
-  const PGDATABASE = Deno.env.get("PGDATABASE");
-  const PGHOST = Deno.env.get("PGHOST");
-  const PGPORT = Deno.env.get("PGPORT");
-  const PGUSER = Deno.env.get("PGUSER");
-
-  Deno.env.set("PGDATABASE", env.database);
-  Deno.env.set("PGHOST", env.host);
-  Deno.env.set("PGPORT", env.port);
-  Deno.env.set("PGUSER", env.user);
-
-  fn();
-
-  // Reset to original state
-  PGDATABASE
-    ? Deno.env.set("PGDATABASE", PGDATABASE)
-    : Deno.env.delete("PGDATABASE");
-  PGHOST ? Deno.env.set("PGHOST", PGHOST) : Deno.env.delete("PGHOST");
-  PGPORT ? Deno.env.set("PGPORT", PGPORT) : Deno.env.delete("PGPORT");
-  PGUSER ? Deno.env.set("PGUSER", PGUSER) : Deno.env.delete("PGUSER");
-};
-
-// TODO
-// Replace with test permission options to remove the need for function override
-/**
- * This function will override getting env variables to simulate having no env permissions
- */
-function withNotAllowedEnv(fn: () => void) {
-  return () => {
-    const getEnv = Deno.env.get;
-
-    Deno.env.get = (_key: string) => {
-      throw new Deno.errors.PermissionDenied("");
-    };
-
-    try {
-      fn();
-    } finally {
-      Deno.env.get = getEnv;
-    }
+function withEnv(
+  {
+    database,
+    host,
+    options,
+    port,
+    user,
+  }: {
+    database?: string;
+    host?: string;
+    options?: string;
+    user?: string;
+    port?: string;
+  },
+  fn: (t: Deno.TestContext) => void,
+): (t: Deno.TestContext) => void | Promise<void> {
+  return (t) => {
+    const PGDATABASE = Deno.env.get("PGDATABASE");
+    const PGHOST = Deno.env.get("PGHOST");
+    const PGOPTIONS = Deno.env.get("PGOPTIONS");
+    const PGPORT = Deno.env.get("PGPORT");
+    const PGUSER = Deno.env.get("PGUSER");
+
+    database && Deno.env.set("PGDATABASE", database);
+    host && Deno.env.set("PGHOST", host);
+    options && Deno.env.set("PGOPTIONS", options);
+    port && Deno.env.set("PGPORT", port);
+    user && Deno.env.set("PGUSER", user);
+
+    fn(t);
+
+    // Reset to original state
+    database && setEnv("PGDATABASE", PGDATABASE);
+    host && setEnv("PGHOST", PGHOST);
+    options && setEnv("PGOPTIONS", PGOPTIONS);
+    port && setEnv("PGPORT", PGPORT);
+    user && setEnv("PGUSER", PGUSER);
   };
 }
 
@@ -136,13 +131,98 @@ Deno.test("Parses connection string with sslmode required", function () {
   assertEquals(p.tls.enforce, true);
 });
 
+Deno.test("Parses connection string with options", () => {
+  {
+    const params = {
+      x: "1",
+      y: "2",
+    };
+
+    const params_as_args = Object.entries(params).map(([key, value]) =>
+      `--${key}=${value}`
+    ).join(" ");
+
+    const p = createParams(
+      `postgres://some_user@some_host:10101/deno_postgres?options=${
+        encodeURIComponent(params_as_args)
+      }`,
+    );
+
+    assertEquals(p.options, params);
+  }
+
+  // Test arguments provided with the -c flag
+  {
+    const params = {
+      x: "1",
+      y: "2",
+    };
+
+    const params_as_args = Object.entries(params).map(([key, value]) =>
+      `-c ${key}=${value}`
+    ).join(" ");
+
+    const p = createParams(
+      `postgres://some_user@some_host:10101/deno_postgres?options=${
+        encodeURIComponent(params_as_args)
+      }`,
+    );
+
+    assertEquals(p.options, params);
+  }
+});
+
+Deno.test("Throws on connection string with invalid options", () => {
+  assertThrows(
+    () =>
+      createParams(
+        `postgres://some_user@some_host:10101/deno_postgres?options=z`,
+      ),
+    Error,
+    `Value "z" is not a valid options argument`,
+  );
+
+  assertThrows(
+    () =>
+      createParams(
+        `postgres://some_user@some_host:10101/deno_postgres?options=${
+          encodeURIComponent("-c")
+        }`,
+      ),
+    Error,
+    `No provided value for "-c" in options parameter`,
+  );
+
+  assertThrows(
+    () =>
+      createParams(
+        `postgres://some_user@some_host:10101/deno_postgres?options=${
+          encodeURIComponent("-c a")
+        }`,
+      ),
+    Error,
+    `Value "a" is not a valid options argument`,
+  );
+
+  assertThrows(
+    () =>
+      createParams(
+        `postgres://some_user@some_host:10101/deno_postgres?options=${
+          encodeURIComponent("-b a=1")
+        }`,
+      ),
+    Error,
+    `Argument "-b" is not supported in options parameter`,
+  );
+});
+
 Deno.test("Throws on connection string with invalid driver", function () {
   assertThrows(
     () =>
       createParams(
         "somedriver://some_user@some_host:10101/deno_postgres",
       ),
-    undefined,
+    Error,
     "Supplied DSN has invalid driver: somedriver.",
   );
 });
@@ -162,10 +242,10 @@ Deno.test("Throws on connection string with invalid ssl mode", function () {
   assertThrows(
     () =>
       createParams(
-        "postgres://some_user@some_host:10101/deno_postgres?sslmode=verify-full",
+        "postgres://some_user@some_host:10101/deno_postgres?sslmode=invalid",
       ),
     ConnectionParamsError,
-    "Supplied DSN has invalid sslmode 'verify-full'. Only 'disable', 'require', and 'prefer' are supported",
+    "Supplied DSN has invalid sslmode 'invalid'",
   );
 });
 
@@ -199,48 +279,54 @@ Deno.test("Throws on invalid tls options", function () {
   );
 });
 
-Deno.test({
-  name: "Parses env connection options",
-  ignore: !has_env_access,
-  fn() {
-    withEnv({
-      database: "deno_postgres",
-      host: "some_host",
-      port: "10101",
-      user: "some_user",
-    }, () => {
-      const p = createParams();
-      assertEquals(p.database, "deno_postgres");
-      assertEquals(p.hostname, "some_host");
-      assertEquals(p.port, 10101);
-      assertEquals(p.user, "some_user");
-    });
-  },
-});
+Deno.test(
+  "Parses env connection options",
+  withEnv({
+    database: "deno_postgres",
+    host: "some_host",
+    port: "10101",
+    user: "some_user",
+  }, () => {
+    const p = createParams();
+    assertEquals(p.database, "deno_postgres");
+    assertEquals(p.hostname, "some_host");
+    assertEquals(p.port, 10101);
+    assertEquals(p.user, "some_user");
+  }),
+);
 
-Deno.test({
-  name: "Throws on env connection options with invalid port",
-  ignore: !has_env_access,
-  fn() {
-    const port = "abc";
-    withEnv({
-      database: "deno_postgres",
-      host: "some_host",
-      port,
-      user: "some_user",
-    }, () => {
-      assertThrows(
-        () => createParams(),
-        ConnectionParamsError,
-        `"${port}" is not a valid port number`,
-      );
-    });
-  },
-});
+Deno.test(
+  "Parses options argument from env",
+  withEnv({
+    database: "deno_postgres",
+    user: "some_user",
+    options: "-c a=1",
+  }, () => {
+    const p = createParams();
+
+    assertEquals(p.options, { a: "1" });
+  }),
+);
 
 Deno.test(
-  "Parses mixed connection options and env connection options",
-  withNotAllowedEnv(function () {
+  "Throws on env connection options with invalid port",
+  withEnv({
+    database: "deno_postgres",
+    host: "some_host",
+    port: "abc",
+    user: "some_user",
+  }, () => {
+    assertThrows(
+      () => createParams(),
+      ConnectionParamsError,
+      `"abc" is not a valid port number`,
+    );
+  }),
+);
+
+Deno.test({
+  name: "Parses mixed connection options and env connection options",
+  fn: () => {
     const p = createParams({
       database: "deno_postgres",
       host_type: "tcp",
@@ -251,12 +337,15 @@ Deno.test(
     assertEquals(p.user, "deno_postgres");
     assertEquals(p.hostname, "127.0.0.1");
     assertEquals(p.port, 5432);
-  }),
-);
+  },
+  permissions: {
+    env: false,
+  },
+});
 
-Deno.test(
-  "Throws if it can't obtain necessary parameters from config or env",
-  withNotAllowedEnv(function () {
+Deno.test({
+  name: "Throws if it can't obtain necessary parameters from config or env",
+  fn: () => {
     assertThrows(
       () => createParams(),
       ConnectionParamsError,
@@ -268,48 +357,53 @@ Deno.test(
       ConnectionParamsError,
       "Missing connection parameters: database",
     );
-  }),
-);
+  },
+  permissions: {
+    env: false,
+  },
+});
 
-Deno.test("Uses default connection options", function () {
-  const database = "deno_postgres";
-  const user = "deno_postgres";
+Deno.test({
+  name: "Uses default connection options",
+  fn: () => {
+    const database = "deno_postgres";
+    const user = "deno_postgres";
 
-  const p = createParams({
-    database,
-    host_type: "tcp",
-    user,
-  });
+    const p = createParams({
+      database,
+      host_type: "tcp",
+      user,
+    });
 
-  assertEquals(p.database, database);
-  assertEquals(p.user, user);
-  assertEquals(
-    p.hostname,
-    has_env_access ? (Deno.env.get("PGHOST") ?? "127.0.0.1") : "127.0.0.1",
-  );
-  assertEquals(p.port, 5432);
-  assertEquals(
-    p.password,
-    has_env_access ? Deno.env.get("PGPASSWORD") : undefined,
-  );
+    assertEquals(p.database, database);
+    assertEquals(p.user, user);
+    assertEquals(
+      p.hostname,
+      "127.0.0.1",
+    );
+    assertEquals(p.port, 5432);
+    assertEquals(
+      p.password,
+      undefined,
+    );
+  },
+  permissions: {
+    env: false,
+  },
 });
 
-Deno.test("Throws when required options are not passed", function () {
-  if (has_env_access) {
-    if (!(Deno.env.get("PGUSER") && Deno.env.get("PGDATABASE"))) {
-      assertThrows(
-        () => createParams(),
-        ConnectionParamsError,
-        "Missing connection parameters:",
-      );
-    }
-  } else {
+Deno.test({
+  name: "Throws when required options are not passed",
+  fn: () => {
     assertThrows(
       () => createParams(),
       ConnectionParamsError,
-      "Missing connection parameters: database, user",
+      "Missing connection parameters:",
     );
-  }
+  },
+  permissions: {
+    env: false,
+  },
 });
 
 Deno.test("Determines host type", () => {
@@ -392,7 +486,50 @@ Deno.test("Throws when host is a URL and host type is socket", () => {
         host_type: "socket",
         user: "some_user",
       }),
-    ConnectionParamsError,
-    "The provided host is not a file path",
+    (e: unknown) => {
+      if (!(e instanceof ConnectionParamsError)) {
+        throw new Error(`Unexpected error: ${e}`);
+      }
+
+      const expected_message = "The provided host is not a file path";
+
+      if (
+        typeof e?.cause?.message !== "string" ||
+        !e.cause.message.includes(expected_message)
+      ) {
+        throw new Error(
+          `Expected error message to include "${expected_message}"`,
+        );
+      }
+    },
+  );
+});
+
+Deno.test("Escapes spaces on option values", () => {
+  const value = "space here";
+
+  const p = createParams({
+    database: "some_db",
+    user: "some_user",
+    options: {
+      "key": value,
+    },
+  });
+
+  assertEquals(value.replaceAll(" ", "\\ "), p.options.key);
+});
+
+Deno.test("Throws on invalid option keys", () => {
+  assertThrows(
+    () =>
+      createParams({
+        database: "some_db",
+        user: "some_user",
+        options: {
+          "asd a": "a",
+        },
+      }),
+    Error,
+    'The "asd a" key in the options argument is invalid',
   );
 });
diff --git a/tests/connection_test.ts b/tests/connection_test.ts
index 572d4a47..8ba6cf2d 100644
--- a/tests/connection_test.ts
+++ b/tests/connection_test.ts
@@ -276,7 +276,7 @@ Deno.test("Exposes session PID", async () => {
   await client.connect();
 
   try {
-    const { rows } = await client.queryObject<{ pid: string }>(
+    const { rows } = await client.queryObject<{ pid: number }>(
       "SELECT PG_BACKEND_PID() AS PID",
     );
     assertEquals(client.session.pid, rows[0].pid);
@@ -544,7 +544,7 @@ Deno.test("Attempts reconnection on disconnection", async function () {
     );
     assertEquals(client.connected, false);
 
-    const { rows: result_1 } = await client.queryObject<{ pid: string }>({
+    const { rows: result_1 } = await client.queryObject<{ pid: number }>({
       text: "SELECT PG_BACKEND_PID() AS PID",
       fields: ["pid"],
     });
@@ -654,3 +654,48 @@ Deno.test("Doesn't attempt reconnection when attempts are set to zero", async fu
     await client.end();
   }
 });
+
+Deno.test("Options are passed to the database on connection", async () => {
+  // Test for both cases cause we don't know what the default value of geqo is gonna be
+  {
+    const client = new Client({
+      ...getMainConfiguration(),
+      options: {
+        "geqo": "off",
+      },
+    });
+
+    await client.connect();
+
+    try {
+      const { rows: result } = await client.queryObject<{ setting: string }>
+        `SELECT SETTING FROM PG_SETTINGS WHERE NAME = 'geqo'`;
+
+      assertEquals(result.length, 1);
+      assertEquals(result[0].setting, "off");
+    } finally {
+      await client.end();
+    }
+  }
+
+  {
+    const client = new Client({
+      ...getMainConfiguration(),
+      options: {
+        geqo: "on",
+      },
+    });
+
+    await client.connect();
+
+    try {
+      const { rows: result } = await client.queryObject<{ setting: string }>
+        `SELECT SETTING FROM PG_SETTINGS WHERE NAME = 'geqo'`;
+
+      assertEquals(result.length, 1);
+      assertEquals(result[0].setting, "on");
+    } finally {
+      await client.end();
+    }
+  }
+});
diff --git a/tests/constants.ts b/tests/constants.ts
deleted file mode 100644
index 1348c46f..00000000
--- a/tests/constants.ts
+++ /dev/null
@@ -1,12 +0,0 @@
-let has_env_access = true;
-try {
-  Deno.env.toObject();
-} catch (e) {
-  if (e instanceof Deno.errors.PermissionDenied) {
-    has_env_access = false;
-  } else {
-    throw e;
-  }
-}
-
-export { has_env_access };
diff --git a/tests/data_types_test.ts b/tests/data_types_test.ts
index f9ff7458..d88cdb2d 100644
--- a/tests/data_types_test.ts
+++ b/tests/data_types_test.ts
@@ -1,7 +1,7 @@
 import { assertEquals, base64, date } from "./test_deps.ts";
 import { getMainConfiguration } from "./config.ts";
 import { generateSimpleClientTest } from "./helpers.ts";
-import {
+import type {
   Box,
   Circle,
   Float4,
@@ -767,12 +767,12 @@ Deno.test(
       new Date().toISOString().slice(0, -1),
     ];
 
-    const result = await client.queryArray<[[Timestamp, Timestamp]]>(
+    const { rows: result } = await client.queryArray<[[Date, Date]]>(
       "SELECT ARRAY[$1::TIMESTAMP, $2]",
       timestamps,
     );
 
-    assertEquals(result.rows[0][0], timestamps.map((x) => new Date(x)));
+    assertEquals(result[0][0], timestamps.map((x) => new Date(x)));
   }),
 );
 
@@ -943,13 +943,13 @@ Deno.test(
     await client.queryArray(`SET SESSION TIMEZONE TO '${timezone}'`);
     const dates = ["2020-01-01", date.format(new Date(), "yyyy-MM-dd")];
 
-    const result = await client.queryArray<[Timestamp, Timestamp]>(
+    const { rows: result } = await client.queryArray<[[Date, Date]]>(
       "SELECT ARRAY[$1::DATE, $2]",
       dates,
     );
 
     assertEquals(
-      result.rows[0][0],
+      result[0][0],
       dates.map((d) => date.parse(d, "yyyy-MM-dd")),
     );
   }),
diff --git a/tests/helpers.ts b/tests/helpers.ts
index e26a7f27..d1630d3e 100644
--- a/tests/helpers.ts
+++ b/tests/helpers.ts
@@ -1,6 +1,6 @@
 import { Client } from "../client.ts";
 import { Pool } from "../pool.ts";
-import type { ClientOptions } from "../connection/connection_params.ts";
+import { type ClientOptions } from "../connection/connection_params.ts";
 
 export function generateSimpleClientTest(
   client_options: ClientOptions,
diff --git a/tests/pool_test.ts b/tests/pool_test.ts
index 7263cf32..fb7c3fcb 100644
--- a/tests/pool_test.ts
+++ b/tests/pool_test.ts
@@ -125,3 +125,18 @@ Deno.test(
     true,
   ),
 );
+
+Deno.test(
+  "Concurrent connect-then-release cycles do not throw",
+  testPool(async (POOL) => {
+    async function connectThenRelease() {
+      let client = await POOL.connect();
+      client.release();
+      client = await POOL.connect();
+      client.release();
+    }
+    await Promise.all(
+      Array.from({ length: POOL.size + 1 }, connectThenRelease),
+    );
+  }),
+);
diff --git a/tests/query_client_test.ts b/tests/query_client_test.ts
index b616fb07..46773b3c 100644
--- a/tests/query_client_test.ts
+++ b/tests/query_client_test.ts
@@ -1,4 +1,10 @@
-import { Client, ConnectionError, Pool, PostgresError } from "../mod.ts";
+import {
+  Client,
+  ConnectionError,
+  Pool,
+  PostgresError,
+  TransactionError,
+} from "../mod.ts";
 import {
   assert,
   assertEquals,
@@ -8,18 +14,53 @@ import {
 import { getMainConfiguration } from "./config.ts";
 import { PoolClient, QueryClient } from "../client.ts";
 
-function testClient(
-  name: string,
+function withClient(
+  t: (client: QueryClient) => void | Promise<void>,
+) {
+  async function clientWrapper() {
+    const client = new Client(getMainConfiguration());
+    try {
+      await client.connect();
+      await t(client);
+    } finally {
+      await client.end();
+    }
+  }
+
+  async function poolWrapper() {
+    const pool = new Pool(getMainConfiguration(), 1);
+    let client;
+    try {
+      client = await pool.connect();
+      await t(client);
+    } finally {
+      client?.release();
+      await pool.end();
+    }
+  }
+
+  return async (test: Deno.TestContext) => {
+    await test.step({ fn: clientWrapper, name: "Client" });
+    await test.step({ fn: poolWrapper, name: "Pool" });
+  };
+}
+
+function withClientGenerator(
   t: (getClient: () => Promise<QueryClient>) => void | Promise<void>,
+  pool_size = 10,
 ) {
   async function clientWrapper() {
     const clients: Client[] = [];
     try {
+      let client_count = 0;
       await t(async () => {
-        const client = new Client(getMainConfiguration());
-        await client.connect();
-        clients.push(client);
-        return client;
+        if (client_count < pool_size) {
+          const client = new Client(getMainConfiguration());
+          await client.connect();
+          clients.push(client);
+          client_count++;
+          return client;
+        } else throw new Error("Max client size exceeded");
       });
     } finally {
       for (const client of clients) {
@@ -29,7 +70,7 @@ function testClient(
   }
 
   async function poolWrapper() {
-    const pool = new Pool(getMainConfiguration(), 10);
+    const pool = new Pool(getMainConfiguration(), pool_size);
     const clients: PoolClient[] = [];
     try {
       await t(async () => {
@@ -45,112 +86,116 @@ function testClient(
     }
   }
 
-  Deno.test({ fn: clientWrapper, name: `Client: ${name}` });
-  Deno.test({ fn: poolWrapper, name: `Pool: ${name}` });
+  return async (test: Deno.TestContext) => {
+    await test.step({ fn: clientWrapper, name: "Client" });
+    await test.step({ fn: poolWrapper, name: "Pool" });
+  };
 }
 
-testClient("Array query", async function (generateClient) {
-  const client = await generateClient();
-
-  const result = await client.queryArray("SELECT UNNEST(ARRAY[1, 2])");
-  assertEquals(result.rows.length, 2);
-});
-
-testClient("Object query", async function (generateClient) {
-  const client = await generateClient();
-
-  const result = await client.queryObject(
-    "SELECT ARRAY[1, 2, 3] AS ID, 'DATA' AS TYPE",
-  );
-
-  assertEquals(result.rows, [{ id: [1, 2, 3], type: "DATA" }]);
-});
-
-testClient("Array arguments", async function (generateClient) {
-  const client = await generateClient();
+Deno.test(
+  "Array query",
+  withClient(async (client) => {
+    const result = await client.queryArray("SELECT UNNEST(ARRAY[1, 2])");
+    assertEquals(result.rows.length, 2);
+  }),
+);
 
-  {
-    const value = "1";
-    const result = await client.queryArray(
-      "SELECT $1",
-      [value],
+Deno.test(
+  "Object query",
+  withClient(async (client) => {
+    const result = await client.queryObject(
+      "SELECT ARRAY[1, 2, 3] AS ID, 'DATA' AS TYPE",
     );
-    assertEquals(result.rows, [[value]]);
-  }
 
-  {
-    const value = "2";
-    const result = await client.queryArray({
-      args: [value],
-      text: "SELECT $1",
-    });
-    assertEquals(result.rows, [[value]]);
-  }
+    assertEquals(result.rows, [{ id: [1, 2, 3], type: "DATA" }]);
+  }),
+);
 
-  {
-    const value = "3";
-    const result = await client.queryObject(
-      "SELECT $1 AS ID",
-      [value],
-    );
-    assertEquals(result.rows, [{ id: value }]);
-  }
+Deno.test(
+  "Array arguments",
+  withClient(async (client) => {
+    {
+      const value = "1";
+      const result = await client.queryArray(
+        "SELECT $1",
+        [value],
+      );
+      assertEquals(result.rows, [[value]]);
+    }
 
-  {
-    const value = "4";
-    const result = await client.queryObject({
-      args: [value],
-      text: "SELECT $1 AS ID",
-    });
-    assertEquals(result.rows, [{ id: value }]);
-  }
-});
+    {
+      const value = "2";
+      const result = await client.queryArray({
+        args: [value],
+        text: "SELECT $1",
+      });
+      assertEquals(result.rows, [[value]]);
+    }
 
-testClient("Object arguments", async function (generateClient) {
-  const client = await generateClient();
+    {
+      const value = "3";
+      const result = await client.queryObject(
+        "SELECT $1 AS ID",
+        [value],
+      );
+      assertEquals(result.rows, [{ id: value }]);
+    }
 
-  {
-    const value = "1";
-    const result = await client.queryArray(
-      "SELECT $id",
-      { id: value },
-    );
-    assertEquals(result.rows, [[value]]);
-  }
+    {
+      const value = "4";
+      const result = await client.queryObject({
+        args: [value],
+        text: "SELECT $1 AS ID",
+      });
+      assertEquals(result.rows, [{ id: value }]);
+    }
+  }),
+);
 
-  {
-    const value = "2";
-    const result = await client.queryArray({
-      args: { id: value },
-      text: "SELECT $ID",
-    });
-    assertEquals(result.rows, [[value]]);
-  }
+Deno.test(
+  "Object arguments",
+  withClient(async (client) => {
+    {
+      const value = "1";
+      const result = await client.queryArray(
+        "SELECT $id",
+        { id: value },
+      );
+      assertEquals(result.rows, [[value]]);
+    }
 
-  {
-    const value = "3";
-    const result = await client.queryObject(
-      "SELECT $id as ID",
-      { id: value },
-    );
-    assertEquals(result.rows, [{ id: value }]);
-  }
+    {
+      const value = "2";
+      const result = await client.queryArray({
+        args: { id: value },
+        text: "SELECT $ID",
+      });
+      assertEquals(result.rows, [[value]]);
+    }
 
-  {
-    const value = "4";
-    const result = await client.queryObject({
-      args: { id: value },
-      text: "SELECT $ID AS ID",
-    });
-    assertEquals(result.rows, [{ id: value }]);
-  }
-});
+    {
+      const value = "3";
+      const result = await client.queryObject(
+        "SELECT $id as ID",
+        { id: value },
+      );
+      assertEquals(result.rows, [{ id: value }]);
+    }
 
-testClient(
-  "Throws on duplicate object arguments",
-  async function (generateClient) {
-    const client = await generateClient();
+    {
+      const value = "4";
+      const result = await client.queryObject({
+        args: { id: value },
+        text: "SELECT $ID AS ID",
+      });
+      assertEquals(result.rows, [{ id: value }]);
+    }
+  }),
+);
 
+Deno.test(
+  "Throws on duplicate object arguments",
+  withClient(async (client) => {
     const value = "some_value";
     const { rows: res } = await client.queryArray(
       "SELECT $value, $VaLue, $VALUE",
@@ -163,14 +208,12 @@ testClient(
       Error,
       "The arguments provided for the query must be unique (insensitive)",
     );
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Array query handles recovery after error state",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await client.queryArray`CREATE TEMP TABLE PREPARED_STATEMENT_ERROR (X INT)`;
 
     await assertRejects(() =>
@@ -186,14 +229,12 @@ testClient(
     });
 
     assertEquals(rows[0], { result: 1 });
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Array query can handle multiple query failures at once",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await assertRejects(
       () =>
         client.queryArray(
@@ -209,14 +250,12 @@ testClient(
     });
 
     assertEquals(rows[0], { result: 1 });
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Array query handles error during data processing",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await assertRejects(
       () => client.queryObject`SELECT 'A' AS X, 'B' AS X`,
     );
@@ -224,38 +263,32 @@ testClient(
     const value = "193";
     const { rows: result_2 } = await client.queryObject`SELECT ${value} AS B`;
     assertEquals(result_2[0], { b: value });
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Array query can return multiple queries",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     const { rows: result } = await client.queryObject<{ result: number }>({
       text: "SELECT 1; SELECT '2'::INT",
       fields: ["result"],
     });
 
     assertEquals(result, [{ result: 1 }, { result: 2 }]);
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Array query handles empty query",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     const { rows: result } = await client.queryArray("");
     assertEquals(result, []);
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Prepared query handles recovery after error state",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await client.queryArray`CREATE TEMP TABLE PREPARED_STATEMENT_ERROR (X INT)`;
 
     await assertRejects(() =>
@@ -273,14 +306,12 @@ testClient(
     });
 
     assertEquals(rows[0], { result });
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Prepared query handles error during data processing",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await assertRejects(
       () => client.queryObject`SELECT ${1} AS A, ${2} AS A`,
     );
@@ -288,13 +319,12 @@ testClient(
     const value = "z";
     const { rows: result_2 } = await client.queryObject`SELECT ${value} AS B`;
     assertEquals(result_2[0], { b: value });
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Handles array with semicolon separator",
-  async (generateClient) => {
-    const client = await generateClient();
+  withClient(async (client) => {
     const item_1 = "Test;Azer";
     const item_2 = "123;456";
 
@@ -303,14 +333,12 @@ testClient(
       [item_1, item_2],
     );
     assertEquals(result_1[0], [[item_1, item_2]]);
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Handles parameter status messages on array query",
-  async (generateClient) => {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     const { rows: result_1 } = await client.queryArray
       `SET TIME ZONE 'HongKong'`;
 
@@ -322,14 +350,12 @@ testClient(
     });
 
     assertEquals(result_2, [{ result: 1 }]);
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Handles parameter status messages on prepared query",
-  async (generateClient) => {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     const result = 10;
 
     await client.queryArray
@@ -363,14 +389,12 @@ testClient(
     });
 
     assertEquals(result_1, [{ result }]);
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Handles parameter status after error",
-  async (generateClient) => {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await client.queryArray
       `CREATE OR REPLACE FUNCTION PG_TEMP.CHANGE_TIMEZONE() RETURNS INT AS $$
 			BEGIN
@@ -383,78 +407,82 @@ testClient(
       PostgresError,
       "control reached end of function without RETURN",
     );
-  },
+  }),
 );
 
-testClient("Terminated connections", async function (generateClient) {
-  const client = await generateClient();
-  await client.end();
+Deno.test(
+  "Terminated connections",
+  withClient(async (client) => {
+    await client.end();
 
-  await assertRejects(
-    async () => {
-      await client.queryArray`SELECT 1`;
-    },
-    Error,
-    "Connection to the database has been terminated",
-  );
-});
+    await assertRejects(
+      async () => {
+        await client.queryArray`SELECT 1`;
+      },
+      Error,
+      "Connection to the database has been terminated",
+    );
+  }),
+);
 
 // This test depends on the assumption that all clients will default to
 // one reconneciton by default
-testClient("Default reconnection", async (generateClient) => {
-  const client = await generateClient();
-
-  await assertRejects(
-    () => client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`,
-    ConnectionError,
-  );
-
-  const { rows: result } = await client.queryObject<{ res: number }>({
-    text: `SELECT 1`,
-    fields: ["res"],
-  });
-  assertEquals(
-    result[0].res,
-    1,
-  );
-
-  assertEquals(client.connected, true);
-});
-
-testClient("Handling of debug notices", async function (generateClient) {
-  const client = await generateClient();
-
-  // Create temporary function
-  await client.queryArray
-    `CREATE OR REPLACE FUNCTION PG_TEMP.CREATE_NOTICE () RETURNS INT AS $$ BEGIN RAISE NOTICE 'NOTICED'; RETURN (SELECT 1); END; $$ LANGUAGE PLPGSQL;`;
-
-  const { rows, warnings } = await client.queryArray(
-    "SELECT * FROM PG_TEMP.CREATE_NOTICE();",
-  );
-  assertEquals(rows[0][0], 1);
-  assertEquals(warnings[0].message, "NOTICED");
-});
+Deno.test(
+  "Default reconnection",
+  withClient(async (client) => {
+    await assertRejects(
+      () =>
+        client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`,
+      ConnectionError,
+    );
+
+    const { rows: result } = await client.queryObject<{ res: number }>({
+      text: `SELECT 1`,
+      fields: ["res"],
+    });
+    assertEquals(
+      result[0].res,
+      1,
+    );
+
+    assertEquals(client.connected, true);
+  }),
+);
+
+Deno.test(
+  "Handling of debug notices",
+  withClient(async (client) => {
+    // Create temporary function
+    await client.queryArray
+      `CREATE OR REPLACE FUNCTION PG_TEMP.CREATE_NOTICE () RETURNS INT AS $$ BEGIN RAISE NOTICE 'NOTICED'; RETURN (SELECT 1); END; $$ LANGUAGE PLPGSQL;`;
+
+    const { rows, warnings } = await client.queryArray(
+      "SELECT * FROM PG_TEMP.CREATE_NOTICE();",
+    );
+    assertEquals(rows[0][0], 1);
+    assertEquals(warnings[0].message, "NOTICED");
+  }),
+);
 
 // This query doesn't recreate the table and outputs
 // a notice instead
-testClient("Handling of query notices", async function (generateClient) {
-  const client = await generateClient();
-
-  await client.queryArray(
-    "CREATE TEMP TABLE NOTICE_TEST (ABC INT);",
-  );
-  const { warnings } = await client.queryArray(
-    "CREATE TEMP TABLE IF NOT EXISTS NOTICE_TEST (ABC INT);",
-  );
+Deno.test(
+  "Handling of query notices",
+  withClient(async (client) => {
+    await client.queryArray(
+      "CREATE TEMP TABLE NOTICE_TEST (ABC INT);",
+    );
+    const { warnings } = await client.queryArray(
+      "CREATE TEMP TABLE IF NOT EXISTS NOTICE_TEST (ABC INT);",
+    );
 
-  assert(warnings[0].message.includes("already exists"));
-});
+    assert(warnings[0].message.includes("already exists"));
+  }),
+);
 
-testClient(
+Deno.test(
   "Handling of messages between data fetching",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await client.queryArray
       `CREATE OR REPLACE FUNCTION PG_TEMP.MESSAGE_BETWEEN_DATA(MESSAGE VARCHAR) RETURNS VARCHAR AS $$
 			BEGIN
@@ -488,130 +516,136 @@ testClient(
 
     assertEquals(result[2], { result: message_3 });
     assertObjectMatch(warnings[2], { message: message_3 });
-  },
+  }),
 );
 
-testClient("nativeType", async function (generateClient) {
-  const client = await generateClient();
-
-  const result = await client.queryArray<[Date]>
-    `SELECT '2019-02-10T10:30:40.005+04:30'::TIMESTAMPTZ`;
-  const row = result.rows[0];
-
-  const expectedDate = Date.UTC(2019, 1, 10, 6, 0, 40, 5);
-
-  assertEquals(row[0].toUTCString(), new Date(expectedDate).toUTCString());
-});
-
-testClient("Binary data is parsed correctly", async function (generateClient) {
-  const client = await generateClient();
-
-  const { rows: result_1 } = await client.queryArray
-    `SELECT E'foo\\\\000\\\\200\\\\\\\\\\\\377'::BYTEA`;
-
-  const expectedBytes = new Uint8Array([102, 111, 111, 0, 128, 92, 255]);
-
-  assertEquals(result_1[0][0], expectedBytes);
-
-  const { rows: result_2 } = await client.queryArray(
-    "SELECT $1::BYTEA",
-    [expectedBytes],
-  );
-  assertEquals(result_2[0][0], expectedBytes);
-});
-
-testClient("Result object metadata", async function (generateClient) {
-  const client = await generateClient();
-
-  await client.queryArray`CREATE TEMP TABLE METADATA (VALUE INTEGER)`;
-  await client.queryArray
-    `INSERT INTO METADATA VALUES (100), (200), (300), (400), (500), (600)`;
-
-  let result;
-
-  // simple select
-  result = await client.queryArray("SELECT * FROM METADATA WHERE VALUE = 100");
-  assertEquals(result.command, "SELECT");
-  assertEquals(result.rowCount, 1);
-
-  // parameterized select
-  result = await client.queryArray(
-    "SELECT * FROM METADATA WHERE VALUE IN ($1, $2)",
-    [200, 300],
-  );
-  assertEquals(result.command, "SELECT");
-  assertEquals(result.rowCount, 2);
-
-  // simple delete
-  result = await client.queryArray(
-    "DELETE FROM METADATA WHERE VALUE IN (100, 200)",
-  );
-  assertEquals(result.command, "DELETE");
-  assertEquals(result.rowCount, 2);
-
-  // parameterized delete
-  result = await client.queryArray(
-    "DELETE FROM METADATA WHERE VALUE = $1",
-    [300],
-  );
-  assertEquals(result.command, "DELETE");
-  assertEquals(result.rowCount, 1);
-
-  // simple insert
-  result = await client.queryArray("INSERT INTO METADATA VALUES (4), (5)");
-  assertEquals(result.command, "INSERT");
-  assertEquals(result.rowCount, 2);
-
-  // parameterized insert
-  result = await client.queryArray("INSERT INTO METADATA VALUES ($1)", [3]);
-  assertEquals(result.command, "INSERT");
-  assertEquals(result.rowCount, 1);
-
-  // simple update
-  result = await client.queryArray(
-    "UPDATE METADATA SET VALUE = 500 WHERE VALUE IN (500, 600)",
-  );
-  assertEquals(result.command, "UPDATE");
-  assertEquals(result.rowCount, 2);
-
-  // parameterized update
-  result = await client.queryArray(
-    "UPDATE METADATA SET VALUE = 400 WHERE VALUE = $1",
-    [400],
-  );
-  assertEquals(result.command, "UPDATE");
-  assertEquals(result.rowCount, 1);
-});
-
-testClient("Long column alias is truncated", async function (generateClient) {
-  const client = await generateClient();
-
-  const { rows: result, warnings } = await client.queryObject(`
+Deno.test(
+  "nativeType",
+  withClient(async (client) => {
+    const result = await client.queryArray<[Date]>
+      `SELECT '2019-02-10T10:30:40.005+04:30'::TIMESTAMPTZ`;
+    const row = result.rows[0];
+
+    const expectedDate = Date.UTC(2019, 1, 10, 6, 0, 40, 5);
+
+    assertEquals(row[0].toUTCString(), new Date(expectedDate).toUTCString());
+  }),
+);
+
+Deno.test(
+  "Binary data is parsed correctly",
+  withClient(async (client) => {
+    const { rows: result_1 } = await client.queryArray
+      `SELECT E'foo\\\\000\\\\200\\\\\\\\\\\\377'::BYTEA`;
+
+    const expectedBytes = new Uint8Array([102, 111, 111, 0, 128, 92, 255]);
+
+    assertEquals(result_1[0][0], expectedBytes);
+
+    const { rows: result_2 } = await client.queryArray(
+      "SELECT $1::BYTEA",
+      [expectedBytes],
+    );
+    assertEquals(result_2[0][0], expectedBytes);
+  }),
+);
+
+Deno.test(
+  "Result object metadata",
+  withClient(async (client) => {
+    await client.queryArray`CREATE TEMP TABLE METADATA (VALUE INTEGER)`;
+    await client.queryArray
+      `INSERT INTO METADATA VALUES (100), (200), (300), (400), (500), (600)`;
+
+    let result;
+
+    // simple select
+    result = await client.queryArray(
+      "SELECT * FROM METADATA WHERE VALUE = 100",
+    );
+    assertEquals(result.command, "SELECT");
+    assertEquals(result.rowCount, 1);
+
+    // parameterized select
+    result = await client.queryArray(
+      "SELECT * FROM METADATA WHERE VALUE IN ($1, $2)",
+      [200, 300],
+    );
+    assertEquals(result.command, "SELECT");
+    assertEquals(result.rowCount, 2);
+
+    // simple delete
+    result = await client.queryArray(
+      "DELETE FROM METADATA WHERE VALUE IN (100, 200)",
+    );
+    assertEquals(result.command, "DELETE");
+    assertEquals(result.rowCount, 2);
+
+    // parameterized delete
+    result = await client.queryArray(
+      "DELETE FROM METADATA WHERE VALUE = $1",
+      [300],
+    );
+    assertEquals(result.command, "DELETE");
+    assertEquals(result.rowCount, 1);
+
+    // simple insert
+    result = await client.queryArray("INSERT INTO METADATA VALUES (4), (5)");
+    assertEquals(result.command, "INSERT");
+    assertEquals(result.rowCount, 2);
+
+    // parameterized insert
+    result = await client.queryArray("INSERT INTO METADATA VALUES ($1)", [3]);
+    assertEquals(result.command, "INSERT");
+    assertEquals(result.rowCount, 1);
+
+    // simple update
+    result = await client.queryArray(
+      "UPDATE METADATA SET VALUE = 500 WHERE VALUE IN (500, 600)",
+    );
+    assertEquals(result.command, "UPDATE");
+    assertEquals(result.rowCount, 2);
+
+    // parameterized update
+    result = await client.queryArray(
+      "UPDATE METADATA SET VALUE = 400 WHERE VALUE = $1",
+      [400],
+    );
+    assertEquals(result.command, "UPDATE");
+    assertEquals(result.rowCount, 1);
+  }),
+);
+
+Deno.test(
+  "Long column alias is truncated",
+  withClient(async (client) => {
+    const { rows: result, warnings } = await client.queryObject(`
     SELECT 1 AS "very_very_very_very_very_very_very_very_very_very_very_long_name"
   `);
 
-  assertEquals(result, [
-    { "very_very_very_very_very_very_very_very_very_very_very_long_nam": 1 },
-  ]);
-
-  assert(warnings[0].message.includes("will be truncated"));
-});
+    assertEquals(result, [
+      { "very_very_very_very_very_very_very_very_very_very_very_long_nam": 1 },
+    ]);
 
-testClient("Query array with template string", async function (generateClient) {
-  const client = await generateClient();
+    assert(warnings[0].message.includes("will be truncated"));
+  }),
+);
 
-  const [value_1, value_2] = ["A", "B"];
+Deno.test(
+  "Query array with template string",
+  withClient(async (client) => {
+    const [value_1, value_2] = ["A", "B"];
 
-  const { rows } = await client.queryArray<[string, string]>
-    `SELECT ${value_1}, ${value_2}`;
+    const { rows } = await client.queryArray<[string, string]>
+      `SELECT ${value_1}, ${value_2}`;
 
-  assertEquals(rows[0], [value_1, value_2]);
-});
+    assertEquals(rows[0], [value_1, value_2]);
+  }),
+);
 
-testClient(
+Deno.test(
   "Object query field names aren't transformed when camelcase is disabled",
-  async function (generateClient) {
-    const client = await generateClient();
+  withClient(async (client) => {
     const record = {
       pos_x: "100",
       pos_y: "200",
@@ -625,13 +659,12 @@ testClient(
     });
 
     assertEquals(result[0], record);
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Object query field names are transformed when camelcase is enabled",
-  async function (generateClient) {
-    const client = await generateClient();
+  withClient(async (client) => {
     const record = {
       posX: "100",
       posY: "200",
@@ -645,28 +678,24 @@ testClient(
     });
 
     assertEquals(result[0], record);
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Object query result is mapped to explicit fields",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     const result = await client.queryObject({
       text: "SELECT ARRAY[1, 2, 3], 'DATA'",
       fields: ["ID", "type"],
     });
 
     assertEquals(result.rows, [{ ID: [1, 2, 3], type: "DATA" }]);
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Object query explicit fields override camelcase",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     const record = { field_1: "A", field_2: "B", field_3: "C" };
 
     const { rows: result } = await client.queryObject({
@@ -677,14 +706,12 @@ testClient(
     });
 
     assertEquals(result[0], record);
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Object query throws if explicit fields aren't unique",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await assertRejects(
       () =>
         client.queryObject({
@@ -694,14 +721,12 @@ testClient(
       TypeError,
       "The fields provided for the query must be unique",
     );
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Object query throws if implicit fields aren't unique 1",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await assertRejects(
       () => client.queryObject`SELECT 1 AS "a", 2 AS A`,
       Error,
@@ -717,14 +742,12 @@ testClient(
       Error,
       `Field names "fieldX" are duplicated in the result of the query`,
     );
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Object query doesn't throw when explicit fields only have one letter",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     const { rows: result_1 } = await client.queryObject<{ a: number }>({
       text: "SELECT 1",
       fields: ["a"],
@@ -745,14 +768,12 @@ testClient(
       TypeError,
       "The fields provided for the query must contain only letters and underscores",
     );
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Object query throws if explicit fields aren't valid",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await assertRejects(
       async () => {
         await client.queryObject({
@@ -785,14 +806,12 @@ testClient(
       TypeError,
       "The fields provided for the query must contain only letters and underscores",
     );
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Object query throws if result columns don't match explicit fields",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     await assertRejects(
       async () => {
         await client.queryObject({
@@ -803,14 +822,12 @@ testClient(
       RangeError,
       "The fields provided for the query don't match the ones returned as a result (1 expected, 2 received)",
     );
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Object query throws when multiple query results don't have the same number of rows",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async function (client) {
     await assertRejects(
       () =>
         client.queryObject<{ result: number }>({
@@ -820,64 +837,89 @@ testClient(
       RangeError,
       "The result fields returned by the database don't match the defined structure of the result",
     );
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Query object with template string",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     const value = { x: "A", y: "B" };
 
     const { rows } = await client.queryObject<{ x: string; y: string }>
       `SELECT ${value.x} AS x, ${value.y} AS y`;
 
     assertEquals(rows[0], value);
-  },
+  }),
+);
+
+Deno.test(
+  "Transaction",
+  withClient(async (client) => {
+    const transaction_name = "x";
+    const transaction = client.createTransaction(transaction_name);
+
+    await transaction.begin();
+    assertEquals(
+      client.session.current_transaction,
+      transaction_name,
+      "Client is locked out during transaction",
+    );
+    await transaction.queryArray`CREATE TEMP TABLE TEST (X INTEGER)`;
+    const savepoint = await transaction.savepoint("table_creation");
+    await transaction.queryArray`INSERT INTO TEST (X) VALUES (1)`;
+    const query_1 = await transaction.queryObject<{ x: number }>
+      `SELECT X FROM TEST`;
+    assertEquals(
+      query_1.rows[0].x,
+      1,
+      "Operation was not executed inside transaction",
+    );
+    await transaction.rollback(savepoint);
+    const query_2 = await transaction.queryObject<{ x: number }>
+      `SELECT X FROM TEST`;
+    assertEquals(
+      query_2.rowCount,
+      0,
+      "Rollback was not succesful inside transaction",
+    );
+    await transaction.commit();
+    assertEquals(
+      client.session.current_transaction,
+      null,
+      "Client was not released after transaction",
+    );
+  }),
 );
 
-testClient("Transaction", async function (generateClient) {
-  const client = await generateClient();
-
-  const transaction_name = "x";
-  const transaction = client.createTransaction(transaction_name);
-
-  await transaction.begin();
-  assertEquals(
-    client.session.current_transaction,
-    transaction_name,
-    "Client is locked out during transaction",
-  );
-  await transaction.queryArray`CREATE TEMP TABLE TEST (X INTEGER)`;
-  const savepoint = await transaction.savepoint("table_creation");
-  await transaction.queryArray`INSERT INTO TEST (X) VALUES (1)`;
-  const query_1 = await transaction.queryObject<{ x: number }>
-    `SELECT X FROM TEST`;
-  assertEquals(
-    query_1.rows[0].x,
-    1,
-    "Operation was not executed inside transaction",
-  );
-  await transaction.rollback(savepoint);
-  const query_2 = await transaction.queryObject<{ x: number }>
-    `SELECT X FROM TEST`;
-  assertEquals(
-    query_2.rowCount,
-    0,
-    "Rollback was not succesful inside transaction",
-  );
-  await transaction.commit();
-  assertEquals(
-    client.session.current_transaction,
-    null,
-    "Client was not released after transaction",
-  );
-});
-
-testClient(
+Deno.test(
+  "Transaction implement queryArray and queryObject correctly",
+  withClient(async (client) => {
+    const transaction = client.createTransaction("test");
+
+    await transaction.begin();
+
+    const data = 1;
+    {
+      const { rows: result } = await transaction.queryArray
+        `SELECT ${data}::INTEGER`;
+      assertEquals(result[0], [data]);
+    }
+    {
+      const { rows: result } = await transaction.queryObject({
+        text: "SELECT $1::INTEGER",
+        args: [data],
+        fields: ["data"],
+      });
+      assertEquals(result[0], { data });
+    }
+
+    await transaction.commit();
+  }),
+);
+
+Deno.test(
   "Transaction with repeatable read isolation level",
-  async function (generateClient) {
+  withClientGenerator(async (generateClient) => {
     const client_1 = await generateClient();
 
     const client_2 = await generateClient();
@@ -923,12 +965,12 @@ testClient(
     );
 
     await client_1.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Transaction with serializable isolation level",
-  async function (generateClient) {
+  withClientGenerator(async (generateClient) => {
     const client_1 = await generateClient();
 
     const client_2 = await generateClient();
@@ -952,7 +994,7 @@ testClient(
 
     await assertRejects(
       () => transaction_rr.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 3`,
-      undefined,
+      TransactionError,
       undefined,
       "A serializable transaction should throw if the data read in the transaction has been modified externally",
     );
@@ -966,129 +1008,135 @@ testClient(
     );
 
     await client_1.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
-  },
+  }),
 );
 
-testClient("Transaction read only", async function (generateClient) {
-  const client = await generateClient();
-
-  await client.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
-  await client.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
-  const transaction = client.createTransaction("transactionReadOnly", {
-    read_only: true,
-  });
-  await transaction.begin();
-
-  await assertRejects(
-    () => transaction.queryArray`DELETE FROM FOR_TRANSACTION_TEST`,
-    undefined,
-    "cannot execute DELETE in a read-only transaction",
-  );
-
-  await client.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
-});
-
-testClient("Transaction snapshot", async function (generateClient) {
-  const client_1 = await generateClient();
-  const client_2 = await generateClient();
-
-  await client_1.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
-  await client_1.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
-  await client_1.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
-  const transaction_1 = client_1.createTransaction(
-    "transactionSnapshot1",
-    { isolation_level: "repeatable_read" },
-  );
-  await transaction_1.begin();
-
-  // This locks the current value of the test table
-  await transaction_1.queryObject<{ x: number }>
-    `SELECT X FROM FOR_TRANSACTION_TEST`;
-
-  // Modify data outside the transaction
-  await client_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
-
-  const { rows: query_1 } = await transaction_1.queryObject<{ x: number }>
-    `SELECT X FROM FOR_TRANSACTION_TEST`;
-  assertEquals(
-    query_1,
-    [{ x: 1 }],
-    "External changes shouldn't affect repeatable read transaction",
-  );
-
-  const snapshot = await transaction_1.getSnapshot();
-
-  const transaction_2 = client_2.createTransaction(
-    "transactionSnapshot2",
-    { isolation_level: "repeatable_read", snapshot },
-  );
-  await transaction_2.begin();
-
-  const { rows: query_2 } = await transaction_2.queryObject<{ x: number }>
-    `SELECT X FROM FOR_TRANSACTION_TEST`;
-  assertEquals(
-    query_2,
-    [{ x: 1 }],
-    "External changes shouldn't affect repeatable read transaction with previous snapshot",
-  );
-
-  await transaction_1.commit();
-  await transaction_2.commit();
-
-  await client_1.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
-});
-
-testClient("Transaction locks client", async function (generateClient) {
-  const client = await generateClient();
-
-  const transaction = client.createTransaction("x");
-
-  await transaction.begin();
-  await transaction.queryArray`SELECT 1`;
-  await assertRejects(
-    () => client.queryArray`SELECT 1`,
-    undefined,
-    "This connection is currently locked",
-    "The connection is not being locked by the transaction",
-  );
-  await transaction.commit();
-
-  await client.queryArray`SELECT 1`;
-  assertEquals(
-    client.session.current_transaction,
-    null,
-    "Client was not released after transaction",
-  );
-});
-
-testClient("Transaction commit chain", async function (generateClient) {
-  const client = await generateClient();
-
-  const name = "transactionCommitChain";
-  const transaction = client.createTransaction(name);
-
-  await transaction.begin();
-
-  await transaction.commit({ chain: true });
-  assertEquals(
-    client.session.current_transaction,
-    name,
-    "Client shouldn't have been released on chained commit",
-  );
-
-  await transaction.commit();
-  assertEquals(
-    client.session.current_transaction,
-    null,
-    "Client was not released after transaction ended",
-  );
-});
-
-testClient(
-  "Transaction lock is released on savepoint-less rollback",
-  async function (generateClient) {
-    const client = await generateClient();
+Deno.test(
+  "Transaction read only",
+  withClient(async (client) => {
+    await client.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
+    await client.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
+    const transaction = client.createTransaction("transactionReadOnly", {
+      read_only: true,
+    });
+    await transaction.begin();
+
+    await assertRejects(
+      () => transaction.queryArray`DELETE FROM FOR_TRANSACTION_TEST`,
+      TransactionError,
+      undefined,
+      "DELETE shouldn't be able to be used in a read-only transaction",
+    );
+
+    await client.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
+  }),
+);
+
+Deno.test(
+  "Transaction snapshot",
+  withClientGenerator(async (generateClient) => {
+    const client_1 = await generateClient();
+    const client_2 = await generateClient();
+
+    await client_1.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
+    await client_1.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
+    await client_1.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
+    const transaction_1 = client_1.createTransaction(
+      "transactionSnapshot1",
+      { isolation_level: "repeatable_read" },
+    );
+    await transaction_1.begin();
+
+    // This locks the current value of the test table
+    await transaction_1.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+
+    // Modify data outside the transaction
+    await client_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
+
+    const { rows: query_1 } = await transaction_1.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+    assertEquals(
+      query_1,
+      [{ x: 1 }],
+      "External changes shouldn't affect repeatable read transaction",
+    );
+
+    const snapshot = await transaction_1.getSnapshot();
+
+    const transaction_2 = client_2.createTransaction(
+      "transactionSnapshot2",
+      { isolation_level: "repeatable_read", snapshot },
+    );
+    await transaction_2.begin();
+
+    const { rows: query_2 } = await transaction_2.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+    assertEquals(
+      query_2,
+      [{ x: 1 }],
+      "External changes shouldn't affect repeatable read transaction with previous snapshot",
+    );
+
+    await transaction_1.commit();
+    await transaction_2.commit();
+
+    await client_1.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
+  }),
+);
+
+Deno.test(
+  "Transaction locks client",
+  withClient(async (client) => {
+    const name = "x";
+    const transaction = client.createTransaction(name);
+
+    await transaction.begin();
+    await transaction.queryArray`SELECT 1`;
+    await assertRejects(
+      () => client.queryArray`SELECT 1`,
+      Error,
+      `This connection is currently locked by the "${name}" transaction`,
+      "The connection is not being locked by the transaction",
+    );
+    await transaction.commit();
+
+    await client.queryArray`SELECT 1`;
+    assertEquals(
+      client.session.current_transaction,
+      null,
+      "Client was not released after transaction",
+    );
+  }),
+);
+
+Deno.test(
+  "Transaction commit chain",
+  withClient(async (client) => {
+    const name = "transactionCommitChain";
+    const transaction = client.createTransaction(name);
+
+    await transaction.begin();
 
+    await transaction.commit({ chain: true });
+    assertEquals(
+      client.session.current_transaction,
+      name,
+      "Client shouldn't have been released on chained commit",
+    );
+
+    await transaction.commit();
+    assertEquals(
+      client.session.current_transaction,
+      null,
+      "Client was not released after transaction ended",
+    );
+  }),
+);
+
+Deno.test(
+  "Transaction lock is released on savepoint-less rollback",
+  withClient(async (client) => {
     const name = "transactionLockIsReleasedOnRollback";
     const transaction = client.createTransaction(name);
 
@@ -1119,117 +1167,115 @@ testClient(
       null,
       "Client was not released after rollback",
     );
-  },
+  }),
 );
 
-testClient("Transaction rollback validations", async function (generateClient) {
-  const client = await generateClient();
-
-  const transaction = client.createTransaction(
-    "transactionRollbackValidations",
-  );
-  await transaction.begin();
+Deno.test(
+  "Transaction rollback validations",
+  withClient(async (client) => {
+    const transaction = client.createTransaction(
+      "transactionRollbackValidations",
+    );
+    await transaction.begin();
 
-  await assertRejects(
-    // @ts-ignore This is made to check the two properties aren't passed at once
-    () => transaction.rollback({ savepoint: "unexistent", chain: true }),
-    undefined,
-    "The chain option can't be used alongside a savepoint on a rollback operation",
-  );
+    await assertRejects(
+      // @ts-ignore This is made to check the two properties aren't passed at once
+      () => transaction.rollback({ savepoint: "unexistent", chain: true }),
+      Error,
+      "The chain option can't be used alongside a savepoint on a rollback operation",
+    );
 
-  await transaction.commit();
-});
+    await transaction.commit();
+  }),
+);
 
-testClient(
+Deno.test(
   "Transaction lock is released after unrecoverable error",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     const name = "transactionLockIsReleasedOnUnrecoverableError";
     const transaction = client.createTransaction(name);
 
     await transaction.begin();
     await assertRejects(
       () => transaction.queryArray`SELECT []`,
-      undefined,
-      `The transaction "${name}" has been aborted due to \`PostgresError:`,
+      TransactionError,
+      `The transaction "${name}" has been aborted`,
     );
     assertEquals(client.session.current_transaction, null);
 
     await transaction.begin();
     await assertRejects(
       () => transaction.queryObject`SELECT []`,
-      undefined,
-      `The transaction "${name}" has been aborted due to \`PostgresError:`,
+      TransactionError,
+      `The transaction "${name}" has been aborted`,
     );
     assertEquals(client.session.current_transaction, null);
-  },
+  }),
 );
 
-testClient("Transaction savepoints", async function (generateClient) {
-  const client = await generateClient();
-
-  const savepoint_name = "a1";
-  const transaction = client.createTransaction("x");
-
-  await transaction.begin();
-  await transaction.queryArray`CREATE TEMP TABLE X (Y INT)`;
-  await transaction.queryArray`INSERT INTO X VALUES (1)`;
-  const { rows: query_1 } = await transaction.queryObject<{ y: number }>
-    `SELECT Y FROM X`;
-  assertEquals(query_1, [{ y: 1 }]);
-
-  const savepoint = await transaction.savepoint(savepoint_name);
-
-  await transaction.queryArray`DELETE FROM X`;
-  const { rowCount: query_2 } = await transaction.queryObject<{ y: number }>
-    `SELECT Y FROM X`;
-  assertEquals(query_2, 0);
-
-  await savepoint.update();
-
-  await transaction.queryArray`INSERT INTO X VALUES (2)`;
-  const { rows: query_3 } = await transaction.queryObject<{ y: number }>
-    `SELECT Y FROM X`;
-  assertEquals(query_3, [{ y: 2 }]);
-
-  await transaction.rollback(savepoint);
-  const { rowCount: query_4 } = await transaction.queryObject<{ y: number }>
-    `SELECT Y FROM X`;
-  assertEquals(query_4, 0);
-
-  assertEquals(
-    savepoint.instances,
-    2,
-    "An incorrect number of instances were created for a transaction savepoint",
-  );
-  await savepoint.release();
-  assertEquals(
-    savepoint.instances,
-    1,
-    "The instance for the savepoint was not released",
-  );
-
-  // This checks that the savepoint can be called by name as well
-  await transaction.rollback(savepoint_name);
-  const { rows: query_5 } = await transaction.queryObject<{ y: number }>
-    `SELECT Y FROM X`;
-  assertEquals(query_5, [{ y: 1 }]);
-
-  await transaction.commit();
-});
-
-testClient(
-  "Transaction savepoint validations",
-  async function (generateClient) {
-    const client = await generateClient();
+Deno.test(
+  "Transaction savepoints",
+  withClient(async (client) => {
+    const savepoint_name = "a1";
+    const transaction = client.createTransaction("x");
+
+    await transaction.begin();
+    await transaction.queryArray`CREATE TEMP TABLE X (Y INT)`;
+    await transaction.queryArray`INSERT INTO X VALUES (1)`;
+    const { rows: query_1 } = await transaction.queryObject<{ y: number }>
+      `SELECT Y FROM X`;
+    assertEquals(query_1, [{ y: 1 }]);
+
+    const savepoint = await transaction.savepoint(savepoint_name);
 
+    await transaction.queryArray`DELETE FROM X`;
+    const { rowCount: query_2 } = await transaction.queryObject<{ y: number }>
+      `SELECT Y FROM X`;
+    assertEquals(query_2, 0);
+
+    await savepoint.update();
+
+    await transaction.queryArray`INSERT INTO X VALUES (2)`;
+    const { rows: query_3 } = await transaction.queryObject<{ y: number }>
+      `SELECT Y FROM X`;
+    assertEquals(query_3, [{ y: 2 }]);
+
+    await transaction.rollback(savepoint);
+    const { rowCount: query_4 } = await transaction.queryObject<{ y: number }>
+      `SELECT Y FROM X`;
+    assertEquals(query_4, 0);
+
+    assertEquals(
+      savepoint.instances,
+      2,
+      "An incorrect number of instances were created for a transaction savepoint",
+    );
+    await savepoint.release();
+    assertEquals(
+      savepoint.instances,
+      1,
+      "The instance for the savepoint was not released",
+    );
+
+    // This checks that the savepoint can be called by name as well
+    await transaction.rollback(savepoint_name);
+    const { rows: query_5 } = await transaction.queryObject<{ y: number }>
+      `SELECT Y FROM X`;
+    assertEquals(query_5, [{ y: 1 }]);
+
+    await transaction.commit();
+  }),
+);
+
+Deno.test(
+  "Transaction savepoint validations",
+  withClient(async (client) => {
     const transaction = client.createTransaction("x");
     await transaction.begin();
 
     await assertRejects(
       () => transaction.savepoint("1"),
-      undefined,
+      Error,
       "The savepoint name can't begin with a number",
     );
 
@@ -1238,13 +1284,13 @@ testClient(
         transaction.savepoint(
           "this_savepoint_is_going_to_be_longer_than_sixty_three_characters",
         ),
-      undefined,
+      Error,
       "The savepoint name can't be longer than 63 characters",
     );
 
     await assertRejects(
       () => transaction.savepoint("+"),
-      undefined,
+      Error,
       "The savepoint name can only contain alphanumeric characters",
     );
 
@@ -1262,31 +1308,29 @@ testClient(
 
     await assertRejects(
       () => savepoint.release(),
-      undefined,
+      Error,
       "This savepoint has no instances to release",
     );
 
     await assertRejects(
       () => transaction.rollback(savepoint),
-      undefined,
+      Error,
       `There are no savepoints of "abc1" left to rollback to`,
     );
 
     await assertRejects(
       () => transaction.rollback("UNEXISTENT"),
-      undefined,
+      Error,
       `There is no "unexistent" savepoint registered in this transaction`,
     );
 
     await transaction.commit();
-  },
+  }),
 );
 
-testClient(
+Deno.test(
   "Transaction operations throw if transaction has not been initialized",
-  async function (generateClient) {
-    const client = await generateClient();
-
+  withClient(async (client) => {
     const transaction_x = client.createTransaction("x");
 
     const transaction_y = client.createTransaction("y");
@@ -1295,7 +1339,7 @@ testClient(
 
     await assertRejects(
       () => transaction_y.begin(),
-      undefined,
+      Error,
       `This client already has an ongoing transaction "x"`,
     );
 
@@ -1303,45 +1347,45 @@ testClient(
     await transaction_y.begin();
     await assertRejects(
       () => transaction_y.begin(),
-      undefined,
+      Error,
       "This transaction is already open",
     );
 
     await transaction_y.commit();
     await assertRejects(
       () => transaction_y.commit(),
-      undefined,
+      Error,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
 
     await assertRejects(
       () => transaction_y.commit(),
-      undefined,
+      Error,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
 
     await assertRejects(
       () => transaction_y.queryArray`SELECT 1`,
-      undefined,
+      Error,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
 
     await assertRejects(
       () => transaction_y.queryObject`SELECT 1`,
-      undefined,
+      Error,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
 
     await assertRejects(
       () => transaction_y.rollback(),
-      undefined,
+      Error,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
 
     await assertRejects(
       () => transaction_y.savepoint("SOME"),
-      undefined,
+      Error,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
-  },
+  }),
 );
diff --git a/tests/test_deps.ts b/tests/test_deps.ts
index e0b91996..a1d955e0 100644
--- a/tests/test_deps.ts
+++ b/tests/test_deps.ts
@@ -6,5 +6,5 @@ export {
   assertObjectMatch,
   assertRejects,
   assertThrows,
-} from "https://deno.land/std@0.114.0/testing/asserts.ts";
-export * as streams from "https://deno.land/std@0.114.0/streams/conversion.ts";
+} from "https://deno.land/std@0.141.0/testing/asserts.ts";
+export * as streams from "https://deno.land/std@0.141.0/streams/conversion.ts";
diff --git a/tests/utils_test.ts b/tests/utils_test.ts
index 253edf71..d5e418d3 100644
--- a/tests/utils_test.ts
+++ b/tests/utils_test.ts
@@ -1,6 +1,6 @@
 import { assertEquals, assertThrows } from "./test_deps.ts";
 import { parseConnectionUri, Uri } from "../utils/utils.ts";
-import { DeferredAccessStack } from "../utils/deferred.ts";
+import { DeferredAccessStack, DeferredStack } from "../utils/deferred.ts";
 
 class LazilyInitializedObject {
   #initialized = false;
@@ -207,6 +207,48 @@ Deno.test("Defaults to connection string literal if decoding fails", async (cont
   });
 });
 
+Deno.test("DeferredStack", async () => {
+  const stack = new DeferredStack<undefined>(
+    10,
+    [],
+    () => new Promise((r) => r(undefined)),
+  );
+
+  assertEquals(stack.size, 0);
+  assertEquals(stack.available, 0);
+
+  const item = await stack.pop();
+  assertEquals(stack.size, 1);
+  assertEquals(stack.available, 0);
+
+  stack.push(item);
+  assertEquals(stack.size, 1);
+  assertEquals(stack.available, 1);
+});
+
+Deno.test("An empty DeferredStack awaits until an object is back in the stack", async () => {
+  const stack = new DeferredStack<undefined>(
+    1,
+    [],
+    () => new Promise((r) => r(undefined)),
+  );
+
+  const a = await stack.pop();
+  let fulfilled = false;
+  const b = stack.pop()
+    .then((e) => {
+      fulfilled = true;
+      return e;
+    });
+
+  await new Promise((r) => setTimeout(r, 100));
+  assertEquals(fulfilled, false);
+
+  stack.push(a);
+  assertEquals(a, await b);
+  assertEquals(fulfilled, true);
+});
+
 Deno.test("DeferredAccessStack", async () => {
   const stack_size = 10;
 
diff --git a/tests/workers/postgres_server.ts b/tests/workers/postgres_server.ts
index 9b5c90a8..54ebace3 100644
--- a/tests/workers/postgres_server.ts
+++ b/tests/workers/postgres_server.ts
@@ -1,6 +1,5 @@
 /// <reference no-default-lib="true" />
 /// <reference lib="deno.worker" />
-/// <reference lib="deno.unstable" />
 
 const server = Deno.listen({ port: 8080 });
 
diff --git a/utils/deferred.ts b/utils/deferred.ts
index 03277fb1..e6378c50 100644
--- a/utils/deferred.ts
+++ b/utils/deferred.ts
@@ -1,7 +1,7 @@
-import { Deferred, deferred } from "../deps.ts";
+import { type Deferred, deferred } from "../deps.ts";
 
 export class DeferredStack<T> {
-  #array: Array<T>;
+  #elements: Array<T>;
   #creator?: () => Promise<T>;
   #max_size: number;
   #queue: Array<Deferred<T>>;
@@ -12,35 +12,35 @@ export class DeferredStack<T> {
     ls?: Iterable<T>,
     creator?: () => Promise<T>,
   ) {
-    this.#array = ls ? [...ls] : [];
+    this.#elements = ls ? [...ls] : [];
     this.#creator = creator;
     this.#max_size = max || 10;
     this.#queue = [];
-    this.#size = this.#array.length;
+    this.#size = this.#elements.length;
   }
 
   get available(): number {
-    return this.#array.length;
+    return this.#elements.length;
   }
 
   async pop(): Promise<T> {
-    if (this.#array.length > 0) {
-      return this.#array.pop()!;
+    if (this.#elements.length > 0) {
+      return this.#elements.pop()!;
     } else if (this.#size < this.#max_size && this.#creator) {
       this.#size++;
       return await this.#creator();
     }
     const d = deferred<T>();
     this.#queue.push(d);
-    await d;
-    return this.#array.pop()!;
+    return await d;
   }
 
   push(value: T): void {
-    this.#array.push(value);
     if (this.#queue.length > 0) {
       const d = this.#queue.shift()!;
-      d.resolve();
+      d.resolve(value);
+    } else {
+      this.#elements.push(value);
     }
   }
 
@@ -62,7 +62,7 @@ export class DeferredAccessStack<T> {
   #elements: Array<T>;
   #initializeElement: (element: T) => Promise<void>;
   #checkElementInitialization: (element: T) => Promise<boolean> | boolean;
-  #queue: Array<Deferred<undefined>>;
+  #queue: Array<Deferred<T>>;
   #size: number;
 
   get available(): number {
@@ -112,10 +112,9 @@ export class DeferredAccessStack<T> {
     } else {
       // If there are not elements left in the stack, it will await the call until
       // at least one is restored and then return it
-      const d = deferred<undefined>();
+      const d = deferred<T>();
       this.#queue.push(d);
-      await d;
-      element = this.#elements.pop()!;
+      element = await d;
     }
 
     if (!await this.#checkElementInitialization(element)) {
@@ -125,12 +124,13 @@ export class DeferredAccessStack<T> {
   }
 
   push(value: T): void {
-    this.#elements.push(value);
     // If an element has been requested while the stack was empty, indicate
     // that an element has been restored
     if (this.#queue.length > 0) {
       const d = this.#queue.shift()!;
-      d.resolve();
+      d.resolve(value);
+    } else {
+      this.#elements.push(value);
     }
   }
 }
