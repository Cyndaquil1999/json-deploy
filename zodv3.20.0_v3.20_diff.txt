diff --git a/.github/workflows/test.yml b/.github/workflows/test.yml
index 8e7abab35..2f2744596 100644
--- a/.github/workflows/test.yml
+++ b/.github/workflows/test.yml
@@ -13,8 +13,8 @@ jobs:
     runs-on: ubuntu-latest
     strategy:
       matrix:
-        node: ["14"]
-        typescript: ["4.2", "4.3", "4.4", "4.5", "4.6"]
+        node: ["18"]
+        typescript: ["4.5", "4.6", "4.7", "4.8", "4.9"]
     name: Test with TypeScript ${{ matrix.typescript }} on Node ${{ matrix.node }}
     steps:
       - uses: actions/checkout@v2
@@ -59,7 +59,7 @@ jobs:
     runs-on: ubuntu-latest
     strategy:
       matrix:
-        node: ["14"]
+        node: ["18"]
     name: Lint on Node ${{ matrix.node }}
     steps:
       - uses: actions/checkout@v2
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 059ba0bf8..0ec91d3bc 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,7 +2,7 @@
 
 ### 3.10
 
-- New parser that allows parsing to continue after non-fatal errors have occured. This allows Zod to surface more errors to the user at once.
+- New parser that allows parsing to continue after non-fatal errors have occurred. This allows Zod to surface more errors to the user at once.
 
 ### 3.9
 
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 3e898c8c8..64dd15151 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,3 +1,5 @@
+# Contributing
+
 When it comes to open source, there are different ways you can contribute, all
 of which are valuable. Here's few guidelines that should help you as you prepare
 your contribution.
@@ -27,7 +29,7 @@ The following steps will get you setup to contribute changes to this repo:
 
 3. Run `yarn` to install dependencies.
 
-4. Start playing with the code! You can do some simple experimentation in `src/playground.ts` (see `yarn play` below) or start implementing a feature right away.
+4. Start playing with the code! You can do some simple experimentation in [`playground.ts`](playground.ts) (see `yarn play` below) or start implementing a feature right away.
 
 ### Commands
 
@@ -45,7 +47,7 @@ The following steps will get you setup to contribute changes to this repo:
 
 **`yarn play`**
 
-- executes `src/playground.ts`, watches for changes. useful for experimentation
+- executes [`playground.ts`](playground.ts), watches for changes. useful for experimentation
 
 ### Tests
 
diff --git a/README.md b/README.md
index 9b9f6e117..3bdcb7cac 100644
--- a/README.md
+++ b/README.md
@@ -89,8 +89,9 @@
   - [Cyclical data](#cyclical-objects)
 - [Promises](#promises)
 - [Instanceof](#instanceof)
-- [Function schemas](#function-schemas)
+- [Functions](#function-schemas)
 - [Preprocess](#preprocess)
+- [Custom](#custom)
 - [Schema methods](#schema-methods)
   - [.parse](#parse)
   - [.parseAsync](#parseasync)
@@ -134,7 +135,7 @@ Some other great aspects:
 - Zero dependencies
 - Works in Node.js and all modern browsers
 - Tiny: 8kb minified + zipped
-- Immutable: methods (i.e. `.optional()`) return a new instance
+- Immutable: methods (e.g. `.optional()`) return a new instance
 - Concise, chainable interface
 - Functional approach: [parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
 - Works with plain JavaScript too! You don't need to use TypeScript.
@@ -358,6 +359,8 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`zod-formik-adapter`](https://github.com/robertLichtnow/zod-formik-adapter): A community-maintained Formik adapter for Zod.
 - [`react-zorm`](https://github.com/esamattis/react-zorm): Standalone `<form>` generation and validation for React using Zod.
 - [`zodix`](https://github.com/rileytomasek/zodix): Zod utilities for FormData and URLSearchParams in Remix loaders and actions.
+- [`formik-validator-zod`](https://github.com/glazy/formik-validator-zod): Formik-compliant validator library that simplifies using Zod with Formik.
+- [`zod-i18n-map`](https://github.com/aiji42/zod-i18n): Useful for translating Zod error messages.
 
 #### Zod to X
 
@@ -392,12 +395,13 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`slonik`](https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference): Node.js Postgres client with strong Zod integration.
 - [`soly`](https://github.com/mdbetancourt/soly): Create CLI applications with zod.
 - [`zod-xlsx`](https://github.com/sidwebworks/zod-xlsx): A xlsx based resource validator using Zod schemas.
+- [`znv`](https://github.com/lostfictions/znv): Type-safe environment parsing and validation for Node.js with Zod schemas
 
 ## Installation
 
 ### Requirements
 
-- TypeScript 4.1+!
+- TypeScript 4.5+!
 - You must enable `strict` mode in your `tsconfig.json`. This is a best practice for all TypeScript projects.
 
   ```ts
@@ -560,6 +564,33 @@ z.string().endsWith(".com", { message: "Only .com domains allowed" });
 z.string().datetime({ message: "Invalid datetime string! Must be UTC." });
 ```
 
+## Coercion for primitives
+
+Zod now provides a more convenient way to coerce primitive values.
+
+```ts
+const schema = z.coerce.string();
+schema.parse("tuna"); // => "tuna"
+schema.parse(12); // => "12"
+schema.parse(true); // => "true"
+```
+
+During the parsing step, the input is passed through the `String()` function, which is a JavaScript built-in for coercing data into strings. Note that the returned schema is a `ZodString` instance so you can use all string methods.
+
+```ts
+z.coerce.string().email().min(5);
+```
+
+All primitive types support coercion.
+
+```ts
+z.coerce.string(); // String(input)
+z.coerce.number(); // Number(input)
+z.coerce.boolean(); // Boolean(input)
+z.coerce.bigint(); // BigInt(input)
+z.coerce.date(); // new Date(input)
+```
+
 ### Datetime validation
 
 The `z.string().datetime()` method defaults to UTC validation: no timezone offsets with arbitrary sub-second decimal precision.
@@ -1523,6 +1554,7 @@ const myFunction = z
   .function()
   .args(z.string(), z.number()) // accepts an arbitrary number of arguments
   .returns(z.boolean());
+
 type myFunction = z.infer<typeof myFunction>;
 // => (arg0: string, arg1: number)=>boolean
 ```
@@ -1564,8 +1596,9 @@ const myFunction = z
   .function()
   .args(z.string())
   .implement((arg) => {
-    return [arg.length]; //
+    return [arg.length];
   });
+
 myFunction; // (arg: string)=>number[]
 ```
 
@@ -1586,6 +1619,8 @@ myFunction.returnType();
 
 ## Preprocess
 
+> Zod now supports primitive coercion without the need for `.preprocess()`. See the [coercion docs](#coercion-for-primitives) for more information.
+
 Typically Zod operates under a "parse then transform" paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the [.transform docs](#transform).)
 
 But sometimes you want to apply some transform to the input _before_ parsing happens. A common use case: type coercion. Zod enables this with the `z.preprocess()`.
@@ -1596,6 +1631,22 @@ const castToString = z.preprocess((val) => String(val), z.string());
 
 This returns a `ZodEffects` instance. `ZodEffects` is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.
 
+## Custom schemas
+
+You can create a Zod schema for any TypeScript type by using `z.custom()`. This is useful for creating schemas for types that are not supported by Zod out of the box, such as template string literals.
+
+```ts
+const px = z.custom<`${number}px`>((val) => /^\d+px$/.test(val));
+px.parse("100px"); // pass
+px.parse("100vw"); // fail
+```
+
+If you don't provide a validation function, Zod will allow any value. This can be dangerous!
+
+```ts
+z.custom<{ arg: string }>(); // performs no validation
+```
+
 ## Schema methods
 
 All Zod schemas contain certain methods.
@@ -1610,6 +1661,7 @@ Given any Zod schema, you can call its `.parse` method to check `data` is valid.
 
 ```ts
 const stringSchema = z.string();
+
 stringSchema.parse("fish"); // => returns "fish"
 stringSchema.parse(12); // throws Error('Non-string type: number');
 ```
@@ -1713,7 +1765,7 @@ type RefineParams = {
 For advanced cases, the second argument can also be a function that returns `RefineParams`/
 
 ```ts
-z.string().refine(
+const longString = z.string().refine(
   (val) => val.length > 10,
   (val) => ({ message: `${val} is not more than 10 characters` })
 );
@@ -1730,8 +1782,9 @@ const passwordForm = z
   .refine((data) => data.password === data.confirm, {
     message: "Passwords don't match",
     path: ["confirm"], // path of error
-  })
-  .parse({ password: "asdf", confirm: "qwer" });
+  });
+
+passwordForm.parse({ password: "asdf", confirm: "qwer" });
 ```
 
 Because you provided a `path` parameter, the resulting error will be:
@@ -1771,7 +1824,6 @@ z.string()
 
 <!-- Note that the `path` is set to `["confirm"]` , so you can easily display this error underneath the "Confirm password" textbox.
 
-
 ```ts
 const allForms = z.object({ passwordForm }).parse({
   passwordForm: {
@@ -1848,12 +1900,40 @@ const schema = z.number().superRefine((val, ctx) => {
 });
 ```
 
+#### Type refinements
+
+If you provide a [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) to `.refine()` or `superRefine()`, the resulting type will be narrowed down to your predicate's type. This is useful if you are mixing multiple chained refinements and transformations:
+
+```ts
+const schema = z
+  .object({
+    first: z.string(),
+    second: z.number(),
+  })
+  .nullable()
+  .superRefine((arg, ctx): arg is { first: string; second: number } => {
+    if (!arg) {
+      ctx.addIssue({
+        code: z.ZodIssueCode.custom, // customize your issue
+        message: "object should exist",
+      });
+      return false;
+    }
+    return true;
+  })
+  // here, TS knows that arg is not null
+  .refine((arg) => arg.first === "bob", "`first` is not `bob`!");
+```
+
+> ⚠️ You must **still** call `ctx.addIssue()` if using `superRefine()` with a type predicate function. Otherwise the refinement won't be validated.
+
 ### `.transform`
 
 To transform data after parsing, use the `transform` method.
 
 ```ts
 const stringToNumber = z.string().transform((val) => val.length);
+
 stringToNumber.parse("string"); // => 6
 ```
 
@@ -1900,7 +1980,7 @@ const Strings = z.string().transform((val, ctx) => {
 Transforms and refinements can be interleaved. These will be executed in the order they are declared.
 
 ```ts
-z.string()
+const nameToGreeting = z.string()
   .transform((val) => val.toUpperCase())
   .refine((val) => val.length > 15)
   .transform((val) => `Hello ${val}`)
@@ -2011,7 +2091,7 @@ z.string().optional().nullable();
 A convenience method that returns an array schema for the given type:
 
 ```ts
-const nullableString = z.string().array(); // string[]
+const stringArray = z.string().array(); // string[]
 
 // equivalent to
 z.array(z.string());
@@ -2033,7 +2113,7 @@ z.promise(z.string());
 A convenience method for union types.
 
 ```ts
-z.string().or(z.number()); // string | number
+const stringOrNumber = z.string().or(z.number()); // string | number
 
 // equivalent to
 z.union([z.string(), z.number()]);
@@ -2044,7 +2124,7 @@ z.union([z.string(), z.number()]);
 A convenience method for creating intersection types.
 
 ```ts
-z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }
+const nameAndAge = z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }
 
 // equivalent to
 z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));
@@ -2124,7 +2204,7 @@ type inferred = z.infer<typeof stringToNumber>; // number
 
 ### Writing generic functions
 
-When attempting to write a functions that accepts a Zod schemas as an input, it's common to try something like this:
+When attempting to write a function that accepts a Zod schema as an input, it's common to try something like this:
 
 ```ts
 function makeSchemaOptional<T>(schema: z.ZodType<T>) {
@@ -2139,7 +2219,7 @@ const arg = makeSchemaOptional(z.string());
 arg.unwrap();
 ```
 
-A better approach is for the generate parameter to refer to _the schema as a whole_.
+A better approach is for the generic parameter to refer to _the schema as a whole_.
 
 ```ts
 function makeSchemaOptional<T extends z.ZodTypeAny>(schema: T) {
diff --git a/README_ZH.md b/README_ZH.md
index 81a60cc9d..8ad320bad 100644
--- a/README_ZH.md
+++ b/README_ZH.md
@@ -318,6 +318,7 @@ npm install zod
 - [`zod-fast-check`](https://github.com/DavidTimms/zod-fast-check): 从 Zod 模式中生成 `fast-check` 的任意数据。
 - [`zod-endpoints`](https://github.com/flock-community/zod-endpoints): 约定优先的严格类型的端点与 Zod。兼容 OpenAPI。
 - [`express-zod-api`](https://github.com/RobinTail/express-zod-api): 用 I/O 模式验证和自定义中间件构建基于 Express 的 API 服务
+- [`zod-i18n-map`](https://github.com/aiji42/zod-i18n): 有助于翻译zod错误信息。
 
 # 基本用法
 
diff --git a/deno/lib/README.md b/deno/lib/README.md
index cd623cafa..3bdcb7cac 100644
--- a/deno/lib/README.md
+++ b/deno/lib/README.md
@@ -89,8 +89,9 @@
   - [Cyclical data](#cyclical-objects)
 - [Promises](#promises)
 - [Instanceof](#instanceof)
-- [Function schemas](#function-schemas)
+- [Functions](#function-schemas)
 - [Preprocess](#preprocess)
+- [Custom](#custom)
 - [Schema methods](#schema-methods)
   - [.parse](#parse)
   - [.parseAsync](#parseasync)
@@ -134,7 +135,7 @@ Some other great aspects:
 - Zero dependencies
 - Works in Node.js and all modern browsers
 - Tiny: 8kb minified + zipped
-- Immutable: methods (i.e. `.optional()`) return a new instance
+- Immutable: methods (e.g. `.optional()`) return a new instance
 - Concise, chainable interface
 - Functional approach: [parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
 - Works with plain JavaScript too! You don't need to use TypeScript.
@@ -358,6 +359,8 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`zod-formik-adapter`](https://github.com/robertLichtnow/zod-formik-adapter): A community-maintained Formik adapter for Zod.
 - [`react-zorm`](https://github.com/esamattis/react-zorm): Standalone `<form>` generation and validation for React using Zod.
 - [`zodix`](https://github.com/rileytomasek/zodix): Zod utilities for FormData and URLSearchParams in Remix loaders and actions.
+- [`formik-validator-zod`](https://github.com/glazy/formik-validator-zod): Formik-compliant validator library that simplifies using Zod with Formik.
+- [`zod-i18n-map`](https://github.com/aiji42/zod-i18n): Useful for translating Zod error messages.
 
 #### Zod to X
 
@@ -392,12 +395,13 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`slonik`](https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference): Node.js Postgres client with strong Zod integration.
 - [`soly`](https://github.com/mdbetancourt/soly): Create CLI applications with zod.
 - [`zod-xlsx`](https://github.com/sidwebworks/zod-xlsx): A xlsx based resource validator using Zod schemas.
+- [`znv`](https://github.com/lostfictions/znv): Type-safe environment parsing and validation for Node.js with Zod schemas
 
 ## Installation
 
 ### Requirements
 
-- TypeScript 4.1+!
+- TypeScript 4.5+!
 - You must enable `strict` mode in your `tsconfig.json`. This is a best practice for all TypeScript projects.
 
   ```ts
@@ -560,6 +564,33 @@ z.string().endsWith(".com", { message: "Only .com domains allowed" });
 z.string().datetime({ message: "Invalid datetime string! Must be UTC." });
 ```
 
+## Coercion for primitives
+
+Zod now provides a more convenient way to coerce primitive values.
+
+```ts
+const schema = z.coerce.string();
+schema.parse("tuna"); // => "tuna"
+schema.parse(12); // => "12"
+schema.parse(true); // => "true"
+```
+
+During the parsing step, the input is passed through the `String()` function, which is a JavaScript built-in for coercing data into strings. Note that the returned schema is a `ZodString` instance so you can use all string methods.
+
+```ts
+z.coerce.string().email().min(5);
+```
+
+All primitive types support coercion.
+
+```ts
+z.coerce.string(); // String(input)
+z.coerce.number(); // Number(input)
+z.coerce.boolean(); // Boolean(input)
+z.coerce.bigint(); // BigInt(input)
+z.coerce.date(); // new Date(input)
+```
+
 ### Datetime validation
 
 The `z.string().datetime()` method defaults to UTC validation: no timezone offsets with arbitrary sub-second decimal precision.
@@ -1234,7 +1265,7 @@ type MyUnion =
   | { status: "failed"; error: Error };
 ```
 
-Such unions can be represented with the `z.discriminatedUnion` method. This enables faster evaluation, because Zod can check the _discriminator key_ (`status` in the example above) ot determine which schema should be used to parse the input. This makes parsing more efficient and lets Zod provide report friendlier errors.
+Such unions can be represented with the `z.discriminatedUnion` method. This enables faster evaluation, because Zod can check the _discriminator key_ (`status` in the example above) to determine which schema should be used to parse the input. This makes parsing more efficient and lets Zod report friendlier errors.
 
 With the basic union method the input is tested against each of the provided "options", and in the case of invalidity, issues for all the "options" are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the "options", testing against it, and showing only the issues related to this "option".
 
@@ -1523,6 +1554,7 @@ const myFunction = z
   .function()
   .args(z.string(), z.number()) // accepts an arbitrary number of arguments
   .returns(z.boolean());
+
 type myFunction = z.infer<typeof myFunction>;
 // => (arg0: string, arg1: number)=>boolean
 ```
@@ -1564,8 +1596,9 @@ const myFunction = z
   .function()
   .args(z.string())
   .implement((arg) => {
-    return [arg.length]; //
+    return [arg.length];
   });
+
 myFunction; // (arg: string)=>number[]
 ```
 
@@ -1586,6 +1619,8 @@ myFunction.returnType();
 
 ## Preprocess
 
+> Zod now supports primitive coercion without the need for `.preprocess()`. See the [coercion docs](#coercion-for-primitives) for more information.
+
 Typically Zod operates under a "parse then transform" paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the [.transform docs](#transform).)
 
 But sometimes you want to apply some transform to the input _before_ parsing happens. A common use case: type coercion. Zod enables this with the `z.preprocess()`.
@@ -1596,6 +1631,22 @@ const castToString = z.preprocess((val) => String(val), z.string());
 
 This returns a `ZodEffects` instance. `ZodEffects` is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.
 
+## Custom schemas
+
+You can create a Zod schema for any TypeScript type by using `z.custom()`. This is useful for creating schemas for types that are not supported by Zod out of the box, such as template string literals.
+
+```ts
+const px = z.custom<`${number}px`>((val) => /^\d+px$/.test(val));
+px.parse("100px"); // pass
+px.parse("100vw"); // fail
+```
+
+If you don't provide a validation function, Zod will allow any value. This can be dangerous!
+
+```ts
+z.custom<{ arg: string }>(); // performs no validation
+```
+
 ## Schema methods
 
 All Zod schemas contain certain methods.
@@ -1610,6 +1661,7 @@ Given any Zod schema, you can call its `.parse` method to check `data` is valid.
 
 ```ts
 const stringSchema = z.string();
+
 stringSchema.parse("fish"); // => returns "fish"
 stringSchema.parse(12); // throws Error('Non-string type: number');
 ```
@@ -1713,7 +1765,7 @@ type RefineParams = {
 For advanced cases, the second argument can also be a function that returns `RefineParams`/
 
 ```ts
-z.string().refine(
+const longString = z.string().refine(
   (val) => val.length > 10,
   (val) => ({ message: `${val} is not more than 10 characters` })
 );
@@ -1730,8 +1782,9 @@ const passwordForm = z
   .refine((data) => data.password === data.confirm, {
     message: "Passwords don't match",
     path: ["confirm"], // path of error
-  })
-  .parse({ password: "asdf", confirm: "qwer" });
+  });
+
+passwordForm.parse({ password: "asdf", confirm: "qwer" });
 ```
 
 Because you provided a `path` parameter, the resulting error will be:
@@ -1771,7 +1824,6 @@ z.string()
 
 <!-- Note that the `path` is set to `["confirm"]` , so you can easily display this error underneath the "Confirm password" textbox.
 
-
 ```ts
 const allForms = z.object({ passwordForm }).parse({
   passwordForm: {
@@ -1848,12 +1900,40 @@ const schema = z.number().superRefine((val, ctx) => {
 });
 ```
 
+#### Type refinements
+
+If you provide a [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) to `.refine()` or `superRefine()`, the resulting type will be narrowed down to your predicate's type. This is useful if you are mixing multiple chained refinements and transformations:
+
+```ts
+const schema = z
+  .object({
+    first: z.string(),
+    second: z.number(),
+  })
+  .nullable()
+  .superRefine((arg, ctx): arg is { first: string; second: number } => {
+    if (!arg) {
+      ctx.addIssue({
+        code: z.ZodIssueCode.custom, // customize your issue
+        message: "object should exist",
+      });
+      return false;
+    }
+    return true;
+  })
+  // here, TS knows that arg is not null
+  .refine((arg) => arg.first === "bob", "`first` is not `bob`!");
+```
+
+> ⚠️ You must **still** call `ctx.addIssue()` if using `superRefine()` with a type predicate function. Otherwise the refinement won't be validated.
+
 ### `.transform`
 
 To transform data after parsing, use the `transform` method.
 
 ```ts
 const stringToNumber = z.string().transform((val) => val.length);
+
 stringToNumber.parse("string"); // => 6
 ```
 
@@ -1900,7 +1980,7 @@ const Strings = z.string().transform((val, ctx) => {
 Transforms and refinements can be interleaved. These will be executed in the order they are declared.
 
 ```ts
-z.string()
+const nameToGreeting = z.string()
   .transform((val) => val.toUpperCase())
   .refine((val) => val.length > 15)
   .transform((val) => `Hello ${val}`)
@@ -2011,7 +2091,7 @@ z.string().optional().nullable();
 A convenience method that returns an array schema for the given type:
 
 ```ts
-const nullableString = z.string().array(); // string[]
+const stringArray = z.string().array(); // string[]
 
 // equivalent to
 z.array(z.string());
@@ -2033,7 +2113,7 @@ z.promise(z.string());
 A convenience method for union types.
 
 ```ts
-z.string().or(z.number()); // string | number
+const stringOrNumber = z.string().or(z.number()); // string | number
 
 // equivalent to
 z.union([z.string(), z.number()]);
@@ -2044,7 +2124,7 @@ z.union([z.string(), z.number()]);
 A convenience method for creating intersection types.
 
 ```ts
-z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }
+const nameAndAge = z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }
 
 // equivalent to
 z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));
@@ -2124,7 +2204,7 @@ type inferred = z.infer<typeof stringToNumber>; // number
 
 ### Writing generic functions
 
-When attempting to write a functions that accepts a Zod schemas as an input, it's common to try something like this:
+When attempting to write a function that accepts a Zod schema as an input, it's common to try something like this:
 
 ```ts
 function makeSchemaOptional<T>(schema: z.ZodType<T>) {
@@ -2139,7 +2219,7 @@ const arg = makeSchemaOptional(z.string());
 arg.unwrap();
 ```
 
-A better approach is for the generate parameter to refer to _the schema as a whole_.
+A better approach is for the generic parameter to refer to _the schema as a whole_.
 
 ```ts
 function makeSchemaOptional<T extends z.ZodTypeAny>(schema: T) {
diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index 63b9af331..cf6f8b083 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -106,6 +106,7 @@ export interface ZodTooSmallIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.too_small;
   minimum: number;
   inclusive: boolean;
+  exact?: boolean;
   type: "array" | "string" | "number" | "set" | "date";
 }
 
@@ -113,6 +114,7 @@ export interface ZodTooBigIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.too_big;
   maximum: number;
   inclusive: boolean;
+  exact?: boolean;
   type: "array" | "string" | "number" | "set" | "date";
 }
 
diff --git a/deno/lib/__tests__/coerce.test.ts b/deno/lib/__tests__/coerce.test.ts
new file mode 100644
index 000000000..98072bb72
--- /dev/null
+++ b/deno/lib/__tests__/coerce.test.ts
@@ -0,0 +1,46 @@
+// @ts-ignore TS6133
+import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
+const test = Deno.test;
+
+import * as z from "../index.ts";
+
+test("string coercion", () => {
+  const schema = z.coerce.string();
+  expect(schema.parse("sup")).toEqual("sup");
+  expect(schema.parse(12)).toEqual("12");
+  expect(schema.parse(true)).toEqual("true");
+  expect(schema.parse(BigInt(15))).toEqual("15");
+});
+
+test("number coercion", () => {
+  const schema = z.coerce.number();
+  expect(schema.parse("12")).toEqual(12);
+  expect(schema.parse(12)).toEqual(12);
+  expect(schema.parse(true)).toEqual(1);
+  expect(schema.parse(BigInt(15))).toEqual(15);
+  expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);
+});
+
+test("boolean coercion", () => {
+  const schema = z.coerce.boolean();
+  expect(schema.parse("")).toEqual(false);
+  expect(schema.parse("12")).toEqual(true);
+  expect(schema.parse(0)).toEqual(false);
+  expect(schema.parse(12)).toEqual(true);
+  expect(schema.parse(true)).toEqual(true);
+});
+
+test("bigint coercion", () => {
+  const schema = z.coerce.bigint();
+  expect(schema.parse("5")).toEqual(BigInt(5));
+  expect(schema.parse(0)).toEqual(BigInt(0));
+  expect(schema.parse(BigInt(5))).toEqual(BigInt(5));
+  expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));
+});
+
+test("date coercion", () => {
+  const schema = z.coerce.date();
+  expect(schema.parse("5") instanceof Date).toEqual(true);
+  expect(schema.parse(0) instanceof Date).toEqual(true);
+  expect(schema.parse(new Date()) instanceof Date).toEqual(true);
+});
diff --git a/deno/lib/__tests__/instanceof.test.ts b/deno/lib/__tests__/instanceof.test.ts
index 93b501a84..2f1f9187c 100644
--- a/deno/lib/__tests__/instanceof.test.ts
+++ b/deno/lib/__tests__/instanceof.test.ts
@@ -15,11 +15,13 @@ test("instanceof", async () => {
 
   const TestSchema = z.instanceof(Test);
   const SubtestSchema = z.instanceof(Subtest);
+  const AbstractSchema = z.instanceof(AbstractBar);
   const BarSchema = z.instanceof(Bar);
 
   TestSchema.parse(new Test());
   TestSchema.parse(new Subtest());
   SubtestSchema.parse(new Subtest());
+  AbstractSchema.parse(new Bar("asdf"));
   const bar = BarSchema.parse(new Bar("asdf"));
   expect(bar.val).toEqual("asdf");
 
diff --git a/deno/lib/__tests__/object.test.ts b/deno/lib/__tests__/object.test.ts
index 200678dd3..99b81c95d 100644
--- a/deno/lib/__tests__/object.test.ts
+++ b/deno/lib/__tests__/object.test.ts
@@ -385,6 +385,7 @@ test("unknownkeys merging", () => {
   type mergedSchema = typeof mergedSchema;
   util.assertEqual<mergedSchema["_def"]["unknownKeys"], "strip">(true);
   expect(mergedSchema._def.unknownKeys).toEqual("strip");
+
   util.assertEqual<mergedSchema["_def"]["catchall"], z.ZodString>(true);
   expect(mergedSchema._def.catchall instanceof z.ZodString).toEqual(true);
 });
diff --git a/deno/lib/__tests__/refine.test.ts b/deno/lib/__tests__/refine.test.ts
index b0cee3a6b..07b380c14 100644
--- a/deno/lib/__tests__/refine.test.ts
+++ b/deno/lib/__tests__/refine.test.ts
@@ -135,6 +135,7 @@ test("superRefine", () => {
         maximum: 3,
         type: "array",
         inclusive: true,
+        exact: true,
         message: "Too many items 😡",
       });
     }
@@ -155,6 +156,64 @@ test("superRefine", () => {
   Strings.parse(["asfd", "qwer"]);
 });
 
+test("superRefine - type narrowing", () => {
+  type NarrowType = { type: string; age: number };
+  const schema = z
+    .object({
+      type: z.string(),
+      age: z.number(),
+    })
+    .nullable()
+    .superRefine((arg, ctx): arg is NarrowType => {
+      if (!arg) {
+        // still need to make a call to ctx.addIssue
+        ctx.addIssue({
+          code: z.ZodIssueCode.custom,
+          message: "cannot be null",
+          fatal: true,
+        });
+        return false;
+      }
+      return true;
+    });
+
+  util.assertEqual<z.infer<typeof schema>, NarrowType>(true);
+
+  expect(schema.safeParse({ type: "test", age: 0 }).success).toEqual(true);
+  expect(schema.safeParse(null).success).toEqual(false);
+});
+
+test("chained mixed refining types", () => {
+  type firstRefinement = { first: string; second: number; third: true };
+  type secondRefinement = { first: "bob"; second: number; third: true };
+  type thirdRefinement = { first: "bob"; second: 33; third: true };
+  const schema = z
+    .object({
+      first: z.string(),
+      second: z.number(),
+      third: z.boolean(),
+    })
+    .nullable()
+    .refine((arg): arg is firstRefinement => !!arg?.third)
+    .superRefine((arg, ctx): arg is secondRefinement => {
+      util.assertEqual<typeof arg, firstRefinement>(true);
+      if (arg.first !== "bob") {
+        ctx.addIssue({
+          code: z.ZodIssueCode.custom,
+          message: "`first` property must be `bob`",
+        });
+        return false;
+      }
+      return true;
+    })
+    .refine((arg): arg is thirdRefinement => {
+      util.assertEqual<typeof arg, secondRefinement>(true);
+      return arg.second === 33;
+    });
+
+  util.assertEqual<z.infer<typeof schema>, thirdRefinement>(true);
+});
+
 test("get inner type", () => {
   z.string()
     .refine(() => true)
diff --git a/deno/lib/__tests__/string.test.ts b/deno/lib/__tests__/string.test.ts
index 9b9de9f25..4d5d20529 100644
--- a/deno/lib/__tests__/string.test.ts
+++ b/deno/lib/__tests__/string.test.ts
@@ -38,6 +38,8 @@ test("email validations", () => {
   expect(() => email.parse("asdf")).toThrow();
   expect(() => email.parse("@lkjasdf.com")).toThrow();
   expect(() => email.parse("asdf@sdf.")).toThrow();
+  expect(() => email.parse("asdf@asdf.com-")).toThrow();
+  expect(() => email.parse("asdf@-asdf.com")).toThrow();
 });
 
 test("more email validations", () => {
@@ -48,6 +50,7 @@ test("more email validations", () => {
     `"🍺🕺🎉"@domain.com`,
     `poop@💩.la`,
     `"🌮"@i❤️tacos.ws`,
+    "sss--asd@i❤️tacos.ws",
   ];
   const email = z.string().email();
   for (const datum of data) {
diff --git a/deno/lib/__tests__/validations.test.ts b/deno/lib/__tests__/validations.test.ts
index 5c58c875e..7ebbaa3d1 100644
--- a/deno/lib/__tests__/validations.test.ts
+++ b/deno/lib/__tests__/validations.test.ts
@@ -24,6 +24,42 @@ test("array max", async () => {
   }
 });
 
+test("array length", async () => {
+  try {
+    await z.array(z.string()).length(2).parseAsync(["asdf", "asdf", "asdf"]);
+  } catch (err) {
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Array must contain exactly 2 element(s)"
+    );
+  }
+
+  try {
+    await z.array(z.string()).length(2).parseAsync(["asdf"]);
+  } catch (err) {
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Array must contain exactly 2 element(s)"
+    );
+  }
+});
+
+test("string length", async () => {
+  try {
+    await z.string().length(4).parseAsync("asd");
+  } catch (err) {
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "String must contain exactly 4 character(s)"
+    );
+  }
+
+  try {
+    await z.string().length(4).parseAsync("asdaa");
+  } catch (err) {
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "String must contain exactly 4 character(s)"
+    );
+  }
+});
+
 test("string min", async () => {
   try {
     await z.string().min(4).parseAsync("asd");
diff --git a/deno/lib/external.ts b/deno/lib/external.ts
index 42772455c..b2070f81c 100644
--- a/deno/lib/external.ts
+++ b/deno/lib/external.ts
@@ -1,6 +1,6 @@
 export * from "./errors.ts";
 export * from "./helpers/parseUtil.ts";
 export * from "./helpers/typeAliases.ts";
-export { getParsedType, ZodParsedType } from "./helpers/util.ts";
+export * from "./helpers/util.ts";
 export * from "./types.ts";
 export * from "./ZodError.ts";
diff --git a/deno/lib/locales/en.ts b/deno/lib/locales/en.ts
index 52685b003..348a84eeb 100644
--- a/deno/lib/locales/en.ts
+++ b/deno/lib/locales/en.ts
@@ -63,39 +63,55 @@ const errorMap: ZodErrorMap = (issue, _ctx) => {
     case ZodIssueCode.too_small:
       if (issue.type === "array")
         message = `Array must contain ${
-          issue.inclusive ? `at least` : `more than`
+          issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`
         } ${issue.minimum} element(s)`;
       else if (issue.type === "string")
         message = `String must contain ${
-          issue.inclusive ? `at least` : `over`
+          issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`
         } ${issue.minimum} character(s)`;
       else if (issue.type === "number")
-        message = `Number must be greater than ${
-          issue.inclusive ? `or equal to ` : ``
+        message = `Number must be ${
+          issue.exact
+            ? `exactly equal to `
+            : issue.inclusive
+            ? `greater than or equal to `
+            : `greater than `
         }${issue.minimum}`;
       else if (issue.type === "date")
-        message = `Date must be greater than ${
-          issue.inclusive ? `or equal to ` : ``
+        message = `Date must be ${
+          issue.exact
+            ? `exactly equal to `
+            : issue.inclusive
+            ? `greater than or equal to `
+            : `greater than `
         }${new Date(issue.minimum)}`;
       else message = "Invalid input";
       break;
     case ZodIssueCode.too_big:
       if (issue.type === "array")
         message = `Array must contain ${
-          issue.inclusive ? `at most` : `less than`
+          issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`
         } ${issue.maximum} element(s)`;
       else if (issue.type === "string")
         message = `String must contain ${
-          issue.inclusive ? `at most` : `under`
+          issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`
         } ${issue.maximum} character(s)`;
       else if (issue.type === "number")
-        message = `Number must be less than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${issue.maximum}`;
+        message = `Number must be ${
+          issue.exact
+            ? `exactly`
+            : issue.inclusive
+            ? `less than or equal to`
+            : `less than`
+        } ${issue.maximum}`;
       else if (issue.type === "date")
-        message = `Date must be smaller than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${new Date(issue.maximum)}`;
+        message = `Date must be ${
+          issue.exact
+            ? `exactly`
+            : issue.inclusive
+            ? `smaller than or equal to`
+            : `smaller than`
+        } ${new Date(issue.maximum)}`;
       else message = "Invalid input";
       break;
     case ZodIssueCode.custom:
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index e7eb1f304..ee260df65 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -201,7 +201,6 @@ export abstract class ZodType<
 
   _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {
     const result = this._parse(input);
-
     return Promise.resolve(result);
   }
 
@@ -350,7 +349,18 @@ export abstract class ZodType<
       effect: { type: "refinement", refinement },
     });
   }
-  superRefine = this._refinement;
+
+  superRefine<RefinedOutput extends Output>(
+    refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput
+  ): ZodEffects<this, RefinedOutput, Input>;
+  superRefine(
+    refinement: (arg: Output, ctx: RefinementCtx) => void
+  ): ZodEffects<this, Output, Input>;
+  superRefine(
+    refinement: (arg: Output, ctx: RefinementCtx) => unknown
+  ): ZodEffects<this, Output, Input> {
+    return this._refinement(refinement);
+  }
 
   constructor(def: Def) {
     this._def = def;
@@ -475,6 +485,7 @@ export abstract class ZodType<
 export type ZodStringCheck =
   | { kind: "min"; value: number; message?: string }
   | { kind: "max"; value: number; message?: string }
+  | { kind: "length"; value: number; message?: string }
   | { kind: "email"; message?: string }
   | { kind: "url"; message?: string }
   | { kind: "uuid"; message?: string }
@@ -493,6 +504,7 @@ export type ZodStringCheck =
 export interface ZodStringDef extends ZodTypeDef {
   checks: ZodStringCheck[];
   typeName: ZodFirstPartyTypeKind.ZodString;
+  coerce: boolean;
 }
 
 const cuidRegex = /^c[^\s-]{8,}$/i;
@@ -503,7 +515,7 @@ const uuidRegex =
 // const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
 // eslint-disable-next-line
 const emailRegex =
-  /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
+  /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{2,})(?<!-)$/i;
 
 // interface IsDateStringOptions extends StringDateOptions {
 /**
@@ -547,6 +559,9 @@ const datetimeRegex = (args: { precision: number | null; offset: boolean }) => {
 
 export class ZodString extends ZodType<string, ZodStringDef> {
   _parse(input: ParseInput): ParseReturnType<string> {
+    if (this._def.coerce) {
+      input.data = String(input.data);
+    }
     const parsedType = this._getType(input);
 
     if (parsedType !== ZodParsedType.string) {
@@ -575,6 +590,7 @@ export class ZodString extends ZodType<string, ZodStringDef> {
             minimum: check.value,
             type: "string",
             inclusive: true,
+            exact: false,
             message: check.message,
           });
           status.dirty();
@@ -587,10 +603,37 @@ export class ZodString extends ZodType<string, ZodStringDef> {
             maximum: check.value,
             type: "string",
             inclusive: true,
+            exact: false,
             message: check.message,
           });
           status.dirty();
         }
+      } else if (check.kind === "length") {
+        const tooBig = input.data.length > check.value;
+        const tooSmall = input.data.length < check.value;
+        if (tooBig || tooSmall) {
+          ctx = this._getOrReturnCtx(input, ctx);
+          if (tooBig) {
+            addIssueToContext(ctx, {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: "string",
+              inclusive: true,
+              exact: true,
+              message: check.message,
+            });
+          } else if (tooSmall) {
+            addIssueToContext(ctx, {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: "string",
+              inclusive: true,
+              exact: true,
+              message: check.message,
+            });
+          }
+          status.dirty();
+        }
       } else if (check.kind === "email") {
         if (!emailRegex.test(input.data)) {
           ctx = this._getOrReturnCtx(input, ctx);
@@ -784,7 +827,11 @@ export class ZodString extends ZodType<string, ZodStringDef> {
   }
 
   length(len: number, message?: errorUtil.ErrMessage) {
-    return this.min(len, message).max(len, message);
+    return this._addCheck({
+      kind: "length",
+      value: len,
+      ...errorUtil.errToObj(message),
+    });
   }
 
   /**
@@ -836,10 +883,11 @@ export class ZodString extends ZodType<string, ZodStringDef> {
     return max;
   }
 
-  static create = (params?: RawCreateParams): ZodString => {
+  static create = (params?: RawCreateParams & { coerce?: true }): ZodString => {
     return new ZodString({
       checks: [],
       typeName: ZodFirstPartyTypeKind.ZodString,
+      coerce: params?.coerce ?? false,
       ...processCreateParams(params),
     });
   };
@@ -872,10 +920,14 @@ function floatSafeRemainder(val: number, step: number) {
 export interface ZodNumberDef extends ZodTypeDef {
   checks: ZodNumberCheck[];
   typeName: ZodFirstPartyTypeKind.ZodNumber;
+  coerce: boolean;
 }
 
 export class ZodNumber extends ZodType<number, ZodNumberDef> {
   _parse(input: ParseInput): ParseReturnType<number> {
+    if (this._def.coerce) {
+      input.data = Number(input.data);
+    }
     const parsedType = this._getType(input);
     if (parsedType !== ZodParsedType.number) {
       const ctx = this._getOrReturnCtx(input);
@@ -913,6 +965,7 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
             minimum: check.value,
             type: "number",
             inclusive: check.inclusive,
+            exact: false,
             message: check.message,
           });
           status.dirty();
@@ -928,6 +981,7 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
             maximum: check.value,
             type: "number",
             inclusive: check.inclusive,
+            exact: false,
             message: check.message,
           });
           status.dirty();
@@ -959,10 +1013,13 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
     return { status: status.value, value: input.data };
   }
 
-  static create = (params?: RawCreateParams): ZodNumber => {
+  static create = (
+    params?: RawCreateParams & { coerce?: boolean }
+  ): ZodNumber => {
     return new ZodNumber({
       checks: [],
       typeName: ZodFirstPartyTypeKind.ZodNumber,
+      coerce: params?.coerce || false,
       ...processCreateParams(params),
     });
   };
@@ -1107,10 +1164,14 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
 
 export interface ZodBigIntDef extends ZodTypeDef {
   typeName: ZodFirstPartyTypeKind.ZodBigInt;
+  coerce: boolean;
 }
 
 export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
   _parse(input: ParseInput): ParseReturnType<bigint> {
+    if (this._def.coerce) {
+      input.data = BigInt(input.data);
+    }
     const parsedType = this._getType(input);
     if (parsedType !== ZodParsedType.bigint) {
       const ctx = this._getOrReturnCtx(input);
@@ -1124,9 +1185,12 @@ export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
     return OK(input.data);
   }
 
-  static create = (params?: RawCreateParams): ZodBigInt => {
+  static create = (
+    params?: RawCreateParams & { coerce?: boolean }
+  ): ZodBigInt => {
     return new ZodBigInt({
       typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      coerce: params?.coerce ?? false,
       ...processCreateParams(params),
     });
   };
@@ -1141,11 +1205,16 @@ export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
 //////////////////////////////////////////
 export interface ZodBooleanDef extends ZodTypeDef {
   typeName: ZodFirstPartyTypeKind.ZodBoolean;
+  coerce: boolean;
 }
 
 export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
   _parse(input: ParseInput): ParseReturnType<boolean> {
+    if (this._def.coerce) {
+      input.data = Boolean(input.data);
+    }
     const parsedType = this._getType(input);
+
     if (parsedType !== ZodParsedType.boolean) {
       const ctx = this._getOrReturnCtx(input);
       addIssueToContext(ctx, {
@@ -1158,9 +1227,12 @@ export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
     return OK(input.data);
   }
 
-  static create = (params?: RawCreateParams): ZodBoolean => {
+  static create = (
+    params?: RawCreateParams & { coerce?: boolean }
+  ): ZodBoolean => {
     return new ZodBoolean({
       typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      coerce: params?.coerce || false,
       ...processCreateParams(params),
     });
   };
@@ -1178,11 +1250,15 @@ export type ZodDateCheck =
   | { kind: "max"; value: number; message?: string };
 export interface ZodDateDef extends ZodTypeDef {
   checks: ZodDateCheck[];
+  coerce: boolean;
   typeName: ZodFirstPartyTypeKind.ZodDate;
 }
 
 export class ZodDate extends ZodType<Date, ZodDateDef> {
   _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    if (this._def.coerce) {
+      input.data = new Date(input.data);
+    }
     const parsedType = this._getType(input);
 
     if (parsedType !== ZodParsedType.date) {
@@ -1214,6 +1290,7 @@ export class ZodDate extends ZodType<Date, ZodDateDef> {
             code: ZodIssueCode.too_small,
             message: check.message,
             inclusive: true,
+            exact: false,
             minimum: check.value,
             type: "date",
           });
@@ -1226,6 +1303,7 @@ export class ZodDate extends ZodType<Date, ZodDateDef> {
             code: ZodIssueCode.too_big,
             message: check.message,
             inclusive: true,
+            exact: false,
             maximum: check.value,
             type: "date",
           });
@@ -1287,9 +1365,12 @@ export class ZodDate extends ZodType<Date, ZodDateDef> {
     return max != null ? new Date(max) : null;
   }
 
-  static create = (params?: RawCreateParams): ZodDate => {
+  static create = (
+    params?: RawCreateParams & { coerce?: boolean }
+  ): ZodDate => {
     return new ZodDate({
       checks: [],
+      coerce: params?.coerce || false,
       typeName: ZodFirstPartyTypeKind.ZodDate,
       ...processCreateParams(params),
     });
@@ -1524,6 +1605,7 @@ export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny>
   extends ZodTypeDef {
   type: T;
   typeName: ZodFirstPartyTypeKind.ZodArray;
+  exactLength: { value: number; message?: string } | null;
   minLength: { value: number; message?: string } | null;
   maxLength: { value: number; message?: string } | null;
 }
@@ -1560,6 +1642,23 @@ export class ZodArray<
       return INVALID;
     }
 
+    if (def.exactLength !== null) {
+      const tooBig = ctx.data.length > def.exactLength.value;
+      const tooSmall = ctx.data.length < def.exactLength.value;
+      if (tooBig || tooSmall) {
+        addIssueToContext(ctx, {
+          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
+          minimum: (tooSmall ? def.exactLength.value : undefined) as number,
+          maximum: (tooBig ? def.exactLength.value : undefined) as number,
+          type: "array",
+          inclusive: true,
+          exact: true,
+          message: def.exactLength.message,
+        });
+        status.dirty();
+      }
+    }
+
     if (def.minLength !== null) {
       if (ctx.data.length < def.minLength.value) {
         addIssueToContext(ctx, {
@@ -1567,6 +1666,7 @@ export class ZodArray<
           minimum: def.minLength.value,
           type: "array",
           inclusive: true,
+          exact: false,
           message: def.minLength.message,
         });
         status.dirty();
@@ -1580,6 +1680,7 @@ export class ZodArray<
           maximum: def.maxLength.value,
           type: "array",
           inclusive: true,
+          exact: false,
           message: def.maxLength.message,
         });
         status.dirty();
@@ -1626,7 +1727,10 @@ export class ZodArray<
   }
 
   length(len: number, message?: errorUtil.ErrMessage): this {
-    return this.min(len, message).max(len, message) as any;
+    return new ZodArray({
+      ...this._def,
+      exactLength: { value: len, message: errorUtil.toString(message) },
+    }) as any;
   }
 
   nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone"> {
@@ -1641,6 +1745,7 @@ export class ZodArray<
       type: schema,
       minLength: null,
       maxLength: null,
+      exactLength: null,
       typeName: ZodFirstPartyTypeKind.ZodArray,
       ...processCreateParams(params),
     });
@@ -1656,7 +1761,6 @@ export type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, "atleastone">;
 //////////                     //////////
 /////////////////////////////////////////
 /////////////////////////////////////////
-
 export namespace objectUtil {
   export type MergeShapes<U extends ZodRawShape, V extends ZodRawShape> = {
     [k in Exclude<keyof U, keyof V>]: U[k];
@@ -2703,6 +2807,7 @@ export class ZodTuple<
         code: ZodIssueCode.too_small,
         minimum: this._def.items.length,
         inclusive: true,
+        exact: false,
         type: "array",
       });
 
@@ -2716,6 +2821,7 @@ export class ZodTuple<
         code: ZodIssueCode.too_big,
         maximum: this._def.items.length,
         inclusive: true,
+        exact: false,
         type: "array",
       });
       status.dirty();
@@ -3016,6 +3122,7 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
           minimum: def.minSize.value,
           type: "set",
           inclusive: true,
+          exact: false,
           message: def.minSize.message,
         });
         status.dirty();
@@ -3029,6 +3136,7 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
           maximum: def.maxSize.value,
           type: "set",
           inclusive: true,
+          exact: false,
           message: def.maxSize.message,
         });
         status.dirty();
@@ -4250,12 +4358,12 @@ export type ZodFirstPartySchemaTypes =
   | ZodPipeline<any, any>;
 
 // new approach that works for abstract classes
-// but required TS 4.4+
-// abstract class Class {
-//   constructor(..._: any[]) {}
-// }
-// const instanceOfType = <T extends typeof Class>(
-const instanceOfType = <T extends new (...args: any[]) => any>(
+// but requires TS 4.4+
+abstract class Class {
+  constructor(..._: any[]) {}
+}
+const instanceOfType = <T extends typeof Class>(
+  // const instanceOfType = <T extends new (...args: any[]) => any>(
   cls: T,
   params: Parameters<ZodTypeAny["refine"]>[1] = {
     message: `Input not instance of ${cls.name}`,
@@ -4300,6 +4408,19 @@ const ostring = () => stringType().optional();
 const onumber = () => numberType().optional();
 const oboolean = () => booleanType().optional();
 
+export const coerce = {
+  string: ((arg) =>
+    ZodString.create({ ...arg, coerce: true })) as typeof ZodString["create"],
+  number: ((arg) =>
+    ZodNumber.create({ ...arg, coerce: true })) as typeof ZodNumber["create"],
+  boolean: ((arg) =>
+    ZodBoolean.create({ ...arg, coerce: true })) as typeof ZodBoolean["create"],
+  bigint: ((arg) =>
+    ZodBigInt.create({ ...arg, coerce: true })) as typeof ZodBigInt["create"],
+  date: ((arg) =>
+    ZodDate.create({ ...arg, coerce: true })) as typeof ZodDate["create"],
+};
+
 export {
   anyType as any,
   arrayType as array,
diff --git a/package.json b/package.json
index 8a00f46b5..9058dc63b 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.19.1",
+  "version": "3.20.0",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./index.d.ts",
@@ -46,8 +46,8 @@
   "scripts": {
     "prettier:check": "prettier --check src/**/*.ts deno/lib/**/*.ts --no-error-on-unmatched-pattern",
     "prettier:fix": "prettier --write src/**/*.ts deno/lib/**/*.ts --ignore-unknown --no-error-on-unmatched-pattern",
-    "lint:check": "eslint --ext .ts ./src",
-    "lint:fix": "eslint --fix --ext .ts ./src",
+    "lint:check": "eslint --cache --ext .ts ./src",
+    "lint:fix": "eslint --cache --fix --ext .ts ./src",
     "check": "yarn lint:check && yarn prettier:check",
     "fix": "yarn lint:fix && yarn prettier:fix",
     "clean": "rm -rf lib/* deno/lib/*",
@@ -92,7 +92,7 @@
     "ts-node": "^10.9.1",
     "tslib": "^2.3.1",
     "tsx": "^3.8.0",
-    "typescript": "4.2"
+    "typescript": "4.5"
   },
   "lint-staged": {
     "src/*.ts": [
diff --git a/playground.ts b/playground.ts
index 72615f672..a512dcd78 100644
--- a/playground.ts
+++ b/playground.ts
@@ -1,16 +1 @@
-import { z, ZodFormattedError } from "./src";
-
-enum Color {
-  RED,
-  GREEN,
-  BLUE,
-}
-
-console.log(Color[1]);
-async function main() {
-  const schema = z.string().catch("1234");
-  const result = await schema.parse(1234);
-
-  console.log(Object.keys(Color));
-}
-main();
+import { z } from "./src";
diff --git a/src/ZodError.ts b/src/ZodError.ts
index d823e2b0d..2a0770274 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -106,6 +106,7 @@ export interface ZodTooSmallIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.too_small;
   minimum: number;
   inclusive: boolean;
+  exact?: boolean;
   type: "array" | "string" | "number" | "set" | "date";
 }
 
@@ -113,6 +114,7 @@ export interface ZodTooBigIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.too_big;
   maximum: number;
   inclusive: boolean;
+  exact?: boolean;
   type: "array" | "string" | "number" | "set" | "date";
 }
 
diff --git a/src/__tests__/coerce.test.ts b/src/__tests__/coerce.test.ts
new file mode 100644
index 000000000..b83699e51
--- /dev/null
+++ b/src/__tests__/coerce.test.ts
@@ -0,0 +1,45 @@
+// @ts-ignore TS6133
+import { expect, test } from "@jest/globals";
+
+import * as z from "../index";
+
+test("string coercion", () => {
+  const schema = z.coerce.string();
+  expect(schema.parse("sup")).toEqual("sup");
+  expect(schema.parse(12)).toEqual("12");
+  expect(schema.parse(true)).toEqual("true");
+  expect(schema.parse(BigInt(15))).toEqual("15");
+});
+
+test("number coercion", () => {
+  const schema = z.coerce.number();
+  expect(schema.parse("12")).toEqual(12);
+  expect(schema.parse(12)).toEqual(12);
+  expect(schema.parse(true)).toEqual(1);
+  expect(schema.parse(BigInt(15))).toEqual(15);
+  expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);
+});
+
+test("boolean coercion", () => {
+  const schema = z.coerce.boolean();
+  expect(schema.parse("")).toEqual(false);
+  expect(schema.parse("12")).toEqual(true);
+  expect(schema.parse(0)).toEqual(false);
+  expect(schema.parse(12)).toEqual(true);
+  expect(schema.parse(true)).toEqual(true);
+});
+
+test("bigint coercion", () => {
+  const schema = z.coerce.bigint();
+  expect(schema.parse("5")).toEqual(BigInt(5));
+  expect(schema.parse(0)).toEqual(BigInt(0));
+  expect(schema.parse(BigInt(5))).toEqual(BigInt(5));
+  expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));
+});
+
+test("date coercion", () => {
+  const schema = z.coerce.date();
+  expect(schema.parse("5") instanceof Date).toEqual(true);
+  expect(schema.parse(0) instanceof Date).toEqual(true);
+  expect(schema.parse(new Date()) instanceof Date).toEqual(true);
+});
diff --git a/src/__tests__/instanceof.test.ts b/src/__tests__/instanceof.test.ts
index 0839322bb..4175f487f 100644
--- a/src/__tests__/instanceof.test.ts
+++ b/src/__tests__/instanceof.test.ts
@@ -14,11 +14,13 @@ test("instanceof", async () => {
 
   const TestSchema = z.instanceof(Test);
   const SubtestSchema = z.instanceof(Subtest);
+  const AbstractSchema = z.instanceof(AbstractBar);
   const BarSchema = z.instanceof(Bar);
 
   TestSchema.parse(new Test());
   TestSchema.parse(new Subtest());
   SubtestSchema.parse(new Subtest());
+  AbstractSchema.parse(new Bar("asdf"));
   const bar = BarSchema.parse(new Bar("asdf"));
   expect(bar.val).toEqual("asdf");
 
diff --git a/src/__tests__/object.test.ts b/src/__tests__/object.test.ts
index c4d2fe1f8..e1e7fc532 100644
--- a/src/__tests__/object.test.ts
+++ b/src/__tests__/object.test.ts
@@ -384,6 +384,7 @@ test("unknownkeys merging", () => {
   type mergedSchema = typeof mergedSchema;
   util.assertEqual<mergedSchema["_def"]["unknownKeys"], "strip">(true);
   expect(mergedSchema._def.unknownKeys).toEqual("strip");
+
   util.assertEqual<mergedSchema["_def"]["catchall"], z.ZodString>(true);
   expect(mergedSchema._def.catchall instanceof z.ZodString).toEqual(true);
 });
diff --git a/src/__tests__/refine.test.ts b/src/__tests__/refine.test.ts
index 1fd8022e1..98036c73f 100644
--- a/src/__tests__/refine.test.ts
+++ b/src/__tests__/refine.test.ts
@@ -134,6 +134,7 @@ test("superRefine", () => {
         maximum: 3,
         type: "array",
         inclusive: true,
+        exact: true,
         message: "Too many items 😡",
       });
     }
@@ -154,6 +155,64 @@ test("superRefine", () => {
   Strings.parse(["asfd", "qwer"]);
 });
 
+test("superRefine - type narrowing", () => {
+  type NarrowType = { type: string; age: number };
+  const schema = z
+    .object({
+      type: z.string(),
+      age: z.number(),
+    })
+    .nullable()
+    .superRefine((arg, ctx): arg is NarrowType => {
+      if (!arg) {
+        // still need to make a call to ctx.addIssue
+        ctx.addIssue({
+          code: z.ZodIssueCode.custom,
+          message: "cannot be null",
+          fatal: true,
+        });
+        return false;
+      }
+      return true;
+    });
+
+  util.assertEqual<z.infer<typeof schema>, NarrowType>(true);
+
+  expect(schema.safeParse({ type: "test", age: 0 }).success).toEqual(true);
+  expect(schema.safeParse(null).success).toEqual(false);
+});
+
+test("chained mixed refining types", () => {
+  type firstRefinement = { first: string; second: number; third: true };
+  type secondRefinement = { first: "bob"; second: number; third: true };
+  type thirdRefinement = { first: "bob"; second: 33; third: true };
+  const schema = z
+    .object({
+      first: z.string(),
+      second: z.number(),
+      third: z.boolean(),
+    })
+    .nullable()
+    .refine((arg): arg is firstRefinement => !!arg?.third)
+    .superRefine((arg, ctx): arg is secondRefinement => {
+      util.assertEqual<typeof arg, firstRefinement>(true);
+      if (arg.first !== "bob") {
+        ctx.addIssue({
+          code: z.ZodIssueCode.custom,
+          message: "`first` property must be `bob`",
+        });
+        return false;
+      }
+      return true;
+    })
+    .refine((arg): arg is thirdRefinement => {
+      util.assertEqual<typeof arg, secondRefinement>(true);
+      return arg.second === 33;
+    });
+
+  util.assertEqual<z.infer<typeof schema>, thirdRefinement>(true);
+});
+
 test("get inner type", () => {
   z.string()
     .refine(() => true)
diff --git a/src/__tests__/string.test.ts b/src/__tests__/string.test.ts
index 2be5d114b..425250595 100644
--- a/src/__tests__/string.test.ts
+++ b/src/__tests__/string.test.ts
@@ -37,6 +37,8 @@ test("email validations", () => {
   expect(() => email.parse("asdf")).toThrow();
   expect(() => email.parse("@lkjasdf.com")).toThrow();
   expect(() => email.parse("asdf@sdf.")).toThrow();
+  expect(() => email.parse("asdf@asdf.com-")).toThrow();
+  expect(() => email.parse("asdf@-asdf.com")).toThrow();
 });
 
 test("more email validations", () => {
@@ -47,6 +49,7 @@ test("more email validations", () => {
     `"🍺🕺🎉"@domain.com`,
     `poop@💩.la`,
     `"🌮"@i❤️tacos.ws`,
+    "sss--asd@i❤️tacos.ws",
   ];
   const email = z.string().email();
   for (const datum of data) {
diff --git a/src/__tests__/validations.test.ts b/src/__tests__/validations.test.ts
index 3da3466fc..6ab351b20 100644
--- a/src/__tests__/validations.test.ts
+++ b/src/__tests__/validations.test.ts
@@ -23,6 +23,42 @@ test("array max", async () => {
   }
 });
 
+test("array length", async () => {
+  try {
+    await z.array(z.string()).length(2).parseAsync(["asdf", "asdf", "asdf"]);
+  } catch (err) {
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Array must contain exactly 2 element(s)"
+    );
+  }
+
+  try {
+    await z.array(z.string()).length(2).parseAsync(["asdf"]);
+  } catch (err) {
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Array must contain exactly 2 element(s)"
+    );
+  }
+});
+
+test("string length", async () => {
+  try {
+    await z.string().length(4).parseAsync("asd");
+  } catch (err) {
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "String must contain exactly 4 character(s)"
+    );
+  }
+
+  try {
+    await z.string().length(4).parseAsync("asdaa");
+  } catch (err) {
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "String must contain exactly 4 character(s)"
+    );
+  }
+});
+
 test("string min", async () => {
   try {
     await z.string().min(4).parseAsync("asd");
diff --git a/src/external.ts b/src/external.ts
index a2d8aeda2..002e17d9c 100644
--- a/src/external.ts
+++ b/src/external.ts
@@ -1,6 +1,6 @@
 export * from "./errors";
 export * from "./helpers/parseUtil";
 export * from "./helpers/typeAliases";
-export { getParsedType, ZodParsedType } from "./helpers/util";
+export * from "./helpers/util";
 export * from "./types";
 export * from "./ZodError";
diff --git a/src/locales/en.ts b/src/locales/en.ts
index 98977aa63..6515f9849 100644
--- a/src/locales/en.ts
+++ b/src/locales/en.ts
@@ -63,39 +63,55 @@ const errorMap: ZodErrorMap = (issue, _ctx) => {
     case ZodIssueCode.too_small:
       if (issue.type === "array")
         message = `Array must contain ${
-          issue.inclusive ? `at least` : `more than`
+          issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`
         } ${issue.minimum} element(s)`;
       else if (issue.type === "string")
         message = `String must contain ${
-          issue.inclusive ? `at least` : `over`
+          issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`
         } ${issue.minimum} character(s)`;
       else if (issue.type === "number")
-        message = `Number must be greater than ${
-          issue.inclusive ? `or equal to ` : ``
+        message = `Number must be ${
+          issue.exact
+            ? `exactly equal to `
+            : issue.inclusive
+            ? `greater than or equal to `
+            : `greater than `
         }${issue.minimum}`;
       else if (issue.type === "date")
-        message = `Date must be greater than ${
-          issue.inclusive ? `or equal to ` : ``
+        message = `Date must be ${
+          issue.exact
+            ? `exactly equal to `
+            : issue.inclusive
+            ? `greater than or equal to `
+            : `greater than `
         }${new Date(issue.minimum)}`;
       else message = "Invalid input";
       break;
     case ZodIssueCode.too_big:
       if (issue.type === "array")
         message = `Array must contain ${
-          issue.inclusive ? `at most` : `less than`
+          issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`
         } ${issue.maximum} element(s)`;
       else if (issue.type === "string")
         message = `String must contain ${
-          issue.inclusive ? `at most` : `under`
+          issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`
         } ${issue.maximum} character(s)`;
       else if (issue.type === "number")
-        message = `Number must be less than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${issue.maximum}`;
+        message = `Number must be ${
+          issue.exact
+            ? `exactly`
+            : issue.inclusive
+            ? `less than or equal to`
+            : `less than`
+        } ${issue.maximum}`;
       else if (issue.type === "date")
-        message = `Date must be smaller than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${new Date(issue.maximum)}`;
+        message = `Date must be ${
+          issue.exact
+            ? `exactly`
+            : issue.inclusive
+            ? `smaller than or equal to`
+            : `smaller than`
+        } ${new Date(issue.maximum)}`;
       else message = "Invalid input";
       break;
     case ZodIssueCode.custom:
diff --git a/src/types.ts b/src/types.ts
index 90f32f4c7..15c0b7d72 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -201,7 +201,6 @@ export abstract class ZodType<
 
   _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {
     const result = this._parse(input);
-
     return Promise.resolve(result);
   }
 
@@ -350,7 +349,18 @@ export abstract class ZodType<
       effect: { type: "refinement", refinement },
     });
   }
-  superRefine = this._refinement;
+
+  superRefine<RefinedOutput extends Output>(
+    refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput
+  ): ZodEffects<this, RefinedOutput, Input>;
+  superRefine(
+    refinement: (arg: Output, ctx: RefinementCtx) => void
+  ): ZodEffects<this, Output, Input>;
+  superRefine(
+    refinement: (arg: Output, ctx: RefinementCtx) => unknown
+  ): ZodEffects<this, Output, Input> {
+    return this._refinement(refinement);
+  }
 
   constructor(def: Def) {
     this._def = def;
@@ -475,6 +485,7 @@ export abstract class ZodType<
 export type ZodStringCheck =
   | { kind: "min"; value: number; message?: string }
   | { kind: "max"; value: number; message?: string }
+  | { kind: "length"; value: number; message?: string }
   | { kind: "email"; message?: string }
   | { kind: "url"; message?: string }
   | { kind: "uuid"; message?: string }
@@ -493,6 +504,7 @@ export type ZodStringCheck =
 export interface ZodStringDef extends ZodTypeDef {
   checks: ZodStringCheck[];
   typeName: ZodFirstPartyTypeKind.ZodString;
+  coerce: boolean;
 }
 
 const cuidRegex = /^c[^\s-]{8,}$/i;
@@ -503,7 +515,7 @@ const uuidRegex =
 // const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
 // eslint-disable-next-line
 const emailRegex =
-  /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
+  /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{2,})(?<!-)$/i;
 
 // interface IsDateStringOptions extends StringDateOptions {
 /**
@@ -547,6 +559,9 @@ const datetimeRegex = (args: { precision: number | null; offset: boolean }) => {
 
 export class ZodString extends ZodType<string, ZodStringDef> {
   _parse(input: ParseInput): ParseReturnType<string> {
+    if (this._def.coerce) {
+      input.data = String(input.data);
+    }
     const parsedType = this._getType(input);
 
     if (parsedType !== ZodParsedType.string) {
@@ -575,6 +590,7 @@ export class ZodString extends ZodType<string, ZodStringDef> {
             minimum: check.value,
             type: "string",
             inclusive: true,
+            exact: false,
             message: check.message,
           });
           status.dirty();
@@ -587,10 +603,37 @@ export class ZodString extends ZodType<string, ZodStringDef> {
             maximum: check.value,
             type: "string",
             inclusive: true,
+            exact: false,
             message: check.message,
           });
           status.dirty();
         }
+      } else if (check.kind === "length") {
+        const tooBig = input.data.length > check.value;
+        const tooSmall = input.data.length < check.value;
+        if (tooBig || tooSmall) {
+          ctx = this._getOrReturnCtx(input, ctx);
+          if (tooBig) {
+            addIssueToContext(ctx, {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: "string",
+              inclusive: true,
+              exact: true,
+              message: check.message,
+            });
+          } else if (tooSmall) {
+            addIssueToContext(ctx, {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: "string",
+              inclusive: true,
+              exact: true,
+              message: check.message,
+            });
+          }
+          status.dirty();
+        }
       } else if (check.kind === "email") {
         if (!emailRegex.test(input.data)) {
           ctx = this._getOrReturnCtx(input, ctx);
@@ -784,7 +827,11 @@ export class ZodString extends ZodType<string, ZodStringDef> {
   }
 
   length(len: number, message?: errorUtil.ErrMessage) {
-    return this.min(len, message).max(len, message);
+    return this._addCheck({
+      kind: "length",
+      value: len,
+      ...errorUtil.errToObj(message),
+    });
   }
 
   /**
@@ -836,10 +883,11 @@ export class ZodString extends ZodType<string, ZodStringDef> {
     return max;
   }
 
-  static create = (params?: RawCreateParams): ZodString => {
+  static create = (params?: RawCreateParams & { coerce?: true }): ZodString => {
     return new ZodString({
       checks: [],
       typeName: ZodFirstPartyTypeKind.ZodString,
+      coerce: params?.coerce ?? false,
       ...processCreateParams(params),
     });
   };
@@ -872,10 +920,14 @@ function floatSafeRemainder(val: number, step: number) {
 export interface ZodNumberDef extends ZodTypeDef {
   checks: ZodNumberCheck[];
   typeName: ZodFirstPartyTypeKind.ZodNumber;
+  coerce: boolean;
 }
 
 export class ZodNumber extends ZodType<number, ZodNumberDef> {
   _parse(input: ParseInput): ParseReturnType<number> {
+    if (this._def.coerce) {
+      input.data = Number(input.data);
+    }
     const parsedType = this._getType(input);
     if (parsedType !== ZodParsedType.number) {
       const ctx = this._getOrReturnCtx(input);
@@ -913,6 +965,7 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
             minimum: check.value,
             type: "number",
             inclusive: check.inclusive,
+            exact: false,
             message: check.message,
           });
           status.dirty();
@@ -928,6 +981,7 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
             maximum: check.value,
             type: "number",
             inclusive: check.inclusive,
+            exact: false,
             message: check.message,
           });
           status.dirty();
@@ -959,10 +1013,13 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
     return { status: status.value, value: input.data };
   }
 
-  static create = (params?: RawCreateParams): ZodNumber => {
+  static create = (
+    params?: RawCreateParams & { coerce?: boolean }
+  ): ZodNumber => {
     return new ZodNumber({
       checks: [],
       typeName: ZodFirstPartyTypeKind.ZodNumber,
+      coerce: params?.coerce || false,
       ...processCreateParams(params),
     });
   };
@@ -1107,10 +1164,14 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
 
 export interface ZodBigIntDef extends ZodTypeDef {
   typeName: ZodFirstPartyTypeKind.ZodBigInt;
+  coerce: boolean;
 }
 
 export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
   _parse(input: ParseInput): ParseReturnType<bigint> {
+    if (this._def.coerce) {
+      input.data = BigInt(input.data);
+    }
     const parsedType = this._getType(input);
     if (parsedType !== ZodParsedType.bigint) {
       const ctx = this._getOrReturnCtx(input);
@@ -1124,9 +1185,12 @@ export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
     return OK(input.data);
   }
 
-  static create = (params?: RawCreateParams): ZodBigInt => {
+  static create = (
+    params?: RawCreateParams & { coerce?: boolean }
+  ): ZodBigInt => {
     return new ZodBigInt({
       typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      coerce: params?.coerce ?? false,
       ...processCreateParams(params),
     });
   };
@@ -1141,11 +1205,16 @@ export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
 //////////////////////////////////////////
 export interface ZodBooleanDef extends ZodTypeDef {
   typeName: ZodFirstPartyTypeKind.ZodBoolean;
+  coerce: boolean;
 }
 
 export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
   _parse(input: ParseInput): ParseReturnType<boolean> {
+    if (this._def.coerce) {
+      input.data = Boolean(input.data);
+    }
     const parsedType = this._getType(input);
+
     if (parsedType !== ZodParsedType.boolean) {
       const ctx = this._getOrReturnCtx(input);
       addIssueToContext(ctx, {
@@ -1158,9 +1227,12 @@ export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
     return OK(input.data);
   }
 
-  static create = (params?: RawCreateParams): ZodBoolean => {
+  static create = (
+    params?: RawCreateParams & { coerce?: boolean }
+  ): ZodBoolean => {
     return new ZodBoolean({
       typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      coerce: params?.coerce || false,
       ...processCreateParams(params),
     });
   };
@@ -1178,11 +1250,15 @@ export type ZodDateCheck =
   | { kind: "max"; value: number; message?: string };
 export interface ZodDateDef extends ZodTypeDef {
   checks: ZodDateCheck[];
+  coerce: boolean;
   typeName: ZodFirstPartyTypeKind.ZodDate;
 }
 
 export class ZodDate extends ZodType<Date, ZodDateDef> {
   _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    if (this._def.coerce) {
+      input.data = new Date(input.data);
+    }
     const parsedType = this._getType(input);
 
     if (parsedType !== ZodParsedType.date) {
@@ -1214,6 +1290,7 @@ export class ZodDate extends ZodType<Date, ZodDateDef> {
             code: ZodIssueCode.too_small,
             message: check.message,
             inclusive: true,
+            exact: false,
             minimum: check.value,
             type: "date",
           });
@@ -1226,6 +1303,7 @@ export class ZodDate extends ZodType<Date, ZodDateDef> {
             code: ZodIssueCode.too_big,
             message: check.message,
             inclusive: true,
+            exact: false,
             maximum: check.value,
             type: "date",
           });
@@ -1287,9 +1365,12 @@ export class ZodDate extends ZodType<Date, ZodDateDef> {
     return max != null ? new Date(max) : null;
   }
 
-  static create = (params?: RawCreateParams): ZodDate => {
+  static create = (
+    params?: RawCreateParams & { coerce?: boolean }
+  ): ZodDate => {
     return new ZodDate({
       checks: [],
+      coerce: params?.coerce || false,
       typeName: ZodFirstPartyTypeKind.ZodDate,
       ...processCreateParams(params),
     });
@@ -1524,6 +1605,7 @@ export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny>
   extends ZodTypeDef {
   type: T;
   typeName: ZodFirstPartyTypeKind.ZodArray;
+  exactLength: { value: number; message?: string } | null;
   minLength: { value: number; message?: string } | null;
   maxLength: { value: number; message?: string } | null;
 }
@@ -1560,6 +1642,23 @@ export class ZodArray<
       return INVALID;
     }
 
+    if (def.exactLength !== null) {
+      const tooBig = ctx.data.length > def.exactLength.value;
+      const tooSmall = ctx.data.length < def.exactLength.value;
+      if (tooBig || tooSmall) {
+        addIssueToContext(ctx, {
+          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
+          minimum: (tooSmall ? def.exactLength.value : undefined) as number,
+          maximum: (tooBig ? def.exactLength.value : undefined) as number,
+          type: "array",
+          inclusive: true,
+          exact: true,
+          message: def.exactLength.message,
+        });
+        status.dirty();
+      }
+    }
+
     if (def.minLength !== null) {
       if (ctx.data.length < def.minLength.value) {
         addIssueToContext(ctx, {
@@ -1567,6 +1666,7 @@ export class ZodArray<
           minimum: def.minLength.value,
           type: "array",
           inclusive: true,
+          exact: false,
           message: def.minLength.message,
         });
         status.dirty();
@@ -1580,6 +1680,7 @@ export class ZodArray<
           maximum: def.maxLength.value,
           type: "array",
           inclusive: true,
+          exact: false,
           message: def.maxLength.message,
         });
         status.dirty();
@@ -1626,7 +1727,10 @@ export class ZodArray<
   }
 
   length(len: number, message?: errorUtil.ErrMessage): this {
-    return this.min(len, message).max(len, message) as any;
+    return new ZodArray({
+      ...this._def,
+      exactLength: { value: len, message: errorUtil.toString(message) },
+    }) as any;
   }
 
   nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone"> {
@@ -1641,6 +1745,7 @@ export class ZodArray<
       type: schema,
       minLength: null,
       maxLength: null,
+      exactLength: null,
       typeName: ZodFirstPartyTypeKind.ZodArray,
       ...processCreateParams(params),
     });
@@ -1656,7 +1761,6 @@ export type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, "atleastone">;
 //////////                     //////////
 /////////////////////////////////////////
 /////////////////////////////////////////
-
 export namespace objectUtil {
   export type MergeShapes<U extends ZodRawShape, V extends ZodRawShape> = {
     [k in Exclude<keyof U, keyof V>]: U[k];
@@ -2703,6 +2807,7 @@ export class ZodTuple<
         code: ZodIssueCode.too_small,
         minimum: this._def.items.length,
         inclusive: true,
+        exact: false,
         type: "array",
       });
 
@@ -2716,6 +2821,7 @@ export class ZodTuple<
         code: ZodIssueCode.too_big,
         maximum: this._def.items.length,
         inclusive: true,
+        exact: false,
         type: "array",
       });
       status.dirty();
@@ -3016,6 +3122,7 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
           minimum: def.minSize.value,
           type: "set",
           inclusive: true,
+          exact: false,
           message: def.minSize.message,
         });
         status.dirty();
@@ -3029,6 +3136,7 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
           maximum: def.maxSize.value,
           type: "set",
           inclusive: true,
+          exact: false,
           message: def.maxSize.message,
         });
         status.dirty();
@@ -4250,12 +4358,12 @@ export type ZodFirstPartySchemaTypes =
   | ZodPipeline<any, any>;
 
 // new approach that works for abstract classes
-// but required TS 4.4+
-// abstract class Class {
-//   constructor(..._: any[]) {}
-// }
-// const instanceOfType = <T extends typeof Class>(
-const instanceOfType = <T extends new (...args: any[]) => any>(
+// but requires TS 4.4+
+abstract class Class {
+  constructor(..._: any[]) {}
+}
+const instanceOfType = <T extends typeof Class>(
+  // const instanceOfType = <T extends new (...args: any[]) => any>(
   cls: T,
   params: Parameters<ZodTypeAny["refine"]>[1] = {
     message: `Input not instance of ${cls.name}`,
@@ -4300,6 +4408,19 @@ const ostring = () => stringType().optional();
 const onumber = () => numberType().optional();
 const oboolean = () => booleanType().optional();
 
+export const coerce = {
+  string: ((arg) =>
+    ZodString.create({ ...arg, coerce: true })) as typeof ZodString["create"],
+  number: ((arg) =>
+    ZodNumber.create({ ...arg, coerce: true })) as typeof ZodNumber["create"],
+  boolean: ((arg) =>
+    ZodBoolean.create({ ...arg, coerce: true })) as typeof ZodBoolean["create"],
+  bigint: ((arg) =>
+    ZodBigInt.create({ ...arg, coerce: true })) as typeof ZodBigInt["create"],
+  date: ((arg) =>
+    ZodDate.create({ ...arg, coerce: true })) as typeof ZodDate["create"],
+};
+
 export {
   anyType as any,
   arrayType as array,
diff --git a/yarn.lock b/yarn.lock
index d7e3c4b4f..3b49f0735 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -4781,10 +4781,10 @@ typedarray-to-buffer@^3.1.5:
   dependencies:
     is-typedarray "^1.0.0"
 
-typescript@4.2:
-  version "4.2.4"
-  resolved "https://registry.yarnpkg.com/typescript/-/typescript-4.2.4.tgz#8610b59747de028fda898a8aef0e103f156d0961"
-  integrity sha512-V+evlYHZnQkaz8TRBuxTA92yZBPotr5H+WhQ7bD3hZUndx5tGOa1fuCgeSjxAzM1RiN5IzvadIXTVefuuwZCRg==
+typescript@4.5:
+  version "4.5.5"
+  resolved "https://registry.yarnpkg.com/typescript/-/typescript-4.5.5.tgz#d8c953832d28924a9e3d37c73d729c846c5896f3"
+  integrity sha512-TCTIul70LyWe6IJWT8QSYeA54WQe8EjQFU4wY52Fasj5UKx88LNYKCgBEHcOMOrFF1rKGbD8v/xcNWVUq9SymA==
 
 uglify-js@^3.1.4:
   version "3.14.3"
