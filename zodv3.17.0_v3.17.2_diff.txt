diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index 91a96dbcb..dfbea6118 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -1,7 +1,6 @@
 import type { TypeOf, ZodType } from "./index.ts";
-import { ZodParsedType } from "./helpers/parseUtil.ts";
 import { Primitive } from "./helpers/typeAliases.ts";
-import { util } from "./helpers/util.ts";
+import { util, ZodParsedType } from "./helpers/util.ts";
 
 type allKeys<T> = T extends any ? keyof T : never;
 
diff --git a/deno/lib/__tests__/error.test.ts b/deno/lib/__tests__/error.test.ts
index 60eb09f73..38140c12d 100644
--- a/deno/lib/__tests__/error.test.ts
+++ b/deno/lib/__tests__/error.test.ts
@@ -2,7 +2,7 @@
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
-import { ZodParsedType } from "../helpers/parseUtil.ts";
+import { ZodParsedType } from "../helpers/util.ts";
 import * as z from "../index.ts";
 import { ZodError, ZodIssueCode } from "../ZodError.ts";
 
diff --git a/deno/lib/__tests__/pickomit.test.ts b/deno/lib/__tests__/pickomit.test.ts
index 0b49dc125..fe4b54147 100644
--- a/deno/lib/__tests__/pickomit.test.ts
+++ b/deno/lib/__tests__/pickomit.test.ts
@@ -80,3 +80,19 @@ test("nonstrict parsing - fail", () => {
   const bad = () => laxfish.parse({ whatever: "asdf" } as any);
   expect(bad).toThrow();
 });
+
+test("pick a nonexistent key", () => {
+  const schema = z.object({
+    a: z.string(),
+    b: z.number(),
+  });
+
+  const pickedSchema = schema.pick({
+    a: true,
+    doesntExist: true,
+  });
+
+  pickedSchema.parse({
+    a: "value",
+  });
+});
diff --git a/deno/lib/declarations.d.ts b/deno/lib/declarations.d.ts
deleted file mode 100644
index e8586a7df..000000000
--- a/deno/lib/declarations.d.ts
+++ /dev/null
@@ -1,20 +0,0 @@
-interface Body<T> {
-  readonly body: ReadableStream<Uint8Array> | null;
-  readonly bodyUsed: boolean;
-  arrayBuffer(): Promise<ArrayBuffer>;
-  blob(): Promise<Blob>;
-  formData(): Promise<FormData>;
-  json(): Promise<T>;
-  text(): Promise<string>;
-}
-
-interface Response<T> extends Body<T> {
-  readonly headers: Headers;
-  readonly ok: boolean;
-  readonly redirected: boolean;
-  readonly status: number;
-  readonly statusText: string;
-  readonly type: ResponseType;
-  readonly url: string;
-  clone(): Response<T>;
-}
diff --git a/deno/lib/external.ts b/deno/lib/external.ts
index 48fd25b83..700b626ac 100644
--- a/deno/lib/external.ts
+++ b/deno/lib/external.ts
@@ -1,4 +1,5 @@
 export * from "./helpers/parseUtil.ts";
 export * from "./helpers/typeAliases.ts";
+export { getParsedType, ZodParsedType } from "./helpers/util.ts";
 export * from "./types.ts";
 export * from "./ZodError.ts";
diff --git a/deno/lib/helpers/parseUtil.ts b/deno/lib/helpers/parseUtil.ts
index 60d9aadcf..46d12a704 100644
--- a/deno/lib/helpers/parseUtil.ts
+++ b/deno/lib/helpers/parseUtil.ts
@@ -1,89 +1,11 @@
 import {
+  type IssueData,
+  type ZodErrorMap,
+  type ZodIssue,
   defaultErrorMap,
-  IssueData,
   overrideErrorMap,
-  ZodErrorMap,
-  ZodIssue,
 } from "../ZodError.ts";
-import { util } from "./util.ts";
-
-export const ZodParsedType = util.arrayToEnum([
-  "string",
-  "nan",
-  "number",
-  "integer",
-  "float",
-  "boolean",
-  "date",
-  "bigint",
-  "symbol",
-  "function",
-  "undefined",
-  "null",
-  "array",
-  "object",
-  "unknown",
-  "promise",
-  "void",
-  "never",
-  "map",
-  "set",
-]);
-
-export type ZodParsedType = keyof typeof ZodParsedType;
-
-export const getParsedType = (data: any): ZodParsedType => {
-  const t = typeof data;
-
-  switch (t) {
-    case "undefined":
-      return ZodParsedType.undefined;
-
-    case "string":
-      return ZodParsedType.string;
-
-    case "number":
-      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
-
-    case "boolean":
-      return ZodParsedType.boolean;
-
-    case "function":
-      return ZodParsedType.function;
-
-    case "bigint":
-      return ZodParsedType.bigint;
-
-    case "object":
-      if (Array.isArray(data)) {
-        return ZodParsedType.array;
-      }
-      if (data === null) {
-        return ZodParsedType.null;
-      }
-      if (
-        data.then &&
-        typeof data.then === "function" &&
-        data.catch &&
-        typeof data.catch === "function"
-      ) {
-        return ZodParsedType.promise;
-      }
-      if (typeof Map !== "undefined" && data instanceof Map) {
-        return ZodParsedType.map;
-      }
-      if (typeof Set !== "undefined" && data instanceof Set) {
-        return ZodParsedType.set;
-      }
-      if (typeof Date !== "undefined" && data instanceof Date) {
-        return ZodParsedType.date;
-      }
-      return ZodParsedType.object;
-
-    default:
-      return ZodParsedType.unknown;
-  }
-};
+import { type ZodParsedType } from "./util.ts";
 
 export const makeIssue = (params: {
   data: any;
diff --git a/deno/lib/helpers/util.ts b/deno/lib/helpers/util.ts
index 2373de715..fe46c050b 100644
--- a/deno/lib/helpers/util.ts
+++ b/deno/lib/helpers/util.ts
@@ -83,3 +83,81 @@ export namespace util {
       .join(separator);
   }
 }
+
+export const ZodParsedType = util.arrayToEnum([
+  "string",
+  "nan",
+  "number",
+  "integer",
+  "float",
+  "boolean",
+  "date",
+  "bigint",
+  "symbol",
+  "function",
+  "undefined",
+  "null",
+  "array",
+  "object",
+  "unknown",
+  "promise",
+  "void",
+  "never",
+  "map",
+  "set",
+]);
+
+export type ZodParsedType = keyof typeof ZodParsedType;
+
+export const getParsedType = (data: any): ZodParsedType => {
+  const t = typeof data;
+
+  switch (t) {
+    case "undefined":
+      return ZodParsedType.undefined;
+
+    case "string":
+      return ZodParsedType.string;
+
+    case "number":
+      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
+
+    case "boolean":
+      return ZodParsedType.boolean;
+
+    case "function":
+      return ZodParsedType.function;
+
+    case "bigint":
+      return ZodParsedType.bigint;
+
+    case "object":
+      if (Array.isArray(data)) {
+        return ZodParsedType.array;
+      }
+      if (data === null) {
+        return ZodParsedType.null;
+      }
+      if (
+        data.then &&
+        typeof data.then === "function" &&
+        data.catch &&
+        typeof data.catch === "function"
+      ) {
+        return ZodParsedType.promise;
+      }
+      if (typeof Map !== "undefined" && data instanceof Map) {
+        return ZodParsedType.map;
+      }
+      if (typeof Set !== "undefined" && data instanceof Set) {
+        return ZodParsedType.set;
+      }
+      if (typeof Date !== "undefined" && data instanceof Date) {
+        return ZodParsedType.date;
+      }
+      return ZodParsedType.object;
+
+    default:
+      return ZodParsedType.unknown;
+  }
+};
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 529c19178..83fd4bf96 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -3,7 +3,6 @@ import {
   addIssueToContext,
   AsyncParseReturnType,
   DIRTY,
-  getParsedType,
   INVALID,
   isAborted,
   isAsync,
@@ -18,11 +17,10 @@ import {
   ParseReturnType,
   ParseStatus,
   SyncParseReturnType,
-  ZodParsedType,
 } from "./helpers/parseUtil.ts";
 import { partialUtil } from "./helpers/partialUtil.ts";
 import { Primitive } from "./helpers/typeAliases.ts";
-import { util } from "./helpers/util.ts";
+import { getParsedType, util, ZodParsedType } from "./helpers/util.ts";
 import {
   defaultErrorMap,
   IssueData,
@@ -1725,7 +1723,8 @@ export class ZodObject<
   ): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall> {
     const shape: any = {};
     util.objectKeys(mask).map((key) => {
-      shape[key] = this.shape[key];
+      // only add to shape if key corresponds to an element of the current shape
+      if (this.shape[key]) shape[key] = this.shape[key];
     });
     return new ZodObject({
       ...this._def,
diff --git a/package.json b/package.json
index 07340129b..1c574418d 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.17.0",
+  "version": "3.17.2",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./index.d.ts",
diff --git a/src/ZodError.ts b/src/ZodError.ts
index 2f2d66fe7..1302ff413 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -1,7 +1,6 @@
 import type { TypeOf, ZodType } from ".";
-import { ZodParsedType } from "./helpers/parseUtil";
 import { Primitive } from "./helpers/typeAliases";
-import { util } from "./helpers/util";
+import { util, ZodParsedType } from "./helpers/util";
 
 type allKeys<T> = T extends any ? keyof T : never;
 
diff --git a/src/__tests__/error.test.ts b/src/__tests__/error.test.ts
index 759035879..c4aa1deaa 100644
--- a/src/__tests__/error.test.ts
+++ b/src/__tests__/error.test.ts
@@ -1,7 +1,7 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-import { ZodParsedType } from "../helpers/parseUtil";
+import { ZodParsedType } from "../helpers/util";
 import * as z from "../index";
 import { ZodError, ZodIssueCode } from "../ZodError";
 
diff --git a/src/__tests__/pickomit.test.ts b/src/__tests__/pickomit.test.ts
index 1f2246084..a73aecc34 100644
--- a/src/__tests__/pickomit.test.ts
+++ b/src/__tests__/pickomit.test.ts
@@ -79,3 +79,19 @@ test("nonstrict parsing - fail", () => {
   const bad = () => laxfish.parse({ whatever: "asdf" } as any);
   expect(bad).toThrow();
 });
+
+test("pick a nonexistent key", () => {
+  const schema = z.object({
+    a: z.string(),
+    b: z.number(),
+  });
+
+  const pickedSchema = schema.pick({
+    a: true,
+    doesntExist: true,
+  });
+
+  pickedSchema.parse({
+    a: "value",
+  });
+});
diff --git a/src/external.ts b/src/external.ts
index 11710315d..9da2ca5ce 100644
--- a/src/external.ts
+++ b/src/external.ts
@@ -1,4 +1,5 @@
 export * from "./helpers/parseUtil";
 export * from "./helpers/typeAliases";
+export { getParsedType, ZodParsedType } from "./helpers/util";
 export * from "./types";
 export * from "./ZodError";
diff --git a/src/helpers/parseUtil.ts b/src/helpers/parseUtil.ts
index f7926d3d6..75eae31dd 100644
--- a/src/helpers/parseUtil.ts
+++ b/src/helpers/parseUtil.ts
@@ -1,89 +1,11 @@
 import {
+  type IssueData,
+  type ZodErrorMap,
+  type ZodIssue,
   defaultErrorMap,
-  IssueData,
   overrideErrorMap,
-  ZodErrorMap,
-  ZodIssue,
 } from "../ZodError";
-import { util } from "./util";
-
-export const ZodParsedType = util.arrayToEnum([
-  "string",
-  "nan",
-  "number",
-  "integer",
-  "float",
-  "boolean",
-  "date",
-  "bigint",
-  "symbol",
-  "function",
-  "undefined",
-  "null",
-  "array",
-  "object",
-  "unknown",
-  "promise",
-  "void",
-  "never",
-  "map",
-  "set",
-]);
-
-export type ZodParsedType = keyof typeof ZodParsedType;
-
-export const getParsedType = (data: any): ZodParsedType => {
-  const t = typeof data;
-
-  switch (t) {
-    case "undefined":
-      return ZodParsedType.undefined;
-
-    case "string":
-      return ZodParsedType.string;
-
-    case "number":
-      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
-
-    case "boolean":
-      return ZodParsedType.boolean;
-
-    case "function":
-      return ZodParsedType.function;
-
-    case "bigint":
-      return ZodParsedType.bigint;
-
-    case "object":
-      if (Array.isArray(data)) {
-        return ZodParsedType.array;
-      }
-      if (data === null) {
-        return ZodParsedType.null;
-      }
-      if (
-        data.then &&
-        typeof data.then === "function" &&
-        data.catch &&
-        typeof data.catch === "function"
-      ) {
-        return ZodParsedType.promise;
-      }
-      if (typeof Map !== "undefined" && data instanceof Map) {
-        return ZodParsedType.map;
-      }
-      if (typeof Set !== "undefined" && data instanceof Set) {
-        return ZodParsedType.set;
-      }
-      if (typeof Date !== "undefined" && data instanceof Date) {
-        return ZodParsedType.date;
-      }
-      return ZodParsedType.object;
-
-    default:
-      return ZodParsedType.unknown;
-  }
-};
+import { type ZodParsedType } from "./util";
 
 export const makeIssue = (params: {
   data: any;
diff --git a/src/helpers/util.ts b/src/helpers/util.ts
index 2373de715..fe46c050b 100644
--- a/src/helpers/util.ts
+++ b/src/helpers/util.ts
@@ -83,3 +83,81 @@ export namespace util {
       .join(separator);
   }
 }
+
+export const ZodParsedType = util.arrayToEnum([
+  "string",
+  "nan",
+  "number",
+  "integer",
+  "float",
+  "boolean",
+  "date",
+  "bigint",
+  "symbol",
+  "function",
+  "undefined",
+  "null",
+  "array",
+  "object",
+  "unknown",
+  "promise",
+  "void",
+  "never",
+  "map",
+  "set",
+]);
+
+export type ZodParsedType = keyof typeof ZodParsedType;
+
+export const getParsedType = (data: any): ZodParsedType => {
+  const t = typeof data;
+
+  switch (t) {
+    case "undefined":
+      return ZodParsedType.undefined;
+
+    case "string":
+      return ZodParsedType.string;
+
+    case "number":
+      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
+
+    case "boolean":
+      return ZodParsedType.boolean;
+
+    case "function":
+      return ZodParsedType.function;
+
+    case "bigint":
+      return ZodParsedType.bigint;
+
+    case "object":
+      if (Array.isArray(data)) {
+        return ZodParsedType.array;
+      }
+      if (data === null) {
+        return ZodParsedType.null;
+      }
+      if (
+        data.then &&
+        typeof data.then === "function" &&
+        data.catch &&
+        typeof data.catch === "function"
+      ) {
+        return ZodParsedType.promise;
+      }
+      if (typeof Map !== "undefined" && data instanceof Map) {
+        return ZodParsedType.map;
+      }
+      if (typeof Set !== "undefined" && data instanceof Set) {
+        return ZodParsedType.set;
+      }
+      if (typeof Date !== "undefined" && data instanceof Date) {
+        return ZodParsedType.date;
+      }
+      return ZodParsedType.object;
+
+    default:
+      return ZodParsedType.unknown;
+  }
+};
diff --git a/src/types.ts b/src/types.ts
index 6ba30bab0..edb717217 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -3,7 +3,6 @@ import {
   addIssueToContext,
   AsyncParseReturnType,
   DIRTY,
-  getParsedType,
   INVALID,
   isAborted,
   isAsync,
@@ -18,11 +17,10 @@ import {
   ParseReturnType,
   ParseStatus,
   SyncParseReturnType,
-  ZodParsedType,
 } from "./helpers/parseUtil";
 import { partialUtil } from "./helpers/partialUtil";
 import { Primitive } from "./helpers/typeAliases";
-import { util } from "./helpers/util";
+import { getParsedType, util, ZodParsedType } from "./helpers/util";
 import {
   defaultErrorMap,
   IssueData,
@@ -1725,7 +1723,8 @@ export class ZodObject<
   ): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall> {
     const shape: any = {};
     util.objectKeys(mask).map((key) => {
-      shape[key] = this.shape[key];
+      // only add to shape if key corresponds to an element of the current shape
+      if (this.shape[key]) shape[key] = this.shape[key];
     });
     return new ZodObject({
       ...this._def,
