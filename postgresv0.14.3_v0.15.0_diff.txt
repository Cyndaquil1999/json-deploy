diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index d9530c1e..5621f8d9 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -1,17 +1,73 @@
 name: ci
 
-on: [push, pull_request, release]
+on: [ push, pull_request, release ]
 
 jobs:
-  test:
+  code_quality:
     runs-on: ubuntu-latest
+    steps:
+      - name: Clone repo
+        uses: actions/checkout@master
 
+      - name: Setup Deno
+        uses: denoland/setup-deno@v1
+        with:
+          deno-version: 1.16.0
+      
+      - name: Format
+        run: deno fmt --check
+      
+      - name: Lint
+        run: deno lint --config=deno.json
+
+      - name: Documentation tests
+        run: deno test --doc client.ts mod.ts pool.ts client/ connection/ query/ utils/
+
+  test:
+    runs-on: ubuntu-latest
     steps:
       - name: Clone repo
         uses: actions/checkout@master
 
-      - name: Build container
+      - name: Build tests container
         run: docker-compose build tests
       
       - name: Run tests
-        run: docker-compose run tests
\ No newline at end of file
+        run: docker-compose run tests
+
+      - name: Run tests without typechecking
+        id: no_typecheck
+        uses: mathiasvr/command-output@v1
+        with:
+          run: docker-compose run no_check_tests
+        continue-on-error: true
+
+      - name: Report no typechecking tests status
+        id: no_typecheck_status
+        if: steps.no_typecheck.outcome == 'success'
+        run: echo "::set-output name=status::success"
+    outputs:
+      no_typecheck: ${{ steps.no_typecheck.outputs.stdout }}
+      no_typecheck_status: ${{ steps.no_typecheck_status.outputs.status }}
+
+  report_warnings:
+    needs: [ code_quality, test ]
+    runs-on: ubuntu-latest
+    steps:
+      - name: Set no-typecheck fail comment
+        if: ${{ needs.test.outputs.no_typecheck_status != 'success' && github.event_name == 'push' }}
+        uses: peter-evans/commit-comment@v1
+        with:
+          body: |
+            # No typecheck tests failure
+
+            This error was most likely caused by incorrect type stripping from the SWC crate
+
+            Please report the following failure to https://github.com/denoland/deno with a reproduction of the current commit
+
+            <details>
+              <summary>Failure log</summary>
+              <pre><code>
+            ${{ needs.test.outputs.no_typecheck }}
+              </code></pre>
+            </details>
\ No newline at end of file
diff --git a/Dockerfile b/Dockerfile
index 34c25f8e..ccb349b0 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -16,10 +16,3 @@ RUN deno cache tests/test_deps.ts
 
 ADD . .
 RUN deno cache mod.ts
-
-# Code health checks
-RUN deno lint --config=deno.json
-RUN deno fmt --check
-
-# Run tests
-CMD /wait && deno test --unstable -A --jobs
diff --git a/README.md b/README.md
index 372e8d96..5ce37a27 100644
--- a/README.md
+++ b/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 [![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)](https://deno-postgres.com)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.14.3/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.15.0/mod.ts)
 [![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)](LICENSE)
 
 A lightweight PostgreSQL driver for Deno focused on user experience
diff --git a/client.ts b/client.ts
index 9261401f..48bbc80d 100644
--- a/client.ts
+++ b/client.ts
@@ -9,9 +9,9 @@ import {
   Query,
   QueryArguments,
   QueryArrayResult,
-  QueryConfig,
-  QueryObjectConfig,
+  QueryObjectOptions,
   QueryObjectResult,
+  QueryOptions,
   QueryResult,
   ResultType,
   templateStringToQuery,
@@ -35,6 +35,12 @@ export interface Session {
    * there is no connection stablished
    */
   tls: boolean | undefined;
+  /**
+   * This indicates the protocol used to connect to the database
+   *
+   * The two supported transports are TCP and Unix sockets
+   */
+  transport: "tcp" | "socket" | undefined;
 }
 
 export abstract class QueryClient {
@@ -55,6 +61,7 @@ export abstract class QueryClient {
       current_transaction: this.#transaction,
       pid: this.#connection.pid,
       tls: this.#connection.tls,
+      transport: this.#connection.transport,
     };
   }
 
@@ -82,7 +89,11 @@ export abstract class QueryClient {
    * In order to create a transaction, use the `createTransaction` method in your client as follows:
    *
    * ```ts
+   * import { Client } from "./client.ts";
+   *
+   * const client = new Client();
    * const transaction = client.createTransaction("my_transaction_name");
+   *
    * await transaction.begin();
    * // All statements between begin and commit will happen inside the transaction
    * await transaction.commit(); // All changes are saved
@@ -92,6 +103,11 @@ export abstract class QueryClient {
    * the client without applying any of the changes that took place inside it
    *
    * ```ts
+   * import { Client } from "./client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * await transaction.begin();
    * await transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES ${"some_value"}`;
    * try {
@@ -105,11 +121,16 @@ export abstract class QueryClient {
    * the transaction
    *
    * ```ts
+   * import { Client } from "./client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * await transaction.begin();
    * await transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES ${"some_value"}`;
    * try {
    *   await transaction.rollback("unexistent_savepoint"); // Validation error
-   * }catch(e){
+   * } catch(e) {
    *   await transaction.commit(); // Transaction will end, changes will be saved
    * }
    * ```
@@ -126,12 +147,18 @@ export abstract class QueryClient {
    * - Repeatable read: This isolates the transaction in a way that any external changes to the data we are reading
    *   won't be visible inside the transaction until it has finished
    *   ```ts
+   *   import { Client } from "./client.ts";
+   *
+   *   const client = new Client();
    *   const transaction = await client.createTransaction("my_transaction", { isolation_level: "repeatable_read" });
    *   ```
    *
    * - Serializable: This isolation level prevents the current transaction from making persistent changes
    *   if the data they were reading at the beginning of the transaction has been modified (recommended)
    *   ```ts
+   *   import { Client } from "./client.ts";
+   *
+   *   const client = new Client();
    *   const transaction = await client.createTransaction("my_transaction", { isolation_level: "serializable" });
    *   ```
    *
@@ -143,6 +170,9 @@ export abstract class QueryClient {
    *   is to in conjuction with the repeatable read isolation, ensuring the data you are reading does not change
    *   during the transaction, specially useful for data extraction
    *   ```ts
+   *   import { Client } from "./client.ts";
+   *
+   *   const client = new Client();
    *   const transaction = await client.createTransaction("my_transaction", { read_only: true });
    *   ```
    *
@@ -152,6 +182,12 @@ export abstract class QueryClient {
    * you can do the following:
    *
    * ```ts
+   * import { Client } from "./client.ts";
+   *
+   * const client_1 = new Client();
+   * const client_2 = new Client();
+   * const transaction_1 = client_1.createTransaction("transaction_1");
+   *
    * const snapshot = await transaction_1.getSnapshot();
    * const transaction_2 = client_2.createTransaction("new_transaction", { isolation_level: "repeatable_read", snapshot });
    * // transaction_2 now shares the same starting state that transaction_1 had
@@ -214,21 +250,31 @@ export abstract class QueryClient {
    * It supports a generic interface in order to type the entries retrieved by the query
    *
    * ```ts
+   * import { Client } from "./client.ts";
+   *
+   * const my_client = new Client();
+   *
    * const {rows} = await my_client.queryArray(
-   *  "SELECT ID, NAME FROM CLIENTS"
+   *   "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<unknown[]>
    * ```
    *
    * You can pass type arguments to the query in order to hint TypeScript what the return value will be
    * ```ts
-   * const {rows} = await my_client.queryArray<[number, string]>(
-   *  "SELECT ID, NAME FROM CLIENTS"
+   * import { Client } from "./client.ts";
+   *
+   * const my_client = new Client();
+   * const { rows } = await my_client.queryArray<[number, string]>(
+   *   "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<[number, string]>
    * ```
    *
    * It also allows you to execute prepared statements with template strings
    *
    * ```ts
+   * import { Client } from "./client.ts";
+   * const my_client = new Client();
+   *
    * const id = 12;
    * // Array<[number, string]>
    * const {rows} = await my_client.queryArray<[number, string]>`SELECT ID, NAME FROM CLIENTS WHERE ID = ${id}`;
@@ -236,18 +282,18 @@ export abstract class QueryClient {
    */
   queryArray<T extends Array<unknown>>(
     query: string,
-    ...args: QueryArguments
+    args?: QueryArguments,
   ): Promise<QueryArrayResult<T>>;
   queryArray<T extends Array<unknown>>(
-    config: QueryConfig,
+    config: QueryOptions,
   ): Promise<QueryArrayResult<T>>;
   queryArray<T extends Array<unknown>>(
     strings: TemplateStringsArray,
-    ...args: QueryArguments
+    ...args: unknown[]
   ): Promise<QueryArrayResult<T>>;
   queryArray<T extends Array<unknown> = Array<unknown>>(
-    query_template_or_config: TemplateStringsArray | string | QueryConfig,
-    ...args: QueryArguments
+    query_template_or_config: TemplateStringsArray | string | QueryOptions,
+    ...args: unknown[] | [QueryArguments | undefined]
   ): Promise<QueryArrayResult<T>> {
     this.#assertOpenConnection();
 
@@ -259,7 +305,11 @@ export abstract class QueryClient {
 
     let query: Query<ResultType.ARRAY>;
     if (typeof query_template_or_config === "string") {
-      query = new Query(query_template_or_config, ResultType.ARRAY, ...args);
+      query = new Query(
+        query_template_or_config,
+        ResultType.ARRAY,
+        args[0] as QueryArguments | undefined,
+      );
     } else if (isTemplateString(query_template_or_config)) {
       query = templateStringToQuery(
         query_template_or_config,
@@ -278,60 +328,79 @@ export abstract class QueryClient {
    * It supports a generic interface in order to type the entries retrieved by the query
    *
    * ```ts
-   * const {rows} = await my_client.queryObject(
-   *  "SELECT ID, NAME FROM CLIENTS"
-   * ); // Record<string, unknown>
+   * import { Client } from "./client.ts";
+   *
+   * const my_client = new Client();
    *
-   * const {rows} = await my_client.queryObject<{id: number, name: string}>(
-   *  "SELECT ID, NAME FROM CLIENTS"
-   * ); // Array<{id: number, name: string}>
+   * {
+   * 	 const { rows } = await my_client.queryObject(
+   *     "SELECT ID, NAME FROM CLIENTS"
+   * 	 ); // Record<string, unknown>
+   * }
+   *
+   * {
+   * 	 const { rows } = await my_client.queryObject<{id: number, name: string}>(
+   *     "SELECT ID, NAME FROM CLIENTS"
+   *   ); // Array<{id: number, name: string}>
+   * }
    * ```
    *
    * You can also map the expected results to object fields using the configuration interface.
    * This will be assigned in the order they were provided
    *
    * ```ts
-   * const {rows} = await my_client.queryObject(
-   *  "SELECT ID, NAME FROM CLIENTS"
-   * );
+   * import { Client } from "./client.ts";
    *
-   * console.log(rows); // [{id: 78, name: "Frank"}, {id: 15, name: "Sarah"}]
+   * const my_client = new Client();
    *
-   * const {rows} = await my_client.queryObject({
-   *  text: "SELECT ID, NAME FROM CLIENTS",
-   *  fields: ["personal_id", "complete_name"],
-   * });
+   * {
+   *   const {rows} = await my_client.queryObject(
+   *     "SELECT ID, NAME FROM CLIENTS"
+   *   );
+   *
+   * 	 console.log(rows); // [{id: 78, name: "Frank"}, {id: 15, name: "Sarah"}]
+   * }
    *
-   * console.log(rows); // [{personal_id: 78, complete_name: "Frank"}, {personal_id: 15, complete_name: "Sarah"}]
+   * {
+   * 	 const {rows} = await my_client.queryObject({
+   *     text: "SELECT ID, NAME FROM CLIENTS",
+   *  	 fields: ["personal_id", "complete_name"],
+   * 	  });
+   *
+   * 	 console.log(rows); // [{personal_id: 78, complete_name: "Frank"}, {personal_id: 15, complete_name: "Sarah"}]
+   * }
    * ```
    *
    * It also allows you to execute prepared statements with template strings
    *
    * ```ts
+   * import { Client } from "./client.ts";
+   *
+   * const my_client = new Client();
    * const id = 12;
    * // Array<{id: number, name: string}>
-   * const {rows} = await my_client.queryObject<{id: number, name: string}>`SELECT ID, NAME FROM CLIENTS WHERE ID = ${id}`;
+   * const { rows } = await my_client.queryObject<{id: number, name: string}>`SELECT ID, NAME FROM CLIENTS WHERE ID = ${id}`;
    * ```
    */
   queryObject<T>(
     query: string,
-    ...args: QueryArguments
+    args?: QueryArguments,
   ): Promise<QueryObjectResult<T>>;
   queryObject<T>(
-    config: QueryObjectConfig,
+    config: QueryObjectOptions,
   ): Promise<QueryObjectResult<T>>;
   queryObject<T>(
     query: TemplateStringsArray,
-    ...args: QueryArguments
+    ...args: unknown[]
   ): Promise<QueryObjectResult<T>>;
   queryObject<
     T = Record<string, unknown>,
   >(
     query_template_or_config:
       | string
-      | QueryObjectConfig
+      | QueryObjectOptions
       | TemplateStringsArray,
-    ...args: QueryArguments
+    ...args: unknown[] | [QueryArguments | undefined]
   ): Promise<QueryObjectResult<T>> {
     this.#assertOpenConnection();
 
@@ -343,7 +412,11 @@ export abstract class QueryClient {
 
     let query: Query<ResultType.OBJECT>;
     if (typeof query_template_or_config === "string") {
-      query = new Query(query_template_or_config, ResultType.OBJECT, ...args);
+      query = new Query(
+        query_template_or_config,
+        ResultType.OBJECT,
+        args[0] as QueryArguments | undefined,
+      );
     } else if (isTemplateString(query_template_or_config)) {
       query = templateStringToQuery(
         query_template_or_config,
@@ -352,7 +425,7 @@ export abstract class QueryClient {
       );
     } else {
       query = new Query(
-        query_template_or_config as QueryObjectConfig,
+        query_template_or_config as QueryObjectOptions,
         ResultType.OBJECT,
       );
     }
@@ -370,7 +443,9 @@ export abstract class QueryClient {
  * statements asynchronously
  *
  * ```ts
- * const client = new Client(connection_parameters);
+ * import { Client } from "./client.ts";
+ *
+ * const client = new Client();
  * await client.connect();
  * await client.queryArray`UPDATE MY_TABLE SET MY_FIELD = 0`;
  * await client.end();
@@ -380,14 +455,16 @@ export abstract class QueryClient {
  * for concurrency capabilities check out connection pools
  *
  * ```ts
- * const client_1 = new Client(connection_parameters);
+ * import { Client } from "./client.ts";
+ *
+ * const client_1 = new Client();
  * await client_1.connect();
  * // Even if operations are not awaited, they will be executed in the order they were
  * // scheduled
  * client_1.queryArray`UPDATE MY_TABLE SET MY_FIELD = 0`;
  * client_1.queryArray`DELETE FROM MY_TABLE`;
  *
- * const client_2 = new Client(connection_parameters);
+ * const client_2 = new Client();
  * await client_2.connect();
  * // `client_2` will execute it's queries in parallel to `client_1`
  * const {rows: result} = await client_2.queryArray`SELECT * FROM MY_TABLE`;
diff --git a/connection/auth.ts b/connection/auth.ts
index 5a67abe6..abc92ab5 100644
--- a/connection/auth.ts
+++ b/connection/auth.ts
@@ -1,25 +1,28 @@
-import { Md5 } from "../deps.ts";
+import { crypto, hex } from "../deps.ts";
 
 const encoder = new TextEncoder();
+const decoder = new TextDecoder();
 
-function md5(bytes: Uint8Array): string {
-  return new Md5().update(bytes).toString("hex");
+async function md5(bytes: Uint8Array): Promise<string> {
+  return decoder.decode(
+    hex.encode(new Uint8Array(await crypto.subtle.digest("MD5", bytes))),
+  );
 }
 
 // AuthenticationMD5Password
 // The actual PasswordMessage can be computed in SQL as:
 //  concat('md5', md5(concat(md5(concat(password, username)), random-salt))).
 // (Keep in mind the md5() function returns its result as a hex string.)
-export function hashMd5Password(
+export async function hashMd5Password(
   password: string,
   username: string,
   salt: Uint8Array,
-): string {
-  const innerHash = md5(encoder.encode(password + username));
+): Promise<string> {
+  const innerHash = await md5(encoder.encode(password + username));
   const innerBytes = encoder.encode(innerHash);
   const outerBuffer = new Uint8Array(innerBytes.length + salt.length);
   outerBuffer.set(innerBytes);
   outerBuffer.set(salt, innerBytes.length);
-  const outerHash = md5(outerBuffer);
+  const outerHash = await md5(outerBuffer);
   return "md5" + outerHash;
 }
diff --git a/connection/connection.ts b/connection/connection.ts
index a5de4dba..6843a99f 100644
--- a/connection/connection.ts
+++ b/connection/connection.ts
@@ -26,9 +26,9 @@
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-import { bold, BufReader, BufWriter, yellow } from "../deps.ts";
+import { bold, BufReader, BufWriter, joinPath, yellow } from "../deps.ts";
 import { DeferredStack } from "../utils/deferred.ts";
-import { readUInt32BE } from "../utils/utils.ts";
+import { getSocketName, readUInt32BE } from "../utils/utils.ts";
 import { PacketWriter } from "./packet.ts";
 import {
   Message,
@@ -62,6 +62,11 @@ import {
 } from "./message_code.ts";
 import { hashMd5Password } from "./auth.ts";
 
+// Work around unstable limitation
+type ConnectOptions =
+  | { hostname: string; port: number; transport: "tcp" }
+  | { path: string; transport: "unix" };
+
 function assertSuccessfulStartup(msg: Message) {
   switch (msg.type) {
     case ERROR_MESSAGE:
@@ -114,6 +119,7 @@ export class Connection {
   // Find out what the secret key is for
   #secretKey?: number;
   #tls?: boolean;
+  #transport?: "tcp" | "socket";
 
   get pid() {
     return this.#pid;
@@ -124,6 +130,11 @@ export class Connection {
     return this.#tls;
   }
 
+  /** Indicates the connection protocol used */
+  get transport() {
+    return this.#transport;
+  }
+
   constructor(
     connection_params: ClientConfiguration,
     disconnection_callback: () => Promise<void>,
@@ -219,16 +230,48 @@ export class Connection {
     return await this.#readMessage();
   }
 
-  async #createNonTlsConnection(options: Deno.ConnectOptions) {
+  async #openConnection(options: ConnectOptions) {
+    // @ts-ignore This will throw in runtime if the options passed to it are socket related and deno is running
+    // on stable
     this.#conn = await Deno.connect(options);
     this.#bufWriter = new BufWriter(this.#conn);
     this.#bufReader = new BufReader(this.#conn);
   }
 
-  async #createTlsConnection(
+  async #openSocketConnection(path: string, port: number) {
+    if (Deno.build.os === "windows") {
+      throw new Error(
+        "Socket connection is only available on UNIX systems",
+      );
+    }
+    const socket = await Deno.stat(path);
+
+    if (socket.isFile) {
+      await this.#openConnection({ path, transport: "unix" });
+    } else {
+      const socket_guess = joinPath(path, getSocketName(port));
+      try {
+        await this.#openConnection({
+          path: socket_guess,
+          transport: "unix",
+        });
+      } catch (e) {
+        if (e instanceof Deno.errors.NotFound) {
+          throw new ConnectionError(
+            `Could not open socket in path "${socket_guess}"`,
+          );
+        }
+        throw e;
+      }
+    }
+  }
+
+  async #openTlsConnection(
     connection: Deno.Conn,
     options: { hostname: string; caCerts: string[] },
   ) {
+    // TODO
+    // Remove unstable check on 1.17.0
     if ("startTls" in Deno) {
       // @ts-ignore This API should be available on unstable
       this.#conn = await Deno.startTls(connection, options);
@@ -251,6 +294,7 @@ export class Connection {
     );
     this.#secretKey = undefined;
     this.#tls = undefined;
+    this.#transport = undefined;
   }
 
   #closeConnection() {
@@ -268,6 +312,7 @@ export class Connection {
 
     const {
       hostname,
+      host_type,
       port,
       tls: {
         enabled: tls_enabled,
@@ -276,47 +321,54 @@ export class Connection {
       },
     } = this.#connection_params;
 
-    // A BufWriter needs to be available in order to check if the server accepts TLS connections
-    await this.#createNonTlsConnection({ hostname, port });
-    this.#tls = false;
-
-    if (tls_enabled) {
-      // If TLS is disabled, we don't even try to connect.
-      const accepts_tls = await this.#serverAcceptsTLS()
-        .catch((e) => {
-          // Make sure to close the connection if the TLS validation throws
-          this.#closeConnection();
-          throw e;
-        });
-
-      // https://www.postgresql.org/docs/14/protocol-flow.html#id-1.10.5.7.11
-      if (accepts_tls) {
-        try {
-          await this.#createTlsConnection(this.#conn, {
-            hostname,
-            caCerts: caCertificates,
-          });
-          this.#tls = true;
-        } catch (e) {
-          if (!tls_enforced) {
-            console.error(
-              bold(yellow("TLS connection failed with message: ")) +
-                e.message +
-                "\n" +
-                bold("Defaulting to non-encrypted connection"),
-            );
-            await this.#createNonTlsConnection({ hostname, port });
-            this.#tls = false;
-          } else {
+    if (host_type === "socket") {
+      await this.#openSocketConnection(hostname, port);
+      this.#tls = undefined;
+      this.#transport = "socket";
+    } else {
+      // A BufWriter needs to be available in order to check if the server accepts TLS connections
+      await this.#openConnection({ hostname, port, transport: "tcp" });
+      this.#tls = false;
+      this.#transport = "tcp";
+
+      if (tls_enabled) {
+        // If TLS is disabled, we don't even try to connect.
+        const accepts_tls = await this.#serverAcceptsTLS()
+          .catch((e) => {
+            // Make sure to close the connection if the TLS validation throws
+            this.#closeConnection();
             throw e;
+          });
+
+        // https://www.postgresql.org/docs/14/protocol-flow.html#id-1.10.5.7.11
+        if (accepts_tls) {
+          try {
+            await this.#openTlsConnection(this.#conn, {
+              hostname,
+              caCerts: caCertificates,
+            });
+            this.#tls = true;
+          } catch (e) {
+            if (!tls_enforced) {
+              console.error(
+                bold(yellow("TLS connection failed with message: ")) +
+                  e.message +
+                  "\n" +
+                  bold("Defaulting to non-encrypted connection"),
+              );
+              await this.#openConnection({ hostname, port, transport: "tcp" });
+              this.#tls = false;
+            } else {
+              throw e;
+            }
           }
+        } else if (tls_enforced) {
+          // Make sure to close the connection before erroring
+          this.#closeConnection();
+          throw new Error(
+            "The server isn't accepting TLS connections. Change the client configuration so TLS configuration isn't required to connect",
+          );
         }
-      } else if (tls_enforced) {
-        // Make sure to close the connection before erroring
-        this.#closeConnection();
-        throw new Error(
-          "The server isn't accepting TLS connections. Change the client configuration so TLS configuration isn't required to connect",
-        );
       }
     }
 
@@ -339,8 +391,9 @@ export class Connection {
                 "\n" +
                 bold("Defaulting to non-encrypted connection"),
             );
-            await this.#createNonTlsConnection({ hostname, port });
+            await this.#openConnection({ hostname, port, transport: "tcp" });
             this.#tls = false;
+            this.#transport = "tcp";
             startup_response = await this.#sendStartupMessage();
           }
         } else {
@@ -499,7 +552,7 @@ export class Connection {
       );
     }
 
-    const password = hashMd5Password(
+    const password = await hashMd5Password(
       this.#connection_params.password,
       this.#connection_params.user,
       salt,
diff --git a/connection/connection_params.ts b/connection/connection_params.ts
index e10d2336..9205ac5f 100644
--- a/connection/connection_params.ts
+++ b/connection/connection_params.ts
@@ -1,14 +1,21 @@
-import { parseDsn } from "../utils/utils.ts";
+import { parseConnectionUri } from "../utils/utils.ts";
 import { ConnectionParamsError } from "../client/error.ts";
+import { fromFileUrl, isAbsolute } from "../deps.ts";
 
 /**
- * The connection string must match the following URI structure
+ * The connection string must match the following URI structure. All parameters but database and user are optional
  *
- * ```ts
- * const connection = "postgres://user:password@hostname:port/database?application_name=application_name";
- * ```
+ * `postgres://user:password@hostname:port/database?sslmode=mode...`
  *
- * Password, port and application name are optional parameters
+ * You can additionally provide the following url search parameters
+ *
+ * - application_name
+ * - dbname
+ * - host
+ * - password
+ * - port
+ * - sslmode
+ * - user
  */
 export type ConnectionString = string;
 
@@ -41,6 +48,8 @@ export interface ConnectionOptions {
   attempts: number;
 }
 
+type TLSModes = "disable" | "prefer" | "require";
+
 // TODO
 // Refactor enabled and enforce into one single option for 1.0
 export interface TLSOptions {
@@ -74,6 +83,7 @@ export interface ClientOptions {
   connection?: Partial<ConnectionOptions>;
   database?: string;
   hostname?: string;
+  host_type?: "tcp" | "socket";
   password?: string;
   port?: string | number;
   tls?: Partial<TLSOptions>;
@@ -85,6 +95,7 @@ export interface ClientConfiguration {
   connection: ConnectionOptions;
   database: string;
   hostname: string;
+  host_type: "tcp" | "socket";
   password?: string;
   port: number;
   tls: TLSOptions;
@@ -133,61 +144,116 @@ function assertRequiredOptions(
   }
 }
 
-function parseOptionsFromDsn(connString: string): ClientOptions {
-  const dsn = parseDsn(connString);
+// TODO
+// Support more options from the spec
+/** options from URI per https://www.postgresql.org/docs/14/libpq-connect.html#LIBPQ-CONNSTRING */
+interface PostgresUri {
+  application_name?: string;
+  dbname?: string;
+  driver: string;
+  host?: string;
+  password?: string;
+  port?: string;
+  sslmode?: TLSModes;
+  user?: string;
+}
+
+function parseOptionsFromUri(connString: string): ClientOptions {
+  let postgres_uri: PostgresUri;
+  try {
+    const uri = parseConnectionUri(connString);
+    postgres_uri = {
+      application_name: uri.params.application_name,
+      dbname: uri.path || uri.params.dbname,
+      driver: uri.driver,
+      host: uri.host || uri.params.host,
+      password: uri.password || uri.params.password,
+      port: uri.port || uri.params.port,
+      // Compatibility with JDBC, not standard
+      // Treat as sslmode=require
+      sslmode: uri.params.ssl === "true"
+        ? "require"
+        : uri.params.sslmode as TLSModes,
+      user: uri.user || uri.params.user,
+    };
+  } catch (e) {
+    // TODO
+    // Use error cause
+    throw new ConnectionParamsError(
+      `Could not parse the connection string due to ${e}`,
+    );
+  }
 
-  if (dsn.driver !== "postgres" && dsn.driver !== "postgresql") {
+  if (!["postgres", "postgresql"].includes(postgres_uri.driver)) {
     throw new ConnectionParamsError(
-      `Supplied DSN has invalid driver: ${dsn.driver}.`,
+      `Supplied DSN has invalid driver: ${postgres_uri.driver}.`,
     );
   }
 
-  let tls: TLSOptions = { enabled: true, enforce: false, caCertificates: [] };
-  if (dsn.params.sslmode) {
-    const sslmode = dsn.params.sslmode;
-    delete dsn.params.sslmode;
+  // No host by default means socket connection
+  const host_type = postgres_uri.host
+    ? (isAbsolute(postgres_uri.host) ? "socket" : "tcp")
+    : "socket";
 
-    if (!["disable", "require", "prefer"].includes(sslmode)) {
-      throw new ConnectionParamsError(
-        `Supplied DSN has invalid sslmode '${sslmode}'. Only 'disable', 'require', and 'prefer' are supported`,
-      );
+  let tls: TLSOptions | undefined;
+  switch (postgres_uri.sslmode) {
+    case undefined: {
+      break;
     }
-
-    if (sslmode === "require") {
+    case "disable": {
+      tls = { enabled: false, enforce: false, caCertificates: [] };
+      break;
+    }
+    case "prefer": {
+      tls = { enabled: true, enforce: false, caCertificates: [] };
+      break;
+    }
+    case "require": {
       tls = { enabled: true, enforce: true, caCertificates: [] };
+      break;
     }
-
-    if (sslmode === "disable") {
-      tls = { enabled: false, enforce: false, caCertificates: [] };
+    default: {
+      throw new ConnectionParamsError(
+        `Supplied DSN has invalid sslmode '${postgres_uri.sslmode}'. Only 'disable', 'require', and 'prefer' are supported`,
+      );
     }
   }
 
   return {
-    ...dsn,
-    applicationName: dsn.params.application_name,
+    applicationName: postgres_uri.application_name,
+    database: postgres_uri.dbname,
+    hostname: postgres_uri.host,
+    host_type,
+    password: postgres_uri.password,
+    port: postgres_uri.port,
     tls,
+    user: postgres_uri.user,
   };
 }
 
-const DEFAULT_OPTIONS: Omit<ClientConfiguration, "database" | "user"> = {
-  applicationName: "deno_postgres",
-  connection: {
-    attempts: 1,
-  },
-  hostname: "127.0.0.1",
-  port: 5432,
-  tls: {
-    enabled: true,
-    enforce: false,
-    caCertificates: [],
-  },
-};
+const DEFAULT_OPTIONS:
+  & Omit<ClientConfiguration, "database" | "user" | "hostname">
+  & { host: string; socket: string } = {
+    applicationName: "deno_postgres",
+    connection: {
+      attempts: 1,
+    },
+    host: "127.0.0.1",
+    socket: "/tmp",
+    host_type: "socket",
+    port: 5432,
+    tls: {
+      enabled: true,
+      enforce: false,
+      caCertificates: [],
+    },
+  };
 
 export function createParams(
   params: string | ClientOptions = {},
 ): ClientConfiguration {
   if (typeof params === "string") {
-    params = parseOptionsFromDsn(params);
+    params = parseOptionsFromUri(params);
   }
 
   let pgEnv: ClientOptions = {};
@@ -202,6 +268,44 @@ export function createParams(
     }
   }
 
+  const provided_host = params.hostname ?? pgEnv.hostname;
+
+  // If a host is provided, the default connection type is TCP
+  const host_type = params.host_type ??
+    (provided_host ? "tcp" : DEFAULT_OPTIONS.host_type);
+  if (!["tcp", "socket"].includes(host_type)) {
+    throw new ConnectionParamsError(`"${host_type}" is not a valid host type`);
+  }
+
+  let host: string;
+  if (host_type === "socket") {
+    const socket = provided_host ?? DEFAULT_OPTIONS.socket;
+    try {
+      if (!isAbsolute(socket)) {
+        const parsed_host = new URL(socket, Deno.mainModule);
+
+        // Resolve relative path
+        if (parsed_host.protocol === "file:") {
+          host = fromFileUrl(parsed_host);
+        } else {
+          throw new ConnectionParamsError(
+            "The provided host is not a file path",
+          );
+        }
+      } else {
+        host = socket;
+      }
+    } catch (e) {
+      // TODO
+      // Add error cause
+      throw new ConnectionParamsError(
+        `Could not parse host "${socket}" due to "${e}"`,
+      );
+    }
+  } else {
+    host = provided_host ?? DEFAULT_OPTIONS.host;
+  }
+
   let port: number;
   if (params.port) {
     port = Number(params.port);
@@ -216,6 +320,11 @@ export function createParams(
     );
   }
 
+  if (host_type === "socket" && params?.tls) {
+    throw new ConnectionParamsError(
+      `No TLS options are allowed when host type is set to "socket"`,
+    );
+  }
   const tls_enabled = !!(params?.tls?.enabled ?? DEFAULT_OPTIONS.tls.enabled);
   const tls_enforced = !!(params?.tls?.enforce ?? DEFAULT_OPTIONS.tls.enforce);
 
@@ -235,7 +344,8 @@ export function createParams(
         DEFAULT_OPTIONS.connection.attempts,
     },
     database: params.database ?? pgEnv.database,
-    hostname: params.hostname ?? pgEnv.hostname ?? DEFAULT_OPTIONS.hostname,
+    hostname: host,
+    host_type,
     password: params.password ?? pgEnv.password,
     port,
     tls: {
@@ -248,7 +358,7 @@ export function createParams(
 
   assertRequiredOptions(
     connection_options,
-    ["applicationName", "database", "hostname", "port", "user"],
+    ["applicationName", "database", "hostname", "host_type", "port", "user"],
     has_env_access,
   );
 
diff --git a/deps.ts b/deps.ts
index ee3269f1..c07efe31 100644
--- a/deps.ts
+++ b/deps.ts
@@ -1,11 +1,17 @@
 export * as base64 from "https://deno.land/std@0.114.0/encoding/base64.ts";
+export * as hex from "https://deno.land/std@0.114.0/encoding/hex.ts";
 export * as date from "https://deno.land/std@0.114.0/datetime/mod.ts";
 export {
   BufReader,
   BufWriter,
 } from "https://deno.land/std@0.114.0/io/buffer.ts";
 export { copy } from "https://deno.land/std@0.114.0/bytes/mod.ts";
-export { Md5 } from "https://deno.land/std@0.120.0/hash/md5.ts";
+export { crypto } from "https://deno.land/std@0.114.0/crypto/mod.ts";
 export { deferred, delay } from "https://deno.land/std@0.114.0/async/mod.ts";
 export type { Deferred } from "https://deno.land/std@0.114.0/async/mod.ts";
 export { bold, yellow } from "https://deno.land/std@0.114.0/fmt/colors.ts";
+export {
+  fromFileUrl,
+  isAbsolute,
+  join as joinPath,
+} from "https://deno.land/std@0.114.0/path/mod.ts";
diff --git a/docker-compose.yml b/docker-compose.yml
index ae5e24be..fce86127 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -1,52 +1,83 @@
 version: '3.8'
 
+x-database-env:
+  &database-env
+  POSTGRES_DB: "postgres"
+  POSTGRES_PASSWORD: "postgres"
+  POSTGRES_USER: "postgres"
+
+x-test-env:
+  &test-env
+  WAIT_HOSTS: "postgres_clear:6000,postgres_md5:6001,postgres_scram:6002"
+  # Wait fifteen seconds after database goes online
+  # for database metadata initialization
+  WAIT_AFTER_HOSTS: "15"
+
+x-test-volumes:
+  &test-volumes
+  - /var/run/postgres_clear:/var/run/postgres_clear
+  - /var/run/postgres_md5:/var/run/postgres_md5
+  - /var/run/postgres_scram:/var/run/postgres_scram
+
 services:
   postgres_clear:
+    # Clear authentication was removed after Postgres 9
     image: postgres:9
     hostname: postgres
     environment:
-      - POSTGRES_DB=postgres
-      - POSTGRES_PASSWORD=postgres
-      - POSTGRES_USER=postgres
+      <<: *database-env
     volumes:
       - ./docker/postgres_clear/data/:/var/lib/postgresql/host/
       - ./docker/postgres_clear/init/:/docker-entrypoint-initdb.d/
+      - /var/run/postgres_clear:/var/run/postgresql
     ports:
-      - "6000:5432"
+      - "6000:6000"
+
   postgres_md5:
     image: postgres:14
     hostname: postgres
     environment:
-      - POSTGRES_DB=postgres
-      - POSTGRES_PASSWORD=postgres
-      - POSTGRES_USER=postgres
+      <<: *database-env
     volumes:
       - ./docker/postgres_md5/data/:/var/lib/postgresql/host/
       - ./docker/postgres_md5/init/:/docker-entrypoint-initdb.d/
+      - /var/run/postgres_md5:/var/run/postgresql
     ports:
-      - "6001:5432"
+      - "6001:6001"
+
   postgres_scram:
     image: postgres:14
     hostname: postgres_scram
     environment:
-      - POSTGRES_DB=postgres
-      - POSTGRES_HOST_AUTH_METHOD=scram-sha-256
-      - POSTGRES_INITDB_ARGS=--auth-host=scram-sha-256
-      - POSTGRES_PASSWORD=postgres
-      - POSTGRES_USER=postgres
+      <<: *database-env
+      POSTGRES_HOST_AUTH_METHOD: "scram-sha-256"
+      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
     volumes:
       - ./docker/postgres_scram/data/:/var/lib/postgresql/host/
       - ./docker/postgres_scram/init/:/docker-entrypoint-initdb.d/
+      - /var/run/postgres_scram:/var/run/postgresql
     ports:
-      - "6002:5432"
+      - "6002:6002"
+
   tests:
     build: .
+    # Name the image to be reused in no_check_tests
+    image: postgres/tests
+    command: sh -c "/wait && deno test --unstable -A --jobs"
     depends_on:
       - postgres_clear
       - postgres_md5
       - postgres_scram
     environment:
-      - WAIT_HOSTS=postgres_clear:5432,postgres_md5:5432,postgres_scram:5432
-      # Wait thirty seconds after database goes online
-      # For database metadata initialization
-      - WAIT_AFTER_HOSTS=15
+      <<: *test-env
+    volumes: *test-volumes
+
+  no_check_tests:
+    image: postgres/tests
+    command: sh -c "/wait && deno test --unstable -A --jobs --no-check"
+    depends_on:
+      - tests
+    environment:
+      <<: *test-env
+      NO_COLOR: "true"
+    volumes: *test-volumes
diff --git a/docker/postgres_clear/data/pg_hba.conf b/docker/postgres_clear/data/pg_hba.conf
index 4dbc2db5..a1be611b 100755
--- a/docker/postgres_clear/data/pg_hba.conf
+++ b/docker/postgres_clear/data/pg_hba.conf
@@ -2,4 +2,5 @@ hostssl     postgres    clear                 0.0.0.0/0  password
 hostnossl   postgres    clear                 0.0.0.0/0  password
 hostssl     all         postgres              0.0.0.0/0  md5
 hostnossl   all         postgres              0.0.0.0/0  md5
+local       postgres    socket                           md5
 
diff --git a/docker/postgres_clear/data/postgresql.conf b/docker/postgres_clear/data/postgresql.conf
index c94e3a22..e452c2d9 100755
--- a/docker/postgres_clear/data/postgresql.conf
+++ b/docker/postgres_clear/data/postgresql.conf
@@ -1,3 +1,4 @@
+port = 6000
 ssl = on
 ssl_cert_file = 'server.crt'
 ssl_key_file = 'server.key'
diff --git a/docker/postgres_clear/init/initialize_test_server.sql b/docker/postgres_clear/init/initialize_test_server.sql
index 137a4cc5..feb6e96e 100644
--- a/docker/postgres_clear/init/initialize_test_server.sql
+++ b/docker/postgres_clear/init/initialize_test_server.sql
@@ -1,2 +1,5 @@
 CREATE USER CLEAR WITH UNENCRYPTED PASSWORD 'postgres';
 GRANT ALL PRIVILEGES ON DATABASE POSTGRES TO CLEAR;
+
+CREATE USER SOCKET WITH UNENCRYPTED PASSWORD 'postgres';
+GRANT ALL PRIVILEGES ON DATABASE POSTGRES TO SOCKET;
diff --git a/docker/postgres_md5/data/pg_hba.conf b/docker/postgres_md5/data/pg_hba.conf
index 47653181..ee71900f 100755
--- a/docker/postgres_md5/data/pg_hba.conf
+++ b/docker/postgres_md5/data/pg_hba.conf
@@ -1,6 +1,6 @@
-hostssl     all         postgres              0.0.0.0/0  md5
-hostnossl   all         postgres              0.0.0.0/0  md5
 hostssl     postgres    md5                   0.0.0.0/0  md5
 hostnossl   postgres    md5                   0.0.0.0/0  md5
+hostssl     all         postgres              0.0.0.0/0  scram-sha-256
+hostnossl   all         postgres              0.0.0.0/0  scram-sha-256
 hostssl     postgres    tls_only              0.0.0.0/0  md5
-
+local       postgres    socket                           md5
diff --git a/docker/postgres_md5/data/postgresql.conf b/docker/postgres_md5/data/postgresql.conf
index c94e3a22..623d8653 100755
--- a/docker/postgres_md5/data/postgresql.conf
+++ b/docker/postgres_md5/data/postgresql.conf
@@ -1,3 +1,4 @@
+port = 6001
 ssl = on
 ssl_cert_file = 'server.crt'
 ssl_key_file = 'server.key'
diff --git a/docker/postgres_md5/init/initialize_test_server.sql b/docker/postgres_md5/init/initialize_test_server.sql
index a80978b7..286327f7 100644
--- a/docker/postgres_md5/init/initialize_test_server.sql
+++ b/docker/postgres_md5/init/initialize_test_server.sql
@@ -1,5 +1,5 @@
--- Create MD5 user and ensure password is stored as md5
--- They get created as SCRAM-SHA-256 in newer versions
+-- Create MD5 users and ensure password is stored as md5
+-- They get created as SCRAM-SHA-256 in newer postgres versions
 CREATE USER MD5 WITH ENCRYPTED PASSWORD 'postgres';
 GRANT ALL PRIVILEGES ON DATABASE POSTGRES TO MD5;
 
@@ -7,3 +7,9 @@ UPDATE PG_AUTHID
 SET ROLPASSWORD = 'md5'||MD5('postgres'||'md5')
 WHERE ROLNAME ILIKE 'MD5';
 
+CREATE USER SOCKET WITH ENCRYPTED PASSWORD 'postgres';
+GRANT ALL PRIVILEGES ON DATABASE POSTGRES TO SOCKET;
+
+UPDATE PG_AUTHID
+SET ROLPASSWORD = 'md5'||MD5('postgres'||'socket')
+WHERE ROLNAME ILIKE 'SOCKET';
diff --git a/docker/postgres_scram/data/pg_hba.conf b/docker/postgres_scram/data/pg_hba.conf
index 9e696ec6..37e4c119 100644
--- a/docker/postgres_scram/data/pg_hba.conf
+++ b/docker/postgres_scram/data/pg_hba.conf
@@ -1,2 +1,5 @@
-hostssl    postgres    scram       0.0.0.0/0  scram-sha-256
-hostnossl  postgres    scram       0.0.0.0/0  scram-sha-256
+hostssl     all         postgres              0.0.0.0/0  scram-sha-256
+hostnossl   all         postgres              0.0.0.0/0  scram-sha-256
+hostssl     postgres    scram                 0.0.0.0/0  scram-sha-256
+hostnossl   postgres    scram                 0.0.0.0/0  scram-sha-256
+local       postgres    socket                           scram-sha-256
diff --git a/docker/postgres_scram/data/postgresql.conf b/docker/postgres_scram/data/postgresql.conf
index 516110b2..f100b563 100644
--- a/docker/postgres_scram/data/postgresql.conf
+++ b/docker/postgres_scram/data/postgresql.conf
@@ -1,4 +1,5 @@
 password_encryption = scram-sha-256
+port = 6002
 ssl = on
 ssl_cert_file = 'server.crt'
 ssl_key_file = 'server.key'
\ No newline at end of file
diff --git a/docker/postgres_scram/init/initialize_test_server.sql b/docker/postgres_scram/init/initialize_test_server.sql
index 4472ffa5..438bc3ac 100644
--- a/docker/postgres_scram/init/initialize_test_server.sql
+++ b/docker/postgres_scram/init/initialize_test_server.sql
@@ -1,2 +1,5 @@
 CREATE USER SCRAM WITH ENCRYPTED PASSWORD 'postgres';
 GRANT ALL PRIVILEGES ON DATABASE POSTGRES TO SCRAM;
+
+CREATE USER SOCKET WITH ENCRYPTED PASSWORD 'postgres';
+GRANT ALL PRIVILEGES ON DATABASE POSTGRES TO SOCKET;
diff --git a/docs/README.md b/docs/README.md
index 3f099bb1..87f7be66 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 ![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.14.3/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.15.0/mod.ts)
 ![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)
 
 `deno-postgres` is a lightweight PostgreSQL driver for Deno focused on user
@@ -11,7 +11,7 @@ experience. It provides abstractions for most common operations such as typed
 queries, prepared statements, connection pools and transactions.
 
 ```ts
-import { Client } from "https://deno.land/x/postgres/mod.ts";
+import { Client } from "https://deno.land/x/postgres@v0.15.0/mod.ts";
 
 const client = new Client({
   user: "user",
@@ -38,7 +38,7 @@ All `deno-postgres` clients provide the following options to authenticate and
 manage your connections
 
 ```ts
-import { Client } from "https://deno.land/x/postgres/mod.ts";
+import { Client } from "https://deno.land/x/postgres@v0.15.0/mod.ts";
 
 let config;
 
@@ -50,6 +50,7 @@ config = {
   },
   database: "test",
   hostname: "localhost",
+  host_type: "tcp",
   password: "password",
   port: 5432,
   user: "user",
@@ -67,15 +68,55 @@ await client.connect();
 await client.end();
 ```
 
+### Connection defaults
+
+The only required parameters for stablishing connection with your database are
+the database name and your user, the rest of them have sensible defaults to save
+up time when configuring your connection, such as the following:
+
+- connection.attempts: "1"
+- hostname: If host_type is set to TCP, it will be "127.0.0.1". Otherwise, it
+  will default to the "/tmp" folder to look for a socket connection
+- host_type: "socket", unless a host is manually specified
+- password: blank
+- port: "5432"
+- tls.enable: "true"
+- tls.enforce: "false"
+
 ### Connection string
 
-A valid connection string must reflect most of the options that will otherwise
-be available in a client configuration, with the following structure:
+Many services provide a connection string as a global format to connect to your
+database, and `deno-postgres` makes it easy to integrate this into your code by
+parsing the options in your connection string as if it was an options object
+
+You can create your own connection string by using the following structure:
 
 ```
 driver://user:password@host:port/database_name
+
+driver://host:port/database_name?user=user&password=password&application_name=my_app
 ```
 
+#### URL parameters
+
+Additional to the basic URI structure, connection strings may contain a variety
+of search parameters such as the following:
+
+- application_name: The equivalent of applicationName in client configuration
+- dbname: If database is not specified on the url path, this will be taken
+  instead
+- host: If host is not specified in the url, this will be taken instead
+- password: If password is not specified in the url, this will be taken instead
+- port: If port is not specified in the url, this will be taken instead
+- sslmode: Allows you to specify the tls configuration for your client, the
+  allowed values are the following:
+  - disable: Skip TLS connection altogether
+  - prefer: Attempt to stablish a TLS connection, default to unencrypted if the
+    negotiation fails
+  - require: Attempt to stablish a TLS connection, abort the connection if the
+    negotiation fails
+- user: If user is not specified in the url, this will be taken instead
+
 #### Password encoding
 
 One thing that must be taken into consideration is that passwords contained
@@ -93,25 +134,11 @@ and passing your password as an argument.
 - `postgres://me:Mtx%253@localhost:5432/my_database`
 - `postgres://me:p%C3%A1ssword!%3Dwith_symbols@localhost:5432/my_database`
 
-When possible and if the password is not encoded correctly, the driver will try
-and pass the raw password to the database, however it's highly recommended that
-all passwords are always encoded.
+If the password is not encoded correctly, the driver will try and pass the raw
+password to the database, however it's highly recommended that all passwords are
+always encoded to prevent authentication errors
 
-#### URL parameters
-
-Additional to the basic structure, connection strings may contain a variety of
-search parameters such as the following:
-
-- application_name: The equivalent of applicationName in client configuration
-- sslmode: Allows you to specify the tls configuration for your client, the
-  allowed values are the following:
-  - disable: Skip TLS connection altogether
-  - prefer: Attempt to stablish a TLS connection, default to unencrypted if the
-    negotiation fails
-  - require: Attempt to stablish a TLS connection, abort the connection if the
-    negotiation fails
-
-#### Database reconnection
+### Database reconnection
 
 It's a very common occurrence to get broken connections due to connectivity
 issues or OS related problems, however while this may be a minor inconvenience
@@ -165,7 +192,96 @@ to your database in the first attempt, the client will keep trying to connect as
 many times as requested, meaning that if your attempt configuration is three,
 your total first-connection-attempts will ammount to four.
 
-#### SSL/TLS connection
+### Unix socket connection
+
+On Unix systems, it's possible to connect to your database through IPC sockets
+instead of TCP by providing the route to the socket file your Postgres database
+creates automatically. You can manually set the protocol used with the
+`host_type` property in the client options
+
+**Note**: This functionality is only available on UNIX systems under the
+`--unstable` flag
+
+In order to connect to the socket you can pass the path as a host in the client
+initialization. Alternatively, you can specify the port the database is
+listening on and the parent folder of the socket as a host (The equivalent of
+Postgres' `unix_socket_directory` option), this way the client will try and
+guess the name for the socket file based on Postgres' defaults
+
+Instead of requiring net access, to connect an IPC socket you need read and
+write permissions to the socket file (You will need read permissions to the
+folder containing the socket in case you specified the socket folder as a path)
+
+If you provide no host when initializing a client it will instead lookup the
+socket file in your `/tmp` folder (In some Linux distributions such as Debian,
+the default route for the socket file is `/var/run/postgresql`), unless you
+specify the protocol as `tcp`, in which case it will try and connect to
+`127.0.0.1` by default
+
+```ts
+{
+  // Will connect to some_host.com using TCP
+  const client = new Client({
+    database: "some_db",
+    hostname: "https://some_host.com",
+    user: "some_user",
+  });
+}
+
+{
+  // Will look for the socket file 6000 in /tmp
+  const client = new Client({
+    database: "some_db",
+    port: 6000,
+    user: "some_user",
+  });
+}
+
+{
+  // Will try an connect to socket_folder:6000 using TCP
+  const client = new Client({
+    database: "some_db",
+    hostname: "socket_folder",
+    port: 6000,
+    user: "some_user",
+  });
+}
+
+{
+  // Will look for the socket file 6000 in ./socket_folder
+  const client = new Client({
+    database: "some_db",
+    hostname: "socket_folder",
+    host_type: "socket",
+    port: 6000,
+    user: "some_user",
+  });
+}
+```
+
+Per https://www.postgresql.org/docs/14/libpq-connect.html#LIBPQ-CONNSTRING, to
+connect to a unix socket using a connection string, you need to URI encode the
+absolute path in order for it to be recognized. Otherwise, it will be treated as
+a TCP host.
+
+```ts
+const path = "/var/run/postgresql";
+
+const client = new Client(
+  // postgres://user:password@%2Fvar%2Frun%2Fpostgresql:port/database_name
+  `postgres://user:password@${encodeURIComponent(path)}:port/database_name`,
+);
+```
+
+Additionally you can specify the host using the `host` URL parameter
+
+```ts
+const client = new Client(
+  `postgres://user:password@:port/database_name?host=/var/run/postgresql`,
+);
+```
+
+### SSL/TLS connection
 
 Using a database that supports TLS is quite simple. After providing your
 connection parameters, the client will check if the database accepts encrypted
@@ -188,7 +304,7 @@ connection string. Although discouraged, this option is pretty useful when
 dealing with development databases or versions of Postgres that didn't support
 TLS encrypted connections.
 
-##### About invalid and custom TLS certificates
+#### About invalid and custom TLS certificates
 
 There is a miriad of factors you have to take into account when using a
 certificate to encrypt your connection that, if not taken care of, can render
@@ -220,7 +336,7 @@ TLS can be disabled from your server by editing your `postgresql.conf` file and
 setting the `ssl` option to `off`, or in the driver side by using the "disabled"
 option in the client configuration.
 
-#### Env parameters
+### Env parameters
 
 The values required to connect to the database can be read directly from
 environmental variables, given the case that the user doesn't provide them while
@@ -240,7 +356,7 @@ await client.connect();
 await client.end();
 ```
 
-### Clients (Single clients)
+## Connection Client
 
 Clients are the most basic block for establishing communication with your
 database. They provide abstractions over queries, transactions and connection
@@ -285,7 +401,7 @@ connections are a synonym for session, which means that temporal operations such
 as the creation of temporal tables or the use of the `PG_TEMP` schema will not
 be persisted after your connection is terminated.
 
-### Pools
+## Connection Pools
 
 For stronger management and scalability, you can use **pools**:
 
@@ -380,14 +496,12 @@ async function runQuery(query: string) {
   return result;
 }
 
-await runQuery("SELECT ID, NAME FROM users"); // [{id: 1, name: 'Carlos'}, {id: 2, name: 'John'}, ...]
-await runQuery("SELECT ID, NAME FROM users WHERE id = '1'"); // [{id: 1, name: 'Carlos'}, {id: 2, name: 'John'}, ...]
+await runQuery("SELECT ID, NAME FROM USERS"); // [{id: 1, name: 'Carlos'}, {id: 2, name: 'John'}, ...]
+await runQuery("SELECT ID, NAME FROM USERS WHERE ID = '1'"); // [{id: 1, name: 'Carlos'}, {id: 2, name: 'John'}, ...]
 ```
 
 ## Executing queries
 
-### Executing simple queries
-
 Executing a query is as simple as providing the raw SQL to your client, it will
 automatically be queued, validated and processed so you can get a human
 readable, blazing fast result
@@ -397,36 +511,84 @@ const result = await client.queryArray("SELECT ID, NAME FROM PEOPLE");
 console.log(result.rows); // [[1, "Laura"], [2, "Jason"]]
 ```
 
-### Executing prepared statements
+### Prepared statements and query arguments
 
 Prepared statements are a Postgres mechanism designed to prevent SQL injection
 and maximize query performance for multiple queries (see
-https://security.stackexchange.com/questions/15214/are-prepared-statements-100-safe-against-sql-injection).
+https://security.stackexchange.com/questions/15214/are-prepared-statements-100-safe-against-sql-injection)
+
 The idea is simple, provide a base sql statement with placeholders for any
-variables required, and then provide said variables as arguments for the query
-call
+variables required, and then provide said variables in an array of arguments
 
 ```ts
 // Example using the simplified argument interface
 {
   const result = await client.queryArray(
     "SELECT ID, NAME FROM PEOPLE WHERE AGE > $1 AND AGE < $2",
-    10,
-    20,
+    [10, 20],
   );
   console.log(result.rows);
 }
 
-// Example using the advanced query interface
 {
   const result = await client.queryArray({
-    text: "SELECT ID, NAME FROM PEOPLE WHERE AGE > $1 AND AGE < $2",
     args: [10, 20],
+    text: "SELECT ID, NAME FROM PEOPLE WHERE AGE > $1 AND AGE < $2",
+  });
+  console.log(result.rows);
+}
+```
+
+#### Named arguments
+
+Alternatively, you can provide such placeholders in the form of variables to be
+replaced at runtime with an argument object
+
+```ts
+{
+  const result = await client.queryArray(
+    "SELECT ID, NAME FROM PEOPLE WHERE AGE > $MIN AND AGE < $MAX",
+    { min: 10, max: 20 },
+  );
+  console.log(result.rows);
+}
+
+{
+  const result = await client.queryArray({
+    args: { min: 10, max: 20 },
+    text: "SELECT ID, NAME FROM PEOPLE WHERE AGE > $MIN AND AGE < $MAX",
   });
   console.log(result.rows);
 }
 ```
 
+Behind the scenes, `deno-postgres` will replace the variables names in your
+query for Postgres-readable placeholders making it easy to reuse values in
+multiple places in your query
+
+```ts
+{
+  const result = await client.queryArray(
+    `SELECT
+			ID,
+			NAME||LASTNAME
+		FROM PEOPLE
+		WHERE NAME ILIKE $SEARCH
+		OR LASTNAME ILIKE $SEARCH`,
+    { search: "JACKSON" },
+  );
+  console.log(result.rows);
+}
+```
+
+The placeholders in the query will be looked up in the argument object without
+taking case into account, so having a variable named `$Value` and an object
+argument like `{value: 1}` will still match the values together
+
+**Note**: This feature has a little overhead when compared to the array of
+arguments, since it needs to transform the SQL and validate the structure of the
+arguments object
+
 #### Template strings
 
 Even thought the previous call is already pretty simple, it can be simplified
diff --git a/mod.ts b/mod.ts
index 9bc1eb03..f72d5d0d 100644
--- a/mod.ts
+++ b/mod.ts
@@ -17,6 +17,6 @@ export type {
 } from "./connection/connection_params.ts";
 export type { Session } from "./client.ts";
 export { PoolClient, QueryClient } from "./client.ts";
-export type { QueryConfig, QueryObjectConfig } from "./query/query.ts";
+export type { QueryObjectOptions, QueryOptions } from "./query/query.ts";
 export { Savepoint, Transaction } from "./query/transaction.ts";
 export type { TransactionOptions } from "./query/transaction.ts";
diff --git a/pool.ts b/pool.ts
index 76075ced..0c2a6edd 100644
--- a/pool.ts
+++ b/pool.ts
@@ -14,6 +14,8 @@ import { DeferredAccessStack } from "./utils/deferred.ts";
  * with their PostgreSQL database
  *
  * ```ts
+ * import { Pool } from "./pool.ts";
+ *
  * const pool = new Pool({
  *   database: "database",
  *   hostname: "hostname",
@@ -33,9 +35,11 @@ import { DeferredAccessStack } from "./utils/deferred.ts";
  * available connections in the pool
  *
  * ```ts
+ * import { Pool } from "./pool.ts";
+ *
  * // Creates a pool with 10 max available connections
  * // Connection with the database won't be established until the user requires it
- * const pool = new Pool(connection_params, 10, true);
+ * const pool = new Pool({}, 10, true);
  *
  * // Connection is created here, will be available from now on
  * const client_1 = await pool.connect();
@@ -112,7 +116,10 @@ export class Pool {
    * with the database if no other connections are available
    *
    * ```ts
-   * const client = pool.connect();
+   * import { Pool } from "./pool.ts";
+   *
+   * const pool = new Pool({}, 10);
+   * const client = await pool.connect();
    * await client.queryArray`UPDATE MY_TABLE SET X = 1`;
    * client.release();
    * ```
@@ -131,8 +138,12 @@ export class Pool {
    * This will close all open connections and set a terminated status in the pool
    *
    * ```ts
+   * import { Pool } from "./pool.ts";
+   *
+   * const pool = new Pool({}, 10);
+   *
    * await pool.end();
-   * assertEquals(pool.available, 0);
+   * console.assert(pool.available === 0, "There are connections available after ending the pool");
    * await pool.end(); // An exception will be thrown, pool doesn't have any connections to close
    * ```
    *
@@ -140,10 +151,13 @@ export class Pool {
    * will reinitialize the connections according to the original configuration of the pool
    *
    * ```ts
+   * import { Pool } from "./pool.ts";
+   *
+   * const pool = new Pool({}, 10);
    * await pool.end();
    * const client = await pool.connect();
    * await client.queryArray`SELECT 1`; // Works!
-   * await client.close();
+   * await client.release();
    * ```
    */
   async end(): Promise<void> {
diff --git a/query/encode.ts b/query/encode.ts
index df736913..6a6b8172 100644
--- a/query/encode.ts
+++ b/query/encode.ts
@@ -63,7 +63,7 @@ function encodeArray(array: Array<unknown>): string {
       // TODO: it should be encoded as bytea?
       throw new Error("Can't encode array of buffers.");
     } else {
-      const encodedElement = encode(element);
+      const encodedElement = encodeArgument(element);
       encodedArray += escapeArrayElement(encodedElement as string);
     }
   });
@@ -81,7 +81,7 @@ function encodeBytes(value: Uint8Array): string {
 
 export type EncodedArg = null | string | Uint8Array;
 
-export function encode(value: unknown): EncodedArg {
+export function encodeArgument(value: unknown): EncodedArg {
   if (value === null || typeof value === "undefined") {
     return null;
   } else if (value instanceof Uint8Array) {
diff --git a/query/query.ts b/query/query.ts
index d0ca0f05..5c3f755b 100644
--- a/query/query.ts
+++ b/query/query.ts
@@ -1,7 +1,31 @@
-import { encode, EncodedArg } from "./encode.ts";
+import { encodeArgument, EncodedArg } from "./encode.ts";
 import { Column, decode } from "./decode.ts";
 import { Notice } from "../connection/message.ts";
 
+// TODO
+// Limit the type of parameters that can be passed
+// to a query
+/**
+ * https://www.postgresql.org/docs/14/sql-prepare.html
+ *
+ * This arguments will be appended to the prepared statement passed
+ * as query
+ *
+ * They will take the position according to the order in which they were provided
+ *
+ * ```ts
+ * import { Client } from "../client.ts";
+ *
+ * const my_client = new Client();
+ *
+ * await my_client.queryArray("SELECT ID, NAME FROM PEOPLE WHERE AGE > $1 AND AGE < $2", [
+ *   10, // $1
+ *   20, // $2
+ * ]);
+ * ```
+ */
+export type QueryArguments = unknown[] | Record<string, unknown>;
+
 const commandTagRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;
 
 type CommandType = (
@@ -33,18 +57,61 @@ export class RowDescription {
  */
 export function templateStringToQuery<T extends ResultType>(
   template: TemplateStringsArray,
-  args: QueryArguments,
+  args: unknown[],
   result_type: T,
 ): Query<T> {
   const text = template.reduce((curr, next, index) => {
     return `${curr}$${index}${next}`;
   });
 
-  return new Query(text, result_type, ...args);
+  return new Query(text, result_type, args);
+}
+
+function objectQueryToQueryArgs(
+  query: string,
+  args: Record<string, unknown>,
+): [string, unknown[]] {
+  args = normalizeObjectQueryArgs(args);
+
+  let counter = 0;
+  const clean_args: unknown[] = [];
+  const clean_query = query.replaceAll(/(?<=\$)\w+/g, (match) => {
+    match = match.toLowerCase();
+    if (match in args) {
+      clean_args.push(args[match]);
+    } else {
+      throw new Error(
+        `No value was provided for the query argument "${match}"`,
+      );
+    }
+
+    return String(++counter);
+  });
+
+  return [clean_query, clean_args];
+}
+
+/** This function lowercases all the keys of the object passed to it and checks for collission names */
+function normalizeObjectQueryArgs(
+  args: Record<string, unknown>,
+): Record<string, unknown> {
+  const normalized_args = Object.fromEntries(
+    Object.entries(args).map((
+      [key, value],
+    ) => [key.toLowerCase(), value]),
+  );
+
+  if (Object.keys(normalized_args).length !== Object.keys(args).length) {
+    throw new Error(
+      "The arguments provided for the query must be unique (insensitive)",
+    );
+  }
+
+  return normalized_args;
 }
 
-export interface QueryConfig {
-  args?: Array<unknown>;
+export interface QueryOptions {
+  args?: QueryArguments;
   encoder?: (arg: unknown) => EncodedArg;
   name?: string;
   // TODO
@@ -52,9 +119,9 @@ export interface QueryConfig {
   text: string;
 }
 
-// TODO
-// Support multiple case options
-export interface QueryObjectConfig extends QueryConfig {
+export interface QueryObjectOptions extends QueryOptions {
+  // TODO
+  // Support multiple case options
   /**
    * Enabling camelcase will transform any snake case field names coming from the database into camel case ones
    *
@@ -75,28 +142,6 @@ export interface QueryObjectConfig extends QueryConfig {
   fields?: string[];
 }
 
-// TODO
-// Limit the type of parameters that can be passed
-// to a query
-/**
- * https://www.postgresql.org/docs/14/sql-prepare.html
- *
- * This arguments will be appended to the prepared statement passed
- * as query
- *
- * They will take the position according to the order in which they were provided
- *
- * ```ts
- * await my_client.queryArray(
- *  "SELECT ID, NAME FROM PEOPLE WHERE AGE > $1 AND AGE < $2",
- *  10, // $1
- *  20, // $2
- * );
- * ```
- */
-// deno-lint-ignore no-explicit-any
-export type QueryArguments = any[];
-
 export class QueryResult {
   public command!: CommandType;
   public rowCount?: number;
@@ -294,25 +339,36 @@ export class Query<T extends ResultType> {
    * for duplicates and invalid names
    */
   public fields?: string[];
+  // TODO
+  // Should be private
   public result_type: ResultType;
+  // TODO
+  // Document that this text is the one sent to the database, not the original one
   public text: string;
-  constructor(config: QueryObjectConfig, result_type: T);
-  constructor(text: string, result_type: T, ...args: unknown[]);
+  constructor(config: QueryObjectOptions, result_type: T);
+  constructor(text: string, result_type: T, args?: QueryArguments);
   constructor(
-    config_or_text: string | QueryObjectConfig,
+    config_or_text: string | QueryObjectOptions,
     result_type: T,
-    ...args: unknown[]
+    args: QueryArguments = [],
   ) {
     this.result_type = result_type;
-
-    let config: QueryConfig;
     if (typeof config_or_text === "string") {
-      config = { text: config_or_text, args };
+      if (!Array.isArray(args)) {
+        [config_or_text, args] = objectQueryToQueryArgs(config_or_text, args);
+      }
+
+      this.text = config_or_text;
+      this.args = args.map(encodeArgument);
     } else {
-      const {
-        fields,
+      let {
+        args = [],
         camelcase,
-        ...query_config
+        encoder = encodeArgument,
+        fields,
+        // deno-lint-ignore no-unused-vars
+        name,
+        text,
       } = config_or_text;
 
       // Check that the fields passed are valid and can be used to map
@@ -337,14 +393,13 @@ export class Query<T extends ResultType> {
       }
 
       this.camelcase = camelcase;
-      config = query_config;
-    }
-    this.text = config.text;
-    this.args = this.#prepareArgs(config);
-  }
 
-  #prepareArgs(config: QueryConfig): EncodedArg[] {
-    const encodingFn = config.encoder ? config.encoder : encode;
-    return (config.args || []).map(encodingFn);
+      if (!Array.isArray(args)) {
+        [text, args] = objectQueryToQueryArgs(text, args);
+      }
+
+      this.args = args.map(encoder);
+      this.text = text;
+    }
   }
 }
diff --git a/query/transaction.ts b/query/transaction.ts
index 9a3017ab..99b0cb92 100644
--- a/query/transaction.ts
+++ b/query/transaction.ts
@@ -3,9 +3,9 @@ import {
   Query,
   QueryArguments,
   QueryArrayResult,
-  QueryConfig,
-  QueryObjectConfig,
+  QueryObjectOptions,
   QueryObjectResult,
+  QueryOptions,
   QueryResult,
   ResultType,
   templateStringToQuery,
@@ -38,6 +38,11 @@ export class Savepoint {
    * Releasing a savepoint will remove it's last instance in the transaction
    *
    * ```ts
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * const savepoint = await transaction.savepoint("n1");
    * await savepoint.release();
    * transaction.rollback(savepoint); // Error, can't rollback because the savepoint was released
@@ -45,7 +50,12 @@ export class Savepoint {
    *
    * It will also allow you to set the savepoint to the position it had before the last update
    *
-   * * ```ts
+   * ```ts
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * const savepoint = await transaction.savepoint("n1");
    * await savepoint.update();
    * await savepoint.release(); // This drops the update of the last statement
@@ -67,6 +77,13 @@ export class Savepoint {
    * Updating a savepoint will update its position in the transaction execution
    *
    * ```ts
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
+   * const my_value = "some value";
+   *
    * const savepoint = await transaction.savepoint("n1");
    * transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES (${my_value})`;
    * await savepoint.update(); // Rolling back will now return you to this point on the transaction
@@ -75,6 +92,11 @@ export class Savepoint {
    * You can also undo a savepoint update by using the `release` method
    *
    * ```ts
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * const savepoint = await transaction.savepoint("n1");
    * transaction.queryArray`DELETE FROM VERY_IMPORTANT_TABLE`;
    * await savepoint.update(); // Oops, shouldn't have updated the savepoint
@@ -147,7 +169,11 @@ export class Transaction {
    * The begin method will officially begin the transaction, and it must be called before
    * any query or transaction operation is executed in order to lock the session
    * ```ts
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
    * const transaction = client.createTransaction("transaction_name");
+   *
    * await transaction.begin(); // Session is locked, transaction operations are now safe
    * // Important operations
    * await transaction.commit(); // Session is unlocked, external operations can now take place
@@ -219,6 +245,11 @@ export class Transaction {
    * current transaction and end the current transaction
    *
    * ```ts
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * await transaction.begin();
    * // Important operations
    * await transaction.commit(); // Will terminate the transaction and save all changes
@@ -228,10 +259,14 @@ export class Transaction {
    * start a new with the same transaction parameters in a single statement
    *
    * ```ts
-   * // ...
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * // Transaction operations I want to commit
    * await transaction.commit({ chain: true }); // All changes are saved, following statements will be executed inside a transaction
-   * await transaction.query`DELETE SOMETHING FROM SOMEWHERE`; // Still inside the transaction
+   * await transaction.queryArray`DELETE SOMETHING FROM SOMEWHERE`; // Still inside the transaction
    * await transaction.commit(); // The transaction finishes for good
    * ```
    *
@@ -280,6 +315,12 @@ export class Transaction {
    * the snapshot state between two transactions
    *
    * ```ts
+   * import { Client } from "../client.ts";
+   *
+   * const client_1 = new Client();
+   * const client_2 = new Client();
+   * const transaction_1 = client_1.createTransaction("transaction");
+   *
    * const snapshot = await transaction_1.getSnapshot();
    * const transaction_2 = client_2.createTransaction("new_transaction", { isolation_level: "repeatable_read", snapshot });
    * // transaction_2 now shares the same starting state that transaction_1 had
@@ -299,6 +340,11 @@ export class Transaction {
    * It supports a generic interface in order to type the entries retrieved by the query
    *
    * ```ts
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * const {rows} = await transaction.queryArray(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<unknown[]>
@@ -306,7 +352,12 @@ export class Transaction {
    *
    * You can pass type arguments to the query in order to hint TypeScript what the return value will be
    * ```ts
-   * const {rows} = await transaction.queryArray<[number, string]>(
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
+   * const { rows } = await transaction.queryArray<[number, string]>(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<[number, string]>
    * ```
@@ -314,31 +365,40 @@ export class Transaction {
    * It also allows you to execute prepared stamements with template strings
    *
    * ```ts
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * const id = 12;
    * // Array<[number, string]>
-   * const {rows} = await transaction.queryArray<[number, string]>`SELECT ID, NAME FROM CLIENTS WHERE ID = ${id}`;
+   * const { rows } = await transaction.queryArray<[number, string]>`SELECT ID, NAME FROM CLIENTS WHERE ID = ${id}`;
    * ```
    */
   async queryArray<T extends Array<unknown>>(
     query: string,
-    ...args: QueryArguments
+    args?: QueryArguments,
   ): Promise<QueryArrayResult<T>>;
   async queryArray<T extends Array<unknown>>(
-    config: QueryConfig,
+    config: QueryOptions,
   ): Promise<QueryArrayResult<T>>;
   async queryArray<T extends Array<unknown>>(
     strings: TemplateStringsArray,
-    ...args: QueryArguments
+    ...args: unknown[]
   ): Promise<QueryArrayResult<T>>;
   async queryArray<T extends Array<unknown> = Array<unknown>>(
-    query_template_or_config: TemplateStringsArray | string | QueryConfig,
-    ...args: QueryArguments
+    query_template_or_config: TemplateStringsArray | string | QueryOptions,
+    ...args: unknown[] | [QueryArguments | undefined]
   ): Promise<QueryArrayResult<T>> {
     this.#assertTransactionOpen();
 
     let query: Query<ResultType.ARRAY>;
     if (typeof query_template_or_config === "string") {
-      query = new Query(query_template_or_config, ResultType.ARRAY, ...args);
+      query = new Query(
+        query_template_or_config,
+        ResultType.ARRAY,
+        args as QueryArguments | undefined,
+      );
     } else if (isTemplateString(query_template_or_config)) {
       query = templateStringToQuery(
         query_template_or_config,
@@ -366,36 +426,59 @@ export class Transaction {
    * It supports a generic interface in order to type the entries retrieved by the query
    *
    * ```ts
-   * const {rows} = await transaction.queryObject(
-   *  "SELECT ID, NAME FROM CLIENTS"
-   * ); // Record<string, unknown>
-   *
-   * const {rows} = await transaction.queryObject<{id: number, name: string}>(
-   *  "SELECT ID, NAME FROM CLIENTS"
-   * ); // Array<{id: number, name: string}>
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
+   * {
+   *   const { rows } = await transaction.queryObject(
+   *     "SELECT ID, NAME FROM CLIENTS"
+   *   ); // Record<string, unknown>
+   * }
+   *
+   * {
+   *   const { rows } = await transaction.queryObject<{id: number, name: string}>(
+   *     "SELECT ID, NAME FROM CLIENTS"
+   *   ); // Array<{id: number, name: string}>
+   * }
    * ```
    *
    * You can also map the expected results to object fields using the configuration interface.
    * This will be assigned in the order they were provided
    *
    * ```ts
-   * const {rows} = await transaction.queryObject(
-   *  "SELECT ID, NAME FROM CLIENTS"
-   * );
+   * import { Client } from "../client.ts";
    *
-   * console.log(rows); // [{id: 78, name: "Frank"}, {id: 15, name: "Sarah"}]
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
    *
-   * const {rows} = await transaction.queryObject({
-   *  text: "SELECT ID, NAME FROM CLIENTS",
-   *  fields: ["personal_id", "complete_name"],
-   * });
+   * {
+   *   const { rows } = await transaction.queryObject(
+   *     "SELECT ID, NAME FROM CLIENTS"
+   *   );
    *
-   * console.log(rows); // [{personal_id: 78, complete_name: "Frank"}, {personal_id: 15, complete_name: "Sarah"}]
+   *   console.log(rows); // [{id: 78, name: "Frank"}, {id: 15, name: "Sarah"}]
+   * }
+   *
+   * {
+   *   const { rows } = await transaction.queryObject({
+   *     text: "SELECT ID, NAME FROM CLIENTS",
+   *     fields: ["personal_id", "complete_name"],
+   *   });
+   *
+   *   console.log(rows); // [{personal_id: 78, complete_name: "Frank"}, {personal_id: 15, complete_name: "Sarah"}]
+   * }
    * ```
    *
    * It also allows you to execute prepared stamements with template strings
    *
    * ```ts
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * const id = 12;
    * // Array<{id: number, name: string}>
    * const {rows} = await transaction.queryObject<{id: number, name: string}>`SELECT ID, NAME FROM CLIENTS WHERE ID = ${id}`;
@@ -403,29 +486,33 @@ export class Transaction {
    */
   async queryObject<T>(
     query: string,
-    ...args: QueryArguments
+    args?: QueryArguments,
   ): Promise<QueryObjectResult<T>>;
   async queryObject<T>(
-    config: QueryObjectConfig,
+    config: QueryObjectOptions,
   ): Promise<QueryObjectResult<T>>;
   async queryObject<T>(
     query: TemplateStringsArray,
-    ...args: QueryArguments
+    ...args: unknown[]
   ): Promise<QueryObjectResult<T>>;
   async queryObject<
     T = Record<string, unknown>,
   >(
     query_template_or_config:
       | string
-      | QueryObjectConfig
+      | QueryObjectOptions
       | TemplateStringsArray,
-    ...args: QueryArguments
+    ...args: unknown[] | [QueryArguments | undefined]
   ): Promise<QueryObjectResult<T>> {
     this.#assertTransactionOpen();
 
     let query: Query<ResultType.OBJECT>;
     if (typeof query_template_or_config === "string") {
-      query = new Query(query_template_or_config, ResultType.OBJECT, ...args);
+      query = new Query(
+        query_template_or_config,
+        ResultType.OBJECT,
+        args[0] as QueryArguments | undefined,
+      );
     } else if (isTemplateString(query_template_or_config)) {
       query = templateStringToQuery(
         query_template_or_config,
@@ -434,7 +521,7 @@ export class Transaction {
       );
     } else {
       query = new Query(
-        query_template_or_config as QueryObjectConfig,
+        query_template_or_config as QueryObjectOptions,
         ResultType.OBJECT,
       );
     }
@@ -457,7 +544,11 @@ export class Transaction {
    *
    * A rollback can be executed the following way
    * ```ts
-   * // ...
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * // Very very important operations that went very, very wrong
    * await transaction.rollback(); // Like nothing ever happened
    * ```
@@ -466,7 +557,11 @@ export class Transaction {
    * but it can be used in conjuction with the savepoint feature to rollback specific changes like the following
    *
    * ```ts
-   * // ...
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * // Important operations I don't want to rollback
    * const savepoint = await transaction.savepoint("before_disaster");
    * await transaction.queryArray`UPDATE MY_TABLE SET X = 0`; // Oops, update without where
@@ -479,10 +574,14 @@ export class Transaction {
    * but to restart it with the same parameters in a single statement
    *
    * ```ts
-   * // ...
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
    * // Transaction operations I want to undo
    * await transaction.rollback({ chain: true }); // All changes are undone, but the following statements will be executed inside a transaction as well
-   * await transaction.query`DELETE SOMETHING FROM SOMEWHERE`; // Still inside the transaction
+   * await transaction.queryArray`DELETE SOMETHING FROM SOMEWHERE`; // Still inside the transaction
    * await transaction.commit(); // The transaction finishes for good
    * ```
    *
@@ -492,7 +591,13 @@ export class Transaction {
    * and start from scratch
    *
    * ```ts
-   * await transaction.rollback({ chain: true, savepoint: my_savepoint }); // Error, can't both return to savepoint and reset transaction
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
+   * // @ts-expect-error
+   * await transaction.rollback({ chain: true, savepoint: "my_savepoint" }); // Error, can't both return to savepoint and reset transaction
    * ```
    * https://www.postgresql.org/docs/14/sql-rollback.html
    */
@@ -588,14 +693,24 @@ export class Transaction {
    *
    * A savepoint can be easily created like this
    * ```ts
-   * const savepoint = await transaction.save("MY_savepoint"); // returns a `Savepoint` with name "my_savepoint"
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
+   * const savepoint = await transaction.savepoint("MY_savepoint"); // returns a `Savepoint` with name "my_savepoint"
    * await transaction.rollback(savepoint);
    * await savepoint.release(); // The savepoint will be removed
    * ```
    * All savepoints can have multiple positions in a transaction, and you can change or update
    * this positions by using the `update` and `release` methods
    * ```ts
-   * const savepoint = await transaction.save("n1");
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
+   * const savepoint = await transaction.savepoint("n1");
    * await transaction.queryArray`INSERT INTO MY_TABLE VALUES (${'A'}, ${2})`;
    * await savepoint.update(); // The savepoint will continue from here
    * await transaction.queryArray`DELETE FROM MY_TABLE`;
@@ -608,9 +723,14 @@ export class Transaction {
    * Creating a new savepoint with an already used name will return you a reference to
    * the original savepoint
    * ```ts
-   * const savepoint_a = await transaction.save("a");
+   * import { Client } from "../client.ts";
+   *
+   * const client = new Client();
+   * const transaction = client.createTransaction("transaction");
+   *
+   * const savepoint_a = await transaction.savepoint("a");
    * await transaction.queryArray`DELETE FROM MY_TABLE`;
-   * const savepoint_b = await transaction.save("a"); // They will be the same savepoint, but the savepoint will be updated to this position
+   * const savepoint_b = await transaction.savepoint("a"); // They will be the same savepoint, but the savepoint will be updated to this position
    * await transaction.rollback(savepoint_a); // Rolls back to savepoint_b
    * ```
    * https://www.postgresql.org/docs/14/sql-savepoint.html
diff --git a/tests/auth_test.ts b/tests/auth_test.ts
index 0c1131df..f7ed38db 100644
--- a/tests/auth_test.ts
+++ b/tests/auth_test.ts
@@ -1,8 +1,4 @@
-import {
-  assertEquals,
-  assertNotEquals,
-  assertThrowsAsync,
-} from "./test_deps.ts";
+import { assertEquals, assertNotEquals, assertRejects } from "./test_deps.ts";
 import { Client as ScramClient, Reason } from "../connection/scram.ts";
 
 Deno.test("Scram client reproduces RFC 7677 example", async () => {
@@ -36,7 +32,7 @@ Deno.test("Scram client catches bad server nonce", async () => {
   for (const testCase of testCases) {
     const client = new ScramClient("user", "password", "nonce1");
     client.composeChallenge();
-    await assertThrowsAsync(
+    await assertRejects(
       () => client.receiveChallenge(testCase),
       Error,
       Reason.BadServerNonce,
@@ -52,7 +48,7 @@ Deno.test("Scram client catches bad salt", async () => {
   for (const testCase of testCases) {
     const client = new ScramClient("user", "password", "nonce1");
     client.composeChallenge();
-    await assertThrowsAsync(
+    await assertRejects(
       () => client.receiveChallenge(testCase),
       Error,
       Reason.BadSalt,
@@ -71,7 +67,7 @@ Deno.test("Scram client catches bad iteration count", async () => {
   for (const testCase of testCases) {
     const client = new ScramClient("user", "password", "nonce1");
     client.composeChallenge();
-    await assertThrowsAsync(
+    await assertRejects(
       () => client.receiveChallenge(testCase),
       Error,
       Reason.BadIterationCount,
@@ -84,7 +80,7 @@ Deno.test("Scram client catches bad verifier", async () => {
   client.composeChallenge();
   await client.receiveChallenge("r=nonce12,s=c2FsdA==,i=4096");
   await client.composeResponse();
-  await assertThrowsAsync(
+  await assertRejects(
     () => client.receiveResponse("v=xxxx"),
     Error,
     Reason.BadVerifier,
@@ -98,7 +94,7 @@ Deno.test("Scram client catches server rejection", async () => {
   await client.composeResponse();
 
   const message = "auth error";
-  await assertThrowsAsync(
+  await assertRejects(
     () => client.receiveResponse(`e=${message}`),
     Error,
     message,
diff --git a/tests/config.json b/tests/config.json
index 8a3cc464..235d05f7 100644
--- a/tests/config.json
+++ b/tests/config.json
@@ -5,9 +5,11 @@
       "database": "postgres",
       "hostname": "postgres_clear",
       "password": "postgres",
-      "port": 5432,
+      "port": 6000,
+      "socket": "/var/run/postgres_clear",
       "users": {
-        "clear": "clear"
+        "clear": "clear",
+        "socket": "socket"
       }
     },
     "postgres_md5": {
@@ -15,10 +17,12 @@
       "database": "postgres",
       "hostname": "postgres_md5",
       "password": "postgres",
-      "port": 5432,
+      "port": 6001,
+      "socket": "/var/run/postgres_md5",
       "users": {
         "main": "postgres",
         "md5": "md5",
+        "socket": "socket",
         "tls_only": "tls_only"
       }
     },
@@ -27,9 +31,11 @@
       "database": "postgres",
       "hostname": "postgres_scram",
       "password": "postgres",
-      "port": 5432,
+      "port": 6002,
+      "socket": "/var/run/postgres_scram",
       "users": {
-        "scram": "scram"
+        "scram": "scram",
+        "socket": "socket"
       }
     }
   },
@@ -40,8 +46,10 @@
       "hostname": "localhost",
       "password": "postgres",
       "port": 6000,
+      "socket": "/var/run/postgres_clear",
       "users": {
-        "clear": "clear"
+        "clear": "clear",
+        "socket": "socket"
       }
     },
     "postgres_md5": {
@@ -50,10 +58,12 @@
       "hostname": "localhost",
       "password": "postgres",
       "port": 6001,
+      "socket": "/var/run/postgres_md5",
       "users": {
         "clear": "clear",
         "main": "postgres",
         "md5": "md5",
+        "socket": "socket",
         "tls_only": "tls_only"
       }
     },
@@ -63,8 +73,10 @@
       "hostname": "localhost",
       "password": "postgres",
       "port": 6002,
+      "socket": "/var/run/postgres_scram",
       "users": {
-        "scram": "scram"
+        "scram": "scram",
+        "socket": "socket"
       }
     }
   }
diff --git a/tests/config.ts b/tests/config.ts
index 7803be08..0eb8d6dc 100644
--- a/tests/config.ts
+++ b/tests/config.ts
@@ -1,18 +1,25 @@
-import {
-  ClientConfiguration,
-  ClientOptions,
-} from "../connection/connection_params.ts";
+import { ClientConfiguration } from "../connection/connection_params.ts";
 
-type Configuration = Omit<ClientConfiguration, "connection">;
+type TcpConfiguration = Omit<ClientConfiguration, "connection"> & {
+  host_type: "tcp";
+};
+type SocketConfiguration = Omit<ClientConfiguration, "connection" | "tls"> & {
+  host_type: "socket";
+};
 
-type ConfigFileConnection = Pick<
-  ClientConfiguration,
-  "applicationName" | "database" | "hostname" | "password" | "port"
->;
+type ConfigFileConnection =
+  & Pick<
+    ClientConfiguration,
+    "applicationName" | "database" | "hostname" | "password" | "port"
+  >
+  & {
+    socket: string;
+  };
 
 type Clear = ConfigFileConnection & {
   users: {
     clear: string;
+    socket: string;
   };
 };
 
@@ -20,6 +27,7 @@ type Classic = ConfigFileConnection & {
   users: {
     main: string;
     md5: string;
+    socket: string;
     tls_only: string;
   };
 };
@@ -27,6 +35,7 @@ type Classic = ConfigFileConnection & {
 type Scram = ConfigFileConnection & {
   users: {
     scram: string;
+    socket: string;
   };
 };
 
@@ -65,10 +74,11 @@ const disabled_tls = {
 
 export const getClearConfiguration = (
   tls: boolean,
-): ClientOptions => {
+): TcpConfiguration => {
   return {
     applicationName: config.postgres_clear.applicationName,
     database: config.postgres_clear.database,
+    host_type: "tcp",
     hostname: config.postgres_clear.hostname,
     password: config.postgres_clear.password,
     port: config.postgres_clear.port,
@@ -77,12 +87,25 @@ export const getClearConfiguration = (
   };
 };
 
+export const getClearSocketConfiguration = (): SocketConfiguration => {
+  return {
+    applicationName: config.postgres_clear.applicationName,
+    database: config.postgres_clear.database,
+    host_type: "socket",
+    hostname: config.postgres_clear.socket,
+    password: config.postgres_clear.password,
+    port: config.postgres_clear.port,
+    user: config.postgres_clear.users.socket,
+  };
+};
+
 /** MD5 authenticated user with privileged access to the database */
-export const getMainConfiguration = (): Configuration => {
+export const getMainConfiguration = (): TcpConfiguration => {
   return {
     applicationName: config.postgres_md5.applicationName,
     database: config.postgres_md5.database,
     hostname: config.postgres_md5.hostname,
+    host_type: "tcp",
     password: config.postgres_md5.password,
     port: config.postgres_md5.port,
     tls: enabled_tls,
@@ -90,11 +113,12 @@ export const getMainConfiguration = (): Configuration => {
   };
 };
 
-export const getMd5Configuration = (tls: boolean): Configuration => {
+export const getMd5Configuration = (tls: boolean): TcpConfiguration => {
   return {
     applicationName: config.postgres_md5.applicationName,
     database: config.postgres_md5.database,
     hostname: config.postgres_md5.hostname,
+    host_type: "tcp",
     password: config.postgres_md5.password,
     port: config.postgres_md5.port,
     tls: tls ? enabled_tls : disabled_tls,
@@ -102,11 +126,24 @@ export const getMd5Configuration = (tls: boolean): Configuration => {
   };
 };
 
-export const getScramConfiguration = (tls: boolean): Configuration => {
+export const getMd5SocketConfiguration = (): SocketConfiguration => {
+  return {
+    applicationName: config.postgres_md5.applicationName,
+    database: config.postgres_md5.database,
+    hostname: config.postgres_md5.socket,
+    host_type: "socket",
+    password: config.postgres_md5.password,
+    port: config.postgres_md5.port,
+    user: config.postgres_md5.users.socket,
+  };
+};
+
+export const getScramConfiguration = (tls: boolean): TcpConfiguration => {
   return {
     applicationName: config.postgres_scram.applicationName,
     database: config.postgres_scram.database,
     hostname: config.postgres_scram.hostname,
+    host_type: "tcp",
     password: config.postgres_scram.password,
     port: config.postgres_scram.port,
     tls: tls ? enabled_tls : disabled_tls,
@@ -114,11 +151,24 @@ export const getScramConfiguration = (tls: boolean): Configuration => {
   };
 };
 
-export const getTlsOnlyConfiguration = (): Configuration => {
+export const getScramSocketConfiguration = (): SocketConfiguration => {
+  return {
+    applicationName: config.postgres_scram.applicationName,
+    database: config.postgres_scram.database,
+    hostname: config.postgres_scram.socket,
+    host_type: "socket",
+    password: config.postgres_scram.password,
+    port: config.postgres_scram.port,
+    user: config.postgres_scram.users.socket,
+  };
+};
+
+export const getTlsOnlyConfiguration = (): TcpConfiguration => {
   return {
     applicationName: config.postgres_md5.applicationName,
     database: config.postgres_md5.database,
     hostname: config.postgres_md5.hostname,
+    host_type: "tcp",
     password: config.postgres_md5.password,
     port: config.postgres_md5.port,
     tls: enabled_tls,
diff --git a/tests/connection_params_test.ts b/tests/connection_params_test.ts
index a2aa9c96..6a4fab98 100644
--- a/tests/connection_params_test.ts
+++ b/tests/connection_params_test.ts
@@ -1,4 +1,4 @@
-import { assertEquals, assertThrows } from "./test_deps.ts";
+import { assertEquals, assertThrows, fromFileUrl } from "./test_deps.ts";
 import { createParams } from "../connection/connection_params.ts";
 import { ConnectionParamsError } from "../client/error.ts";
 import { has_env_access } from "./constants.ts";
@@ -37,6 +37,11 @@ const withEnv = (env: {
   PGUSER ? Deno.env.set("PGUSER", PGUSER) : Deno.env.delete("PGUSER");
 };
 
+// TODO
+// Replace with test permission options to remove the need for function override
+/**
+ * This function will override getting env variables to simulate having no env permissions
+ */
 function withNotAllowedEnv(fn: () => void) {
   return () => {
     const getEnv = Deno.env.get;
@@ -59,9 +64,24 @@ Deno.test("Parses connection string", function () {
   );
 
   assertEquals(p.database, "deno_postgres");
-  assertEquals(p.user, "some_user");
+  assertEquals(p.host_type, "tcp");
   assertEquals(p.hostname, "some_host");
   assertEquals(p.port, 10101);
+  assertEquals(p.user, "some_user");
+});
+
+Deno.test("Parses connection string with socket host", function () {
+  const socket = "/var/run/postgresql";
+
+  const p = createParams(
+    `postgres://some_user@${encodeURIComponent(socket)}:10101/deno_postgres`,
+  );
+
+  assertEquals(p.database, "deno_postgres");
+  assertEquals(p.hostname, socket);
+  assertEquals(p.host_type, "socket");
+  assertEquals(p.port, 10101);
+  assertEquals(p.user, "some_user");
 });
 
 Deno.test('Parses connection string with "postgresql" as driver', function () {
@@ -98,6 +118,15 @@ Deno.test("Parses connection string with application name", function () {
   assertEquals(p.port, 10101);
 });
 
+Deno.test("Parses connection string with reserved URL parameters", () => {
+  const p = createParams(
+    "postgres://?dbname=some_db&user=some_user",
+  );
+
+  assertEquals(p.database, "some_db");
+  assertEquals(p.user, "some_user");
+});
+
 Deno.test("Parses connection string with sslmode required", function () {
   const p = createParams(
     "postgres://some_user@some_host:10101/deno_postgres?sslmode=require",
@@ -124,8 +153,8 @@ Deno.test("Throws on connection string with invalid port", function () {
       createParams(
         "postgres://some_user@some_host:abc/deno_postgres",
       ),
-    undefined,
-    "Invalid URL",
+    ConnectionParamsError,
+    "Could not parse the connection string",
   );
 });
 
@@ -135,7 +164,7 @@ Deno.test("Throws on connection string with invalid ssl mode", function () {
       createParams(
         "postgres://some_user@some_host:10101/deno_postgres?sslmode=verify-full",
       ),
-    undefined,
+    ConnectionParamsError,
     "Supplied DSN has invalid sslmode 'verify-full'. Only 'disable', 'require', and 'prefer' are supported",
   );
 });
@@ -146,6 +175,7 @@ Deno.test("Parses connection options", function () {
     hostname: "some_host",
     port: 10101,
     database: "deno_postgres",
+    host_type: "tcp",
   });
 
   assertEquals(p.database, "deno_postgres");
@@ -158,6 +188,7 @@ Deno.test("Throws on invalid tls options", function () {
   assertThrows(
     () =>
       createParams({
+        host_type: "tcp",
         tls: {
           enabled: false,
           enforce: true,
@@ -212,6 +243,7 @@ Deno.test(
   withNotAllowedEnv(function () {
     const p = createParams({
       database: "deno_postgres",
+      host_type: "tcp",
       user: "deno_postgres",
     });
 
@@ -222,12 +254,30 @@ Deno.test(
   }),
 );
 
+Deno.test(
+  "Throws if it can't obtain necessary parameters from config or env",
+  withNotAllowedEnv(function () {
+    assertThrows(
+      () => createParams(),
+      ConnectionParamsError,
+      "Missing connection parameters: database, user",
+    );
+
+    assertThrows(
+      () => createParams({ user: "some_user" }),
+      ConnectionParamsError,
+      "Missing connection parameters: database",
+    );
+  }),
+);
+
 Deno.test("Uses default connection options", function () {
   const database = "deno_postgres";
   const user = "deno_postgres";
 
   const p = createParams({
     database,
+    host_type: "tcp",
     user,
   });
 
@@ -261,3 +311,88 @@ Deno.test("Throws when required options are not passed", function () {
     );
   }
 });
+
+Deno.test("Determines host type", () => {
+  {
+    const p = createParams({
+      database: "some_db",
+      hostname: "127.0.0.1",
+      user: "some_user",
+    });
+
+    assertEquals(p.host_type, "tcp");
+  }
+
+  {
+    const p = createParams(
+      "postgres://somehost.com?dbname=some_db&user=some_user",
+    );
+    assertEquals(p.hostname, "somehost.com");
+    assertEquals(p.host_type, "tcp");
+  }
+
+  {
+    const abs_path = "/some/absolute/path";
+
+    const p = createParams({
+      database: "some_db",
+      hostname: abs_path,
+      host_type: "socket",
+      user: "some_user",
+    });
+
+    assertEquals(p.hostname, abs_path);
+    assertEquals(p.host_type, "socket");
+  }
+
+  {
+    const rel_path = "./some_file";
+
+    const p = createParams({
+      database: "some_db",
+      hostname: rel_path,
+      host_type: "socket",
+      user: "some_user",
+    });
+
+    assertEquals(p.hostname, fromFileUrl(new URL(rel_path, import.meta.url)));
+    assertEquals(p.host_type, "socket");
+  }
+
+  {
+    const p = createParams("postgres://?dbname=some_db&user=some_user");
+    assertEquals(p.hostname, "/tmp");
+    assertEquals(p.host_type, "socket");
+  }
+});
+
+Deno.test("Throws when TLS options and socket type are specified", () => {
+  assertThrows(
+    () =>
+      createParams({
+        database: "some_db",
+        hostname: "./some_file",
+        host_type: "socket",
+        user: "some_user",
+        tls: {
+          enabled: true,
+        },
+      }),
+    ConnectionParamsError,
+    `No TLS options are allowed when host type is set to "socket"`,
+  );
+});
+
+Deno.test("Throws when host is a URL and host type is socket", () => {
+  assertThrows(
+    () =>
+      createParams({
+        database: "some_db",
+        hostname: "https://some_host.com",
+        host_type: "socket",
+        user: "some_user",
+      }),
+    ConnectionParamsError,
+    "The provided host is not a file path",
+  );
+});
diff --git a/tests/connection_test.ts b/tests/connection_test.ts
index 61ae51c9..572d4a47 100644
--- a/tests/connection_test.ts
+++ b/tests/connection_test.ts
@@ -1,17 +1,22 @@
 import {
   assertEquals,
-  assertThrowsAsync,
+  assertRejects,
   deferred,
+  joinPath,
   streams,
 } from "./test_deps.ts";
 import {
   getClearConfiguration,
+  getClearSocketConfiguration,
   getMainConfiguration,
   getMd5Configuration,
+  getMd5SocketConfiguration,
   getScramConfiguration,
+  getScramSocketConfiguration,
   getTlsOnlyConfiguration,
 } from "./config.ts";
 import { Client, ConnectionError, PostgresError } from "../mod.ts";
+import { getSocketName } from "../utils/utils.ts";
 
 function createProxy(
   target: Deno.Listener,
@@ -57,6 +62,7 @@ Deno.test("Clear password authentication (unencrypted)", async () => {
 
   try {
     assertEquals(client.session.tls, false);
+    assertEquals(client.session.transport, "tcp");
   } finally {
     await client.end();
   }
@@ -68,6 +74,19 @@ Deno.test("Clear password authentication (tls)", async () => {
 
   try {
     assertEquals(client.session.tls, true);
+    assertEquals(client.session.transport, "tcp");
+  } finally {
+    await client.end();
+  }
+});
+
+Deno.test("Clear password authentication (socket)", async () => {
+  const client = new Client(getClearSocketConfiguration());
+  await client.connect();
+
+  try {
+    assertEquals(client.session.tls, undefined);
+    assertEquals(client.session.transport, "socket");
   } finally {
     await client.end();
   }
@@ -79,6 +98,7 @@ Deno.test("MD5 authentication (unencrypted)", async () => {
 
   try {
     assertEquals(client.session.tls, false);
+    assertEquals(client.session.transport, "tcp");
   } finally {
     await client.end();
   }
@@ -90,6 +110,19 @@ Deno.test("MD5 authentication (tls)", async () => {
 
   try {
     assertEquals(client.session.tls, true);
+    assertEquals(client.session.transport, "tcp");
+  } finally {
+    await client.end();
+  }
+});
+
+Deno.test("MD5 authentication (socket)", async () => {
+  const client = new Client(getMd5SocketConfiguration());
+  await client.connect();
+
+  try {
+    assertEquals(client.session.tls, undefined);
+    assertEquals(client.session.transport, "socket");
   } finally {
     await client.end();
   }
@@ -101,6 +134,7 @@ Deno.test("SCRAM-SHA-256 authentication (unencrypted)", async () => {
 
   try {
     assertEquals(client.session.tls, false);
+    assertEquals(client.session.transport, "tcp");
   } finally {
     await client.end();
   }
@@ -112,10 +146,24 @@ Deno.test("SCRAM-SHA-256 authentication (tls)", async () => {
 
   try {
     assertEquals(client.session.tls, true);
+    assertEquals(client.session.transport, "tcp");
   } finally {
     await client.end();
   }
 });
+
+Deno.test("SCRAM-SHA-256 authentication (socket)", async () => {
+  const client = new Client(getScramSocketConfiguration());
+  await client.connect();
+
+  try {
+    assertEquals(client.session.tls, undefined);
+    assertEquals(client.session.transport, "socket");
+  } finally {
+    await client.end();
+  }
+});
+
 Deno.test("Skips TLS connection when TLS disabled", async () => {
   const client = new Client({
     ...getTlsOnlyConfiguration(),
@@ -124,7 +172,7 @@ Deno.test("Skips TLS connection when TLS disabled", async () => {
 
   // Connection will fail due to TLS only user
   try {
-    await assertThrowsAsync(
+    await assertRejects(
       () => client.connect(),
       PostgresError,
       "no pg_hba.conf",
@@ -132,6 +180,7 @@ Deno.test("Skips TLS connection when TLS disabled", async () => {
   } finally {
     try {
       assertEquals(client.session.tls, undefined);
+      assertEquals(client.session.transport, undefined);
     } finally {
       await client.end();
     }
@@ -149,7 +198,7 @@ Deno.test("Aborts TLS connection when certificate is untrusted", async () => {
   });
 
   try {
-    await assertThrowsAsync(
+    await assertRejects(
       async (): Promise<void> => {
         await client.connect();
       },
@@ -159,6 +208,7 @@ Deno.test("Aborts TLS connection when certificate is untrusted", async () => {
   } finally {
     try {
       assertEquals(client.session.tls, undefined);
+      assertEquals(client.session.transport, undefined);
     } finally {
       await client.end();
     }
@@ -177,6 +227,7 @@ Deno.test("Defaults to unencrypted when certificate is invalid and TLS is not en
   // Connection will fail due to TLS only user
   try {
     assertEquals(client.session.tls, false);
+    assertEquals(client.session.transport, "tcp");
   } finally {
     await client.end();
   }
@@ -188,7 +239,7 @@ Deno.test("Handles bad authentication correctly", async function () {
   const client = new Client(badConnectionData);
 
   try {
-    await assertThrowsAsync(
+    await assertRejects(
       async (): Promise<void> => {
         await client.connect();
       },
@@ -208,7 +259,7 @@ Deno.test("Startup error when database does not exist", async function () {
   const client = new Client(badConnectionData);
 
   try {
-    await assertThrowsAsync(
+    await assertRejects(
       async (): Promise<void> => {
         await client.connect();
       },
@@ -257,6 +308,63 @@ Deno.test("Exposes session encryption", async () => {
   }
 });
 
+Deno.test("Exposes session transport", async () => {
+  const client = new Client(getMainConfiguration());
+  await client.connect();
+
+  try {
+    assertEquals(client.session.transport, "tcp");
+  } finally {
+    await client.end();
+
+    assertEquals(
+      client.session.transport,
+      undefined,
+      "Transport was not cleared after disconnection",
+    );
+  }
+});
+
+Deno.test("Attempts to guess socket route", async () => {
+  await assertRejects(
+    async () => {
+      const mock_socket = await Deno.makeTempFile({
+        prefix: ".postgres_socket.",
+      });
+
+      const client = new Client({
+        database: "some_database",
+        hostname: mock_socket,
+        host_type: "socket",
+        user: "some_user",
+      });
+      await client.connect();
+    },
+    Deno.errors.ConnectionRefused,
+    undefined,
+    "It doesn't use exact file name when real file provided",
+  );
+
+  const path = await Deno.makeTempDir({ prefix: "postgres_socket" });
+  const port = 1234;
+
+  await assertRejects(
+    async () => {
+      const client = new Client({
+        database: "some_database",
+        hostname: path,
+        host_type: "socket",
+        user: "some_user",
+        port,
+      });
+      await client.connect();
+    },
+    ConnectionError,
+    `Could not open socket in path "${joinPath(path, getSocketName(port))}"`,
+    "It doesn't guess socket location based on port",
+  );
+});
+
 Deno.test("Closes connection on bad TLS availability verification", async function () {
   const server = new Worker(
     new URL("./workers/postgres_server.ts", import.meta.url).href,
@@ -426,7 +534,7 @@ Deno.test("Attempts reconnection on disconnection", async function () {
     await client.queryArray(`DROP TABLE IF EXISTS ${test_table}`);
     await client.queryArray(`CREATE TABLE ${test_table} (X INT)`);
 
-    await assertThrowsAsync(
+    await assertRejects(
       () =>
         client.queryArray(
           `INSERT INTO ${test_table} VALUES (${test_value}); COMMIT; SELECT PG_TERMINATE_BACKEND(${client.session.pid})`,
@@ -463,6 +571,28 @@ Deno.test("Attempts reconnection on disconnection", async function () {
   }
 });
 
+Deno.test("Attempts reconnection on socket disconnection", async () => {
+  const client = new Client(getMd5SocketConfiguration());
+  await client.connect();
+
+  try {
+    await assertRejects(
+      () =>
+        client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`,
+      ConnectionError,
+      "The session was terminated unexpectedly",
+    );
+
+    const { rows: query_1 } = await client.queryArray`SELECT 1`;
+    assertEquals(query_1, [[1]]);
+  } finally {
+    await client.end();
+  }
+});
+
+// TODO
+// Find a way to unlink the socket to simulate unexpected socket disconnection
+
 Deno.test("Attempts reconnection when connection is lost", async function () {
   const cfg = getMainConfiguration();
   const listener = Deno.listen({ hostname: "127.0.0.1", port: 0 });
@@ -487,7 +617,7 @@ Deno.test("Attempts reconnection when connection is lost", async function () {
   // a new connection should be established.
   aborter.abort();
 
-  await assertThrowsAsync(
+  await assertRejects(
     () => client.queryObject("SELECT 1"),
     ConnectionError,
     "The session was terminated unexpectedly",
@@ -509,12 +639,12 @@ Deno.test("Doesn't attempt reconnection when attempts are set to zero", async fu
   await client.connect();
 
   try {
-    await assertThrowsAsync(() =>
+    await assertRejects(() =>
       client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`
     );
     assertEquals(client.connected, false);
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => client.queryArray`SELECT 1`,
       Error,
       "The client has been disconnected from the database",
diff --git a/tests/data_types_test.ts b/tests/data_types_test.ts
index 5652bd29..f9ff7458 100644
--- a/tests/data_types_test.ts
+++ b/tests/data_types_test.ts
@@ -53,7 +53,7 @@ Deno.test(
     const url = "127.0.0.1";
     const selectRes = await client.queryArray(
       "SELECT $1::INET",
-      url,
+      [url],
     );
     assertEquals(selectRes.rows[0], [url]);
   }),
@@ -81,7 +81,7 @@ Deno.test(
 
     const { rows } = await client.queryArray(
       "SELECT $1::MACADDR",
-      address,
+      [address],
     );
     assertEquals(rows[0], [address]);
   }),
@@ -115,7 +115,7 @@ Deno.test(
 
     const { rows } = await client.queryArray(
       "SELECT $1::CIDR",
-      host,
+      [host],
     );
     assertEquals(rows[0], [host]);
   }),
@@ -140,7 +140,7 @@ Deno.test(
   "name",
   testClient(async (client) => {
     const name = "some";
-    const result = await client.queryArray(`SELECT $1::name`, name);
+    const result = await client.queryArray(`SELECT $1::name`, [name]);
     assertEquals(result.rows[0], [name]);
   }),
 );
@@ -348,7 +348,7 @@ Deno.test(
 
     const result = await client.queryArray(
       `SELECT ($1)::regrole`,
-      user,
+      [user],
     );
 
     assertEquals(result.rows[0][0], user);
@@ -362,7 +362,7 @@ Deno.test(
 
     const result = await client.queryArray(
       `SELECT ARRAY[($1)::regrole]`,
-      user,
+      [user],
     );
 
     assertEquals(result.rows[0][0], [user]);
@@ -445,7 +445,7 @@ Deno.test(
   "numeric",
   testClient(async (client) => {
     const number = "1234567890.1234567890";
-    const result = await client.queryArray(`SELECT $1::numeric`, number);
+    const result = await client.queryArray(`SELECT $1::numeric`, [number]);
     assertEquals(result.rows[0][0], number);
   }),
 );
@@ -456,8 +456,7 @@ Deno.test(
     const numeric = ["1234567890.1234567890", "6107693.123123124"];
     const result = await client.queryArray(
       `SELECT ARRAY[$1::numeric, $2]`,
-      numeric[0],
-      numeric[1],
+      [numeric[0], numeric[1]],
     );
     assertEquals(result.rows[0][0], numeric);
   }),
@@ -573,7 +572,7 @@ Deno.test(
   "uuid",
   testClient(async (client) => {
     const uuid_text = "c4792ecb-c00a-43a2-bd74-5b0ed551c599";
-    const result = await client.queryArray(`SELECT $1::uuid`, uuid_text);
+    const result = await client.queryArray(`SELECT $1::uuid`, [uuid_text]);
     assertEquals(result.rows[0][0], uuid_text);
   }),
 );
@@ -752,8 +751,8 @@ Deno.test(
   testClient(async (client) => {
     const date = "1999-01-08 04:05:06";
     const result = await client.queryArray<[Timestamp]>(
-      `SELECT $1::TIMESTAMP, 'INFINITY'::TIMESTAMP`,
-      date,
+      "SELECT $1::TIMESTAMP, 'INFINITY'::TIMESTAMP",
+      [date],
     );
 
     assertEquals(result.rows[0], [new Date(date), Infinity]);
@@ -769,8 +768,8 @@ Deno.test(
     ];
 
     const result = await client.queryArray<[[Timestamp, Timestamp]]>(
-      `SELECT ARRAY[$1::TIMESTAMP, $2]`,
-      ...timestamps,
+      "SELECT ARRAY[$1::TIMESTAMP, $2]",
+      timestamps,
     );
 
     assertEquals(result.rows[0][0], timestamps.map((x) => new Date(x)));
@@ -782,8 +781,8 @@ Deno.test(
   testClient(async (client) => {
     const timestamp = "1999-01-08 04:05:06+02";
     const result = await client.queryArray<[Timestamp]>(
-      `SELECT $1::TIMESTAMPTZ, 'INFINITY'::TIMESTAMPTZ`,
-      timestamp,
+      "SELECT $1::TIMESTAMPTZ, 'INFINITY'::TIMESTAMPTZ",
+      [timestamp],
     );
 
     assertEquals(result.rows[0], [new Date(timestamp), Infinity]);
@@ -800,7 +799,7 @@ Deno.test(
 
     const result = await client.queryArray<[[Timestamp, Timestamp]]>(
       `SELECT ARRAY[$1::TIMESTAMPTZ, $2]`,
-      ...timestamps,
+      timestamps,
     );
 
     assertEquals(result.rows[0][0], [
@@ -928,7 +927,7 @@ Deno.test(
 
     const result = await client.queryArray<[Timestamp, Timestamp]>(
       "SELECT $1::DATE, 'Infinity'::Date",
-      date_text,
+      [date_text],
     );
 
     assertEquals(result.rows[0], [
@@ -946,7 +945,7 @@ Deno.test(
 
     const result = await client.queryArray<[Timestamp, Timestamp]>(
       "SELECT ARRAY[$1::DATE, $2]",
-      ...dates,
+      dates,
     );
 
     assertEquals(
diff --git a/tests/encode_test.ts b/tests/encode_test.ts
index 125bbf80..784fdaab 100644
--- a/tests/encode_test.ts
+++ b/tests/encode_test.ts
@@ -1,7 +1,7 @@
 import { assertEquals } from "./test_deps.ts";
-import { encode } from "../query/encode.ts";
+import { encodeArgument } from "../query/encode.ts";
 
-// internally `encode` uses `getTimezoneOffset` to encode Date
+// internally `encodeArguments` uses `getTimezoneOffset` to encode Date
 // so for testing purposes we'll be overriding it
 const _getTimezoneOffset = Date.prototype.getTimezoneOffset;
 
@@ -20,7 +20,7 @@ Deno.test("encodeDatetime", function () {
   overrideTimezoneOffset(0);
 
   const gmtDate = new Date(2019, 1, 10, 20, 30, 40, 5);
-  const gmtEncoded = encode(gmtDate);
+  const gmtEncoded = encodeArgument(gmtDate);
   assertEquals(gmtEncoded, "2019-02-10T20:30:40.005+00:00");
 
   resetTimezoneOffset();
@@ -29,36 +29,36 @@ Deno.test("encodeDatetime", function () {
   overrideTimezoneOffset(-150);
 
   const date = new Date(2019, 1, 10, 20, 30, 40, 5);
-  const encoded = encode(date);
+  const encoded = encodeArgument(date);
   assertEquals(encoded, "2019-02-10T20:30:40.005+02:30");
 
   resetTimezoneOffset();
 });
 
 Deno.test("encodeUndefined", function () {
-  assertEquals(encode(undefined), null);
+  assertEquals(encodeArgument(undefined), null);
 });
 
 Deno.test("encodeNull", function () {
-  assertEquals(encode(null), null);
+  assertEquals(encodeArgument(null), null);
 });
 
 Deno.test("encodeBoolean", function () {
-  assertEquals(encode(true), "true");
-  assertEquals(encode(false), "false");
+  assertEquals(encodeArgument(true), "true");
+  assertEquals(encodeArgument(false), "false");
 });
 
 Deno.test("encodeNumber", function () {
-  assertEquals(encode(1), "1");
-  assertEquals(encode(1.2345), "1.2345");
+  assertEquals(encodeArgument(1), "1");
+  assertEquals(encodeArgument(1.2345), "1.2345");
 });
 
 Deno.test("encodeString", function () {
-  assertEquals(encode("deno-postgres"), "deno-postgres");
+  assertEquals(encodeArgument("deno-postgres"), "deno-postgres");
 });
 
 Deno.test("encodeObject", function () {
-  assertEquals(encode({ x: 1 }), '{"x":1}');
+  assertEquals(encodeArgument({ x: 1 }), '{"x":1}');
 });
 
 Deno.test("encodeUint8Array", function () {
@@ -66,21 +66,21 @@ Deno.test("encodeUint8Array", function () {
   const buf2 = new Uint8Array([2, 10, 500]);
   const buf3 = new Uint8Array([11]);
 
-  assertEquals("\\x010203", encode(buf1));
-  assertEquals("\\x020af4", encode(buf2));
-  assertEquals("\\x0b", encode(buf3));
+  assertEquals("\\x010203", encodeArgument(buf1));
+  assertEquals("\\x020af4", encodeArgument(buf2));
+  assertEquals("\\x0b", encodeArgument(buf3));
 });
 
 Deno.test("encodeArray", function () {
   const array = [null, "postgres", 1, ["foo", "bar"]];
-  const encodedArray = encode(array);
+  const encodedArray = encodeArgument(array);
 
   assertEquals(encodedArray, '{NULL,"postgres","1",{"foo","bar"}}');
 });
 
 Deno.test("encodeObjectArray", function () {
   const array = [{ x: 1 }, { y: 2 }];
-  const encodedArray = encode(array);
+  const encodedArray = encodeArgument(array);
   assertEquals(encodedArray, '{"{\\"x\\":1}","{\\"y\\":2}"}');
 });
 
@@ -88,7 +88,7 @@ Deno.test("encodeDateArray", function () {
   overrideTimezoneOffset(0);
 
   const array = [new Date(2019, 1, 10, 20, 30, 40, 5)];
-  const encodedArray = encode(array);
+  const encodedArray = encodeArgument(array);
   assertEquals(encodedArray, '{"2019-02-10T20:30:40.005+00:00"}');
 
   resetTimezoneOffset();
diff --git a/tests/pool_test.ts b/tests/pool_test.ts
index 25215664..7263cf32 100644
--- a/tests/pool_test.ts
+++ b/tests/pool_test.ts
@@ -22,7 +22,7 @@ Deno.test(
         const client = await POOL.connect();
         const query = await client.queryArray(
           "SELECT pg_sleep(0.1) is null, $1::text as id",
-          i,
+          [i],
         );
         client.release();
         return query;
@@ -68,7 +68,7 @@ Deno.test(
           const client = await POOL.connect();
           const query = await client.queryArray(
             "SELECT pg_sleep(0.1) is null, $1::text as id",
-            i,
+            [i],
           );
           client.release();
           return query;
diff --git a/tests/query_client_test.ts b/tests/query_client_test.ts
index 94fc16bc..b616fb07 100644
--- a/tests/query_client_test.ts
+++ b/tests/query_client_test.ts
@@ -3,7 +3,7 @@ import {
   assert,
   assertEquals,
   assertObjectMatch,
-  assertThrowsAsync,
+  assertRejects,
 } from "./test_deps.ts";
 import { getMainConfiguration } from "./config.ts";
 import { PoolClient, QueryClient } from "../client.ts";
@@ -49,7 +49,7 @@ function testClient(
   Deno.test({ fn: poolWrapper, name: `Pool: ${name}` });
 }
 
-testClient("Simple query", async function (generateClient) {
+testClient("Array query", async function (generateClient) {
   const client = await generateClient();
 
   const result = await client.queryArray("SELECT UNNEST(ARRAY[1, 2])");
@@ -66,27 +66,117 @@ testClient("Object query", async function (generateClient) {
   assertEquals(result.rows, [{ id: [1, 2, 3], type: "DATA" }]);
 });
 
-testClient("Prepared statements", async function (generateClient) {
+testClient("Array arguments", async function (generateClient) {
   const client = await generateClient();
 
-  const result = await client.queryObject(
-    "SELECT ID FROM ( SELECT UNNEST(ARRAY[1, 2]) AS ID ) A WHERE ID < $1",
-    2,
-  );
-  assertEquals(result.rows, [{ id: 1 }]);
+  {
+    const value = "1";
+    const result = await client.queryArray(
+      "SELECT $1",
+      [value],
+    );
+    assertEquals(result.rows, [[value]]);
+  }
+
+  {
+    const value = "2";
+    const result = await client.queryArray({
+      args: [value],
+      text: "SELECT $1",
+    });
+    assertEquals(result.rows, [[value]]);
+  }
+
+  {
+    const value = "3";
+    const result = await client.queryObject(
+      "SELECT $1 AS ID",
+      [value],
+    );
+    assertEquals(result.rows, [{ id: value }]);
+  }
+
+  {
+    const value = "4";
+    const result = await client.queryObject({
+      args: [value],
+      text: "SELECT $1 AS ID",
+    });
+    assertEquals(result.rows, [{ id: value }]);
+  }
 });
 
+testClient("Object arguments", async function (generateClient) {
+  const client = await generateClient();
+
+  {
+    const value = "1";
+    const result = await client.queryArray(
+      "SELECT $id",
+      { id: value },
+    );
+    assertEquals(result.rows, [[value]]);
+  }
+
+  {
+    const value = "2";
+    const result = await client.queryArray({
+      args: { id: value },
+      text: "SELECT $ID",
+    });
+    assertEquals(result.rows, [[value]]);
+  }
+
+  {
+    const value = "3";
+    const result = await client.queryObject(
+      "SELECT $id as ID",
+      { id: value },
+    );
+    assertEquals(result.rows, [{ id: value }]);
+  }
+
+  {
+    const value = "4";
+    const result = await client.queryObject({
+      args: { id: value },
+      text: "SELECT $ID AS ID",
+    });
+    assertEquals(result.rows, [{ id: value }]);
+  }
+});
+
+testClient(
+  "Throws on duplicate object arguments",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    const value = "some_value";
+    const { rows: res } = await client.queryArray(
+      "SELECT $value, $VaLue, $VALUE",
+      { value },
+    );
+    assertEquals(res, [[value, value, value]]);
+
+    await assertRejects(
+      () => client.queryArray("SELECT $A", { a: 1, A: 2 }),
+      Error,
+      "The arguments provided for the query must be unique (insensitive)",
+    );
+  },
+);
+
 testClient(
-  "Simple query handles recovery after error state",
+  "Array query handles recovery after error state",
   async function (generateClient) {
     const client = await generateClient();
 
     await client.queryArray`CREATE TEMP TABLE PREPARED_STATEMENT_ERROR (X INT)`;
 
-    await assertThrowsAsync(() =>
+    await assertRejects(() =>
       client.queryArray(
         "INSERT INTO PREPARED_STATEMENT_ERROR VALUES ($1)",
-        "TEXT",
+        ["TEXT"],
       )
     );
 
@@ -100,11 +190,11 @@ testClient(
 );
 
 testClient(
-  "Simple query can handle multiple query failures at once",
+  "Array query can handle multiple query failures at once",
   async function (generateClient) {
     const client = await generateClient();
 
-    await assertThrowsAsync(
+    await assertRejects(
       () =>
         client.queryArray(
           "SELECT 1; SELECT '2'::INT; SELECT 'A'::INT",
@@ -123,11 +213,11 @@ testClient(
 );
 
 testClient(
-  "Simple query handles error during data processing",
+  "Array query handles error during data processing",
   async function (generateClient) {
     const client = await generateClient();
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => client.queryObject`SELECT 'A' AS X, 'B' AS X`,
     );
 
@@ -138,7 +228,7 @@ testClient(
 );
 
 testClient(
-  "Simple query can return multiple queries",
+  "Array query can return multiple queries",
   async function (generateClient) {
     const client = await generateClient();
 
@@ -152,7 +242,7 @@ testClient(
 );
 
 testClient(
-  "Simple query handles empty query",
+  "Array query handles empty query",
   async function (generateClient) {
     const client = await generateClient();
 
@@ -168,10 +258,10 @@ testClient(
 
     await client.queryArray`CREATE TEMP TABLE PREPARED_STATEMENT_ERROR (X INT)`;
 
-    await assertThrowsAsync(() =>
+    await assertRejects(() =>
       client.queryArray(
         "INSERT INTO PREPARED_STATEMENT_ERROR VALUES ($1)",
-        "TEXT",
+        ["TEXT"],
       ), PostgresError);
 
     const result = "handled";
@@ -191,7 +281,7 @@ testClient(
   async function (generateClient) {
     const client = await generateClient();
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => client.queryObject`SELECT ${1} AS A, ${2} AS A`,
     );
 
@@ -210,15 +300,14 @@ testClient(
 
     const { rows: result_1 } = await client.queryArray(
       `SELECT ARRAY[$1, $2]`,
-      item_1,
-      item_2,
+      [item_1, item_2],
     );
     assertEquals(result_1[0], [[item_1, item_2]]);
   },
 );
 
 testClient(
-  "Handles parameter status messages on simple query",
+  "Handles parameter status messages on array query",
   async (generateClient) => {
     const client = await generateClient();
 
@@ -250,9 +339,11 @@ testClient(
 			END;
 			$$ LANGUAGE PLPGSQL;`;
 
-    await assertThrowsAsync(
+    await assertRejects(
       () =>
-        client.queryArray("SELECT * FROM PG_TEMP.CHANGE_TIMEZONE($1)", result),
+        client.queryArray("SELECT * FROM PG_TEMP.CHANGE_TIMEZONE($1)", [
+          result,
+        ]),
       PostgresError,
       "control reached end of function without RETURN",
     );
@@ -287,7 +378,7 @@ testClient(
 			END;
 			$$ LANGUAGE PLPGSQL;`;
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => client.queryArray`SELECT * FROM PG_TEMP.CHANGE_TIMEZONE()`,
       PostgresError,
       "control reached end of function without RETURN",
@@ -299,7 +390,7 @@ testClient("Terminated connections", async function (generateClient) {
   const client = await generateClient();
   await client.end();
 
-  await assertThrowsAsync(
+  await assertRejects(
     async () => {
       await client.queryArray`SELECT 1`;
     },
@@ -313,7 +404,7 @@ testClient("Terminated connections", async function (generateClient) {
 testClient("Default reconnection", async (generateClient) => {
   const client = await generateClient();
 
-  await assertThrowsAsync(
+  await assertRejects(
     () => client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`,
     ConnectionError,
   );
@@ -424,7 +515,7 @@ testClient("Binary data is parsed correctly", async function (generateClient) {
 
   const { rows: result_2 } = await client.queryArray(
     "SELECT $1::BYTEA",
-    expectedBytes,
+    [expectedBytes],
   );
   assertEquals(result_2[0][0], expectedBytes);
 });
@@ -446,8 +537,7 @@ testClient("Result object metadata", async function (generateClient) {
   // parameterized select
   result = await client.queryArray(
     "SELECT * FROM METADATA WHERE VALUE IN ($1, $2)",
-    200,
-    300,
+    [200, 300],
   );
   assertEquals(result.command, "SELECT");
   assertEquals(result.rowCount, 2);
@@ -462,7 +552,7 @@ testClient("Result object metadata", async function (generateClient) {
   // parameterized delete
   result = await client.queryArray(
     "DELETE FROM METADATA WHERE VALUE = $1",
-    300,
+    [300],
   );
   assertEquals(result.command, "DELETE");
   assertEquals(result.rowCount, 1);
@@ -473,7 +563,7 @@ testClient("Result object metadata", async function (generateClient) {
   assertEquals(result.rowCount, 2);
 
   // parameterized insert
-  result = await client.queryArray("INSERT INTO METADATA VALUES ($1)", 3);
+  result = await client.queryArray("INSERT INTO METADATA VALUES ($1)", [3]);
   assertEquals(result.command, "INSERT");
   assertEquals(result.rowCount, 1);
 
@@ -487,7 +577,7 @@ testClient("Result object metadata", async function (generateClient) {
   // parameterized update
   result = await client.queryArray(
     "UPDATE METADATA SET VALUE = 400 WHERE VALUE = $1",
-    400,
+    [400],
   );
   assertEquals(result.command, "UPDATE");
   assertEquals(result.rowCount, 1);
@@ -595,7 +685,7 @@ testClient(
   async function (generateClient) {
     const client = await generateClient();
 
-    await assertThrowsAsync(
+    await assertRejects(
       () =>
         client.queryObject({
           text: "SELECT 1",
@@ -612,13 +702,13 @@ testClient(
   async function (generateClient) {
     const client = await generateClient();
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => client.queryObject`SELECT 1 AS "a", 2 AS A`,
       Error,
       `Field names "a" are duplicated in the result of the query`,
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       () =>
         client.queryObject({
           camelcase: true,
@@ -645,7 +735,7 @@ testClient(
       1,
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       async () => {
         await client.queryObject({
           text: "SELECT 1",
@@ -663,7 +753,7 @@ testClient(
   async function (generateClient) {
     const client = await generateClient();
 
-    await assertThrowsAsync(
+    await assertRejects(
       async () => {
         await client.queryObject({
           text: "SELECT 1",
@@ -674,7 +764,7 @@ testClient(
       "The fields provided for the query must contain only letters and underscores",
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       async () => {
         await client.queryObject({
           text: "SELECT 1",
@@ -685,7 +775,7 @@ testClient(
       "The fields provided for the query must contain only letters and underscores",
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       async () => {
         await client.queryObject({
           text: "SELECT 1",
@@ -703,7 +793,7 @@ testClient(
   async function (generateClient) {
     const client = await generateClient();
 
-    await assertThrowsAsync(
+    await assertRejects(
       async () => {
         await client.queryObject({
           text: "SELECT 1",
@@ -721,7 +811,7 @@ testClient(
   async function (generateClient) {
     const client = await generateClient();
 
-    await assertThrowsAsync(
+    await assertRejects(
       () =>
         client.queryObject<{ result: number }>({
           text: "SELECT 1; SELECT '2'::INT, '3'",
@@ -860,7 +950,7 @@ testClient(
     // Modify data outside the transaction
     await client_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction_rr.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 3`,
       undefined,
       undefined,
@@ -889,7 +979,7 @@ testClient("Transaction read only", async function (generateClient) {
   });
   await transaction.begin();
 
-  await assertThrowsAsync(
+  await assertRejects(
     () => transaction.queryArray`DELETE FROM FOR_TRANSACTION_TEST`,
     undefined,
     "cannot execute DELETE in a read-only transaction",
@@ -955,7 +1045,7 @@ testClient("Transaction locks client", async function (generateClient) {
 
   await transaction.begin();
   await transaction.queryArray`SELECT 1`;
-  await assertThrowsAsync(
+  await assertRejects(
     () => client.queryArray`SELECT 1`,
     undefined,
     "This connection is currently locked",
@@ -1040,7 +1130,7 @@ testClient("Transaction rollback validations", async function (generateClient) {
   );
   await transaction.begin();
 
-  await assertThrowsAsync(
+  await assertRejects(
     // @ts-ignore This is made to check the two properties aren't passed at once
     () => transaction.rollback({ savepoint: "unexistent", chain: true }),
     undefined,
@@ -1059,7 +1149,7 @@ testClient(
     const transaction = client.createTransaction(name);
 
     await transaction.begin();
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction.queryArray`SELECT []`,
       undefined,
       `The transaction "${name}" has been aborted due to \`PostgresError:`,
@@ -1067,7 +1157,7 @@ testClient(
     assertEquals(client.session.current_transaction, null);
 
     await transaction.begin();
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction.queryObject`SELECT []`,
       undefined,
       `The transaction "${name}" has been aborted due to \`PostgresError:`,
@@ -1137,13 +1227,13 @@ testClient(
     const transaction = client.createTransaction("x");
     await transaction.begin();
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction.savepoint("1"),
       undefined,
       "The savepoint name can't begin with a number",
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       () =>
         transaction.savepoint(
           "this_savepoint_is_going_to_be_longer_than_sixty_three_characters",
@@ -1152,7 +1242,7 @@ testClient(
       "The savepoint name can't be longer than 63 characters",
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction.savepoint("+"),
       undefined,
       "The savepoint name can only contain alphanumeric characters",
@@ -1170,19 +1260,19 @@ testClient(
 
     await savepoint.release();
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => savepoint.release(),
       undefined,
       "This savepoint has no instances to release",
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction.rollback(savepoint),
       undefined,
       `There are no savepoints of "abc1" left to rollback to`,
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction.rollback("UNEXISTENT"),
       undefined,
       `There is no "unexistent" savepoint registered in this transaction`,
@@ -1203,7 +1293,7 @@ testClient(
 
     await transaction_x.begin();
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction_y.begin(),
       undefined,
       `This client already has an ongoing transaction "x"`,
@@ -1211,44 +1301,44 @@ testClient(
 
     await transaction_x.commit();
     await transaction_y.begin();
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction_y.begin(),
       undefined,
       "This transaction is already open",
     );
 
     await transaction_y.commit();
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction_y.commit(),
       undefined,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction_y.commit(),
       undefined,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction_y.queryArray`SELECT 1`,
       undefined,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction_y.queryObject`SELECT 1`,
       undefined,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction_y.rollback(),
       undefined,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
     );
 
-    await assertThrowsAsync(
+    await assertRejects(
       () => transaction_y.savepoint("SOME"),
       undefined,
       `This transaction has not been started yet, make sure to use the "begin" method to do so`,
diff --git a/tests/test_deps.ts b/tests/test_deps.ts
index a0eece0c..e0b91996 100644
--- a/tests/test_deps.ts
+++ b/tests/test_deps.ts
@@ -4,8 +4,7 @@ export {
   assertEquals,
   assertNotEquals,
   assertObjectMatch,
+  assertRejects,
   assertThrows,
-  assertThrowsAsync,
 } from "https://deno.land/std@0.114.0/testing/asserts.ts";
-export { fromFileUrl } from "https://deno.land/std@0.114.0/path/mod.ts";
 export * as streams from "https://deno.land/std@0.114.0/streams/conversion.ts";
diff --git a/tests/utils_test.ts b/tests/utils_test.ts
index 067cdcee..253edf71 100644
--- a/tests/utils_test.ts
+++ b/tests/utils_test.ts
@@ -1,5 +1,5 @@
-import { assertEquals } from "./test_deps.ts";
-import { DsnResult, parseDsn } from "../utils/utils.ts";
+import { assertEquals, assertThrows } from "./test_deps.ts";
+import { parseConnectionUri, Uri } from "../utils/utils.ts";
 import { DeferredAccessStack } from "../utils/deferred.ts";
 
 class LazilyInitializedObject {
@@ -22,29 +22,118 @@ class LazilyInitializedObject {
   }
 }
 
-Deno.test("Parses connection string into config", function () {
-  let c: DsnResult;
+const dns_examples: Partial<Uri>[] = [
+  { driver: "postgresql", host: "localhost" },
+  { driver: "postgresql", host: "localhost", port: "5433" },
+  { driver: "postgresql", host: "localhost", port: "5433", path: "mydb" },
+  { driver: "postgresql", host: "localhost", path: "mydb" },
+  { driver: "postgresql", host: "localhost", user: "user" },
+  { driver: "postgresql", host: "localhost", password: "secret" },
+  { driver: "postgresql", host: "localhost", user: "user", password: "secret" },
+  {
+    driver: "postgresql",
+    host: "localhost",
+    user: "user",
+    password: "secret",
+    params: { "param_1": "a" },
+  },
+  {
+    driver: "postgresql",
+    host: "localhost",
+    user: "user",
+    password: "secret",
+    path: "otherdb",
+    params: { "param_1": "a" },
+  },
+  {
+    driver: "postgresql",
+    path: "otherdb",
+    params: { "param_1": "a" },
+  },
+  {
+    driver: "postgresql",
+    host: "[2001:db8::1234]",
+  },
+  {
+    driver: "postgresql",
+    host: "[2001:db8::1234]",
+    port: "1500",
+  },
+  {
+    driver: "postgresql",
+    host: "[2001:db8::1234]",
+    port: "1500",
+    params: { "param_1": "a" },
+  },
+];
 
-  c = parseDsn("postgres://deno.land/test_database");
+Deno.test("Parses connection string into config", async function (context) {
+  for (
+    const {
+      driver,
+      user = "",
+      host = "",
+      params = {},
+      password = "",
+      path = "",
+      port = "",
+    } of dns_examples
+  ) {
+    const url_params = new URLSearchParams();
+    for (const key in params) {
+      url_params.set(key, params[key]);
+    }
 
-  assertEquals(c.driver, "postgres");
-  assertEquals(c.user, "");
-  assertEquals(c.password, "");
-  assertEquals(c.hostname, "deno.land");
-  assertEquals(c.port, "");
-  assertEquals(c.database, "test_database");
+    const dirty_dns =
+      `${driver}://${user}:${password}@${host}:${port}/${path}?${url_params.toString()}`;
 
-  c = parseDsn(
-    "postgres://fizz:buzz@deno.land:8000/test_database?application_name=myapp",
-  );
+    await context.step(dirty_dns, () => {
+      const parsed_dirty_dsn = parseConnectionUri(dirty_dns);
+
+      assertEquals(parsed_dirty_dsn.driver, driver);
+      assertEquals(parsed_dirty_dsn.host, host);
+      assertEquals(parsed_dirty_dsn.params, params);
+      assertEquals(parsed_dirty_dsn.password, password);
+      assertEquals(parsed_dirty_dsn.path, path);
+      assertEquals(parsed_dirty_dsn.port, port);
+      assertEquals(parsed_dirty_dsn.user, user);
+    });
+
+    // Build the URL without leaving placeholders
+    let clean_dns_string = `${driver}://`;
+    if (user || password) {
+      clean_dns_string += `${user ?? ""}${password ? `:${password}` : ""}@`;
+    }
+    if (host || port) {
+      clean_dns_string += `${host ?? ""}${port ? `:${port}` : ""}`;
+    }
+    if (path) {
+      clean_dns_string += `/${path}`;
+    }
+    if (Object.keys(params).length > 0) {
+      clean_dns_string += `?${url_params.toString()}`;
+    }
+
+    await context.step(clean_dns_string, () => {
+      const parsed_clean_dsn = parseConnectionUri(clean_dns_string);
+
+      assertEquals(parsed_clean_dsn.driver, driver);
+      assertEquals(parsed_clean_dsn.host, host);
+      assertEquals(parsed_clean_dsn.params, params);
+      assertEquals(parsed_clean_dsn.password, password);
+      assertEquals(parsed_clean_dsn.path, path);
+      assertEquals(parsed_clean_dsn.port, port);
+      assertEquals(parsed_clean_dsn.user, user);
+    });
+  }
+});
 
-  assertEquals(c.driver, "postgres");
-  assertEquals(c.user, "fizz");
-  assertEquals(c.password, "buzz");
-  assertEquals(c.hostname, "deno.land");
-  assertEquals(c.port, "8000");
-  assertEquals(c.database, "test_database");
-  assertEquals(c.params.application_name, "myapp");
+Deno.test("Throws on invalid parameters", () => {
+  assertThrows(
+    () => parseConnectionUri("postgres://some_host:invalid"),
+    Error,
+    `The provided port "invalid" is not a valid number`,
+  );
 });
 
 Deno.test("Parses connection string params into param object", function () {
@@ -59,39 +148,63 @@ Deno.test("Parses connection string params into param object", function () {
     base_url.searchParams.set(key, value);
   }
 
-  const parsed_dsn = parseDsn(base_url.toString());
+  const parsed_dsn = parseConnectionUri(base_url.toString());
 
   assertEquals(parsed_dsn.params, params);
 });
 
-Deno.test("Decodes connection string password correctly", function () {
-  let parsed_dsn: DsnResult;
-  let password: string;
+const encoded_hosts = ["/var/user/postgres", "./some_other_route"];
+const encoded_passwords = ["Mtx=", "pssword!=?with_symbols"];
 
-  password = "Mtx=";
-  parsed_dsn = parseDsn(
-    `postgres://root:${encodeURIComponent(password)}@localhost:9999/txdb`,
-  );
-  assertEquals(parsed_dsn.password, password);
+Deno.test("Decodes connection string values correctly", async (context) => {
+  await context.step("Host", () => {
+    for (const host of encoded_hosts) {
+      assertEquals(
+        parseConnectionUri(
+          `postgres://${encodeURIComponent(host)}:9999/txdb`,
+        ).host,
+        host,
+      );
+    }
+  });
 
-  password = "pssword!=?with_symbols";
-  parsed_dsn = parseDsn(
-    `postgres://root:${encodeURIComponent(password)}@localhost:9999/txdb`,
-  );
-  assertEquals(parsed_dsn.password, password);
+  await context.step("Password", () => {
+    for (const pwd of encoded_passwords) {
+      assertEquals(
+        parseConnectionUri(
+          `postgres://root:${encodeURIComponent(pwd)}@localhost:9999/txdb`,
+        ).password,
+        pwd,
+      );
+    }
+  });
 });
 
-Deno.test("Defaults to connection string password literal if decoding fails", function () {
-  let parsed_dsn: DsnResult;
-  let password: string;
+const invalid_hosts = ["Mtx%3", "%E0%A4%A.socket"];
+const invalid_passwords = ["Mtx%3", "%E0%A4%A"];
 
-  password = "Mtx%3";
-  parsed_dsn = parseDsn(`postgres://root:${password}@localhost:9999/txdb`);
-  assertEquals(parsed_dsn.password, password);
+Deno.test("Defaults to connection string literal if decoding fails", async (context) => {
+  await context.step("Host", () => {
+    for (const host of invalid_hosts) {
+      assertEquals(
+        parseConnectionUri(
+          `postgres://${host}`,
+        ).host,
+        host,
+      );
+    }
+  });
 
-  password = "%E0%A4%A";
-  parsed_dsn = parseDsn(`postgres://root:${password}@localhost:9999/txdb`);
-  assertEquals(parsed_dsn.password, password);
+  await context.step("Password", () => {
+    for (const pwd of invalid_passwords) {
+      assertEquals(
+        parseConnectionUri(
+          `postgres://root:${pwd}@localhost:9999/txdb`,
+        ).password,
+        pwd,
+      );
+    }
+  });
 });
 
 Deno.test("DeferredAccessStack", async () => {
diff --git a/utils/utils.ts b/utils/utils.ts
index 1fd7f90e..3add6096 100644
--- a/utils/utils.ts
+++ b/utils/utils.ts
@@ -33,28 +33,74 @@ export function readUInt32BE(buffer: Uint8Array, offset: number): number {
   );
 }
 
-export interface DsnResult {
+export interface Uri {
   driver: string;
-  user: string;
+  host: string;
   password: string;
-  hostname: string;
+  path: string;
+  params: Record<string, string>;
   port: string;
-  database: string;
-  params: {
-    [key: string]: string;
-  };
+  user: string;
 }
 
-export function parseDsn(dsn: string): DsnResult {
-  //URL object won't parse the URL if it doesn't recognize the protocol
-  //This line replaces the protocol with http and then leaves it up to URL
-  const [protocol, strippedUrl] = dsn.match(/(?:(?!:\/\/).)+/g) ?? ["", ""];
-  const url = new URL(`http:${strippedUrl}`);
+/**
+ * This function parses valid connection strings according to https://www.postgresql.org/docs/14/libpq-connect.html#LIBPQ-CONNSTRING
+ *
+ * The only exception to this rule are multi-host connection strings
+ */
+export function parseConnectionUri(uri: string): Uri {
+  const parsed_uri = uri.match(
+    /(?<driver>\w+):\/{2}((?<user>[^\/?#\s:]+?)?(:(?<password>[^\/?#\s]+)?)?@)?(?<full_host>[^\/?#\s]+)?(\/(?<path>[^?#\s]*))?(\?(?<params>[^#\s]+))?.*/,
+  );
+  if (!parsed_uri) throw new Error("Could not parse the provided URL");
+  let {
+    driver = "",
+    full_host = "",
+    params = "",
+    password = "",
+    path = "",
+    user = "",
+  }: {
+    driver?: string;
+    user?: string;
+    password?: string;
+    full_host?: string;
+    path?: string;
+    params?: string;
+  } = parsed_uri.groups ?? {};
+
+  const parsed_host = full_host.match(
+    /(?<host>(\[.+\])|(.*?))(:(?<port>[\w]*))?$/,
+  );
+  if (!parsed_host) throw new Error(`Could not parse "${full_host}" host`);
+  let {
+    host = "",
+    port = "",
+  }: {
+    host?: string;
+    port?: string;
+  } = parsed_host.groups ?? {};
 
-  let password = url.password;
-  // Special characters in the password may be url-encoded by URL(), such as =
   try {
-    password = decodeURIComponent(password);
+    if (host) {
+      host = decodeURIComponent(host);
+    }
+  } catch (_e) {
+    console.error(
+      bold(
+        yellow("Failed to decode URL host") + "\nDefaulting to raw host",
+      ),
+    );
+  }
+
+  if (port && Number.isNaN(Number(port))) {
+    throw new Error(`The provided port "${port}" is not a valid number`);
+  }
+
+  try {
+    if (password) {
+      password = decodeURIComponent(password);
+    }
   } catch (_e) {
     console.error(
       bold(
@@ -65,14 +111,13 @@ export function parseDsn(dsn: string): DsnResult {
   }
 
   return {
+    driver,
+    host,
+    params: Object.fromEntries(new URLSearchParams(params).entries()),
     password,
-    driver: protocol,
-    user: url.username,
-    hostname: url.hostname,
-    port: url.port,
-    // remove leading slash from path
-    database: url.pathname.slice(1),
-    params: Object.fromEntries(url.searchParams.entries()),
+    path,
+    port,
+    user,
   };
 }
 
@@ -84,3 +129,9 @@ export function isTemplateString(
   }
   return true;
 }
+
+/**
+ * https://www.postgresql.org/docs/14/runtime-config-connection.html#RUNTIME-CONFIG-CONNECTION-SETTINGS
+ * unix_socket_directories
+ */
+export const getSocketName = (port: number) => `.s.PGSQL.${port}`;
