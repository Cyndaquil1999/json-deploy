diff --git a/.dependency-cruiser.js b/.dependency-cruiser.js
index 613ac40a9..a614ad019 100644
--- a/.dependency-cruiser.js
+++ b/.dependency-cruiser.js
@@ -91,7 +91,7 @@ module.exports = {
     {
       name: 'no-duplicate-dep-types',
       comment:
-        "Likeley this module depends on an external ('npm') package that occurs more than once " +
+        "Likely this module depends on an external ('npm') package that occurs more than once " +
         "in your package.json i.e. bot as a devDependencies and in dependencies. This will cause " +
         "maintenance problems later on.",
       severity: 'warn',
@@ -140,7 +140,7 @@ module.exports = {
         "This module depends on an npm package that is declared as an optional dependency " +
         "in your package.json. As this makes sense in limited situations only, it's flagged here. " +
         "If you're using an optional dependency here by design - add an exception to your" +
-        "depdency-cruiser configuration.",
+        "dependency-cruiser configuration.",
       from: {},
       to: {
         dependencyTypes: [
diff --git a/.github/workflows/test.yaml b/.github/workflows/test.yaml
index 01dd95234..822715a02 100644
--- a/.github/workflows/test.yaml
+++ b/.github/workflows/test.yaml
@@ -14,7 +14,7 @@ jobs:
     strategy:
       matrix:
         node: [ '14' ]
-        typescript: [ '4.1', '4.2' ]
+        typescript: [ '4.1', '4.2', '4.3', '4.4' ]
     name: Test with TypeScript ${{ matrix.typescript }} on Node ${{ matrix.node }}
     steps:
       - uses: actions/checkout@v2
diff --git a/CHANGELOG.md b/CHANGELOG.md
index da6323071..c3235a006 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,61 @@
 # Changelog
 
+### 3.9
+
+- Custom error messages in schemas
+
+```ts
+const name = z.string({
+  invalid_type_error: "Name must be string",
+  required_error: "Name is required",
+});
+```
+
+Under the hood, this creates a custom error map that's bound to the schema. You can also pass a custom error map explicitly.
+
+```ts
+const name = z.string({ errorMap: myErrorMap });
+```
+
+- Rest parameters for tuples
+
+```ts
+const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());
+type t1 = z.output<typeof myTuple>; // [string, number, ...boolean[]]
+```
+
+- Selective `.partial`
+
+You can specify certain fields to make optional with the `ZodObject.partial` method.
+
+```ts
+const user = z.object({
+  name: z.string(),
+  age: z.number(),
+});
+
+const optionalNameUser = user.partial({ name: true });
+// { name?: string; age: number; }
+```
+
+- Specify key schema in ZodRecord
+
+Previously, `z.record` only accepted a single schema:
+
+```ts
+z.record(z.boolean()); // Record<string, boolean>;
+```
+
+Now `z.record` has been overloaded to support two schemas. The first validates the _keys_ of the record, and the second validates the _values_.
+
+```ts
+const schema = z.record(z.number(), z.boolean());
+type schema = z.infer<typeof schema>; // Record<number, boolean>
+
+const schema = z.record(z.enum(["Tuna", "Trout"]), z.boolean());
+type schema = z.infer<typeof schema>; // Record<"Tuna" | "Trout", boolean>
+```
+
 ### 3.8
 
 - Add `z.preprocess`
diff --git a/ERROR_HANDLING.md b/ERROR_HANDLING.md
index 1a6680513..32eacc698 100644
--- a/ERROR_HANDLING.md
+++ b/ERROR_HANDLING.md
@@ -40,19 +40,20 @@ _Every_ ZodIssue has these fields:
 
 ## ZodIssueCode
 
-| code                             | additional fields                                                                                                                                                                                                                                                                    |
-| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
-| ZodIssueCode.invalid_type        | `expected: ZodParsedType` <br> `received: ZodParsedType` <br><br>Jump to [this section](#parsedtype) for a breakdown of the possible values of ZodParsedType.                                                                                                                        |
-| ZodIssueCode.unrecognized_keys   | `keys: string[]`<br>The list of unrecognized keys<br>                                                                                                                                                                                                                                |
-| ZodIssueCode.invalid_union       | `unionErrors: ZodError[]` <br> The errors thrown by each element of the union.                                                                                                                                                                                                       |
-| ZodIssueCode.invalid_enum_value  | `options: string[]` <br> The set of acceptable string values for this enum.                                                                                                                                                                                                          |
-| ZodIssueCode.invalid_arguments   | `argumentsError: ZodError` <br> This is a special error code only thrown by a wrapped function returned by `ZodFunction.implement()`. The `argumentsError` property is another ZodError containing the validation error details.                                                     |
-| ZodIssueCode.invalid_return_type | `returnTypeError: ZodError` <br> This is a special error code only thrown by a wrapped function returned by `ZodFunction.implement()`. The `returnTypeError` property is another ZodError containing the validation error details.                                                   |
-| ZodIssueCode.invalid_date        | _no additional properties_                                                                                                                                                                                                                                                           |
-| ZodIssueCode.invalid_string      | `validation: "url" \| "email" \| "uuid"`<br> Which built-in string validator failed                                                                                                                                                                                                  |
-| ZodIssueCode.too_small           | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `minimum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the minimum is included in the range of acceptable values.<br>                                   |
-| ZodIssueCode.too_big             | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `maximum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the minimum is included in the range of acceptable values.<br>                                   |
-| ZodIssueCode.custom              | `params: { [k: string]: any }` <br> This is the error code throw by **all custom refinements**. You are able to pass in a `params` object here that is available in your custom error maps (see [ZodErrorMap](#Customizing-errors-with-ZodErrorMap) below for details on error maps) |
+| code                             | additional fields                                                                                                                                                                                                                                                                                                                                                    |
+| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
+| ZodIssueCode.invalid_type        | `expected: ZodParsedType` <br> `received: ZodParsedType` <br><br>Jump to [this section](#parsedtype) for a breakdown of the possible values of ZodParsedType.                                                                                                                                                                                                        |
+| ZodIssueCode.unrecognized_keys   | `keys: string[]`<br>The list of unrecognized keys<br>                                                                                                                                                                                                                                                                                                                |
+| ZodIssueCode.invalid_union       | `unionErrors: ZodError[]` <br> The errors thrown by each element of the union.                                                                                                                                                                                                                                                                                       |
+| ZodIssueCode.invalid_enum_value  | `options: string[]` <br> The set of acceptable string values for this enum.                                                                                                                                                                                                                                                                                          |
+| ZodIssueCode.invalid_arguments   | `argumentsError: ZodError` <br> This is a special error code only thrown by a wrapped function returned by `ZodFunction.implement()`. The `argumentsError` property is another ZodError containing the validation error details.                                                                                                                                     |
+| ZodIssueCode.invalid_return_type | `returnTypeError: ZodError` <br> This is a special error code only thrown by a wrapped function returned by `ZodFunction.implement()`. The `returnTypeError` property is another ZodError containing the validation error details.                                                                                                                                   |
+| ZodIssueCode.invalid_date        | _no additional properties_                                                                                                                                                                                                                                                                                                                                           |
+| ZodIssueCode.invalid_string      | `validation: "url" \| "email" \| "uuid"`<br> Which built-in string validator failed                                                                                                                                                                                                                                                                                  |
+| ZodIssueCode.too_small           | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `minimum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the minimum is included in the range of acceptable values.<br>                                                                                                                   |
+| ZodIssueCode.too_big             | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `maximum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the minimum is included in the range of acceptable values.<br>                                                                                                                   |
+| ZodIssueCode.not_multiple_of     | `multipleOf: number` <br>The value the number should be a multiple of.<br>                                                                                                                                                                                                                                                                                           |
+| ZodIssueCode.custom              | `params: { [k: string]: any }` <br> This is the error code throw by refinements (unless you are using `superRefine` in which case it's possible to throw issues of any `code`). You are able to pass in a `params` object here that is available in your custom error maps (see [ZodErrorMap](#Customizing-errors-with-ZodErrorMap) below for details on error maps) |
 
 <!--
 | ZodIssueCode.nonempty_array_is_empty | _no additional properties_                                      |
@@ -106,7 +107,7 @@ try {
     names: ["Dave", 12], // 12 is not a string
     address: {
       line1: "123 Maple Ave",
-      zipCode: 123, // zip code isnt 5 digits
+      zipCode: 123, // zip code isn't 5 digits
       extra: "other stuff", // unrecognized key
     },
   });
@@ -169,9 +170,9 @@ const customErrorMap: z.ZodErrorMap = (issue, ctx) => {
 z.setErrorMap(customErrorMap);
 ```
 
-`ZodErrorMap` is a special function. It accepts two arguments: `error` and `ctx`. The return type is `{ message: string }`. Essentially the error map accepts some information about the validation that is failing and returns an appropriate error message.
+`ZodErrorMap` is a special function. It accepts two arguments: `issue` and `ctx`. The return type is `{ message: string }`. Essentially the error map accepts some information about the validation that is failing and returns an appropriate error message.
 
-- `error: Omit<ZodIssue, "message">`
+- `issue: Omit<ZodIssue, "message">`
 
   As mentioned above, ZodIssue is a discriminated union.
 
@@ -183,7 +184,48 @@ z.setErrorMap(customErrorMap);
 
 As in the example, you can modify certain error messages and simply fall back to `ctx.defaultError` otherwise.
 
-### A working example
+## Error map priority
+
+A custom error maps doesn't need to produce an error message for every kind of issue in Zod. Instead, your error map can override certain errors and return `ctx.defaultError` for everything else.
+
+But how is the value of `ctx.defaultError` determined?
+
+Error messages in Zod are generated by passing metadata about a validation issue through a chain of error maps. Error maps with higher priority override messages generated by maps with lower priority.
+
+The lowest priority map is the `defaultErrorMap`, which defined in [`src/ZodError.ts`](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts). This produces the default error message for all issues in Zod.
+
+### Global error map
+
+This message is then passed as `ctx.defaultError` into `overrideErrorMap`. This is a global error map you can set with `z.setErrorMap`:
+
+```ts
+const myErrorMap: z.ZodErrorMap = /* ... */;
+z.setErrorMap(errorMap);
+```
+
+### Schema-bound error map
+
+The `overrideErrorMap` message is then passed as `ctx.defaultError` into any schema-bound error maps. Every schema can be associated with an error map.
+
+```ts
+z.string({ errorMap: myErrorMap });
+
+// this creates an error map under the hood
+z.string({
+  invalid_type_error: "Invalid name",
+  required_error: "Name is required",
+});
+```
+
+### Contextual error map
+
+Finally, you can pass an error map as a parameter to any `parse` method. This error map, if provided, has highest priority.
+
+```ts
+z.string().parse("adsf", { errorMap: myErrorMap });
+```
+
+## A working example
 
 Let's look at a practical example of of customized error map:
 
@@ -215,8 +257,6 @@ const errorMap: z.ZodErrorMap = (error, ctx) => {
   return { message: ctx.defaultError };
 };
 
-z.setErrorMap(errorMap);
-
 z.string().parse(12, { errorMap });
 
 /* throws: 
@@ -327,7 +367,7 @@ err.flatten( (i: ZodIssue) => {
 ```
 
 - `fieldErrors` is an object. The keys are the field(s) that threw the error. The values are an array of error strings that can be easily presented in the interface.
-- `formErrors: string[]` is an array of errors that occured on the "root" of the object schema. For instance if you called `FormData.parse(null)`, `formErrors` would be:
+- `formErrors: string[]` is an array of errors that occurred on the "root" of the object schema. For instance if you called `FormData.parse(null)`, `formErrors` would be:
   ```ts
   ["Invalid input: expected object, received null"];
   ```
diff --git a/MIGRATION.md b/MIGRATION.md
index 2d07f2fdd..472dea686 100644
--- a/MIGRATION.md
+++ b/MIGRATION.md
@@ -40,7 +40,7 @@ Zod 2 is being retired and will not leave beta. This is due to some unintuitive
 
 - The **minimum TypeScript version** is now _4.1_ (up from 3.7 for Zod 2). Several features have been rewritten to use [recursive conditional types](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#recursive-conditional-types), an incredibly powerful new feature introduced in TS4.1.
 
-- **Transformers syntax**. Previously, creating a transformer required an input schema, an output schema, and a function to tranform between them. You created transformers like `z.transform(A, B, func)`, where `A` and `B` are Zod schemas. This is no longer the case. Accordingly:
+- **Transformers syntax**. Previously, creating a transformer required an input schema, an output schema, and a function to transform between them. You created transformers like `z.transform(A, B, func)`, where `A` and `B` are Zod schemas. This is no longer the case. Accordingly:
 
   The old syntax is no longer available:
 
diff --git a/README.md b/README.md
index 780ef7931..aeee09355 100644
--- a/README.md
+++ b/README.md
@@ -14,30 +14,10 @@
 ⭐️ smash that star button ⭐️
 </p>
 
-> If you like Zod, you'll love my new library [tRPC](https://trpc.io). It's a way to build end-to-end typesafe APIs without GraphQL or code generation! Check it out at [trpc.io](https://trpc.io).
+> Like typesafety? Check out [tRPC](https://trpc.io) — a better way to build end-to-end typesafe APIs without GraphQL or code generation — just TypeScript.
 
 <br/>
 
-## May 17, 2021: Zod v3 is now in stable release!
-
-Check out the [Migration Guide](https://github.com/colinhacks/zod/blob/master/MIGRATION.md) to upgrade.
-
-Previous versions:
-
-- [`Zod 1 docs`](https://github.com/colinhacks/zod/tree/v1)
-- [`Zod 2 docs`](https://github.com/colinhacks/zod/tree/v2)
-
-#### New features
-
-- **Easier imports**: you can now import Zod like `import { z } from 'zod';` instead of using `import * as` syntax.
-- **Structured error messages**. Use the `.format()` method to ZodError to convert the error into a strongly-typed, nested object: [format method](#error-formatting)
-- **Easier unions**. Use the `or` method to ZodType (the base class for all Zod schemas) to easily create union types like `z.string().or(z.number())`
-- **Easier intersections**. Use the `and` method to ZodType (the base class for all Zod schemas) to easily create intersection types
-- **Global error customization**. Use `z.setErrorMap(myErrorMap)` to _globally_ customize the error messages produced by Zod: [setErrorMap](ERROR_HANDLING.md#customizing-errors-with-zoderrormap)
-- **Maps and sets**. Zod now supports [`Map`](#maps) and [`Set`](#sets) schemas.
-- **Optional and nullable unwrapping**. ZodOptional and ZodNullable now have a `.unwrap()` method for retrieving the schema they wrap.
-- **A new implementation of transformers**. See the [Migration Guide](https://github.com/colinhacks/zod/blob/master/MIGRATION.md) section to understand the syntax changes.
-
 # Table of contents
 
 - [What is Zod](#what-is-zod)
@@ -49,6 +29,12 @@ Previous versions:
   - [Literals](#literals)
   - [Strings](#strings)
   - [Numbers](#numbers)
+  - [Booleans](#booleans)
+  - [Enums](#enums)
+    - [Zod enums](#zod-enums)
+    - [Native enums](#native-enums)
+  - [Optionals](#optionals)
+  - [Nullables](#nullables)
   - [Objects](#objects)
     - [.shape](#shape)
     - [.extend](#extend)
@@ -60,26 +46,22 @@ Previous versions:
     - [.strict](#strict)
     - [.strip](#strip)
     - [.catchall](#catchall)
-  - [Records](#records)
-  - [Maps](#maps)
-  - [Sets](#sets)
   - [Arrays](#arrays)
     - [.nonempty](#nonempty)
     - [.min/.max/.length](#minmaxlength)
-  - [Unions](#unions)
-  - [Optionals](#optionals)
-  - [Nullables](#nullables)
-  - [Enums](#enums)
-    - [Zod enums](#zod-enums)
-    - [Native enums](#native-enums)
   - [Tuples](#tuples)
+  - [Records](#records)
+  - [Maps](#maps)
+  - [Sets](#sets)
+  - [Unions](#unions)
   - [Recursive types](#recursive-types)
     - [JSON type](#json-type)
     - [Cyclical data](#cyclical-objects)
   - [Promises](#promises)
   - [Instanceof](#instanceof)
   - [Function schemas](#function-schemas)
-- [Base class methods (ZodType)](#zodtype-methods-and-properties)
+  - [Preprocess](#preprocess)
+- [Schema methods](#zodtype-methods-and-properties)
   - [.parse](#parse)
   - [.parseAsync](#parseasync)
   - [.safeParse](#safeparse)
@@ -137,7 +119,7 @@ Sponsorship at any level is appreciated and encouraged. Zod is maintained by a s
       <br>
       <b>Deletype</b>
       <br>
-      <a href="https://deletype.com/">https://deletype.com/</a>
+      <a href="https://deletype.com/">deletype.com/</a>
     </td>
   <td align="center">
       <a href="https://github.com/kevinsimper">
@@ -169,7 +151,7 @@ Sponsorship at any level is appreciated and encouraged. Zod is maintained by a s
       <br>
       <b>Bamboo Creative</b>
       <br>
-      <a href="https://www.bamboocreative.nz/">https://bamboocreative.nz</a>
+      <a href="https://www.bamboocreative.nz/">bamboocreative.nz</a>
     </td>
     <td align="center">
       <a href="https://github.com/jeremyBanks">
@@ -248,8 +230,14 @@ import { z } from "zod";
 
 // creating a schema for strings
 const mySchema = z.string();
+
+// parsing
 mySchema.parse("tuna"); // => "tuna"
 mySchema.parse(12); // => throws ZodError
+
+// "safe" parsing (doesn't throw error if validation fails)
+mySchema.safeParse("tuna"); // => { success: true; data: "tuna" }
+mySchema.safeParse(12); // => { success: false; error: ZodError }
 ```
 
 Creating an object schema
@@ -261,7 +249,7 @@ const User = z.object({
   username: z.string(),
 });
 
-User.parse({ username: string });
+User.parse({ username: "Ludwig" });
 
 // extract the inferred type
 type User = z.infer<typeof User>;
@@ -312,6 +300,15 @@ tuna.value; // "tuna"
 
 ## Strings
 
+You can customize certain errors when creating a string schema.
+
+```ts
+const name = z.string({
+  required: "Name is required",
+  invalid: "Invalid name",
+});
+```
+
 Zod includes a handful of string-specific validations.
 
 ```ts
@@ -335,19 +332,37 @@ z.string().nonempty({ message: "Can't be empty" });
 
 #### Custom error messages
 
-Optionally, you can pass in a second argument to provide a custom error message.
+You can customize certain errors when creating a string schema.
+
+```ts
+const name = z.string({
+  required_error: "Name is required",
+  invalid_type_error: "Name must be a string",
+});
+```
+
+When using validation methods, you can pass in an additional argument to provide a custom error message.
 
 ```ts
 z.string().min(5, { message: "Must be 5 or more characters long" });
 z.string().max(5, { message: "Must be 5 or fewer characters long" });
 z.string().length(5, { message: "Must be exactly 5 characters long" });
-z.string().email({ message: "Invalid email address." });
+z.string().email({ message: "Invalid email address" });
 z.string().url({ message: "Invalid url" });
 z.string().uuid({ message: "Invalid UUID" });
 ```
 
 ## Numbers
 
+You can customize certain error messages when creating a number schema.
+
+```ts
+const age = z.number({
+  required_error: "Age is required",
+  invalid_type_error: "Age must be a number",
+});
+```
+
 Zod includes a handful of number-specific validations.
 
 ```ts
@@ -362,6 +377,8 @@ z.number().positive(); //     > 0
 z.number().nonnegative(); //  >= 0
 z.number().negative(); //     < 0
 z.number().nonpositive(); //  <= 0
+
+z.number().multipleOf(5); // Evenly divisible by 5. Alias .step(5)
 ```
 
 Optionally, you can pass in a second argument to provide a custom error message.
@@ -370,6 +387,183 @@ Optionally, you can pass in a second argument to provide a custom error message.
 z.number().lte(5, { message: "this👏is👏too👏big" });
 ```
 
+## Booleans
+
+You can customize certain error messages when creating a boolean schema.
+
+```ts
+const isActive = z.boolean({
+  required_error: "isActive is required",
+  invalid_type_error: "isActive must be a boolean",
+});
+```
+
+## Enums
+
+There are two ways to define enums in Zod.
+
+### Zod enums
+
+```ts
+const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
+type FishEnum = z.infer<typeof FishEnum>;
+// 'Salmon' | 'Tuna' | 'Trout'
+```
+
+You must pass the array of values directly into `z.enum()`. Alternatively, use `as const` to define your enum values as a tuple of strings. See the [const assertion docs](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) for details.
+
+```ts
+const VALUES = ["Salmon", "Tuna", "Trout"] as const;
+const FishEnum = z.enum(VALUES);
+```
+
+This is not allowed:
+
+```ts
+const fish = ["Salmon", "Tuna", "Trout"];
+const FishEnum = z.enum(fish);
+```
+
+In that case, the inferred type of `fish` is simply `string[]`, so Zod isn't able to infer the individual enum elements.
+
+**Autocompletion**
+
+To get autocompletion with a Zod enum, use the `.enum` property of your schema:
+
+```ts
+FishEnum.enum.Salmon; // => autocompletes
+
+FishEnum.enum;
+/* 
+=> {
+  Salmon: "Salmon",
+  Tuna: "Tuna",
+  Trout: "Trout",
+} 
+*/
+```
+
+You can also retrieve the list of options as a tuple with the `.options` property:
+
+```ts
+FishEnum.options; // ["Salmon", "Tuna", "Trout"]);
+```
+
+### Native enums
+
+Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don't want to rewrite your existing enums) you can use `z.nativeEnum()` .
+
+**Numeric enums**
+
+```ts
+enum Fruits {
+  Apple,
+  Banana,
+}
+
+const FruitEnum = z.nativeEnum(Fruits);
+type FruitEnum = z.infer<typeof FruitEnum>; // Fruits
+
+FruitEnum.parse(Fruits.Apple); // passes
+FruitEnum.parse(Fruits.Banana); // passes
+FruitEnum.parse(0); // passes
+FruitEnum.parse(1); // passes
+FruitEnum.parse(3); // fails
+```
+
+**String enums**
+
+```ts
+enum Fruits {
+  Apple = "apple",
+  Banana = "banana",
+  Cantaloupe, // you can mix numerical and string enums
+}
+
+const FruitEnum = z.nativeEnum(Fruits);
+type FruitEnum = z.infer<typeof FruitEnum>; // Fruits
+
+FruitEnum.parse(Fruits.Apple); // passes
+FruitEnum.parse(Fruits.Cantaloupe); // passes
+FruitEnum.parse("apple"); // passes
+FruitEnum.parse("banana"); // passes
+FruitEnum.parse(0); // passes
+FruitEnum.parse("Cantaloupe"); // fails
+```
+
+**Const enums**
+
+The `.nativeEnum()` function works for `as const` objects as well. ⚠️ `as const` required TypeScript 3.4+!
+
+```ts
+const Fruits = {
+  Apple: "apple",
+  Banana: "banana",
+  Cantaloupe: 3,
+} as const;
+
+const FruitEnum = z.nativeEnum(Fruits);
+type FruitEnum = z.infer<typeof FruitEnum>; // "apple" | "banana" | 3
+
+FruitEnum.parse("apple"); // passes
+FruitEnum.parse("banana"); // passes
+FruitEnum.parse(3); // passes
+FruitEnum.parse("Cantaloupe"); // fails
+```
+
+## Optionals
+
+You can make any schema optional with `z.optional()`:
+
+```ts
+const schema = z.optional(z.string());
+
+schema.parse(undefined); // => returns undefined
+type A = z.infer<typeof A>; // string | undefined
+```
+
+You can make an existing schema optional with the `.optional()` method:
+
+```ts
+const user = z.object({
+  username: z.string().optional(),
+});
+type C = z.infer<typeof C>; // { username?: string | undefined };
+```
+
+#### `.unwrap`
+
+```ts
+const stringSchema = z.string();
+const optionalString = stringSchema.optional();
+optionalString.unwrap() === stringSchema; // true
+```
+
+## Nullables
+
+Similarly, you can create nullable types like so:
+
+```ts
+const nullableString = z.nullable(z.string());
+nullableString.parse("asdf"); // => "asdf"
+nullableString.parse(null); // => null
+```
+
+You can make an existing schema nullable with the `nullable` method:
+
+```ts
+const E = z.string().nullable(); // equivalent to D
+type E = z.infer<typeof D>; // string | null
+```
+
+#### `.unwrap`
+
+```ts
+const stringSchema = z.string();
+const nullableString = stringSchema.nullable();
+nullableString.unwrap() === stringSchema; // true
+```
+
 ## Objects
 
 ```ts
@@ -461,16 +655,31 @@ Starting from this object:
 
 ```ts
 const user = z.object({
+  email: z.string()
   username: z.string(),
 });
-// { username: string }
+// { email: string; username: string }
 ```
 
 We can create a partial version:
 
 ```ts
 const partialUser = user.partial();
-// { username?: string | undefined }
+// { email?: string | undefined; username?: string | undefined }
+```
+
+You can also specify which properties to make optional:
+
+```ts
+const optionalEmail = user.partial({
+  email: true,
+});
+/* 
+{ 
+  email?: string | undefined; 
+  username: string
+} 
+*/
 ```
 
 ### `.deepPartial`
@@ -627,6 +836,23 @@ z.string().array().length(5); // must contain 5 items exactly
 
 Unlike `.nonempty()` these methods do not change the inferred type.
 
+## Tuples
+
+Unlike arrays, tuples have a fixed number of elements and each element can have a different type.
+
+```ts
+const athleteSchema = z.tuple([
+  z.string(), // name
+  z.number(), // jersey number
+  z.object({
+    pointsScored: z.number(),
+  }), // statistics
+]);
+
+type Athlete = z.infer<typeof athleteSchema>;
+// type Athlete = [string, number, { pointsScored: number }]
+```
+
 ## Unions
 
 Zod includes a built-in `z.union` method for composing "OR" types.
@@ -646,79 +872,6 @@ For convenience, you can also use the `.or` method:
 const stringOrNumber = z.string().or(z.number());
 ```
 
-## Optionals
-
-You can make any schema optional with `z.optional()`:
-
-```ts
-const schema = z.optional(z.string());
-
-schema.parse(undefined); // => returns undefined
-type A = z.infer<typeof A>; // string | undefined
-```
-
-You can make an existing schema optional with the `.optional()` method:
-
-```ts
-const user = z.object({
-  username: z.string().optional(),
-});
-type C = z.infer<typeof C>; // { username?: string | undefined };
-```
-
-#### `.unwrap`
-
-```ts
-const stringSchema = z.string();
-const optionalString = stringSchema.optional();
-optionalString.unwrap() === stringSchema; // true
-```
-
-## Nullables
-
-Similarly, you can create nullable types like so:
-
-```ts
-const nullableString = z.nullable(z.string());
-nullableString.parse("asdf"); // => "asdf"
-nullableString.parse(null); // => null
-```
-
-You can make an existing schema nullable with the `nullable` method:
-
-```ts
-const E = z.string().nullable(); // equivalent to D
-type E = z.infer<typeof D>; // string | null
-```
-
-#### `.unwrap`
-
-```ts
-const stringSchema = z.string();
-const nullableString = stringSchema.nullable();
-nullableString.unwrap() === stringSchema; // true
-```
-
-<!--
-
-``` ts
-/* Custom Union Types */
-
-const F = z
-  .union([z.string(), z.number(), z.boolean()])
-  .optional()
-  .nullable();
-
-F.parse('tuna'); // => tuna
-F.parse(42); // => 42
-F.parse(true); // => true
-F.parse(undefined); // => undefined
-F.parse(null); // => null
-F.parse({}); // => throws Error!
-
-type F = z.infer<typeof F>; // string | number | boolean | undefined | null;
-``` -->
-
 ## Records
 
 Record schemas are used to validate types such as `{ [k: string]: number }`.
@@ -784,134 +937,6 @@ type numberSet = z.infer<typeof numberSet>;
 // Set<number>
 ```
 
-## Enums
-
-There are two ways to define enums in Zod.
-
-### Zod enums
-
-<!-- An enum is just a union of string literals, so you _could_ define an enum like this:
-
-```ts
-const FishEnum = z.union([
-  z.literal("Salmon"),
-  z.literal("Tuna"),
-  z.literal("Trout"),
-]);
-
-FishEnum.parse("Salmon"); // => "Salmon"
-FishEnum.parse("Flounder"); // => throws
-```
-
-For convenience Zod provides a built-in `z.enum()` function. Here's is the equivalent code: -->
-
-```ts
-const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
-type FishEnum = z.infer<typeof FishEnum>;
-// 'Salmon' | 'Tuna' | 'Trout'
-```
-
-You must pass the array of values directly into `z.enum()`. Alternatively, use `as const` to define your enum values as a tuple of strings. See the [const assertion docs](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) for details.
-
-```ts
-const VALUES = ["Salmon", "Tuna", "Trout"] as const;
-const FishEnum = z.enum(VALUES);
-```
-
-This is not allowed:
-
-```ts
-const fish = ["Salmon", "Tuna", "Trout"];
-const FishEnum = z.enum(fish);
-```
-
-In that case, the inferred type of `fish` is simply `string[]`, so Zod isn't able to infer the individual enum elements.
-
-**Autocompletion**
-
-To get autocompletion with a Zod enum, use the `.enum` property of your schema:
-
-```ts
-FishEnum.enum.Salmon; // => autocompletes
-
-FishEnum.enum;
-/* 
-=> {
-  Salmon: "Salmon",
-  Tuna: "Tuna",
-  Trout: "Trout",
-} 
-*/
-```
-
-You can also retrieve the list of options as a tuple with the `.options` property:
-
-```ts
-FishEnum.options; // ["Salmon", "Tuna", "Trout"]);
-```
-
-### Native enums
-
-Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don't want to rewrite your existing enums) you can use `z.nativeEnum()` .
-
-**Numeric enums**
-
-```ts
-enum Fruits {
-  Apple,
-  Banana,
-}
-
-const FruitEnum = z.nativeEnum(Fruits);
-type FruitEnum = z.infer<typeof FruitEnum>; // Fruits
-
-FruitEnum.parse(Fruits.Apple); // passes
-FruitEnum.parse(Fruits.Banana); // passes
-FruitEnum.parse(0); // passes
-FruitEnum.parse(1); // passes
-FruitEnum.parse(3); // fails
-```
-
-**String enums**
-
-```ts
-enum Fruits {
-  Apple = "apple",
-  Banana = "banana",
-  Cantaloupe, // you can mix numerical and string enums
-}
-
-const FruitEnum = z.nativeEnum(Fruits);
-type FruitEnum = z.infer<typeof FruitEnum>; // Fruits
-
-FruitEnum.parse(Fruits.Apple); // passes
-FruitEnum.parse(Fruits.Cantaloupe); // passes
-FruitEnum.parse("apple"); // passes
-FruitEnum.parse("banana"); // passes
-FruitEnum.parse(0); // passes
-FruitEnum.parse("Cantaloupe"); // fails
-```
-
-**Const enums**
-
-The `.nativeEnum()` function works for `as const` objects as well. ⚠️ `as const` required TypeScript 3.4+!
-
-```ts
-const Fruits = {
-  Apple: "apple",
-  Banana: "banana",
-  Cantaloupe: 3,
-} as const;
-
-const FruitEnum = z.nativeEnum(Fruits);
-type FruitEnum = z.infer<typeof FruitEnum>; // "apple" | "banana" | 3
-
-FruitEnum.parse("apple"); // passes
-FruitEnum.parse("banana"); // passes
-FruitEnum.parse(3); // passes
-FruitEnum.parse("Cantaloupe"); // fails
-```
-
 ## Intersections
 
 <!-- > ⚠️ Intersections are deprecated. If you are trying to merge objects, use the `.merge` method instead. -->
@@ -962,23 +987,6 @@ type Teacher = z.infer<typeof Teacher>;
 // { id:string; name:string };
 ```  -->
 
-## Tuples
-
-Unlike arrays, tuples have a fixed number of elements and each element can have a different type.
-
-```ts
-const athleteSchema = z.tuple([
-  z.string(), // name
-  z.number(), // jersey number
-  z.object({
-    pointsScored: z.number(),
-  }), // statistics
-]);
-
-type Athlete = z.infer<typeof athleteSchema>;
-// type Athlete = [string, number, { pointsScored: number }]
-```
-
 ## Recursive types
 
 You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a "type hint".
@@ -1184,6 +1192,18 @@ const myFunction = z
 myFunction; // (arg: string)=>number[]
 ```
 
+## Preprocess
+
+Typically Zod operates under a "parse then transform" paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the [.transform docs](#transform).)
+
+But sometimes you want to apply some transform to the input _before_ parsing happens. A common use case: type coercion. Zod enables this with the `z.preprocess()`.
+
+```ts
+const castToString = z.preprocess((val) => String(val), z.string());
+```
+
+This returns a `ZodEffects` instance. `ZodEffects` is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.
+
 # ZodType: methods and properties
 
 All Zod schemas contain certain methods.
@@ -1417,11 +1437,11 @@ const stringToNumber = z.string().transform((val) => myString.length);
 stringToNumber.parse("string"); // => 6
 ```
 
-> ⚠️ Transformation functions must not throw. Make sure to use refinements before the transformer to make sure the input can be parsed by the transformer.
+> ⚠️ Transform functions must not throw. Make sure to use refinements before the transform to make sure the input can be parsed by the transform.
 
 #### Chaining order
 
-Note that `stringToNumber` above is an instance of the `ZodEffects` subclass. It is NOT an instance of `ZodString`. If you want to use the built-in methods of `ZodString` (e.g. `.email()`) you must apply those methods _before_ any transformations.
+Note that `stringToNumber` above is an instance of the `ZodEffects` subclass. It is NOT an instance of `ZodString`. If you want to use the built-in methods of `ZodString` (e.g. `.email()`) you must apply those methods _before_ any transforms.
 
 ```ts
 const emailToDomain = z
@@ -1442,25 +1462,24 @@ z.string()
   .refine((val) => val > 25);
 ```
 
-#### Async transformations
+#### Async transforms
 
-Transformations can also be async.
+Transforms can also be async.
 
 ```ts
-const IdToUser = z.transformer(
-  z.string().uuid(),
-  UserSchema,
-  (userId) => async (id) => {
+const IdToUser = z
+  .string()
+  .uuid()
+  .transform(async (id) => {
     return await getUserById(id);
-  }
-);
+  });
 ```
 
-> ⚠️ If your schema contains asynchronous transformers, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error.
+> ⚠️ If your schema contains asynchronous transforms, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error.
 
 ### `.default`
 
-You can use transformers to implement the concept of "default values" in Zod.
+You can use transforms to implement the concept of "default values" in Zod.
 
 ```ts
 const stringWithDefault = z.string().default("tuna");
@@ -1546,7 +1565,7 @@ z.union([z.string(), z.number()]);
 
 ### `.and`
 
-A convenience method for creating interesection types.
+A convenience method for creating intersection types.
 
 ```ts
 z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }
@@ -1569,7 +1588,7 @@ const u: A = "asdf"; // compiles
 
 #### What about transforms?
 
-In reality each Zod schema is actually associated with **two** types: an input and an output. For most schemas (e.g. `z.string()`) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance `z.string().transform(val => val.length)` has an input of `string` and an output of `number`.
+In reality each Zod schema internally tracks **two** types: an input and an output. For most schemas (e.g. `z.string()`) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance `z.string().transform(val => val.length)` has an input of `string` and an output of `number`.
 
 You can separately extract the input and output types like so:
 
@@ -1655,7 +1674,7 @@ Tuples
 Recursive Types
 Function Schemas
 
-<abbr title="For instance, Yup allows custmo error messages with the syntax yup.number().min(5, 'Number must be more than 5!')">Validation Messages</abbr>
+<abbr title="For instance, Yup allows custom error messages with the syntax yup.number().min(5, 'Number must be more than 5!')">Validation Messages</abbr>
 Immutable instances
 Type Guards
 Validity Checking
@@ -1688,7 +1707,7 @@ Yup is a full-featured library that was implemented first in vanilla JS, and lat
 
 Differences
 
-- Supports for casting and transformation
+- Supports casting and transforms
 - All object fields are optional by default
 - Missing object methods: (partial, deepPartial)
 <!-- - Missing nonempty arrays with proper typing (`[T, ...T[]]`) -->
diff --git a/README_ZH.md b/README_ZH.md
index 59a710b25..14614be5a 100644
--- a/README_ZH.md
+++ b/README_ZH.md
@@ -351,6 +351,8 @@ z.number().positive(); //     > 0
 z.number().nonnegative(); //  >= 0
 z.number().negative(); //     < 0
 z.number().nonpositive(); //  <= 0
+
+z.number().multipleOf(5); // x % 5 === 0
 ```
 
 你可以选择传入第二个参数来提供一个自定义的错误信息。
@@ -1418,13 +1420,12 @@ z.string()
 转换也可以是异步的。
 
 ```ts
-const IdToUser = z.transformer(
-  z.string().uuid(),
-  UserSchema,
-  (userId) => async (id) => {
+const IdToUser = z
+  .string()
+  .uuid()
+  .transform(async (id) => {
     return await getUserById(id);
-  }
-);
+  });
 ```
 
 > ⚠️ 如果你的模式包含异步变换器，你必须使用.parseAsync()或.safeParseAsync()来解析数据。否则，Zod 将抛出一个错误。
diff --git a/coverage.svg b/coverage.svg
index 4e2422f60..f9317e682 100644
--- a/coverage.svg
+++ b/coverage.svg
@@ -1 +1 @@
-<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 89.34%"><title>Coverage: 89.34%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#dfb317"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">89.34%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">89.34%</text></g></svg>
\ No newline at end of file
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 89.16%"><title>Coverage: 89.16%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#dfb317"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">89.16%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">89.16%</text></g></svg>
\ No newline at end of file
diff --git a/deno/lib/PseudoPromise.ts b/deno/lib/PseudoPromise.ts
deleted file mode 100644
index 864314f6a..000000000
--- a/deno/lib/PseudoPromise.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-export class PseudoPromise<PayloadType = undefined> {
-  readonly promise: Promise<PayloadType>;
-
-  constructor(promise: Promise<PayloadType>) {
-    this.promise = promise;
-  }
-
-  then<MappedType>(
-    f: (_v: PayloadType) => MappedType
-  ): PseudoPromise<MappedType> {
-    return new PseudoPromise<MappedType>(this.promise.then(f));
-  }
-
-  static all = <T extends (any | PseudoPromise<any>)[]>(
-    pps: T
-  ): PseudoPromise<
-    { [K in keyof T]: T[K] extends PseudoPromise<infer I> ? I : T[K] }
-  > => {
-    return new PseudoPromise(
-      Promise.all(pps.map((v) => (v instanceof PseudoPromise ? v.promise : v)))
-    ) as any;
-  };
-}
diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index 4ee50696b..077a2a23d 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -14,6 +14,7 @@ export const ZodIssueCode = util.arrayToEnum([
   "too_small",
   "too_big",
   "invalid_intersection_types",
+  "not_multiple_of",
 ]);
 
 export type ZodIssueCode = keyof typeof ZodIssueCode;
@@ -84,6 +85,11 @@ export interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.invalid_intersection_types;
 }
 
+export interface ZodNotMultipleOfIssue extends ZodIssueBase {
+  code: typeof ZodIssueCode.not_multiple_of;
+  multipleOf: number;
+}
+
 export interface ZodCustomIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.custom;
   params?: { [k: string]: any };
@@ -103,6 +109,7 @@ export type ZodIssueOptionalMessage =
   | ZodTooSmallIssue
   | ZodTooBigIssue
   | ZodInvalidIntersectionTypesIssue
+  | ZodNotMultipleOfIssue
   | ZodCustomIssue;
 
 export type ZodIssue = ZodIssueOptionalMessage & { message: string };
@@ -239,9 +246,10 @@ type stripPath<T extends object> = T extends any
   ? util.OmitKeys<T, "path">
   : never;
 
-export type MakeErrorData = stripPath<ZodIssueOptionalMessage> & {
+export type IssueData = stripPath<ZodIssueOptionalMessage> & {
   path?: (string | number)[];
 };
+export type MakeErrorData = IssueData;
 
 type ErrorMapCtx = {
   defaultError: string;
@@ -250,20 +258,20 @@ type ErrorMapCtx = {
 
 export type ZodErrorMap = typeof defaultErrorMap;
 export const defaultErrorMap = (
-  error: ZodIssueOptionalMessage,
+  issue: ZodIssueOptionalMessage,
   _ctx: ErrorMapCtx
 ): { message: string } => {
   let message: string;
-  switch (error.code) {
+  switch (issue.code) {
     case ZodIssueCode.invalid_type:
-      if (error.received === "undefined") {
+      if (issue.received === "undefined") {
         message = "Required";
       } else {
-        message = `Expected ${error.expected}, received ${error.received}`;
+        message = `Expected ${issue.expected}, received ${issue.received}`;
       }
       break;
     case ZodIssueCode.unrecognized_keys:
-      message = `Unrecognized key(s) in object: ${error.keys
+      message = `Unrecognized key(s) in object: ${issue.keys
         .map((k) => `'${k}'`)
         .join(", ")}`;
       break;
@@ -271,7 +279,7 @@ export const defaultErrorMap = (
       message = `Invalid input`;
       break;
     case ZodIssueCode.invalid_enum_value:
-      message = `Invalid enum value. Expected ${error.options
+      message = `Invalid enum value. Expected ${issue.options
         .map((val) => (typeof val === "string" ? `'${val}'` : val))
         .join(" | ")}, received ${
         typeof _ctx.data === "string" ? `'${_ctx.data}'` : _ctx.data
@@ -287,37 +295,37 @@ export const defaultErrorMap = (
       message = `Invalid date`;
       break;
     case ZodIssueCode.invalid_string:
-      if (error.validation !== "regex") message = `Invalid ${error.validation}`;
+      if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
       else message = "Invalid";
       break;
     case ZodIssueCode.too_small:
-      if (error.type === "array")
-        message = `Should have ${error.inclusive ? `at least` : `more than`} ${
-          error.minimum
+      if (issue.type === "array")
+        message = `Should have ${issue.inclusive ? `at least` : `more than`} ${
+          issue.minimum
         } items`;
-      else if (error.type === "string")
-        message = `Should be ${error.inclusive ? `at least` : `over`} ${
-          error.minimum
+      else if (issue.type === "string")
+        message = `Should be ${issue.inclusive ? `at least` : `over`} ${
+          issue.minimum
         } characters`;
-      else if (error.type === "number")
+      else if (issue.type === "number")
         message = `Value should be greater than ${
-          error.inclusive ? `or equal to ` : ``
-        }${error.minimum}`;
+          issue.inclusive ? `or equal to ` : ``
+        }${issue.minimum}`;
       else message = "Invalid input";
       break;
     case ZodIssueCode.too_big:
-      if (error.type === "array")
-        message = `Should have ${error.inclusive ? `at most` : `less than`} ${
-          error.maximum
+      if (issue.type === "array")
+        message = `Should have ${issue.inclusive ? `at most` : `less than`} ${
+          issue.maximum
         } items`;
-      else if (error.type === "string")
-        message = `Should be ${error.inclusive ? `at most` : `under`} ${
-          error.maximum
+      else if (issue.type === "string")
+        message = `Should be ${issue.inclusive ? `at most` : `under`} ${
+          issue.maximum
         } characters long`;
-      else if (error.type === "number")
+      else if (issue.type === "number")
         message = `Value should be less than ${
-          error.inclusive ? `or equal to ` : ``
-        }${error.maximum}`;
+          issue.inclusive ? `or equal to ` : ``
+        }${issue.maximum}`;
       else message = "Invalid input";
       break;
     case ZodIssueCode.custom:
@@ -326,9 +334,12 @@ export const defaultErrorMap = (
     case ZodIssueCode.invalid_intersection_types:
       message = `Intersection results could not be merged`;
       break;
+    case ZodIssueCode.not_multiple_of:
+      message = `Should be multiple of ${issue.multipleOf}`;
+      break;
     default:
       message = _ctx.defaultError;
-      util.assertNever(error);
+      util.assertNever(issue);
   }
   return { message };
 };
diff --git a/deno/lib/__tests__/all-errors.test.ts b/deno/lib/__tests__/all-errors.test.ts
index 99b98d66a..ecc8082ac 100644
--- a/deno/lib/__tests__/all-errors.test.ts
+++ b/deno/lib/__tests__/all-errors.test.ts
@@ -38,7 +38,7 @@ test("all errors", () => {
       b: null,
     });
   } catch (_error) {
-    const error: z.ZodError = _error;
+    const error = _error as z.ZodError;
     expect(error.flatten()).toEqual({
       formErrors: [],
       fieldErrors: {
diff --git a/deno/lib/__tests__/async-parsing.test.ts b/deno/lib/__tests__/async-parsing.test.ts
index 561a68559..83b4d6242 100644
--- a/deno/lib/__tests__/async-parsing.test.ts
+++ b/deno/lib/__tests__/async-parsing.test.ts
@@ -370,19 +370,23 @@ test("ensure early async failure prevents follow-up refinement checks", async ()
       .number()
       .refine(async () => {
         count++;
-        return false;
+        return true;
       })
       .refine(async () => {
         count++;
         return true;
-      }),
+      }, "Good"),
   });
 
   const testval = { hello: "bye", foo: 3 };
-  const result = base.safeParseAsync(testval);
+  const result = await base.safeParseAsync(testval);
+  if (result.success === false) {
+    expect(result.error.issues.length).toBe(1);
+    expect(count).toBe(1);
+  }
 
-  await result.then((r) => {
-    if (r.success === false) expect(r.error.issues.length).toBe(1);
-    expect(count).toBe(2);
-  });
+  // await result.then((r) => {
+  //   if (r.success === false) expect(r.error.issues.length).toBe(1);
+  //   expect(count).toBe(2);
+  // });
 });
diff --git a/deno/lib/__tests__/error.test.ts b/deno/lib/__tests__/error.test.ts
index 5ef8ee2ba..1758bcaa3 100644
--- a/deno/lib/__tests__/error.test.ts
+++ b/deno/lib/__tests__/error.test.ts
@@ -42,7 +42,7 @@ test("type error with custom error map", () => {
   try {
     z.string().parse(234, { errorMap });
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
 
     expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
     expect(zerr.issues[0].message).toEqual(`bad type!`);
@@ -57,7 +57,7 @@ test("refinement fail with params", () => {
       })
       .parse(2, { errorMap });
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
     expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.custom);
     expect(zerr.issues[0].message).toEqual(`less-than-3`);
   }
@@ -72,7 +72,7 @@ test("custom error with custom errormap", () => {
       })
       .parse("asdf", { errorMap });
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
     expect(zerr.issues[0].message).toEqual("override");
   }
 });
@@ -83,7 +83,7 @@ test("default error message", () => {
       .refine((x) => x > 3)
       .parse(2);
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
     expect(zerr.issues.length).toEqual(1);
     expect(zerr.issues[0].message).toEqual("Invalid input");
   }
@@ -95,7 +95,7 @@ test("override error in refine", () => {
       .refine((x) => x > 3, "override")
       .parse(2);
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
     expect(zerr.issues.length).toEqual(1);
     expect(zerr.issues[0].message).toEqual("override");
   }
@@ -109,7 +109,7 @@ test("override error in refinement", () => {
       })
       .parse(2);
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
     expect(zerr.issues.length).toEqual(1);
     expect(zerr.issues[0].message).toEqual("override");
   }
@@ -119,14 +119,14 @@ test("array minimum", () => {
   try {
     z.array(z.string()).min(3, "tooshort").parse(["asdf", "qwer"]);
   } catch (err) {
-    const zerr: ZodError = err;
+    const zerr: ZodError = err as any;
     expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);
     expect(zerr.issues[0].message).toEqual("tooshort");
   }
   try {
     z.array(z.string()).min(3).parse(["asdf", "qwer"]);
   } catch (err) {
-    const zerr: ZodError = err;
+    const zerr: ZodError = err as any;
     expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);
     expect(zerr.issues[0].message).toEqual(`Should have at least 3 items`);
   }
@@ -231,17 +231,28 @@ test("custom path", () => {
   }
 });
 
-test("formatting", () => {
-  const schema = z.object({
-    inner: z.object({
-      name: z
-        .string()
-        .refine((val) => val.length > 5)
-        .array()
-        .refine((val) => val.length <= 1),
-    }),
-  });
+const schema = z.object({
+  inner: z.object({
+    name: z
+      .string()
+      .refine((val) => val.length > 5)
+      .array()
+      .refine((val) => val.length <= 1),
+  }),
+});
 
+test("no abort early on refinements", () => {
+  const invalidItem = {
+    inner: { name: ["aasd", "asdfasdfasfd"] },
+  };
+
+  const result1 = schema.safeParse(invalidItem);
+  expect(result1.success).toEqual(false);
+  if (!result1.success) {
+    expect(result1.error.issues.length).toEqual(2);
+  }
+});
+test("formatting", () => {
   const invalidItem = {
     inner: { name: ["aasd", "asdfasdfasfd"] },
   };
@@ -257,7 +268,7 @@ test("formatting", () => {
     const error = result1.error.format();
     expect(error._errors).toEqual([]);
     expect(error.inner?._errors).toEqual([]);
-    expect(error.inner?.name?._errors).toEqual([]);
+    expect(error.inner?.name?._errors).toEqual(["Invalid input"]);
     expect(error.inner?.name?.[0]._errors).toEqual(["Invalid input"]);
     expect(error.inner?.name?.[1]).toEqual(undefined);
   }
@@ -271,3 +282,104 @@ test("formatting", () => {
     expect(error.inner?.name?.[2]).toEqual(undefined);
   }
 });
+
+const stringWithCustomError = z.string({
+  errorMap: (issue, ctx) => ({
+    message:
+      issue.code === "invalid_type"
+        ? ctx.data
+          ? "Invalid name"
+          : "Name is required"
+        : ctx.defaultError,
+  }),
+});
+
+test("schema-bound error map", () => {
+  const result = stringWithCustomError.safeParse(1234);
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual("Invalid name");
+  }
+
+  const result2 = stringWithCustomError.safeParse(undefined);
+  expect(result2.success).toEqual(false);
+  if (!result2.success) {
+    expect(result2.error.issues[0].message).toEqual("Name is required");
+  }
+
+  // support contextual override
+  const result3 = stringWithCustomError.safeParse(undefined, {
+    errorMap: () => ({ message: "OVERRIDE" }),
+  });
+  expect(result3.success).toEqual(false);
+  if (!result3.success) {
+    expect(result3.error.issues[0].message).toEqual("OVERRIDE");
+  }
+});
+
+test("overrideErrorMap", () => {
+  // support overrideErrorMap
+  z.setErrorMap(() => ({ message: "OVERRIDE" }));
+  const result4 = stringWithCustomError.min(10).safeParse("tooshort");
+  expect(result4.success).toEqual(false);
+  if (!result4.success) {
+    expect(result4.error.issues[0].message).toEqual("OVERRIDE");
+  }
+  z.setErrorMap(z.defaultErrorMap);
+});
+
+test("invalid and required", () => {
+  const str = z.string({
+    invalid_type_error: "Invalid name",
+    required_error: "Name is required",
+  });
+  const result1 = str.safeParse(1234);
+  expect(result1.success).toEqual(false);
+  if (!result1.success) {
+    expect(result1.error.issues[0].message).toEqual("Invalid name");
+  }
+  const result2 = str.safeParse(undefined);
+  expect(result2.success).toEqual(false);
+  if (!result2.success) {
+    expect(result2.error.issues[0].message).toEqual("Name is required");
+  }
+});
+
+test("Fallback to invalid_type_error without required_error", () => {
+  const str = z.string({
+    invalid_type_error: "Invalid name",
+    // required_error: "Name is required",
+  });
+
+  const result2 = str.safeParse(undefined);
+  expect(result2.success).toEqual(false);
+  if (!result2.success) {
+    expect(result2.error.issues[0].message).toEqual("Invalid name");
+  }
+});
+
+test("invalid and required and errorMap", () => {
+  expect(() => {
+    return z.string({
+      invalid_type_error: "Invalid name",
+      required_error: "Name is required",
+      errorMap: () => ({ message: "OVERRIDE" }),
+    });
+  }).toThrow();
+});
+
+test("dont short circuit on continuable errors", () => {
+  const user = z
+    .object({
+      password: z.string().min(6),
+      confirm: z.string(),
+    })
+    .refine((data) => data.password === data.confirm, {
+      message: "Passwords don't match",
+      path: ["confirm"],
+    });
+  const result = user.safeParse({ password: "asdf", confirm: "qwer" });
+  if (!result.success) {
+    expect(result.error.issues.length).toEqual(2);
+  }
+});
diff --git a/deno/lib/__tests__/function.test.ts b/deno/lib/__tests__/function.test.ts
index 1e6cec145..dd23063f8 100644
--- a/deno/lib/__tests__/function.test.ts
+++ b/deno/lib/__tests__/function.test.ts
@@ -125,7 +125,7 @@ test("special function error codes", () => {
   try {
     checker("12" as any);
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr = err as z.ZodError;
     const first = zerr.issues[0];
     if (first.code !== z.ZodIssueCode.invalid_return_type) throw new Error();
 
@@ -135,7 +135,7 @@ test("special function error codes", () => {
   try {
     checker(12 as any);
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr = err as z.ZodError;
     const first = zerr.issues[0];
     if (first.code !== z.ZodIssueCode.invalid_arguments) throw new Error();
     expect(first.argumentsError).toBeInstanceOf(z.ZodError);
@@ -186,3 +186,22 @@ test("non async function with async refinements should fail", async () => {
 
   expect(results).toEqual(["fail"]);
 });
+
+test("allow extra parameters", () => {
+  const maxLength5 = z
+    .function()
+    .args(z.string())
+    .returns(z.boolean())
+    .implement((str, _arg, _qewr) => {
+      return str.length <= 5;
+    });
+
+  const filteredList = [
+    "apple",
+    "orange",
+    "pear",
+    "banana",
+    "strawberry",
+  ].filter(maxLength5);
+  expect(filteredList.length).toEqual(2);
+});
diff --git a/deno/lib/__tests__/nullable.test.ts b/deno/lib/__tests__/nullable.test.ts
index 0c09b85dd..4dd9e8094 100644
--- a/deno/lib/__tests__/nullable.test.ts
+++ b/deno/lib/__tests__/nullable.test.ts
@@ -9,12 +9,12 @@ function checkErrors(a: z.ZodTypeAny, bad: any) {
   try {
     a.parse(bad);
   } catch (error) {
-    expected = error.formErrors;
+    expected = (error as z.ZodError).formErrors;
   }
   try {
     a.nullable().parse(bad);
   } catch (error) {
-    expect(error.formErrors).toEqual(expected);
+    expect((error as z.ZodError).formErrors).toEqual(expected);
   }
 }
 
diff --git a/deno/lib/__tests__/number.test.ts b/deno/lib/__tests__/number.test.ts
index 1dc16981b..882ec970c 100644
--- a/deno/lib/__tests__/number.test.ts
+++ b/deno/lib/__tests__/number.test.ts
@@ -9,6 +9,8 @@ const gteFive = z.number().gte(5);
 const ltFive = z.number().lt(5);
 const lteFive = z.number().lte(5);
 const intNum = z.number().int();
+const multipleOfFive = z.number().multipleOf(5);
+const stepSixPointFour = z.number().step(6.4);
 
 test("passing validations", () => {
   gtFive.parse(6);
@@ -16,6 +18,8 @@ test("passing validations", () => {
   ltFive.parse(4);
   lteFive.parse(5);
   intNum.parse(4);
+  multipleOfFive.parse(15);
+  stepSixPointFour.parse(12.8);
 });
 
 test("failing validations", () => {
@@ -24,6 +28,8 @@ test("failing validations", () => {
   expect(() => gtFive.parse(5)).toThrow();
   expect(() => gteFive.parse(4)).toThrow();
   expect(() => intNum.parse(3.14)).toThrow();
+  expect(() => multipleOfFive.parse(14.9)).toThrow();
+  expect(() => stepSixPointFour.parse(6.41)).toThrow();
 });
 
 test("parse NaN", () => {
diff --git a/deno/lib/__tests__/object.test.ts b/deno/lib/__tests__/object.test.ts
index 37bcf7c9e..71b02b41f 100644
--- a/deno/lib/__tests__/object.test.ts
+++ b/deno/lib/__tests__/object.test.ts
@@ -194,7 +194,7 @@ test("test nonexistent keys", async () => {
   expect(result.success).toBe(true);
 });
 
-test("test async PseudoPromise.all", async () => {
+test("test async union", async () => {
   const Schema2 = z.union([
     z.object({
       ty: z.string(),
diff --git a/deno/lib/__tests__/optional.test.ts b/deno/lib/__tests__/optional.test.ts
index 3c4bd60dd..15b08a4fa 100644
--- a/deno/lib/__tests__/optional.test.ts
+++ b/deno/lib/__tests__/optional.test.ts
@@ -9,12 +9,12 @@ function checkErrors(a: z.ZodTypeAny, bad: any) {
   try {
     a.parse(bad);
   } catch (error) {
-    expected = error.formErrors;
+    expected = (error as z.ZodError).formErrors;
   }
   try {
     a.optional().parse(bad);
   } catch (error) {
-    expect(error.formErrors).toEqual(expected);
+    expect((error as z.ZodError).formErrors).toEqual(expected);
   }
 }
 
diff --git a/deno/lib/__tests__/primitive.test.ts b/deno/lib/__tests__/primitive.test.ts
index f3fe2fd50..94d554c13 100644
--- a/deno/lib/__tests__/primitive.test.ts
+++ b/deno/lib/__tests__/primitive.test.ts
@@ -246,7 +246,9 @@ test("parse dateSchema invalid date", async () => {
   try {
     await dateSchema.parseAsync(new Date("invalid"));
   } catch (err) {
-    expect(err.issues[0].code).toEqual(z.ZodIssueCode.invalid_date);
+    expect((err as z.ZodError).issues[0].code).toEqual(
+      z.ZodIssueCode.invalid_date
+    );
   }
 });
 // ==============
diff --git a/deno/lib/__tests__/pseudopromise.test.ts b/deno/lib/__tests__/pseudopromise.test.ts
deleted file mode 100644
index 3a62a921d..000000000
--- a/deno/lib/__tests__/pseudopromise.test.ts
+++ /dev/null
@@ -1,75 +0,0 @@
-// @ts-ignore TS6133
-import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
-const test = Deno.test;
-
-test("foo", () => {
-  expect(1).toEqual(1);
-});
-
-/*
-// import * as z from '.';
-import { PseudoPromise } from "../PseudoPromise.ts";
-
-test("sync pass", () => {
-  const myProm = new PseudoPromise()
-    .then(() => 15)
-    .then((arg) => arg.toString())
-    .then((arg) => arg.length);
-  expect(myProm.getValueSync()).toEqual(2);
-});
-
-test("sync fail", async () => {
-  const myProm = new PseudoPromise()
-    .then(async () => 15)
-    .then((arg) => arg.toString())
-    .then((arg) => {
-      return arg.length;
-    });
-
-  expect(myProm.getValueSync()).toEqual(16);
-  myProm.getValueSync();
-  // expect(myProm.getValue()).resolves.toEqual(2);
-  const val = await myProm.getValueAsync();
-  expect(val).toEqual(2);
-  // (myProm.getValue() as Promise<any>).then(val => expect(val).toEqual(2));
-});
-
-test("pseudopromise all", async () => {
-  const myProm = PseudoPromise.all([
-    new PseudoPromise().then(() => "asdf"),
-    PseudoPromise.resolve(12),
-  ]).getValueAsync();
-  await expect(await myProm).toEqual(["asdf", 12]);
-});
-
-test(".resolve sync ", () => {
-  expect(PseudoPromise.resolve(12).getValueSync()).toEqual(12);
-});
-
-test(".resolve async", async () => {
-  expect(
-    await PseudoPromise.resolve(Promise.resolve(12)).getValueAsync()
-  ).toEqual(12);
-});
-
-test("sync and async", async () => {
-  expect(PseudoPromise.resolve(15).getValueSync()).toEqual(15);
-  expect(await PseudoPromise.resolve(15).getValueAsync()).toEqual(15);
-});
-
-test("object", async () => {
-  const prom = PseudoPromise.object({
-    asdf: PseudoPromise.resolve(15),
-    qwer: new PseudoPromise().then(async () => "asdfadsf"),
-  });
-
-  expect(await prom.getValueAsync()).toEqual({ asdf: 15, qwer: "asdfadsf" });
-});
-
-test("all", async () => {
-  const asdf = new PseudoPromise().then(async () => "asdf");
-  await PseudoPromise.all([asdf])
-    .getValueAsync()
-    .then((val) => expect(val).toEqual(["asdf"]));
-});
-*/
diff --git a/deno/lib/__tests__/record.test.ts b/deno/lib/__tests__/record.test.ts
index f39c8573d..396435c76 100644
--- a/deno/lib/__tests__/record.test.ts
+++ b/deno/lib/__tests__/record.test.ts
@@ -8,9 +8,29 @@ import * as z from "../index.ts";
 const booleanRecord = z.record(z.boolean());
 type booleanRecord = z.infer<typeof booleanRecord>;
 
+const recordWithEnumKeys = z.record(z.enum(["Tuna", "Salmon"]), z.string());
+type recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;
+
+const recordWithLiteralKeys = z.record(
+  z.union([z.literal("Tuna"), z.literal("Salmon")]),
+  z.string()
+);
+type recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;
+
 test("type inference", () => {
   const f1: util.AssertEqual<booleanRecord, Record<string, boolean>> = true;
   f1;
+
+  const f2: util.AssertEqual<
+    recordWithEnumKeys,
+    Record<"Tuna" | "Salmon", string>
+  > = true;
+  f2;
+  const f3: util.AssertEqual<
+    recordWithLiteralKeys,
+    Record<"Tuna" | "Salmon", string>
+  > = true;
+  f3;
 });
 
 test("methods", () => {
@@ -51,3 +71,44 @@ test("string record parse - fail", () => {
     } as any);
   expect(badCheck).toThrow();
 });
+
+test("key schema", () => {
+  const result1 = recordWithEnumKeys.parse({
+    Tuna: "asdf",
+    Salmon: "asdf",
+  });
+  expect(result1).toEqual({
+    Tuna: "asdf",
+    Salmon: "asdf",
+  });
+
+  const result2 = recordWithLiteralKeys.parse({
+    Tuna: "asdf",
+    Salmon: "asdf",
+  });
+  expect(result2).toEqual({
+    Tuna: "asdf",
+    Salmon: "asdf",
+  });
+
+  expect(() =>
+    recordWithEnumKeys.parse({
+      Tuna: "asdf",
+      Salmon: "asdf",
+      Trout: "asdf",
+    })
+  ).toThrow();
+
+  expect(() =>
+    recordWithLiteralKeys.parse({
+      Tuna: "asdf",
+      Salmon: "asdf",
+
+      Trout: "asdf",
+    })
+  ).toThrow();
+});
+
+// test("record element", () => {
+//   expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);
+// });
diff --git a/deno/lib/__tests__/refine.test.ts b/deno/lib/__tests__/refine.test.ts
index 443372e8c..22e423f9b 100644
--- a/deno/lib/__tests__/refine.test.ts
+++ b/deno/lib/__tests__/refine.test.ts
@@ -59,7 +59,7 @@ test("custom path", async () => {
       .refine((data) => data.confirm === data.password, { path: ["confirm"] })
       .parseAsync({ password: "asdf", confirm: "qewr" });
   } catch (err) {
-    expect(err.issues[0].path).toEqual(["confirm"]);
+    expect((err as z.ZodError).issues[0].path).toEqual(["confirm"]);
   }
 });
 
diff --git a/deno/lib/__tests__/string.test.ts b/deno/lib/__tests__/string.test.ts
index 22be848ce..5fdf4fcb6 100644
--- a/deno/lib/__tests__/string.test.ts
+++ b/deno/lib/__tests__/string.test.ts
@@ -66,17 +66,17 @@ test("url error overrides", () => {
   try {
     z.string().url().parse("https");
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Invalid url");
+    expect((err as z.ZodError).issues[0].message).toEqual("Invalid url");
   }
   try {
     z.string().url("badurl").parse("https");
   } catch (err) {
-    expect(err.issues[0].message).toEqual("badurl");
+    expect((err as z.ZodError).issues[0].message).toEqual("badurl");
   }
   try {
     z.string().url({ message: "badurl" }).parse("https");
   } catch (err) {
-    expect(err.issues[0].message).toEqual("badurl");
+    expect((err as z.ZodError).issues[0].message).toEqual("badurl");
   }
 });
 
diff --git a/deno/lib/__tests__/transformer.test.ts b/deno/lib/__tests__/transformer.test.ts
index 8b6784c76..d3b5b855f 100644
--- a/deno/lib/__tests__/transformer.test.ts
+++ b/deno/lib/__tests__/transformer.test.ts
@@ -9,20 +9,18 @@ const stringToNumber = z.string().transform((arg) => parseFloat(arg));
 // const numberToString = z
 //   .transformer(z.number())
 //   .transform((n) => String(n));
-const asyncNumberToString = z
-  .transformer(z.number())
-  .transform(async (n) => String(n));
+const asyncNumberToString = z.number().transform(async (n) => String(n));
 
 test("basic transformations", () => {
   const r1 = z
-    .transformer(z.string())
+    .string()
     .transform((data) => data.length)
     .parse("asdf");
   expect(r1).toEqual(4);
 });
 
 test("coercion", () => {
-  const numToString = z.transformer(z.number()).transform((n) => String(n));
+  const numToString = z.number().transform((n) => String(n));
   const data = z
     .object({
       id: numToString,
@@ -33,9 +31,7 @@ test("coercion", () => {
 });
 
 test("async coercion", async () => {
-  const numToString = z
-    .transformer(z.number())
-    .transform(async (n) => String(n));
+  const numToString = z.number().transform(async (n) => String(n));
   const data = await z
     .object({
       id: numToString,
@@ -127,3 +123,10 @@ test("preprocess", () => {
   const value = schema.parse("asdf");
   expect(value).toEqual(["asdf"]);
 });
+
+test("async preprocess", async () => {
+  const schema = z.preprocess(async (data) => [data], z.string().array());
+
+  const value = await schema.parseAsync("asdf");
+  expect(value).toEqual(["asdf"]);
+});
diff --git a/deno/lib/__tests__/tuple.test.ts b/deno/lib/__tests__/tuple.test.ts
index 4363fc421..ad9c97bee 100644
--- a/deno/lib/__tests__/tuple.test.ts
+++ b/deno/lib/__tests__/tuple.test.ts
@@ -61,19 +61,37 @@ test("failed async validation", async () => {
   // }
 });
 
-// test("tuple with transformers", () => {
-//   const stringToNumber = z.string().transform(z.number(), (val) => val.length);
-//   const val = z.tuple([stringToNumber]);
+test("tuple with transformers", () => {
+  const stringToNumber = z.string().transform((val) => val.length);
+  const val = z.tuple([stringToNumber]);
 
-//   type t1 = z.input<typeof val>;
-//   const f1: util.AssertEqual<t1, [string]> = true;
-//   //  const f1: util.AssertEqual<t1, [string]> =
-//   type t2 = z.output<typeof val>;
-//   const f2: util.AssertEqual<t2, [number]> = true;
+  type t1 = z.input<typeof val>;
+  const f1: util.AssertEqual<t1, [string]> = true;
+  type t2 = z.output<typeof val>;
+  const f2: util.AssertEqual<t2, [number]> = true;
+  expect(val.parse(["1234"])).toEqual([4]);
+  f1;
+  f2;
+});
 
-//   f1;
-//   f2;
-// });
+test("tuple with rest schema", () => {
+  const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());
+  expect(myTuple.parse(["asdf", 1234, true, false, true])).toEqual([
+    "asdf",
+    1234,
+    true,
+    false,
+    true,
+  ]);
+
+  expect(myTuple.parse(["asdf", 1234])).toEqual(["asdf", 1234]);
+
+  expect(() => myTuple.parse(["asdf", 1234, "asdf"])).toThrow();
+  type t1 = z.output<typeof myTuple>;
+
+  const f1: util.AssertEqual<t1, [string, number, ...boolean[]]> = true;
+  f1;
+});
 
 // test('tuple with optional elements', () => {
 //   const result = z
diff --git a/deno/lib/__tests__/validations.test.ts b/deno/lib/__tests__/validations.test.ts
index b3ba23faf..31c6243e8 100644
--- a/deno/lib/__tests__/validations.test.ts
+++ b/deno/lib/__tests__/validations.test.ts
@@ -8,7 +8,9 @@ test("array min", async () => {
   try {
     await z.array(z.string()).min(4).parseAsync([]);
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Should have at least 4 items");
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Should have at least 4 items"
+    );
   }
 });
 
@@ -16,7 +18,9 @@ test("array max", async () => {
   try {
     await z.array(z.string()).max(2).parseAsync(["asdf", "asdf", "asdf"]);
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Should have at most 2 items");
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Should have at most 2 items"
+    );
   }
 });
 
@@ -24,7 +28,9 @@ test("string min", async () => {
   try {
     await z.string().min(4).parseAsync("asd");
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Should be at least 4 characters");
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Should be at least 4 characters"
+    );
   }
 });
 
@@ -32,7 +38,7 @@ test("string max", async () => {
   try {
     await z.string().max(4).parseAsync("aasdfsdfsd");
   } catch (err) {
-    expect(err.issues[0].message).toEqual(
+    expect((err as z.ZodError).issues[0].message).toEqual(
       "Should be at most 4 characters long"
     );
   }
@@ -42,7 +48,7 @@ test("number min", async () => {
   try {
     await z.number().gte(3).parseAsync(2);
   } catch (err) {
-    expect(err.issues[0].message).toEqual(
+    expect((err as z.ZodError).issues[0].message).toEqual(
       "Value should be greater than or equal to 3"
     );
   }
@@ -52,7 +58,7 @@ test("number max", async () => {
   try {
     await z.number().lte(3).parseAsync(4);
   } catch (err) {
-    expect(err.issues[0].message).toEqual(
+    expect((err as z.ZodError).issues[0].message).toEqual(
       "Value should be less than or equal to 3"
     );
   }
@@ -62,7 +68,7 @@ test("number nonnegative", async () => {
   try {
     await z.number().nonnegative().parseAsync(-1);
   } catch (err) {
-    expect(err.issues[0].message).toEqual(
+    expect((err as z.ZodError).issues[0].message).toEqual(
       "Value should be greater than or equal to 0"
     );
   }
@@ -72,7 +78,7 @@ test("number nonpositive", async () => {
   try {
     await z.number().nonpositive().parseAsync(1);
   } catch (err) {
-    expect(err.issues[0].message).toEqual(
+    expect((err as z.ZodError).issues[0].message).toEqual(
       "Value should be less than or equal to 0"
     );
   }
@@ -82,7 +88,9 @@ test("number negative", async () => {
   try {
     await z.number().negative().parseAsync(1);
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Value should be less than 0");
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Value should be less than 0"
+    );
   }
 });
 
@@ -90,7 +98,9 @@ test("number positive", async () => {
   try {
     await z.number().positive().parseAsync(-1);
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Value should be greater than 0");
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Value should be greater than 0"
+    );
   }
 });
 
diff --git a/deno/lib/helpers/parseUtil.ts b/deno/lib/helpers/parseUtil.ts
index 7034e260a..81015dc18 100644
--- a/deno/lib/helpers/parseUtil.ts
+++ b/deno/lib/helpers/parseUtil.ts
@@ -1,9 +1,7 @@
-import { PseudoPromise } from "../PseudoPromise.ts";
 import {
   defaultErrorMap,
-  MakeErrorData,
+  IssueData,
   overrideErrorMap,
-  ZodError,
   ZodErrorMap,
   ZodIssue,
 } from "../ZodError.ts";
@@ -76,38 +74,44 @@ export const getParsedType = (data: any): ZodParsedType => {
 };
 
 export const makeIssue = (
-  data: any,
-  path: (string | number)[],
-  errorMap: ZodErrorMap,
-  errorData: MakeErrorData
+  params: {
+    data: any;
+    path: (string | number)[];
+    errorMaps: (ZodErrorMap | undefined)[];
+    issueData: IssueData;
+  }
+  // data: any,
+  // path: (string | number)[],
+  // errorMap: ZodErrorMap,
+  // issueData: IssueData
 ): ZodIssue => {
-  const fullPath = [...path, ...(errorData.path || [])];
-  const errorArg = {
-    ...errorData,
+  const { data, path, errorMaps, issueData } = params;
+  const fullPath = [...path, ...(issueData.path || [])];
+  const fullIssue = {
+    ...issueData,
     path: fullPath,
   };
 
-  const defaultError = defaultErrorMap(errorArg, {
-    data: data,
-    defaultError: `Invalid input`,
-  });
+  let errorMessage = "";
+  const maps = errorMaps
+    .filter((m) => !!m)
+    .slice()
+    .reverse() as ZodErrorMap[];
+  for (const map of maps) {
+    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
+  }
+
   return {
-    ...errorData,
+    ...issueData,
     path: fullPath,
-    message:
-      errorData.message ||
-      errorMap(errorArg, {
-        data: data,
-        defaultError: defaultError.message,
-      }).message,
+    message: issueData.message || errorMessage,
   };
 };
 
 export type ParseParams = {
-  data: any;
+  // data: any;
   path: (string | number)[];
   errorMap: ZodErrorMap;
-  parentError: ZodError;
   async: boolean;
 };
 
@@ -146,56 +150,78 @@ export type ParseContextParameters = {
   async: boolean;
 };
 
+interface ParseContextDef {
+  readonly path: ParsePath;
+  readonly issues: ZodIssue[];
+  readonly errorMap?: ZodErrorMap;
+  readonly async: boolean;
+}
+
 export class ParseContext {
-  constructor(
-    public readonly path: ParsePath,
-    public readonly issues: ZodIssue[],
-    public readonly params: ParseContextParameters
-  ) {}
+  // public readonly path: ParsePath;
+  // public readonly issues: ZodIssue[];
+  // public readonly errorMap: ZodErrorMap;
+  public readonly def: ParseContextDef;
+
+  constructor(def: ParseContextDef) {
+    this.def = def;
+  }
+  get path() {
+    return this.def.path;
+  }
+  get issues() {
+    return this.def.issues;
+  }
+  get errorMap() {
+    return this.def.errorMap;
+  }
+  get async() {
+    return this.def.async;
+  }
 
   stepInto(component: ParsePathComponent): ParseContext {
-    return new ParseContext(
-      this.path === null
-        ? { parent: null, count: 1, component }
-        : { parent: this.path, count: this.path.count + 1, component },
-      this.issues,
-      this.params
-    );
+    return new ParseContext({
+      ...this.def,
+      path:
+        this.path === null
+          ? { parent: null, count: 1, component }
+          : { parent: this.path, count: this.path.count + 1, component },
+    });
   }
 
-  addIssue(data: any, errorData: MakeErrorData): void {
-    const issue = makeIssue(
+  addIssue(
+    data: any,
+    issueData: IssueData,
+    params: { schemaErrorMap?: ZodErrorMap } = {}
+  ): void {
+    const issue = makeIssue({
       data,
-      pathToArray(this.path),
-      this.params.errorMap,
-      errorData
-    );
+      issueData,
+      path: pathToArray(this.path),
+      errorMaps: [
+        this.def.errorMap, // contextual error map is first priority
+        params.schemaErrorMap, // then schema-bound map if available
+        overrideErrorMap, // then global override map
+        defaultErrorMap, // then global default map
+      ],
+      // errorMaps: [this.errorMap],
+      // issueData,
+    });
     this.issues.push(issue);
   }
 }
 
-export const createRootContext = (
-  params: Partial<ParseParamsNoData>
-): ParseContext =>
-  new ParseContext(EMPTY_PATH, [], {
-    async: params.async ?? false,
-    errorMap: params.errorMap || overrideErrorMap,
-  });
-
 export type INVALID = { valid: false };
 export const INVALID: INVALID = Object.freeze({ valid: false });
 
 export type OK<T> = { valid: true; value: T };
 export const OK = <T>(value: T): OK<T> => ({ valid: true, value });
 
-export type ASYNC<T> = PseudoPromise<T>;
-export const ASYNC = <T>(promise: Promise<T>): ASYNC<T> =>
-  new PseudoPromise<T>(promise);
-
 export type SyncParseReturnType<T> = OK<T> | INVALID;
+export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
 export type ParseReturnType<T> =
   | SyncParseReturnType<T>
-  | ASYNC<SyncParseReturnType<T>>;
+  | AsyncParseReturnType<T>;
 
 export const isInvalid = (x: ParseReturnType<any>): x is INVALID =>
   (x as any).valid === false;
@@ -203,4 +229,4 @@ export const isOk = <T>(x: ParseReturnType<T>): x is OK<T> =>
   (x as any).valid === true;
 export const isAsync = <T>(
   x: ParseReturnType<T>
-): x is ASYNC<SyncParseReturnType<T>> => x instanceof PseudoPromise;
+): x is AsyncParseReturnType<T> => x instanceof Promise;
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index dcd2c2684..b949c3a93 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -1,6 +1,6 @@
 import { errorUtil } from "./helpers/errorUtil.ts";
 import {
-  ASYNC,
+  AsyncParseReturnType,
   getParsedType,
   INVALID,
   isAsync,
@@ -18,13 +18,12 @@ import {
 } from "./helpers/parseUtil.ts";
 import { partialUtil } from "./helpers/partialUtil.ts";
 import { util } from "./helpers/util.ts";
-import { PseudoPromise } from "./PseudoPromise.ts";
 import {
-  MakeErrorData,
-  overrideErrorMap,
+  IssueData,
   StringValidation,
   ZodCustomIssue,
   ZodError,
+  ZodErrorMap,
   ZodIssue,
   ZodIssueCode,
 } from "./ZodError.ts";
@@ -38,46 +37,87 @@ import {
 ///////////////////////////////////////
 
 export type RefinementCtx = {
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
   path: (string | number)[];
-  issueFound: boolean;
 };
 export type ZodRawShape = { [k: string]: ZodTypeAny };
 export type ZodTypeAny = ZodType<any, any, any>;
-export type TypeOf<T extends ZodType<any>> = T["_output"];
-export type input<T extends ZodType<any>> = T["_input"];
-export type output<T extends ZodType<any>> = T["_output"];
+export type TypeOf<T extends ZodType<any, any, any>> = T["_output"];
+export type input<T extends ZodType<any, any, any>> = T["_input"];
+export type output<T extends ZodType<any, any, any>> = T["_output"];
 export type { TypeOf as infer };
 
 export type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
-export interface ZodTypeDef {}
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
 
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === "string") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
 
 const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap,
     async: params.async ?? false,
-    errorMap: params.errorMap || overrideErrorMap,
   });
 
 const handleResult = <Input, Output>(
   ctx: ParseContext,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
 ):
   | { success: true; data: Output }
   | { success: false; error: ZodError<Input> } => {
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
     return { success: true, data: result.value };
   } else {
-    parentError?.addIssues(ctx.issues);
     const error = new ZodError(ctx.issues);
     return { success: false, error };
   }
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
 };
 
+type RawCreateParams =
+  | {
+      errorMap?: ZodErrorMap;
+      invalid_type_error?: string;
+      required_error?: string;
+    }
+  | undefined;
+type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
+  if (!params) return {};
+  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+    throw new Error(
+      `Can't use "invalid" or "required" in conjunction with custom error map.`
+    );
+  }
+  if (params.errorMap) return { errorMap: params.errorMap };
+  const customMap: ZodErrorMap = (iss, ctx) => {
+    if (iss.code !== "invalid_type") return { message: ctx.defaultError };
+    if (typeof ctx.data === "undefined" && params.required_error)
+      return { message: params.required_error };
+    if (params.invalid_type_error)
+      return { message: params.invalid_type_error };
+    return { message: ctx.defaultError };
+  };
+  return { errorMap: customMap };
+}
+
 export abstract class ZodType<
   Output,
   Def extends ZodTypeDef = ZodTypeDef,
@@ -94,6 +134,12 @@ export abstract class ZodType<
     _parsedType: ZodParsedType
   ): ParseReturnType<Output>;
 
+  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx.addIssue(params.data, issueData, {
+      schemaErrorMap: this._def.errorMap,
+    });
+  }
+
   _parseSync(
     _ctx: ParseContext,
     _data: any,
@@ -106,62 +152,72 @@ export abstract class ZodType<
     return result;
   }
 
-  parse: (data: unknown, params?: Partial<ParseParamsNoData>) => Output = (
-    data,
-    params
-  ) => {
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    // if (isAsync(result)) {
+    //   return result;
+    // }
+
+    return Promise.resolve(result);
+  }
+
+  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
     const result = this.safeParse(data, params);
     if (result.success) return result.data;
     throw result.error;
-  };
+  }
 
-  safeParse: (
+  safeParse(
     data: unknown,
     params?: Partial<ParseParamsNoData>
-  ) =>
+  ):
     | { success: true; data: Output }
-    | { success: false; error: ZodError<Input> } = (data, params) => {
+    | { success: false; error: ZodError<Input> } {
     const ctx = createRootContext({ ...params, async: false });
     const result = this._parseSync(ctx, data, getParsedType(data));
-    return handleResult(ctx, result, params?.parentError);
-  };
+    return handleResult(ctx, result);
+  }
 
-  parseAsync: (
-    x: unknown,
+  async parseAsync(
+    data: unknown,
     params?: Partial<ParseParamsNoData>
-  ) => Promise<Output> = async (data, params) => {
+  ): Promise<Output> {
     const result = await this.safeParseAsync(data, params);
     if (result.success) return result.data;
     throw result.error;
-  };
+  }
 
-  safeParseAsync: (
-    x: unknown,
+  async safeParseAsync(
+    data: unknown,
     params?: Partial<ParseParamsNoData>
-  ) => Promise<
+  ): Promise<
     { success: true; data: Output } | { success: false; error: ZodError }
-  > = async (data, params) => {
+  > {
     const ctx = createRootContext({ ...params, async: true });
     const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
     const result = await (isAsync(maybeAsyncResult)
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
       : Promise.resolve(maybeAsyncResult));
-    return handleResult(ctx, result, params?.parentError);
-  };
+    return handleResult(ctx, result);
+  }
 
   /** Alias of safeParseAsync */
   spa = this.safeParseAsync;
 
   /** The .is method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
-  is: never;
+  is!: never;
 
   /** The .check method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
-  check: never;
+  check!: never;
 
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine<Func extends (arg: Output) => any>(
     check: Func,
     message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
-  ) => ZodEffectsType<This> = (check, message) => {
+  ): ZodEffects<this> {
     const getIssueProperties: any = (val: Output) => {
       if (typeof message === "string" || typeof message === "undefined") {
         return { message };
@@ -195,14 +251,12 @@ export abstract class ZodType<
         return true;
       }
     });
-  };
+  }
 
-  refinement: <This extends this = this>(
+  refinement(
     check: (arg: Output) => any,
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this> {
     return this._refinement((val, ctx) => {
       if (!check(val)) {
         ctx.addIssue(
@@ -215,28 +269,16 @@ export abstract class ZodType<
         return true;
       }
     });
-  };
+  }
 
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>["refinement"]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: "refinement", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: "refinement", refinement }],
-      }) as any;
-    }
-    return returnType;
+  _refinement(
+    refinement: RefinementEffect<Output>["refinement"]
+  ): ZodEffects<this> {
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: "refinement", refinement },
+    }) as any;
   }
   superRefine = this._refinement;
 
@@ -246,17 +288,21 @@ export abstract class ZodType<
     this.default = this.default.bind(this);
   }
 
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
-
-  array: () => ZodArray<this> = () => ZodArray.create(this);
-
-  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
+  optional(): ZodOptional<this> {
+    return ZodOptional.create(this) as any;
+  }
+  nullable(): ZodNullable<this> {
+    return ZodNullable.create(this) as any;
+  }
+  nullish(): ZodNullable<ZodOptional<this>> {
+    return this.optional().nullable();
+  }
+  array(): ZodArray<this> {
+    return ZodArray.create(this);
+  }
+  promise(): ZodPromise<this> {
+    return ZodPromise.create(this);
+  }
 
   or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
     return ZodUnion.create([this, option]) as any;
@@ -272,16 +318,12 @@ export abstract class ZodType<
     return new ZodEffects({
       schema: this,
       typeName: ZodFirstPartyTypeKind.ZodEffects,
-      effects: [{ type: "transform", transform }],
+      effect: { type: "transform", transform },
     }) as any;
   }
 
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
   default(def: any) {
     const defaultValueFunc = typeof def === "function" ? def : () => def;
     // if (this instanceof ZodOptional) {
@@ -297,8 +339,12 @@ export abstract class ZodType<
     }) as any;
   }
 
-  isOptional: () => boolean = () => this.safeParse(undefined).success;
-  isNullable: () => boolean = () => this.safeParse(null).success;
+  isOptional(): boolean {
+    return this.safeParse(undefined).success;
+  }
+  isNullable(): boolean {
+    return this.safeParse(null).success;
+  }
 }
 
 /////////////////////////////////////////
@@ -337,85 +383,118 @@ export class ZodString extends ZodType<string, ZodStringDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<string> {
     if (parsedType !== ZodParsedType.string) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.string,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        },
+        { data }
+      );
       return INVALID;
     }
-    let invalid = false;
+    const invalid = false;
 
     for (const check of this._def.checks) {
       if (check.kind === "min") {
         if (data.length < check.value) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: "string",
-            inclusive: true,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: "string",
+              inclusive: true,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "max") {
         if (data.length > check.value) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: "string",
-            inclusive: true,
-            message: check.message,
-            // ...errorUtil.errToObj(this._def.maxLength.message),
-          });
+          // invalid = true;
+
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: "string",
+              inclusive: true,
+              message: check.message,
+              // ...errorUtil.errToObj(this._def.maxLength.message),
+            },
+            { data }
+          );
         }
       } else if (check.kind === "email") {
         if (!emailRegex.test(data)) {
-          invalid = true;
-          ctx.addIssue(data, {
-            validation: "email",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              validation: "email",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "uuid") {
         if (!uuidRegex.test(data)) {
-          invalid = true;
-          ctx.addIssue(data, {
-            validation: "uuid",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              validation: "uuid",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "cuid") {
         if (!cuidRegex.test(data)) {
-          invalid = true;
-          ctx.addIssue(data, {
-            validation: "cuid",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              validation: "cuid",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "url") {
         try {
           new URL(data);
         } catch {
-          invalid = true;
-          ctx.addIssue(data, {
-            validation: "url",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              validation: "url",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "regex") {
         if (!check.regex.test(data)) {
-          invalid = true;
-          ctx.addIssue(data, {
-            validation: "regex",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              validation: "regex",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
         }
       }
     }
@@ -434,68 +513,48 @@ export class ZodString extends ZodType<string, ZodStringDef> {
       ...errorUtil.errToObj(message),
     });
 
-  email = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "email", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  url = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "url", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  uuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "uuid", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  cuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
+  _addCheck(check: ZodStringCheck) {
+    return new ZodString({
       ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "cuid", ...errorUtil.errToObj(message) },
-      ],
+      checks: [...this._def.checks, check],
     });
+  }
 
-  regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "regex", regex: regex, ...errorUtil.errToObj(message) },
-      ],
+  email(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
+  }
+  url(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
+  }
+  uuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
+  }
+  cuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
+  }
+  regex(regex: RegExp, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "regex",
+      regex: regex,
+      ...errorUtil.errToObj(message),
     });
+  }
 
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "min", value: minLength, ...errorUtil.errToObj(message) },
-      ],
+  min(minLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "min",
+      value: minLength,
+      ...errorUtil.errToObj(message),
     });
+  }
 
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "max", value: maxLength, ...errorUtil.errToObj(message) },
-      ],
+  max(maxLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "max",
+      value: maxLength,
+      ...errorUtil.errToObj(message),
     });
+  }
 
   length(len: number, message?: errorUtil.ErrMessage) {
     return this.min(len, message).max(len, message);
@@ -539,10 +598,11 @@ export class ZodString extends ZodType<string, ZodStringDef> {
     });
     return max;
   }
-  static create = (): ZodString => {
+  static create = (params?: RawCreateParams): ZodString => {
     return new ZodString({
       checks: [],
       typeName: ZodFirstPartyTypeKind.ZodString,
+      ...processCreateParams(params),
     });
   };
 }
@@ -557,7 +617,8 @@ export class ZodString extends ZodType<string, ZodStringDef> {
 type ZodNumberCheck =
   | { kind: "min"; value: number; inclusive: boolean; message?: string }
   | { kind: "max"; value: number; inclusive: boolean; message?: string }
-  | { kind: "int"; message?: string };
+  | { kind: "int"; message?: string }
+  | { kind: "multipleOf"; value: number; message?: string };
 
 export interface ZodNumberDef extends ZodTypeDef {
   checks: ZodNumberCheck[];
@@ -571,27 +632,35 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<number> {
     if (parsedType !== ZodParsedType.number) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
 
-    let invalid = false;
+    const invalid = false;
 
     for (const check of this._def.checks) {
       if (check.kind === "int") {
         if (!util.isInteger(data)) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.invalid_type,
-            expected: "integer",
-            received: "float",
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.invalid_type,
+              expected: "integer",
+              received: "float",
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "min") {
         // const MIN = check.value;
@@ -599,63 +668,92 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
           ? data < check.value
           : data <= check.value;
         if (tooSmall) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: "number",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: "number",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "max") {
         const tooBig = check.inclusive
           ? data > check.value
           : data >= check.value;
         if (tooBig) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: "number",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: "number",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
+        }
+      } else if (check.kind === "multipleOf") {
+        if (data % check.value !== 0) {
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.not_multiple_of,
+              multipleOf: check.value,
+              message: check.message,
+            },
+            { data }
+          );
         }
+      } else {
+        util.assertNever(check);
       }
     }
 
     return invalid ? INVALID : OK(data);
   }
 
-  static create = (): ZodNumber => {
+  static create = (params?: RawCreateParams): ZodNumber => {
     return new ZodNumber({
       checks: [],
       typeName: ZodFirstPartyTypeKind.ZodNumber,
+      ...processCreateParams(params),
+      ...processCreateParams(params),
     });
   };
 
-  gte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit("min", value, true, errorUtil.toString(message));
+  gte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit("min", value, true, errorUtil.toString(message));
+  }
   min = this.gte;
 
-  gt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit("min", value, false, errorUtil.toString(message));
+  gt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit("min", value, false, errorUtil.toString(message));
+  }
 
-  lte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit("max", value, true, errorUtil.toString(message));
+  lte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit("max", value, true, errorUtil.toString(message));
+  }
   max = this.lte;
 
-  lt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit("max", value, false, errorUtil.toString(message));
+  lt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit("max", value, false, errorUtil.toString(message));
+  }
 
-  protected setLimit = (
+  protected setLimit(
     kind: "min" | "max",
     value: number,
     inclusive: boolean,
     message?: string
-  ) =>
-    new ZodNumber({
+  ) {
+    return new ZodNumber({
       ...this._def,
       checks: [
         ...this._def.checks,
@@ -667,74 +765,67 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
         },
       ],
     });
+  }
 
-  int = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
+  _addCheck(check: ZodNumberCheck) {
+    return new ZodNumber({
       ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: "int",
-          message: errorUtil.toString(message),
-        },
-      ],
+      checks: [...this._def.checks, check],
     });
+  }
 
-  positive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: "min",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
+  int(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "int",
+      message: errorUtil.toString(message),
     });
+  }
 
-  negative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: "max",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
+  positive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "min",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
     });
+  }
 
-  nonpositive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: "max",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
+  negative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "max",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
     });
+  }
 
-  nonnegative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: "min",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
+  nonpositive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "max",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  nonnegative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "min",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
     });
+  }
+
+  multipleOf(value: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "multipleOf",
+      value: value,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  step = this.multipleOf;
 
   get minValue() {
     let min: number | null = null;
@@ -780,19 +871,26 @@ export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<bigint> {
     if (parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.bigint,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     return OK(data);
   }
 
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
+  static create = (params?: RawCreateParams): ZodBigInt => {
+    return new ZodBigInt({
+      typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -814,19 +912,26 @@ export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<boolean> {
     if (parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.boolean,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     return OK(data);
   }
 
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
+  static create = (params?: RawCreateParams): ZodBoolean => {
+    return new ZodBoolean({
+      typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -848,18 +953,26 @@ export class ZodDate extends ZodType<Date, ZodDateDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<Date> {
     if (parsedType !== ZodParsedType.date) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.date,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     if (isNaN(data.getTime())) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_date,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_date,
+        },
+        { data }
+      );
 
       return INVALID;
     }
@@ -867,8 +980,11 @@ export class ZodDate extends ZodType<Date, ZodDateDef> {
     return OK(new Date((data as Date).getTime()));
   }
 
-  static create = (): ZodDate => {
-    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
+  static create = (params?: RawCreateParams): ZodDate => {
+    return new ZodDate({
+      typeName: ZodFirstPartyTypeKind.ZodDate,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -890,19 +1006,27 @@ export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<undefined> {
     if (parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.undefined,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     return OK(data);
   }
+  params?: RawCreateParams;
 
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
+  static create = (params?: RawCreateParams): ZodUndefined => {
+    return new ZodUndefined({
+      typeName: ZodFirstPartyTypeKind.ZodUndefined,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -924,18 +1048,25 @@ export class ZodNull extends ZodType<null, ZodNullDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<null> {
     if (parsedType !== ZodParsedType.null) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.null,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     return OK(data);
   }
-  static create = (): ZodNull => {
-    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
+  static create = (params?: RawCreateParams): ZodNull => {
+    return new ZodNull({
+      typeName: ZodFirstPartyTypeKind.ZodNull,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -960,8 +1091,11 @@ export class ZodAny extends ZodType<any, ZodAnyDef> {
   ): ParseReturnType<any> {
     return OK(data);
   }
-  static create = (): ZodAny => {
-    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
+  static create = (params?: RawCreateParams): ZodAny => {
+    return new ZodAny({
+      typeName: ZodFirstPartyTypeKind.ZodAny,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -987,8 +1121,11 @@ export class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
     return OK(data);
   }
 
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
+  static create = (params?: RawCreateParams): ZodUnknown => {
+    return new ZodUnknown({
+      typeName: ZodFirstPartyTypeKind.ZodUnknown,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -1009,15 +1146,22 @@ export class ZodNever extends ZodType<never, ZodNeverDef> {
     data: any,
     parsedType: ZodParsedType
   ): ParseReturnType<never> {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.never,
-      received: parsedType,
-    });
+    this._addIssue(
+      ctx,
+      {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      },
+      { data }
+    );
     return INVALID;
   }
-  static create = (): ZodNever => {
-    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
+  static create = (params?: RawCreateParams): ZodNever => {
+    return new ZodNever({
+      typeName: ZodFirstPartyTypeKind.ZodNever,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -1039,19 +1183,26 @@ export class ZodVoid extends ZodType<void, ZodVoidDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<void> {
     if (parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.void,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     return OK(data);
   }
 
-  static create = (): ZodVoid => {
-    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  static create = (params?: RawCreateParams): ZodVoid => {
+    return new ZodVoid({
+      typeName: ZodFirstPartyTypeKind.ZodVoid,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -1070,140 +1221,145 @@ export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny>
   maxLength: { value: number; message?: string } | null;
 }
 
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
+export type ArrayCardinality = "many" | "atleastone";
+type arrayOutputType<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = "many"
+> = Cardinality extends "atleastone"
+  ? [T["_output"], ...T["_output"][]]
+  : T["_output"][];
 
-    return INVALID;
-  }
+export class ZodArray<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = "many"
+> extends ZodType<
+  arrayOutputType<T, Cardinality>,
+  ZodArrayDef<T>,
+  Cardinality extends "atleastone"
+    ? [T["_input"], ...T["_input"][]]
+    : T["_input"][]
+> {
+  _parse(
+    ctx: ParseContext,
+    _data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
 
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: "array",
-        inclusive: true,
-        message: def.minLength.message,
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
       });
-    }
-  }
 
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: "array",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
+      return INVALID;
     }
-  }
 
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
+    const data: any[] = _data;
 
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        // invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_small,
+            minimum: def.minLength.value,
+            type: "array",
+            inclusive: true,
+            message: def.minLength.message,
+          },
+          { data }
+        );
+      }
+    }
 
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        // invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_big,
+            maximum: def.maxLength.value,
+            type: "array",
+            inclusive: true,
+            message: def.maxLength.message,
+          },
+          { data }
+        );
+      }
+    }
 
-export type ArrayCardinality = "many" | "atleastone";
-type arrayOutputType<
-  T extends ZodTypeAny,
-  Cardinality extends ArrayCardinality = "many"
-> = Cardinality extends "atleastone"
-  ? [T["_output"], ...T["_output"][]]
-  : T["_output"][];
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
 
-export class ZodArray<
-  T extends ZodTypeAny,
-  Cardinality extends ArrayCardinality = "many"
-> extends ZodType<
-  arrayOutputType<T, Cardinality>,
-  ZodArrayDef<T>,
-  Cardinality extends "atleastone"
-    ? [T["_input"], ...T["_input"][]]
-    : T["_input"][]
-> {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
   }
 
   get element() {
     return this._def.type;
   }
 
-  min = (minLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  min(minLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
       ...this._def,
       minLength: { value: minLength, message: errorUtil.toString(message) },
     }) as any;
+  }
 
-  max = (maxLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  max(maxLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
       ...this._def,
       maxLength: { value: maxLength, message: errorUtil.toString(message) },
     }) as any;
+  }
 
-  length = (len: number, message?: errorUtil.ErrMessage): this =>
-    this.min(len, message).max(len, message) as any;
+  length(len: number, message?: errorUtil.ErrMessage): this {
+    return this.min(len, message).max(len, message) as any;
+  }
 
-  nonempty: (message?: errorUtil.ErrMessage) => ZodArray<T, "atleastone"> = (
-    message?: any
-  ) => {
+  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone"> {
     return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:"atleastone" });
-  };
+  }
 
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodArray<T> => {
     return new ZodArray({
       type: schema,
       minLength: null,
       maxLength: null,
       typeName: ZodFirstPartyTypeKind.ZodArray,
+      ...processCreateParams(params),
     });
   };
 }
@@ -1445,11 +1601,15 @@ export class ZodObject<
     parsedType: ZodParsedType
   ): ParseReturnType<Output> {
     if (parsedType !== ZodParsedType.object) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
@@ -1457,7 +1617,7 @@ export class ZodObject<
     const { shape, keys: shapeKeys } = this._getCached();
 
     let invalid = false;
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
     const resultObject: Record<string, any> = {};
 
     const handleParsed = (
@@ -1475,9 +1635,7 @@ export class ZodObject<
       } else if (isInvalid(parsedValue)) {
         invalid = true;
       } else {
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
       }
     };
 
@@ -1503,11 +1661,15 @@ export class ZodObject<
         const dataKeys = util.objectKeys(data);
         const extraKeys = dataKeys.filter((k) => !(k in shape));
         if (extraKeys.length > 0) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.unrecognized_keys,
-            keys: extraKeys,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            },
+            { data }
+          );
         }
       } else if (unknownKeys === "strip") {
       } else {
@@ -1526,12 +1688,9 @@ export class ZodObject<
         );
       }
     }
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
       );
     } else {
       return invalid ? INVALID : OK(resultObject as Output);
@@ -1542,23 +1701,26 @@ export class ZodObject<
     return this._def.shape();
   }
 
-  strict = (): ZodObject<T, "strict", Catchall> =>
-    new ZodObject({
+  strict(): ZodObject<T, "strict", Catchall> {
+    return new ZodObject({
       ...this._def,
       unknownKeys: "strict",
     }) as any;
+  }
 
-  strip = (): ZodObject<T, "strip", Catchall> =>
-    new ZodObject({
+  strip(): ZodObject<T, "strip", Catchall> {
+    return new ZodObject({
       ...this._def,
       unknownKeys: "strip",
     }) as any;
+  }
 
-  passthrough = (): ZodObject<T, "passthrough", Catchall> =>
-    new ZodObject({
+  passthrough(): ZodObject<T, "passthrough", Catchall> {
+    return new ZodObject({
       ...this._def,
       unknownKeys: "passthrough",
     }) as any;
+  }
 
   /**
    * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
@@ -1569,24 +1731,22 @@ export class ZodObject<
   augment = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
   extend = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
 
-  setKey = <Key extends string, Schema extends ZodTypeAny>(
+  setKey<Key extends string, Schema extends ZodTypeAny>(
     key: Key,
     schema: Schema
-  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> => {
+  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {
     return this.augment({ [key]: schema }) as any;
-  };
+  }
 
   /**
    * Prior to zod@1.0.12 there was a bug in the
    * inferred type of merged objects. Please
    * upgrade if you are experiencing issues.
    */
-  merge: <Incoming extends AnyZodObject>(
+  merge<Incoming extends AnyZodObject>(
     merging: Incoming
-  ) => //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
-  ZodObject<extendShape<T, Incoming["_shape"]>, UnknownKeys, Catchall> = (
-    merging
-  ) => {
+  ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
+  ZodObject<extendShape<T, Incoming["_shape"]>, UnknownKeys, Catchall> {
     const mergedShape = objectUtil.mergeShapes(
       this._def.shape(),
       merging._def.shape()
@@ -1599,24 +1759,24 @@ export class ZodObject<
       typeName: ZodFirstPartyTypeKind.ZodObject,
     }) as any;
     return merged;
-  };
+  }
 
-  catchall = <Index extends ZodTypeAny>(
+  catchall<Index extends ZodTypeAny>(
     index: Index
-  ): ZodObject<T, UnknownKeys, Index> => {
+  ): ZodObject<T, UnknownKeys, Index> {
     return new ZodObject({
       ...this._def,
       catchall: index,
     }) as any;
-  };
+  }
 
-  pick = <Mask extends { [k in keyof T]?: true }>(
+  pick<Mask extends { [k in keyof T]?: true }>(
     mask: Mask
   ): ZodObject<
     objectUtil.noNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
     UnknownKeys,
     Catchall
-  > => {
+  > {
     const shape: any = {};
     util.objectKeys(mask).map((key) => {
       shape[key] = this.shape[key];
@@ -1625,15 +1785,15 @@ export class ZodObject<
       ...this._def,
       shape: () => shape,
     }) as any;
-  };
+  }
 
-  omit = <Mask extends { [k in keyof T]?: true }>(
+  omit<Mask extends { [k in keyof T]?: true }>(
     mask: Mask
   ): ZodObject<
     objectUtil.noNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
     UnknownKeys,
     Catchall
-  > => {
+  > {
     const shape: any = {};
     util.objectKeys(this.shape).map((key) => {
       if (util.objectKeys(mask).indexOf(key) === -1) {
@@ -1644,35 +1804,61 @@ export class ZodObject<
       ...this._def,
       shape: () => shape,
     }) as any;
-  };
+  }
+
+  deepPartial(): partialUtil.DeepPartial<this> {
+    return deepPartialify(this) as any;
+  }
 
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k]["optional"]> },
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
+    UnknownKeys,
+    Catchall
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
     UnknownKeys,
     Catchall
-  > => {
+  >;
+  partial(mask?: any) {
     const newShape: any = {};
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
     }
+
     return new ZodObject({
       ...this._def,
       shape: () => newShape,
     }) as any;
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
 
-  required = (): ZodObject<
+  required(): ZodObject<
     { [k in keyof T]: deoptional<T[k]> },
     UnknownKeys,
     Catchall
-  > => {
+  > {
     const newShape: any = {};
     for (const key in this.shape) {
       const fieldSchema = this.shape[key];
@@ -1687,34 +1873,44 @@ export class ZodObject<
       ...this._def,
       shape: () => newShape,
     }) as any;
-  };
+  }
 
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+  static create = <T extends ZodRawShape>(
+    shape: T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
     return new ZodObject({
       shape: () => shape,
       unknownKeys: "strip",
       catchall: ZodNever.create(),
       typeName: ZodFirstPartyTypeKind.ZodObject,
+      ...processCreateParams(params),
     }) as any;
   };
 
   static strictCreate = <T extends ZodRawShape>(
-    shape: T
+    shape: T,
+    params?: RawCreateParams
   ): ZodObject<T, "strict"> => {
     return new ZodObject({
       shape: () => shape,
       unknownKeys: "strict",
       catchall: ZodNever.create(),
       typeName: ZodFirstPartyTypeKind.ZodObject,
+      ...processCreateParams(params),
     }) as any;
   };
 
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends ZodRawShape>(
+    shape: () => T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
     return new ZodObject({
       shape,
       unknownKeys: "strip",
       catchall: ZodNever.create(),
       typeName: ZodFirstPartyTypeKind.ZodObject,
+      ...processCreateParams(params),
     }) as any;
   };
 }
@@ -1768,19 +1964,23 @@ export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
         // TODO encapsulate
         nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
       } else {
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_union,
-          unionErrors,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_union,
+            unionErrors,
+          },
+          { data }
+        );
       }
       return INVALID;
     };
 
-    if (ctx.params.async) {
+    if (ctx.async) {
       const contexts = options.map(
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
       );
-      return PseudoPromise.all(
+      return Promise.all(
         options.map((option, index) =>
           option._parse(contexts[index], data, parsedType)
         )
@@ -1795,7 +1995,7 @@ export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
     } else {
       const allIssues: ZodIssue[][] = [];
       for (const option of options) {
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
         const parsedOption = option._parseSync(optionCtx, data, parsedType);
         if (isInvalid(parsedOption)) {
           allIssues.push(optionCtx.issues);
@@ -1812,11 +2012,13 @@ export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
   }
 
   static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
-    types: T
+    types: T,
+    params?: RawCreateParams
   ): ZodUnion<T> => {
     return new ZodUnion({
       options: types,
       typeName: ZodFirstPartyTypeKind.ZodUnion,
+      ...processCreateParams(params),
     });
   };
 }
@@ -1879,7 +2081,7 @@ export class ZodIntersection<
     ctx: ParseContext,
     data: any,
     parsedType: ZodParsedType
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T["_output"] & U["_output"]> {
     const handleParsed = (
       parsedLeft: SyncParseReturnType<T>,
       parsedRight: SyncParseReturnType<U>
@@ -1890,16 +2092,20 @@ export class ZodIntersection<
 
       const merged = mergeValues(parsedLeft.value, parsedRight.value);
       if (!merged.valid) {
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_intersection_types,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_intersection_types,
+          },
+          { data }
+        );
         return INVALID;
       }
       return OK(merged.data);
     };
 
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
         this._def.left._parse(ctx, data, parsedType),
         this._def.right._parse(ctx, data, parsedType),
       ]).then(([left, right]: any) => handleParsed(left, right));
@@ -1913,12 +2119,14 @@ export class ZodIntersection<
 
   static create = <T extends ZodTypeAny, U extends ZodTypeAny>(
     left: T,
-    right: U
+    right: U,
+    params?: RawCreateParams
   ): ZodIntersection<T, U> => {
     return new ZodIntersection({
       left: left,
       right: right,
       typeName: ZodFirstPartyTypeKind.ZodIntersection,
+      ...processCreateParams(params),
     });
   };
 }
@@ -1931,58 +2139,100 @@ export class ZodIntersection<
 ////////////////////////////////////////
 ////////////////////////////////////////
 export type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
-};
-
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
-};
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
+  }
+>;
+export type OutputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...OutputTypeOfTuple<T>, ...Rest["_output"][]]
+  : OutputTypeOfTuple<T>;
 
-export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
-  extends ZodTypeDef {
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
+  }
+>;
+export type InputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...InputTypeOfTuple<T>, ...Rest["_input"][]]
+  : InputTypeOfTuple<T>;
+
+export interface ZodTupleDef<
+  T extends ZodTupleItems | [] = ZodTupleItems,
+  Rest extends ZodTypeAny | null = null
+> extends ZodTypeDef {
   items: T;
+  rest: Rest;
   typeName: ZodFirstPartyTypeKind.ZodTuple;
 }
 
 export class ZodTuple<
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
+  Rest extends ZodTypeAny | null = null
+> extends ZodType<
+  OutputTypeOfTupleWithRest<T, Rest>,
+  ZodTupleDef<T, Rest>,
+  InputTypeOfTupleWithRest<T, Rest>
+> {
   _parse(
     ctx: ParseContext,
     data: any,
     parsedType: ZodParsedType
   ): ParseReturnType<any> {
     if (parsedType !== ZodParsedType.array) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data }
+      );
       return INVALID;
     }
 
-    if (data.length > this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: this._def.items.length,
-        inclusive: true,
-        type: "array",
-      });
+    const rest = this._def.rest;
+
+    if (!rest && data.length > this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_big,
+          maximum: this._def.items.length,
+          inclusive: true,
+          type: "array",
+        },
+        { data }
+      );
       return INVALID;
-    } else if (data.length < this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: this._def.items.length,
-        inclusive: true,
-        type: "array",
-      });
+    }
+
+    if (data.length < this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_small,
+          minimum: this._def.items.length,
+          inclusive: true,
+          type: "array",
+        },
+        { data }
+      );
       return INVALID;
     }
 
-    const tasks = createTasks(ctx);
-    const items = this._def.items as ZodType<any>[];
-    const parseResult: any[] = new Array(items.length);
+    const tasks: Promise<unknown>[] = [];
+    const items = this._def.items as ZodType<any, any, any>[];
+
+    const parseResult: any[] = new Array(data.length);
     let invalid = false;
 
     const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
@@ -1991,9 +2241,7 @@ export class ZodTuple<
       } else if (isInvalid(parsedItem)) {
         invalid = true;
       } else {
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
       }
     };
 
@@ -2008,9 +2256,20 @@ export class ZodTuple<
       );
     });
 
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (rest) {
+      const restData: any[] = data.slice(items.length);
+      restData.forEach((dataItem, _index) => {
+        const index = _index + items.length;
+        handleParsed(
+          index,
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+        );
+      });
+    }
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
       );
     } else {
       return invalid ? INVALID : OK(parseResult);
@@ -2021,12 +2280,22 @@ export class ZodTuple<
     return this._def.items;
   }
 
+  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
+    return new ZodTuple({
+      ...this._def,
+      rest,
+    });
+  }
+
   static create = <T extends [ZodTypeAny, ...ZodTypeAny[]] | []>(
-    schemas: T
-  ): ZodTuple<T> => {
+    schemas: T,
+    params?: RawCreateParams
+  ): ZodTuple<T, null> => {
     return new ZodTuple({
       items: schemas,
       typeName: ZodFirstPartyTypeKind.ZodTuple,
+      rest: null,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2038,74 +2307,116 @@ export class ZodTuple<
 //////////                     //////////
 /////////////////////////////////////////
 /////////////////////////////////////////
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
   valueType: Value;
+  keyType: Key;
   typeName: ZodFirstPartyTypeKind.ZodRecord;
 }
 
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value["_output"]>,
-  ZodRecordDef<Value>,
-  Record<string, Value["_input"]>
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Record<Key["_output"], Value["_output"]>,
+  ZodRecordDef<Key, Value>,
+  Record<Key["_input"], Value["_input"]>
 > {
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
   _parse(
     ctx: ParseContext,
     data: any,
     parsedType: ZodParsedType
-  ): ParseReturnType<Record<string, any>> {
+  ): ParseReturnType<Record<any, any>> {
     if (parsedType !== ZodParsedType.object) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
       return INVALID;
     }
 
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
+    const keyType = this._def.keyType;
     const valueType = this._def.valueType;
     const parseResult: Record<string, ParseReturnType<any>> = {};
     let invalid = false;
     const handleParsed = (
-      key: string,
-      parsedKey: ParseReturnType<any>
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
     ): void => {
-      if (isOk(parsedKey)) {
-        parseResult[key] = parsedKey.value;
-      } else if (isInvalid(parsedKey)) {
-        invalid = true;
-      } else {
-        tasks?.push(
-          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+      if (isOk(parsedKey) && isOk(parsedValue)) {
+        parseResult[parsedKey.value] = parsedValue.value;
+      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+            handleParsed(k, v)
+          )
         );
+      } else {
+        invalid = true;
       }
     };
 
     for (const key in data) {
       handleParsed(
-        key,
+        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
         valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
       );
     }
 
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
       );
     } else {
       return invalid ? INVALID : OK(parseResult);
     }
   }
 
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
+  get element() {
+    return this._def.valueType;
+  }
+
+  static create<Value extends ZodTypeAny>(
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<ZodString, Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
+    keySchema: Keys,
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<Keys, Value>;
+  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
+    if (second instanceof ZodType) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+        ...processCreateParams(third),
+      });
+    }
+
     return new ZodRecord({
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
       typeName: ZodFirstPartyTypeKind.ZodRecord,
+      ...processCreateParams(second),
     });
-  };
+  }
 }
 
 //////////////////////////////////////
@@ -2138,11 +2449,15 @@ export class ZodMap<
     parsedType: ZodParsedType
   ): ParseReturnType<Map<any, any>> {
     if (parsedType !== ZodParsedType.map) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.map,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
@@ -2151,15 +2466,15 @@ export class ZodMap<
     const valueType = this._def.valueType;
     const dataMap: Map<unknown, unknown> = data;
     const parseResult = new Map();
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
     let invalid = false;
     const handleParsed = (
       parsedKey: ParseReturnType<any>,
       parsedValue: ParseReturnType<any>
     ): void => {
       if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
             handleParsed(k, v)
           )
         );
@@ -2185,9 +2500,9 @@ export class ZodMap<
       handleParsed(parsedKey, parsedValue);
     });
 
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
       );
     } else {
       return invalid ? INVALID : OK(parseResult);
@@ -2198,12 +2513,14 @@ export class ZodMap<
     Value extends ZodTypeAny = ZodTypeAny
   >(
     keyType: Key,
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
   ): ZodMap<Key, Value> => {
     return new ZodMap({
       valueType,
       keyType,
       typeName: ZodFirstPartyTypeKind.ZodMap,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2232,11 +2549,15 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
     parsedType: ZodParsedType
   ): ParseReturnType<Set<any>> {
     if (parsedType !== ZodParsedType.set) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.set,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
@@ -2244,7 +2565,7 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
     const dataSet: Set<unknown> = data;
     const valueType = this._def.valueType;
     const parsedSet = new Set();
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
     let invalid = false;
 
     const handleParsed = (parsedItem: ParseReturnType<any>): void => {
@@ -2253,7 +2574,7 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
       } else if (isInvalid(parsedItem)) {
         invalid = true;
       } else {
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
       }
     };
 
@@ -2261,21 +2582,21 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
       handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
     );
 
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
     } else {
       return invalid ? INVALID : OK(parsedSet);
     }
   }
 
   static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
   ): ZodSet<Value> => {
     return new ZodSet({
       valueType,
       typeName: ZodFirstPartyTypeKind.ZodSet,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2288,7 +2609,7 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
 ///////////////////////////////////////////
 ///////////////////////////////////////////
 export interface ZodFunctionDef<
-  Args extends ZodTuple<any> = ZodTuple<any>,
+  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
   Returns extends ZodTypeAny = ZodTypeAny
 > extends ZodTypeDef {
   args: Args;
@@ -2297,21 +2618,21 @@ export interface ZodFunctionDef<
 }
 
 export type OuterTypeOfFunction<
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
   Returns extends ZodTypeAny
 > = Args["_input"] extends Array<any>
   ? (...args: Args["_input"]) => Returns["_output"]
   : never;
 
 export type InnerTypeOfFunction<
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
   Returns extends ZodTypeAny
 > = Args["_output"] extends Array<any>
   ? (...args: Args["_output"]) => Returns["_input"]
   : never;
 
 export class ZodFunction<
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
   Returns extends ZodTypeAny
 > extends ZodType<
   OuterTypeOfFunction<Args, Returns>,
@@ -2324,30 +2645,44 @@ export class ZodFunction<
     parsedType: ZodParsedType
   ): ParseReturnType<any> {
     if (parsedType !== ZodParsedType.function) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.function,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
 
     function makeArgsIssue(args: any, error: ZodError): ZodIssue {
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_arguments,
-        argumentsError: error,
+      return makeIssue({
+        data: args,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_arguments,
+          argumentsError: error,
+        },
       });
     }
 
     function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_return_type,
-        returnTypeError: error,
+      return makeIssue({
+        data: returns,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_return_type,
+          returnTypeError: error,
+        },
       });
     }
 
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
     const fn = data;
 
     if (this._def.returns instanceof ZodPromise) {
@@ -2392,49 +2727,53 @@ export class ZodFunction<
     return this._def.returns;
   }
 
-  args = <Items extends Parameters<typeof ZodTuple["create"]>[0]>(
+  args<Items extends Parameters<typeof ZodTuple["create"]>[0]>(
     ...items: Items
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
+  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {
     return new ZodFunction({
       ...this._def,
-      args: ZodTuple.create(items),
+      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
     });
-  };
+  }
 
-  returns = <NewReturnType extends ZodType<any, any>>(
+  returns<NewReturnType extends ZodType<any, any>>(
     returnType: NewReturnType
-  ): ZodFunction<Args, NewReturnType> => {
+  ): ZodFunction<Args, NewReturnType> {
     return new ZodFunction({
       ...this._def,
       returns: returnType,
     });
-  };
+  }
 
-  implement = <F extends InnerTypeOfFunction<Args, Returns>>(func: F): F => {
+  implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): F {
     const validatedFunc = this.parse(func);
     return validatedFunc as any;
-  };
+  }
 
-  strictImplement = (
+  strictImplement(
     func: InnerTypeOfFunction<Args, Returns>
-  ): InnerTypeOfFunction<Args, Returns> => {
+  ): InnerTypeOfFunction<Args, Returns> {
     const validatedFunc = this.parse(func);
     return validatedFunc as any;
-  };
+  }
 
   validate = this.implement;
 
   static create = <
-    T extends ZodTuple<any> = ZodTuple<[]>,
+    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
     U extends ZodTypeAny = ZodUnknown
   >(
     args?: T,
-    returns?: U
+    returns?: U,
+    params?: RawCreateParams
   ): ZodFunction<T, U> => {
     return new ZodFunction({
-      args: args || ZodTuple.create([]),
+      args: (args
+        ? args.rest(ZodUnknown.create())
+        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
       returns: returns || ZodUnknown.create(),
       typeName: ZodFirstPartyTypeKind.ZodFunction,
+      ...processCreateParams(params),
     }) as any;
   };
 }
@@ -2470,10 +2809,14 @@ export class ZodLazy<T extends ZodTypeAny> extends ZodType<
     return lazySchema._parse(ctx, data, parsedType);
   }
 
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+  static create = <T extends ZodTypeAny>(
+    getter: () => T,
+    params?: RawCreateParams
+  ): ZodLazy<T> => {
     return new ZodLazy({
       getter: getter,
       typeName: ZodFirstPartyTypeKind.ZodLazy,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2497,11 +2840,15 @@ export class ZodLiteral<T extends any> extends ZodType<T, ZodLiteralDef<T>> {
     _parsedType: ZodParsedType
   ): ParseReturnType<T> {
     if (data !== this._def.value) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: this._def.value as any,
-        received: data,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: this._def.value as any,
+          received: data,
+        },
+        { data }
+      );
       return INVALID;
     }
     return OK(data);
@@ -2511,10 +2858,14 @@ export class ZodLiteral<T extends any> extends ZodType<T, ZodLiteralDef<T>> {
     return this._def.value;
   }
 
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends Primitive>(
+    value: T,
+    params?: RawCreateParams
+  ): ZodLiteral<T> => {
     return new ZodLiteral({
       value: value,
       typeName: ZodFirstPartyTypeKind.ZodLiteral,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2566,10 +2917,14 @@ export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
     _parsedType: ZodParsedType
   ): ParseReturnType<T[number]> {
     if (this._def.values.indexOf(data) === -1) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: this._def.values,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: this._def.values,
+        },
+        { data }
+      );
       return INVALID;
     }
     return OK(data);
@@ -2632,18 +2987,26 @@ export class ZodNativeEnum<T extends EnumLike> extends ZodType<
   ): ParseReturnType<T[keyof T]> {
     const nativeEnumValues = util.getValidEnumValues(this._def.values);
     if (nativeEnumValues.indexOf(data) === -1) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: util.objectValues(nativeEnumValues),
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        },
+        { data }
+      );
       return INVALID;
     }
     return OK(data);
   }
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+  static create = <T extends EnumLike>(
+    values: T,
+    params?: RawCreateParams
+  ): ZodNativeEnum<T> => {
     return new ZodNativeEnum({
       values: values,
       typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2671,12 +3034,16 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
     data: any,
     parsedType: ZodParsedType
   ): ParseReturnType<Promise<T["_output"]>> {
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.promise,
-        received: parsedType,
-      });
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
@@ -2688,16 +3055,20 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
       promisified.then((data: any) => {
         return this._def.type.parseAsync(data, {
           path: pathToArray(ctx.path),
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
         });
       })
     );
   }
 
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodPromise<T> => {
     return new ZodPromise({
       type: schema,
       typeName: ZodFirstPartyTypeKind.ZodPromise,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2709,34 +3080,39 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
 //////////                          //////////
 //////////////////////////////////////////////
 //////////////////////////////////////////////
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T["_output"]>;
 
 export type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
 export type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
   type: "refinement";
   refinement: (arg: T, ctx: RefinementCtx) => any;
 };
-export type Mod<T> = {
+export type TransformEffect<T> = {
   type: "transform";
   transform: (arg: T) => any;
 };
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: "preprocess";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
 
 export interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny>
   extends ZodTypeDef {
   schema: T;
   typeName: ZodFirstPartyTypeKind.ZodEffects;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
 }
 
 export class ZodEffects<
   T extends ZodTypeAny,
-  Output = T["_type"]
-> extends ZodType<Output, ZodEffectsDef<T>, T["_input"]> {
+  Output = T["_output"],
+  Input = T["_input"]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
   innerType() {
     return this._def.schema;
   }
@@ -2746,137 +3122,135 @@ export class ZodEffects<
     initialData: any,
     initialParsedType: ZodParsedType
   ): ParseReturnType<Output> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
 
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
+    if (effect.type === "preprocess") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            "Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead."
+          );
+        return result;
+      }
+    }
 
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+    if (effect.type === "refinement") {
+      const invalid = false;
 
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case "refinement":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                "You can't use .parse() on a schema containing async refinements. Use .parseAsync instead."
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case "transform":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
             throw new Error(
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
             );
           }
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const _addIssue = (arg: IssueData) => {
+        // don't abort early on refinement issues
+        // invalid = true;
+        this._addIssue(ctx, arg, { data });
+      };
+      const checkCtx: RefinementCtx = {
+        addIssue: _addIssue,
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
 
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
         return invalid ? INVALID : OK(result);
       } else {
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
       }
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === "transform") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
           );
-        } else {
-          return invalid ? INVALID : OK(result);
         }
+        return transformed;
       };
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
       } else {
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
             if (isInvalid(base)) return INVALID;
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
           })
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
       }
     }
-  }
 
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested.");
-    // }
+    util.assertNever(effect);
   }
 
   static create = <I extends ZodTypeAny>(
-    schema: I
+    schema: I,
+    effect: Effect<I["_output"]>,
+    params?: RawCreateParams
   ): ZodEffects<I, I["_output"]> => {
-    const newTx = new ZodEffects({
+    return new ZodEffects({
       schema,
       typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect,
+      ...processCreateParams(params),
     });
-
-    return newTx;
   };
 
   static createWithPreprocess = <I extends ZodTypeAny>(
     preprocess: (arg: unknown) => unknown,
-    schema: I
+    schema: I,
+    params?: RawCreateParams
   ): ZodEffects<I, I["_output"]> => {
-    const newTx = new ZodEffects({
+    return new ZodEffects({
       schema,
-      preprocess: { type: "transform", transform: preprocess },
+      effect: { type: "preprocess", transform: preprocess },
       typeName: ZodFirstPartyTypeKind.ZodEffects,
+      ...processCreateParams(params),
     });
-
-    return newTx;
   };
 }
 
@@ -2917,10 +3291,14 @@ export class ZodOptional<T extends ZodTypeAny> extends ZodType<
     return this._def.innerType;
   }
 
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
     return new ZodOptional({
       innerType: type,
       typeName: ZodFirstPartyTypeKind.ZodOptional,
+      ...processCreateParams(params),
     }) as any;
   };
 }
@@ -2960,10 +3338,14 @@ export class ZodNullable<T extends ZodTypeAny> extends ZodType<
     return this._def.innerType;
   }
 
-  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodNullable<T> => {
     return new ZodNullable({
       innerType: type,
       typeName: ZodFirstPartyTypeKind.ZodNullable,
+      ...processCreateParams(params),
     }) as any;
   };
 }
@@ -3002,10 +3384,14 @@ export class ZodDefault<T extends ZodTypeAny> extends ZodType<
     return this._def.innerType;
   }
 
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
     return new ZodOptional({
       innerType: type,
       typeName: ZodFirstPartyTypeKind.ZodOptional,
+      ...processCreateParams(params),
     }) as any;
   };
 }
diff --git a/package.json b/package.json
index 1c35c3e3c..d9d2ff684 100644
--- a/package.json
+++ b/package.json
@@ -1,13 +1,16 @@
 {
   "name": "zod",
-  "version": "3.8.0",
+  "version": "3.9.1",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./lib/index.d.ts",
   "module": "./lib/index.mjs",
   "exports": {
-    "require": "./lib/index.js",
-    "import": "./lib/index.mjs"
+    ".": {
+      "require": "./lib/index.js",
+      "import": "./lib/index.mjs"
+    },
+    "./package.json": "./package.json"
   },
   "files": [
     "/lib"
@@ -84,7 +87,7 @@
     "ts-jest": "^26.4.4",
     "ts-node": "^9.1.0",
     "tslib": "^2.1.0",
-    "typescript": "^4.3.2"
+    "typescript": "4.3"
   },
   "husky": {
     "hooks": {
diff --git a/src/PseudoPromise.ts b/src/PseudoPromise.ts
deleted file mode 100644
index 864314f6a..000000000
--- a/src/PseudoPromise.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-export class PseudoPromise<PayloadType = undefined> {
-  readonly promise: Promise<PayloadType>;
-
-  constructor(promise: Promise<PayloadType>) {
-    this.promise = promise;
-  }
-
-  then<MappedType>(
-    f: (_v: PayloadType) => MappedType
-  ): PseudoPromise<MappedType> {
-    return new PseudoPromise<MappedType>(this.promise.then(f));
-  }
-
-  static all = <T extends (any | PseudoPromise<any>)[]>(
-    pps: T
-  ): PseudoPromise<
-    { [K in keyof T]: T[K] extends PseudoPromise<infer I> ? I : T[K] }
-  > => {
-    return new PseudoPromise(
-      Promise.all(pps.map((v) => (v instanceof PseudoPromise ? v.promise : v)))
-    ) as any;
-  };
-}
diff --git a/src/ZodError.ts b/src/ZodError.ts
index c73a4080f..186ad7d04 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -14,6 +14,7 @@ export const ZodIssueCode = util.arrayToEnum([
   "too_small",
   "too_big",
   "invalid_intersection_types",
+  "not_multiple_of",
 ]);
 
 export type ZodIssueCode = keyof typeof ZodIssueCode;
@@ -84,6 +85,11 @@ export interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.invalid_intersection_types;
 }
 
+export interface ZodNotMultipleOfIssue extends ZodIssueBase {
+  code: typeof ZodIssueCode.not_multiple_of;
+  multipleOf: number;
+}
+
 export interface ZodCustomIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.custom;
   params?: { [k: string]: any };
@@ -103,6 +109,7 @@ export type ZodIssueOptionalMessage =
   | ZodTooSmallIssue
   | ZodTooBigIssue
   | ZodInvalidIntersectionTypesIssue
+  | ZodNotMultipleOfIssue
   | ZodCustomIssue;
 
 export type ZodIssue = ZodIssueOptionalMessage & { message: string };
@@ -239,9 +246,10 @@ type stripPath<T extends object> = T extends any
   ? util.OmitKeys<T, "path">
   : never;
 
-export type MakeErrorData = stripPath<ZodIssueOptionalMessage> & {
+export type IssueData = stripPath<ZodIssueOptionalMessage> & {
   path?: (string | number)[];
 };
+export type MakeErrorData = IssueData;
 
 type ErrorMapCtx = {
   defaultError: string;
@@ -250,20 +258,20 @@ type ErrorMapCtx = {
 
 export type ZodErrorMap = typeof defaultErrorMap;
 export const defaultErrorMap = (
-  error: ZodIssueOptionalMessage,
+  issue: ZodIssueOptionalMessage,
   _ctx: ErrorMapCtx
 ): { message: string } => {
   let message: string;
-  switch (error.code) {
+  switch (issue.code) {
     case ZodIssueCode.invalid_type:
-      if (error.received === "undefined") {
+      if (issue.received === "undefined") {
         message = "Required";
       } else {
-        message = `Expected ${error.expected}, received ${error.received}`;
+        message = `Expected ${issue.expected}, received ${issue.received}`;
       }
       break;
     case ZodIssueCode.unrecognized_keys:
-      message = `Unrecognized key(s) in object: ${error.keys
+      message = `Unrecognized key(s) in object: ${issue.keys
         .map((k) => `'${k}'`)
         .join(", ")}`;
       break;
@@ -271,7 +279,7 @@ export const defaultErrorMap = (
       message = `Invalid input`;
       break;
     case ZodIssueCode.invalid_enum_value:
-      message = `Invalid enum value. Expected ${error.options
+      message = `Invalid enum value. Expected ${issue.options
         .map((val) => (typeof val === "string" ? `'${val}'` : val))
         .join(" | ")}, received ${
         typeof _ctx.data === "string" ? `'${_ctx.data}'` : _ctx.data
@@ -287,37 +295,37 @@ export const defaultErrorMap = (
       message = `Invalid date`;
       break;
     case ZodIssueCode.invalid_string:
-      if (error.validation !== "regex") message = `Invalid ${error.validation}`;
+      if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
       else message = "Invalid";
       break;
     case ZodIssueCode.too_small:
-      if (error.type === "array")
-        message = `Should have ${error.inclusive ? `at least` : `more than`} ${
-          error.minimum
+      if (issue.type === "array")
+        message = `Should have ${issue.inclusive ? `at least` : `more than`} ${
+          issue.minimum
         } items`;
-      else if (error.type === "string")
-        message = `Should be ${error.inclusive ? `at least` : `over`} ${
-          error.minimum
+      else if (issue.type === "string")
+        message = `Should be ${issue.inclusive ? `at least` : `over`} ${
+          issue.minimum
         } characters`;
-      else if (error.type === "number")
+      else if (issue.type === "number")
         message = `Value should be greater than ${
-          error.inclusive ? `or equal to ` : ``
-        }${error.minimum}`;
+          issue.inclusive ? `or equal to ` : ``
+        }${issue.minimum}`;
       else message = "Invalid input";
       break;
     case ZodIssueCode.too_big:
-      if (error.type === "array")
-        message = `Should have ${error.inclusive ? `at most` : `less than`} ${
-          error.maximum
+      if (issue.type === "array")
+        message = `Should have ${issue.inclusive ? `at most` : `less than`} ${
+          issue.maximum
         } items`;
-      else if (error.type === "string")
-        message = `Should be ${error.inclusive ? `at most` : `under`} ${
-          error.maximum
+      else if (issue.type === "string")
+        message = `Should be ${issue.inclusive ? `at most` : `under`} ${
+          issue.maximum
         } characters long`;
-      else if (error.type === "number")
+      else if (issue.type === "number")
         message = `Value should be less than ${
-          error.inclusive ? `or equal to ` : ``
-        }${error.maximum}`;
+          issue.inclusive ? `or equal to ` : ``
+        }${issue.maximum}`;
       else message = "Invalid input";
       break;
     case ZodIssueCode.custom:
@@ -326,9 +334,12 @@ export const defaultErrorMap = (
     case ZodIssueCode.invalid_intersection_types:
       message = `Intersection results could not be merged`;
       break;
+    case ZodIssueCode.not_multiple_of:
+      message = `Should be multiple of ${issue.multipleOf}`;
+      break;
     default:
       message = _ctx.defaultError;
-      util.assertNever(error);
+      util.assertNever(issue);
   }
   return { message };
 };
diff --git a/src/__tests__/all-errors.test.ts b/src/__tests__/all-errors.test.ts
index ac8110c30..b1b45212f 100644
--- a/src/__tests__/all-errors.test.ts
+++ b/src/__tests__/all-errors.test.ts
@@ -37,7 +37,7 @@ test("all errors", () => {
       b: null,
     });
   } catch (_error) {
-    const error: z.ZodError = _error;
+    const error = _error as z.ZodError;
     expect(error.flatten()).toEqual({
       formErrors: [],
       fieldErrors: {
diff --git a/src/__tests__/async-parsing.test.ts b/src/__tests__/async-parsing.test.ts
index 6ab2f97f5..4970f32d0 100644
--- a/src/__tests__/async-parsing.test.ts
+++ b/src/__tests__/async-parsing.test.ts
@@ -369,19 +369,23 @@ test("ensure early async failure prevents follow-up refinement checks", async ()
       .number()
       .refine(async () => {
         count++;
-        return false;
+        return true;
       })
       .refine(async () => {
         count++;
         return true;
-      }),
+      }, "Good"),
   });
 
   const testval = { hello: "bye", foo: 3 };
-  const result = base.safeParseAsync(testval);
+  const result = await base.safeParseAsync(testval);
+  if (result.success === false) {
+    expect(result.error.issues.length).toBe(1);
+    expect(count).toBe(1);
+  }
 
-  await result.then((r) => {
-    if (r.success === false) expect(r.error.issues.length).toBe(1);
-    expect(count).toBe(2);
-  });
+  // await result.then((r) => {
+  //   if (r.success === false) expect(r.error.issues.length).toBe(1);
+  //   expect(count).toBe(2);
+  // });
 });
diff --git a/src/__tests__/error.test.ts b/src/__tests__/error.test.ts
index 56f0f4efd..0c8101d5a 100644
--- a/src/__tests__/error.test.ts
+++ b/src/__tests__/error.test.ts
@@ -41,7 +41,7 @@ test("type error with custom error map", () => {
   try {
     z.string().parse(234, { errorMap });
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
 
     expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
     expect(zerr.issues[0].message).toEqual(`bad type!`);
@@ -56,7 +56,7 @@ test("refinement fail with params", () => {
       })
       .parse(2, { errorMap });
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
     expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.custom);
     expect(zerr.issues[0].message).toEqual(`less-than-3`);
   }
@@ -71,7 +71,7 @@ test("custom error with custom errormap", () => {
       })
       .parse("asdf", { errorMap });
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
     expect(zerr.issues[0].message).toEqual("override");
   }
 });
@@ -82,7 +82,7 @@ test("default error message", () => {
       .refine((x) => x > 3)
       .parse(2);
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
     expect(zerr.issues.length).toEqual(1);
     expect(zerr.issues[0].message).toEqual("Invalid input");
   }
@@ -94,7 +94,7 @@ test("override error in refine", () => {
       .refine((x) => x > 3, "override")
       .parse(2);
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
     expect(zerr.issues.length).toEqual(1);
     expect(zerr.issues[0].message).toEqual("override");
   }
@@ -108,7 +108,7 @@ test("override error in refinement", () => {
       })
       .parse(2);
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr: z.ZodError = err as any;
     expect(zerr.issues.length).toEqual(1);
     expect(zerr.issues[0].message).toEqual("override");
   }
@@ -118,14 +118,14 @@ test("array minimum", () => {
   try {
     z.array(z.string()).min(3, "tooshort").parse(["asdf", "qwer"]);
   } catch (err) {
-    const zerr: ZodError = err;
+    const zerr: ZodError = err as any;
     expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);
     expect(zerr.issues[0].message).toEqual("tooshort");
   }
   try {
     z.array(z.string()).min(3).parse(["asdf", "qwer"]);
   } catch (err) {
-    const zerr: ZodError = err;
+    const zerr: ZodError = err as any;
     expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);
     expect(zerr.issues[0].message).toEqual(`Should have at least 3 items`);
   }
@@ -230,17 +230,28 @@ test("custom path", () => {
   }
 });
 
-test("formatting", () => {
-  const schema = z.object({
-    inner: z.object({
-      name: z
-        .string()
-        .refine((val) => val.length > 5)
-        .array()
-        .refine((val) => val.length <= 1),
-    }),
-  });
+const schema = z.object({
+  inner: z.object({
+    name: z
+      .string()
+      .refine((val) => val.length > 5)
+      .array()
+      .refine((val) => val.length <= 1),
+  }),
+});
 
+test("no abort early on refinements", () => {
+  const invalidItem = {
+    inner: { name: ["aasd", "asdfasdfasfd"] },
+  };
+
+  const result1 = schema.safeParse(invalidItem);
+  expect(result1.success).toEqual(false);
+  if (!result1.success) {
+    expect(result1.error.issues.length).toEqual(2);
+  }
+});
+test("formatting", () => {
   const invalidItem = {
     inner: { name: ["aasd", "asdfasdfasfd"] },
   };
@@ -256,7 +267,7 @@ test("formatting", () => {
     const error = result1.error.format();
     expect(error._errors).toEqual([]);
     expect(error.inner?._errors).toEqual([]);
-    expect(error.inner?.name?._errors).toEqual([]);
+    expect(error.inner?.name?._errors).toEqual(["Invalid input"]);
     expect(error.inner?.name?.[0]._errors).toEqual(["Invalid input"]);
     expect(error.inner?.name?.[1]).toEqual(undefined);
   }
@@ -270,3 +281,104 @@ test("formatting", () => {
     expect(error.inner?.name?.[2]).toEqual(undefined);
   }
 });
+
+const stringWithCustomError = z.string({
+  errorMap: (issue, ctx) => ({
+    message:
+      issue.code === "invalid_type"
+        ? ctx.data
+          ? "Invalid name"
+          : "Name is required"
+        : ctx.defaultError,
+  }),
+});
+
+test("schema-bound error map", () => {
+  const result = stringWithCustomError.safeParse(1234);
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual("Invalid name");
+  }
+
+  const result2 = stringWithCustomError.safeParse(undefined);
+  expect(result2.success).toEqual(false);
+  if (!result2.success) {
+    expect(result2.error.issues[0].message).toEqual("Name is required");
+  }
+
+  // support contextual override
+  const result3 = stringWithCustomError.safeParse(undefined, {
+    errorMap: () => ({ message: "OVERRIDE" }),
+  });
+  expect(result3.success).toEqual(false);
+  if (!result3.success) {
+    expect(result3.error.issues[0].message).toEqual("OVERRIDE");
+  }
+});
+
+test("overrideErrorMap", () => {
+  // support overrideErrorMap
+  z.setErrorMap(() => ({ message: "OVERRIDE" }));
+  const result4 = stringWithCustomError.min(10).safeParse("tooshort");
+  expect(result4.success).toEqual(false);
+  if (!result4.success) {
+    expect(result4.error.issues[0].message).toEqual("OVERRIDE");
+  }
+  z.setErrorMap(z.defaultErrorMap);
+});
+
+test("invalid and required", () => {
+  const str = z.string({
+    invalid_type_error: "Invalid name",
+    required_error: "Name is required",
+  });
+  const result1 = str.safeParse(1234);
+  expect(result1.success).toEqual(false);
+  if (!result1.success) {
+    expect(result1.error.issues[0].message).toEqual("Invalid name");
+  }
+  const result2 = str.safeParse(undefined);
+  expect(result2.success).toEqual(false);
+  if (!result2.success) {
+    expect(result2.error.issues[0].message).toEqual("Name is required");
+  }
+});
+
+test("Fallback to invalid_type_error without required_error", () => {
+  const str = z.string({
+    invalid_type_error: "Invalid name",
+    // required_error: "Name is required",
+  });
+
+  const result2 = str.safeParse(undefined);
+  expect(result2.success).toEqual(false);
+  if (!result2.success) {
+    expect(result2.error.issues[0].message).toEqual("Invalid name");
+  }
+});
+
+test("invalid and required and errorMap", () => {
+  expect(() => {
+    return z.string({
+      invalid_type_error: "Invalid name",
+      required_error: "Name is required",
+      errorMap: () => ({ message: "OVERRIDE" }),
+    });
+  }).toThrow();
+});
+
+test("dont short circuit on continuable errors", () => {
+  const user = z
+    .object({
+      password: z.string().min(6),
+      confirm: z.string(),
+    })
+    .refine((data) => data.password === data.confirm, {
+      message: "Passwords don't match",
+      path: ["confirm"],
+    });
+  const result = user.safeParse({ password: "asdf", confirm: "qwer" });
+  if (!result.success) {
+    expect(result.error.issues.length).toEqual(2);
+  }
+});
diff --git a/src/__tests__/function.test.ts b/src/__tests__/function.test.ts
index da5d2a92a..ab79e2f0b 100644
--- a/src/__tests__/function.test.ts
+++ b/src/__tests__/function.test.ts
@@ -124,7 +124,7 @@ test("special function error codes", () => {
   try {
     checker("12" as any);
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr = err as z.ZodError;
     const first = zerr.issues[0];
     if (first.code !== z.ZodIssueCode.invalid_return_type) throw new Error();
 
@@ -134,7 +134,7 @@ test("special function error codes", () => {
   try {
     checker(12 as any);
   } catch (err) {
-    const zerr: z.ZodError = err;
+    const zerr = err as z.ZodError;
     const first = zerr.issues[0];
     if (first.code !== z.ZodIssueCode.invalid_arguments) throw new Error();
     expect(first.argumentsError).toBeInstanceOf(z.ZodError);
@@ -185,3 +185,22 @@ test("non async function with async refinements should fail", async () => {
 
   expect(results).toEqual(["fail"]);
 });
+
+test("allow extra parameters", () => {
+  const maxLength5 = z
+    .function()
+    .args(z.string())
+    .returns(z.boolean())
+    .implement((str, _arg, _qewr) => {
+      return str.length <= 5;
+    });
+
+  const filteredList = [
+    "apple",
+    "orange",
+    "pear",
+    "banana",
+    "strawberry",
+  ].filter(maxLength5);
+  expect(filteredList.length).toEqual(2);
+});
diff --git a/src/__tests__/nullable.test.ts b/src/__tests__/nullable.test.ts
index 2d4231c31..e57f6079b 100644
--- a/src/__tests__/nullable.test.ts
+++ b/src/__tests__/nullable.test.ts
@@ -8,12 +8,12 @@ function checkErrors(a: z.ZodTypeAny, bad: any) {
   try {
     a.parse(bad);
   } catch (error) {
-    expected = error.formErrors;
+    expected = (error as z.ZodError).formErrors;
   }
   try {
     a.nullable().parse(bad);
   } catch (error) {
-    expect(error.formErrors).toEqual(expected);
+    expect((error as z.ZodError).formErrors).toEqual(expected);
   }
 }
 
diff --git a/src/__tests__/number.test.ts b/src/__tests__/number.test.ts
index f8110b534..f592f5d4f 100644
--- a/src/__tests__/number.test.ts
+++ b/src/__tests__/number.test.ts
@@ -8,6 +8,8 @@ const gteFive = z.number().gte(5);
 const ltFive = z.number().lt(5);
 const lteFive = z.number().lte(5);
 const intNum = z.number().int();
+const multipleOfFive = z.number().multipleOf(5);
+const stepSixPointFour = z.number().step(6.4);
 
 test("passing validations", () => {
   gtFive.parse(6);
@@ -15,6 +17,8 @@ test("passing validations", () => {
   ltFive.parse(4);
   lteFive.parse(5);
   intNum.parse(4);
+  multipleOfFive.parse(15);
+  stepSixPointFour.parse(12.8);
 });
 
 test("failing validations", () => {
@@ -23,6 +27,8 @@ test("failing validations", () => {
   expect(() => gtFive.parse(5)).toThrow();
   expect(() => gteFive.parse(4)).toThrow();
   expect(() => intNum.parse(3.14)).toThrow();
+  expect(() => multipleOfFive.parse(14.9)).toThrow();
+  expect(() => stepSixPointFour.parse(6.41)).toThrow();
 });
 
 test("parse NaN", () => {
diff --git a/src/__tests__/object.test.ts b/src/__tests__/object.test.ts
index 567fe44c4..8ca6e6f79 100644
--- a/src/__tests__/object.test.ts
+++ b/src/__tests__/object.test.ts
@@ -193,7 +193,7 @@ test("test nonexistent keys", async () => {
   expect(result.success).toBe(true);
 });
 
-test("test async PseudoPromise.all", async () => {
+test("test async union", async () => {
   const Schema2 = z.union([
     z.object({
       ty: z.string(),
diff --git a/src/__tests__/optional.test.ts b/src/__tests__/optional.test.ts
index 02b096113..4ed86d3aa 100644
--- a/src/__tests__/optional.test.ts
+++ b/src/__tests__/optional.test.ts
@@ -8,12 +8,12 @@ function checkErrors(a: z.ZodTypeAny, bad: any) {
   try {
     a.parse(bad);
   } catch (error) {
-    expected = error.formErrors;
+    expected = (error as z.ZodError).formErrors;
   }
   try {
     a.optional().parse(bad);
   } catch (error) {
-    expect(error.formErrors).toEqual(expected);
+    expect((error as z.ZodError).formErrors).toEqual(expected);
   }
 }
 
diff --git a/src/__tests__/primitive.test.ts b/src/__tests__/primitive.test.ts
index d3bd5d992..465c0019c 100644
--- a/src/__tests__/primitive.test.ts
+++ b/src/__tests__/primitive.test.ts
@@ -245,7 +245,9 @@ test("parse dateSchema invalid date", async () => {
   try {
     await dateSchema.parseAsync(new Date("invalid"));
   } catch (err) {
-    expect(err.issues[0].code).toEqual(z.ZodIssueCode.invalid_date);
+    expect((err as z.ZodError).issues[0].code).toEqual(
+      z.ZodIssueCode.invalid_date
+    );
   }
 });
 // ==============
diff --git a/src/__tests__/pseudopromise.test.ts b/src/__tests__/pseudopromise.test.ts
deleted file mode 100644
index 2bee72a1e..000000000
--- a/src/__tests__/pseudopromise.test.ts
+++ /dev/null
@@ -1,74 +0,0 @@
-// @ts-ignore TS6133
-import { expect, test } from "@jest/globals";
-
-test("foo", () => {
-  expect(1).toEqual(1);
-});
-
-/*
-// import * as z from '.';
-import { PseudoPromise } from "../PseudoPromise";
-
-test("sync pass", () => {
-  const myProm = new PseudoPromise()
-    .then(() => 15)
-    .then((arg) => arg.toString())
-    .then((arg) => arg.length);
-  expect(myProm.getValueSync()).toEqual(2);
-});
-
-test("sync fail", async () => {
-  const myProm = new PseudoPromise()
-    .then(async () => 15)
-    .then((arg) => arg.toString())
-    .then((arg) => {
-      return arg.length;
-    });
-
-  expect(myProm.getValueSync()).toEqual(16);
-  myProm.getValueSync();
-  // expect(myProm.getValue()).resolves.toEqual(2);
-  const val = await myProm.getValueAsync();
-  expect(val).toEqual(2);
-  // (myProm.getValue() as Promise<any>).then(val => expect(val).toEqual(2));
-});
-
-test("pseudopromise all", async () => {
-  const myProm = PseudoPromise.all([
-    new PseudoPromise().then(() => "asdf"),
-    PseudoPromise.resolve(12),
-  ]).getValueAsync();
-  await expect(await myProm).toEqual(["asdf", 12]);
-});
-
-test(".resolve sync ", () => {
-  expect(PseudoPromise.resolve(12).getValueSync()).toEqual(12);
-});
-
-test(".resolve async", async () => {
-  expect(
-    await PseudoPromise.resolve(Promise.resolve(12)).getValueAsync()
-  ).toEqual(12);
-});
-
-test("sync and async", async () => {
-  expect(PseudoPromise.resolve(15).getValueSync()).toEqual(15);
-  expect(await PseudoPromise.resolve(15).getValueAsync()).toEqual(15);
-});
-
-test("object", async () => {
-  const prom = PseudoPromise.object({
-    asdf: PseudoPromise.resolve(15),
-    qwer: new PseudoPromise().then(async () => "asdfadsf"),
-  });
-
-  expect(await prom.getValueAsync()).toEqual({ asdf: 15, qwer: "asdfadsf" });
-});
-
-test("all", async () => {
-  const asdf = new PseudoPromise().then(async () => "asdf");
-  await PseudoPromise.all([asdf])
-    .getValueAsync()
-    .then((val) => expect(val).toEqual(["asdf"]));
-});
-*/
diff --git a/src/__tests__/record.test.ts b/src/__tests__/record.test.ts
index 30eb0dd90..d0490f5aa 100644
--- a/src/__tests__/record.test.ts
+++ b/src/__tests__/record.test.ts
@@ -7,9 +7,29 @@ import * as z from "../index";
 const booleanRecord = z.record(z.boolean());
 type booleanRecord = z.infer<typeof booleanRecord>;
 
+const recordWithEnumKeys = z.record(z.enum(["Tuna", "Salmon"]), z.string());
+type recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;
+
+const recordWithLiteralKeys = z.record(
+  z.union([z.literal("Tuna"), z.literal("Salmon")]),
+  z.string()
+);
+type recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;
+
 test("type inference", () => {
   const f1: util.AssertEqual<booleanRecord, Record<string, boolean>> = true;
   f1;
+
+  const f2: util.AssertEqual<
+    recordWithEnumKeys,
+    Record<"Tuna" | "Salmon", string>
+  > = true;
+  f2;
+  const f3: util.AssertEqual<
+    recordWithLiteralKeys,
+    Record<"Tuna" | "Salmon", string>
+  > = true;
+  f3;
 });
 
 test("methods", () => {
@@ -50,3 +70,44 @@ test("string record parse - fail", () => {
     } as any);
   expect(badCheck).toThrow();
 });
+
+test("key schema", () => {
+  const result1 = recordWithEnumKeys.parse({
+    Tuna: "asdf",
+    Salmon: "asdf",
+  });
+  expect(result1).toEqual({
+    Tuna: "asdf",
+    Salmon: "asdf",
+  });
+
+  const result2 = recordWithLiteralKeys.parse({
+    Tuna: "asdf",
+    Salmon: "asdf",
+  });
+  expect(result2).toEqual({
+    Tuna: "asdf",
+    Salmon: "asdf",
+  });
+
+  expect(() =>
+    recordWithEnumKeys.parse({
+      Tuna: "asdf",
+      Salmon: "asdf",
+      Trout: "asdf",
+    })
+  ).toThrow();
+
+  expect(() =>
+    recordWithLiteralKeys.parse({
+      Tuna: "asdf",
+      Salmon: "asdf",
+
+      Trout: "asdf",
+    })
+  ).toThrow();
+});
+
+// test("record element", () => {
+//   expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);
+// });
diff --git a/src/__tests__/refine.test.ts b/src/__tests__/refine.test.ts
index d785d48f0..466b1f9a3 100644
--- a/src/__tests__/refine.test.ts
+++ b/src/__tests__/refine.test.ts
@@ -58,7 +58,7 @@ test("custom path", async () => {
       .refine((data) => data.confirm === data.password, { path: ["confirm"] })
       .parseAsync({ password: "asdf", confirm: "qewr" });
   } catch (err) {
-    expect(err.issues[0].path).toEqual(["confirm"]);
+    expect((err as z.ZodError).issues[0].path).toEqual(["confirm"]);
   }
 });
 
diff --git a/src/__tests__/string.test.ts b/src/__tests__/string.test.ts
index 1ca8cede2..5fc8ffd9b 100644
--- a/src/__tests__/string.test.ts
+++ b/src/__tests__/string.test.ts
@@ -65,17 +65,17 @@ test("url error overrides", () => {
   try {
     z.string().url().parse("https");
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Invalid url");
+    expect((err as z.ZodError).issues[0].message).toEqual("Invalid url");
   }
   try {
     z.string().url("badurl").parse("https");
   } catch (err) {
-    expect(err.issues[0].message).toEqual("badurl");
+    expect((err as z.ZodError).issues[0].message).toEqual("badurl");
   }
   try {
     z.string().url({ message: "badurl" }).parse("https");
   } catch (err) {
-    expect(err.issues[0].message).toEqual("badurl");
+    expect((err as z.ZodError).issues[0].message).toEqual("badurl");
   }
 });
 
diff --git a/src/__tests__/transformer.test.ts b/src/__tests__/transformer.test.ts
index af0130862..a1eb606d1 100644
--- a/src/__tests__/transformer.test.ts
+++ b/src/__tests__/transformer.test.ts
@@ -8,20 +8,18 @@ const stringToNumber = z.string().transform((arg) => parseFloat(arg));
 // const numberToString = z
 //   .transformer(z.number())
 //   .transform((n) => String(n));
-const asyncNumberToString = z
-  .transformer(z.number())
-  .transform(async (n) => String(n));
+const asyncNumberToString = z.number().transform(async (n) => String(n));
 
 test("basic transformations", () => {
   const r1 = z
-    .transformer(z.string())
+    .string()
     .transform((data) => data.length)
     .parse("asdf");
   expect(r1).toEqual(4);
 });
 
 test("coercion", () => {
-  const numToString = z.transformer(z.number()).transform((n) => String(n));
+  const numToString = z.number().transform((n) => String(n));
   const data = z
     .object({
       id: numToString,
@@ -32,9 +30,7 @@ test("coercion", () => {
 });
 
 test("async coercion", async () => {
-  const numToString = z
-    .transformer(z.number())
-    .transform(async (n) => String(n));
+  const numToString = z.number().transform(async (n) => String(n));
   const data = await z
     .object({
       id: numToString,
@@ -126,3 +122,10 @@ test("preprocess", () => {
   const value = schema.parse("asdf");
   expect(value).toEqual(["asdf"]);
 });
+
+test("async preprocess", async () => {
+  const schema = z.preprocess(async (data) => [data], z.string().array());
+
+  const value = await schema.parseAsync("asdf");
+  expect(value).toEqual(["asdf"]);
+});
diff --git a/src/__tests__/tuple.test.ts b/src/__tests__/tuple.test.ts
index 0688a0925..9a3bead18 100644
--- a/src/__tests__/tuple.test.ts
+++ b/src/__tests__/tuple.test.ts
@@ -60,19 +60,37 @@ test("failed async validation", async () => {
   // }
 });
 
-// test("tuple with transformers", () => {
-//   const stringToNumber = z.string().transform(z.number(), (val) => val.length);
-//   const val = z.tuple([stringToNumber]);
+test("tuple with transformers", () => {
+  const stringToNumber = z.string().transform((val) => val.length);
+  const val = z.tuple([stringToNumber]);
 
-//   type t1 = z.input<typeof val>;
-//   const f1: util.AssertEqual<t1, [string]> = true;
-//   //  const f1: util.AssertEqual<t1, [string]> =
-//   type t2 = z.output<typeof val>;
-//   const f2: util.AssertEqual<t2, [number]> = true;
+  type t1 = z.input<typeof val>;
+  const f1: util.AssertEqual<t1, [string]> = true;
+  type t2 = z.output<typeof val>;
+  const f2: util.AssertEqual<t2, [number]> = true;
+  expect(val.parse(["1234"])).toEqual([4]);
+  f1;
+  f2;
+});
 
-//   f1;
-//   f2;
-// });
+test("tuple with rest schema", () => {
+  const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());
+  expect(myTuple.parse(["asdf", 1234, true, false, true])).toEqual([
+    "asdf",
+    1234,
+    true,
+    false,
+    true,
+  ]);
+
+  expect(myTuple.parse(["asdf", 1234])).toEqual(["asdf", 1234]);
+
+  expect(() => myTuple.parse(["asdf", 1234, "asdf"])).toThrow();
+  type t1 = z.output<typeof myTuple>;
+
+  const f1: util.AssertEqual<t1, [string, number, ...boolean[]]> = true;
+  f1;
+});
 
 // test('tuple with optional elements', () => {
 //   const result = z
diff --git a/src/__tests__/validations.test.ts b/src/__tests__/validations.test.ts
index 7c0b76866..47ef7d6b8 100644
--- a/src/__tests__/validations.test.ts
+++ b/src/__tests__/validations.test.ts
@@ -7,7 +7,9 @@ test("array min", async () => {
   try {
     await z.array(z.string()).min(4).parseAsync([]);
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Should have at least 4 items");
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Should have at least 4 items"
+    );
   }
 });
 
@@ -15,7 +17,9 @@ test("array max", async () => {
   try {
     await z.array(z.string()).max(2).parseAsync(["asdf", "asdf", "asdf"]);
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Should have at most 2 items");
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Should have at most 2 items"
+    );
   }
 });
 
@@ -23,7 +27,9 @@ test("string min", async () => {
   try {
     await z.string().min(4).parseAsync("asd");
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Should be at least 4 characters");
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Should be at least 4 characters"
+    );
   }
 });
 
@@ -31,7 +37,7 @@ test("string max", async () => {
   try {
     await z.string().max(4).parseAsync("aasdfsdfsd");
   } catch (err) {
-    expect(err.issues[0].message).toEqual(
+    expect((err as z.ZodError).issues[0].message).toEqual(
       "Should be at most 4 characters long"
     );
   }
@@ -41,7 +47,7 @@ test("number min", async () => {
   try {
     await z.number().gte(3).parseAsync(2);
   } catch (err) {
-    expect(err.issues[0].message).toEqual(
+    expect((err as z.ZodError).issues[0].message).toEqual(
       "Value should be greater than or equal to 3"
     );
   }
@@ -51,7 +57,7 @@ test("number max", async () => {
   try {
     await z.number().lte(3).parseAsync(4);
   } catch (err) {
-    expect(err.issues[0].message).toEqual(
+    expect((err as z.ZodError).issues[0].message).toEqual(
       "Value should be less than or equal to 3"
     );
   }
@@ -61,7 +67,7 @@ test("number nonnegative", async () => {
   try {
     await z.number().nonnegative().parseAsync(-1);
   } catch (err) {
-    expect(err.issues[0].message).toEqual(
+    expect((err as z.ZodError).issues[0].message).toEqual(
       "Value should be greater than or equal to 0"
     );
   }
@@ -71,7 +77,7 @@ test("number nonpositive", async () => {
   try {
     await z.number().nonpositive().parseAsync(1);
   } catch (err) {
-    expect(err.issues[0].message).toEqual(
+    expect((err as z.ZodError).issues[0].message).toEqual(
       "Value should be less than or equal to 0"
     );
   }
@@ -81,7 +87,9 @@ test("number negative", async () => {
   try {
     await z.number().negative().parseAsync(1);
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Value should be less than 0");
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Value should be less than 0"
+    );
   }
 });
 
@@ -89,7 +97,9 @@ test("number positive", async () => {
   try {
     await z.number().positive().parseAsync(-1);
   } catch (err) {
-    expect(err.issues[0].message).toEqual("Value should be greater than 0");
+    expect((err as z.ZodError).issues[0].message).toEqual(
+      "Value should be greater than 0"
+    );
   }
 });
 
diff --git a/src/helpers/parseUtil.ts b/src/helpers/parseUtil.ts
index dbbf90684..22a39c780 100644
--- a/src/helpers/parseUtil.ts
+++ b/src/helpers/parseUtil.ts
@@ -1,9 +1,7 @@
-import { PseudoPromise } from "../PseudoPromise";
 import {
   defaultErrorMap,
-  MakeErrorData,
+  IssueData,
   overrideErrorMap,
-  ZodError,
   ZodErrorMap,
   ZodIssue,
 } from "../ZodError";
@@ -76,38 +74,44 @@ export const getParsedType = (data: any): ZodParsedType => {
 };
 
 export const makeIssue = (
-  data: any,
-  path: (string | number)[],
-  errorMap: ZodErrorMap,
-  errorData: MakeErrorData
+  params: {
+    data: any;
+    path: (string | number)[];
+    errorMaps: (ZodErrorMap | undefined)[];
+    issueData: IssueData;
+  }
+  // data: any,
+  // path: (string | number)[],
+  // errorMap: ZodErrorMap,
+  // issueData: IssueData
 ): ZodIssue => {
-  const fullPath = [...path, ...(errorData.path || [])];
-  const errorArg = {
-    ...errorData,
+  const { data, path, errorMaps, issueData } = params;
+  const fullPath = [...path, ...(issueData.path || [])];
+  const fullIssue = {
+    ...issueData,
     path: fullPath,
   };
 
-  const defaultError = defaultErrorMap(errorArg, {
-    data: data,
-    defaultError: `Invalid input`,
-  });
+  let errorMessage = "";
+  const maps = errorMaps
+    .filter((m) => !!m)
+    .slice()
+    .reverse() as ZodErrorMap[];
+  for (const map of maps) {
+    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
+  }
+
   return {
-    ...errorData,
+    ...issueData,
     path: fullPath,
-    message:
-      errorData.message ||
-      errorMap(errorArg, {
-        data: data,
-        defaultError: defaultError.message,
-      }).message,
+    message: issueData.message || errorMessage,
   };
 };
 
 export type ParseParams = {
-  data: any;
+  // data: any;
   path: (string | number)[];
   errorMap: ZodErrorMap;
-  parentError: ZodError;
   async: boolean;
 };
 
@@ -146,56 +150,78 @@ export type ParseContextParameters = {
   async: boolean;
 };
 
+interface ParseContextDef {
+  readonly path: ParsePath;
+  readonly issues: ZodIssue[];
+  readonly errorMap?: ZodErrorMap;
+  readonly async: boolean;
+}
+
 export class ParseContext {
-  constructor(
-    public readonly path: ParsePath,
-    public readonly issues: ZodIssue[],
-    public readonly params: ParseContextParameters
-  ) {}
+  // public readonly path: ParsePath;
+  // public readonly issues: ZodIssue[];
+  // public readonly errorMap: ZodErrorMap;
+  public readonly def: ParseContextDef;
+
+  constructor(def: ParseContextDef) {
+    this.def = def;
+  }
+  get path() {
+    return this.def.path;
+  }
+  get issues() {
+    return this.def.issues;
+  }
+  get errorMap() {
+    return this.def.errorMap;
+  }
+  get async() {
+    return this.def.async;
+  }
 
   stepInto(component: ParsePathComponent): ParseContext {
-    return new ParseContext(
-      this.path === null
-        ? { parent: null, count: 1, component }
-        : { parent: this.path, count: this.path.count + 1, component },
-      this.issues,
-      this.params
-    );
+    return new ParseContext({
+      ...this.def,
+      path:
+        this.path === null
+          ? { parent: null, count: 1, component }
+          : { parent: this.path, count: this.path.count + 1, component },
+    });
   }
 
-  addIssue(data: any, errorData: MakeErrorData): void {
-    const issue = makeIssue(
+  addIssue(
+    data: any,
+    issueData: IssueData,
+    params: { schemaErrorMap?: ZodErrorMap } = {}
+  ): void {
+    const issue = makeIssue({
       data,
-      pathToArray(this.path),
-      this.params.errorMap,
-      errorData
-    );
+      issueData,
+      path: pathToArray(this.path),
+      errorMaps: [
+        this.def.errorMap, // contextual error map is first priority
+        params.schemaErrorMap, // then schema-bound map if available
+        overrideErrorMap, // then global override map
+        defaultErrorMap, // then global default map
+      ],
+      // errorMaps: [this.errorMap],
+      // issueData,
+    });
     this.issues.push(issue);
   }
 }
 
-export const createRootContext = (
-  params: Partial<ParseParamsNoData>
-): ParseContext =>
-  new ParseContext(EMPTY_PATH, [], {
-    async: params.async ?? false,
-    errorMap: params.errorMap || overrideErrorMap,
-  });
-
 export type INVALID = { valid: false };
 export const INVALID: INVALID = Object.freeze({ valid: false });
 
 export type OK<T> = { valid: true; value: T };
 export const OK = <T>(value: T): OK<T> => ({ valid: true, value });
 
-export type ASYNC<T> = PseudoPromise<T>;
-export const ASYNC = <T>(promise: Promise<T>): ASYNC<T> =>
-  new PseudoPromise<T>(promise);
-
 export type SyncParseReturnType<T> = OK<T> | INVALID;
+export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
 export type ParseReturnType<T> =
   | SyncParseReturnType<T>
-  | ASYNC<SyncParseReturnType<T>>;
+  | AsyncParseReturnType<T>;
 
 export const isInvalid = (x: ParseReturnType<any>): x is INVALID =>
   (x as any).valid === false;
@@ -203,4 +229,4 @@ export const isOk = <T>(x: ParseReturnType<T>): x is OK<T> =>
   (x as any).valid === true;
 export const isAsync = <T>(
   x: ParseReturnType<T>
-): x is ASYNC<SyncParseReturnType<T>> => x instanceof PseudoPromise;
+): x is AsyncParseReturnType<T> => x instanceof Promise;
diff --git a/src/types.ts b/src/types.ts
index 3283723df..4d96b7017 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -1,6 +1,6 @@
 import { errorUtil } from "./helpers/errorUtil";
 import {
-  ASYNC,
+  AsyncParseReturnType,
   getParsedType,
   INVALID,
   isAsync,
@@ -18,13 +18,12 @@ import {
 } from "./helpers/parseUtil";
 import { partialUtil } from "./helpers/partialUtil";
 import { util } from "./helpers/util";
-import { PseudoPromise } from "./PseudoPromise";
 import {
-  MakeErrorData,
-  overrideErrorMap,
+  IssueData,
   StringValidation,
   ZodCustomIssue,
   ZodError,
+  ZodErrorMap,
   ZodIssue,
   ZodIssueCode,
 } from "./ZodError";
@@ -38,46 +37,87 @@ import {
 ///////////////////////////////////////
 
 export type RefinementCtx = {
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
   path: (string | number)[];
-  issueFound: boolean;
 };
 export type ZodRawShape = { [k: string]: ZodTypeAny };
 export type ZodTypeAny = ZodType<any, any, any>;
-export type TypeOf<T extends ZodType<any>> = T["_output"];
-export type input<T extends ZodType<any>> = T["_input"];
-export type output<T extends ZodType<any>> = T["_output"];
+export type TypeOf<T extends ZodType<any, any, any>> = T["_output"];
+export type input<T extends ZodType<any, any, any>> = T["_input"];
+export type output<T extends ZodType<any, any, any>> = T["_output"];
 export type { TypeOf as infer };
 
 export type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
-export interface ZodTypeDef {}
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
 
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === "string") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
 
 const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap,
     async: params.async ?? false,
-    errorMap: params.errorMap || overrideErrorMap,
   });
 
 const handleResult = <Input, Output>(
   ctx: ParseContext,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
 ):
   | { success: true; data: Output }
   | { success: false; error: ZodError<Input> } => {
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
     return { success: true, data: result.value };
   } else {
-    parentError?.addIssues(ctx.issues);
     const error = new ZodError(ctx.issues);
     return { success: false, error };
   }
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
 };
 
+type RawCreateParams =
+  | {
+      errorMap?: ZodErrorMap;
+      invalid_type_error?: string;
+      required_error?: string;
+    }
+  | undefined;
+type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
+  if (!params) return {};
+  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+    throw new Error(
+      `Can't use "invalid" or "required" in conjunction with custom error map.`
+    );
+  }
+  if (params.errorMap) return { errorMap: params.errorMap };
+  const customMap: ZodErrorMap = (iss, ctx) => {
+    if (iss.code !== "invalid_type") return { message: ctx.defaultError };
+    if (typeof ctx.data === "undefined" && params.required_error)
+      return { message: params.required_error };
+    if (params.invalid_type_error)
+      return { message: params.invalid_type_error };
+    return { message: ctx.defaultError };
+  };
+  return { errorMap: customMap };
+}
+
 export abstract class ZodType<
   Output,
   Def extends ZodTypeDef = ZodTypeDef,
@@ -94,6 +134,12 @@ export abstract class ZodType<
     _parsedType: ZodParsedType
   ): ParseReturnType<Output>;
 
+  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx.addIssue(params.data, issueData, {
+      schemaErrorMap: this._def.errorMap,
+    });
+  }
+
   _parseSync(
     _ctx: ParseContext,
     _data: any,
@@ -106,62 +152,72 @@ export abstract class ZodType<
     return result;
   }
 
-  parse: (data: unknown, params?: Partial<ParseParamsNoData>) => Output = (
-    data,
-    params
-  ) => {
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    // if (isAsync(result)) {
+    //   return result;
+    // }
+
+    return Promise.resolve(result);
+  }
+
+  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
     const result = this.safeParse(data, params);
     if (result.success) return result.data;
     throw result.error;
-  };
+  }
 
-  safeParse: (
+  safeParse(
     data: unknown,
     params?: Partial<ParseParamsNoData>
-  ) =>
+  ):
     | { success: true; data: Output }
-    | { success: false; error: ZodError<Input> } = (data, params) => {
+    | { success: false; error: ZodError<Input> } {
     const ctx = createRootContext({ ...params, async: false });
     const result = this._parseSync(ctx, data, getParsedType(data));
-    return handleResult(ctx, result, params?.parentError);
-  };
+    return handleResult(ctx, result);
+  }
 
-  parseAsync: (
-    x: unknown,
+  async parseAsync(
+    data: unknown,
     params?: Partial<ParseParamsNoData>
-  ) => Promise<Output> = async (data, params) => {
+  ): Promise<Output> {
     const result = await this.safeParseAsync(data, params);
     if (result.success) return result.data;
     throw result.error;
-  };
+  }
 
-  safeParseAsync: (
-    x: unknown,
+  async safeParseAsync(
+    data: unknown,
     params?: Partial<ParseParamsNoData>
-  ) => Promise<
+  ): Promise<
     { success: true; data: Output } | { success: false; error: ZodError }
-  > = async (data, params) => {
+  > {
     const ctx = createRootContext({ ...params, async: true });
     const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
     const result = await (isAsync(maybeAsyncResult)
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
       : Promise.resolve(maybeAsyncResult));
-    return handleResult(ctx, result, params?.parentError);
-  };
+    return handleResult(ctx, result);
+  }
 
   /** Alias of safeParseAsync */
   spa = this.safeParseAsync;
 
   /** The .is method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
-  is: never;
+  is!: never;
 
   /** The .check method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
-  check: never;
+  check!: never;
 
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine<Func extends (arg: Output) => any>(
     check: Func,
     message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
-  ) => ZodEffectsType<This> = (check, message) => {
+  ): ZodEffects<this> {
     const getIssueProperties: any = (val: Output) => {
       if (typeof message === "string" || typeof message === "undefined") {
         return { message };
@@ -195,14 +251,12 @@ export abstract class ZodType<
         return true;
       }
     });
-  };
+  }
 
-  refinement: <This extends this = this>(
+  refinement(
     check: (arg: Output) => any,
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this> {
     return this._refinement((val, ctx) => {
       if (!check(val)) {
         ctx.addIssue(
@@ -215,28 +269,16 @@ export abstract class ZodType<
         return true;
       }
     });
-  };
+  }
 
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>["refinement"]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: "refinement", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: "refinement", refinement }],
-      }) as any;
-    }
-    return returnType;
+  _refinement(
+    refinement: RefinementEffect<Output>["refinement"]
+  ): ZodEffects<this> {
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: "refinement", refinement },
+    }) as any;
   }
   superRefine = this._refinement;
 
@@ -246,17 +288,21 @@ export abstract class ZodType<
     this.default = this.default.bind(this);
   }
 
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
-
-  array: () => ZodArray<this> = () => ZodArray.create(this);
-
-  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
+  optional(): ZodOptional<this> {
+    return ZodOptional.create(this) as any;
+  }
+  nullable(): ZodNullable<this> {
+    return ZodNullable.create(this) as any;
+  }
+  nullish(): ZodNullable<ZodOptional<this>> {
+    return this.optional().nullable();
+  }
+  array(): ZodArray<this> {
+    return ZodArray.create(this);
+  }
+  promise(): ZodPromise<this> {
+    return ZodPromise.create(this);
+  }
 
   or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
     return ZodUnion.create([this, option]) as any;
@@ -272,16 +318,12 @@ export abstract class ZodType<
     return new ZodEffects({
       schema: this,
       typeName: ZodFirstPartyTypeKind.ZodEffects,
-      effects: [{ type: "transform", transform }],
+      effect: { type: "transform", transform },
     }) as any;
   }
 
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
   default(def: any) {
     const defaultValueFunc = typeof def === "function" ? def : () => def;
     // if (this instanceof ZodOptional) {
@@ -297,8 +339,12 @@ export abstract class ZodType<
     }) as any;
   }
 
-  isOptional: () => boolean = () => this.safeParse(undefined).success;
-  isNullable: () => boolean = () => this.safeParse(null).success;
+  isOptional(): boolean {
+    return this.safeParse(undefined).success;
+  }
+  isNullable(): boolean {
+    return this.safeParse(null).success;
+  }
 }
 
 /////////////////////////////////////////
@@ -337,85 +383,118 @@ export class ZodString extends ZodType<string, ZodStringDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<string> {
     if (parsedType !== ZodParsedType.string) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.string,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        },
+        { data }
+      );
       return INVALID;
     }
-    let invalid = false;
+    const invalid = false;
 
     for (const check of this._def.checks) {
       if (check.kind === "min") {
         if (data.length < check.value) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: "string",
-            inclusive: true,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: "string",
+              inclusive: true,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "max") {
         if (data.length > check.value) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: "string",
-            inclusive: true,
-            message: check.message,
-            // ...errorUtil.errToObj(this._def.maxLength.message),
-          });
+          // invalid = true;
+
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: "string",
+              inclusive: true,
+              message: check.message,
+              // ...errorUtil.errToObj(this._def.maxLength.message),
+            },
+            { data }
+          );
         }
       } else if (check.kind === "email") {
         if (!emailRegex.test(data)) {
-          invalid = true;
-          ctx.addIssue(data, {
-            validation: "email",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              validation: "email",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "uuid") {
         if (!uuidRegex.test(data)) {
-          invalid = true;
-          ctx.addIssue(data, {
-            validation: "uuid",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              validation: "uuid",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "cuid") {
         if (!cuidRegex.test(data)) {
-          invalid = true;
-          ctx.addIssue(data, {
-            validation: "cuid",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              validation: "cuid",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "url") {
         try {
           new URL(data);
         } catch {
-          invalid = true;
-          ctx.addIssue(data, {
-            validation: "url",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              validation: "url",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "regex") {
         if (!check.regex.test(data)) {
-          invalid = true;
-          ctx.addIssue(data, {
-            validation: "regex",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              validation: "regex",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
         }
       }
     }
@@ -434,68 +513,48 @@ export class ZodString extends ZodType<string, ZodStringDef> {
       ...errorUtil.errToObj(message),
     });
 
-  email = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "email", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  url = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "url", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  uuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "uuid", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  cuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
+  _addCheck(check: ZodStringCheck) {
+    return new ZodString({
       ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "cuid", ...errorUtil.errToObj(message) },
-      ],
+      checks: [...this._def.checks, check],
     });
+  }
 
-  regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "regex", regex: regex, ...errorUtil.errToObj(message) },
-      ],
+  email(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
+  }
+  url(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
+  }
+  uuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
+  }
+  cuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
+  }
+  regex(regex: RegExp, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "regex",
+      regex: regex,
+      ...errorUtil.errToObj(message),
     });
+  }
 
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "min", value: minLength, ...errorUtil.errToObj(message) },
-      ],
+  min(minLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "min",
+      value: minLength,
+      ...errorUtil.errToObj(message),
     });
+  }
 
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: "max", value: maxLength, ...errorUtil.errToObj(message) },
-      ],
+  max(maxLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "max",
+      value: maxLength,
+      ...errorUtil.errToObj(message),
     });
+  }
 
   length(len: number, message?: errorUtil.ErrMessage) {
     return this.min(len, message).max(len, message);
@@ -539,10 +598,11 @@ export class ZodString extends ZodType<string, ZodStringDef> {
     });
     return max;
   }
-  static create = (): ZodString => {
+  static create = (params?: RawCreateParams): ZodString => {
     return new ZodString({
       checks: [],
       typeName: ZodFirstPartyTypeKind.ZodString,
+      ...processCreateParams(params),
     });
   };
 }
@@ -557,7 +617,8 @@ export class ZodString extends ZodType<string, ZodStringDef> {
 type ZodNumberCheck =
   | { kind: "min"; value: number; inclusive: boolean; message?: string }
   | { kind: "max"; value: number; inclusive: boolean; message?: string }
-  | { kind: "int"; message?: string };
+  | { kind: "int"; message?: string }
+  | { kind: "multipleOf"; value: number; message?: string };
 
 export interface ZodNumberDef extends ZodTypeDef {
   checks: ZodNumberCheck[];
@@ -571,27 +632,35 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<number> {
     if (parsedType !== ZodParsedType.number) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
 
-    let invalid = false;
+    const invalid = false;
 
     for (const check of this._def.checks) {
       if (check.kind === "int") {
         if (!util.isInteger(data)) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.invalid_type,
-            expected: "integer",
-            received: "float",
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.invalid_type,
+              expected: "integer",
+              received: "float",
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "min") {
         // const MIN = check.value;
@@ -599,63 +668,92 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
           ? data < check.value
           : data <= check.value;
         if (tooSmall) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: "number",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: "number",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
         }
       } else if (check.kind === "max") {
         const tooBig = check.inclusive
           ? data > check.value
           : data >= check.value;
         if (tooBig) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: "number",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: "number",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
+        }
+      } else if (check.kind === "multipleOf") {
+        if (data % check.value !== 0) {
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.not_multiple_of,
+              multipleOf: check.value,
+              message: check.message,
+            },
+            { data }
+          );
         }
+      } else {
+        util.assertNever(check);
       }
     }
 
     return invalid ? INVALID : OK(data);
   }
 
-  static create = (): ZodNumber => {
+  static create = (params?: RawCreateParams): ZodNumber => {
     return new ZodNumber({
       checks: [],
       typeName: ZodFirstPartyTypeKind.ZodNumber,
+      ...processCreateParams(params),
+      ...processCreateParams(params),
     });
   };
 
-  gte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit("min", value, true, errorUtil.toString(message));
+  gte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit("min", value, true, errorUtil.toString(message));
+  }
   min = this.gte;
 
-  gt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit("min", value, false, errorUtil.toString(message));
+  gt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit("min", value, false, errorUtil.toString(message));
+  }
 
-  lte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit("max", value, true, errorUtil.toString(message));
+  lte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit("max", value, true, errorUtil.toString(message));
+  }
   max = this.lte;
 
-  lt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit("max", value, false, errorUtil.toString(message));
+  lt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit("max", value, false, errorUtil.toString(message));
+  }
 
-  protected setLimit = (
+  protected setLimit(
     kind: "min" | "max",
     value: number,
     inclusive: boolean,
     message?: string
-  ) =>
-    new ZodNumber({
+  ) {
+    return new ZodNumber({
       ...this._def,
       checks: [
         ...this._def.checks,
@@ -667,74 +765,67 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
         },
       ],
     });
+  }
 
-  int = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
+  _addCheck(check: ZodNumberCheck) {
+    return new ZodNumber({
       ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: "int",
-          message: errorUtil.toString(message),
-        },
-      ],
+      checks: [...this._def.checks, check],
     });
+  }
 
-  positive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: "min",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
+  int(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "int",
+      message: errorUtil.toString(message),
     });
+  }
 
-  negative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: "max",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
+  positive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "min",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
     });
+  }
 
-  nonpositive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: "max",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
+  negative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "max",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
     });
+  }
 
-  nonnegative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: "min",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
+  nonpositive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "max",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  nonnegative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "min",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
     });
+  }
+
+  multipleOf(value: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: "multipleOf",
+      value: value,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  step = this.multipleOf;
 
   get minValue() {
     let min: number | null = null;
@@ -780,19 +871,26 @@ export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<bigint> {
     if (parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.bigint,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     return OK(data);
   }
 
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
+  static create = (params?: RawCreateParams): ZodBigInt => {
+    return new ZodBigInt({
+      typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -814,19 +912,26 @@ export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<boolean> {
     if (parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.boolean,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     return OK(data);
   }
 
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
+  static create = (params?: RawCreateParams): ZodBoolean => {
+    return new ZodBoolean({
+      typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -848,18 +953,26 @@ export class ZodDate extends ZodType<Date, ZodDateDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<Date> {
     if (parsedType !== ZodParsedType.date) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.date,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     if (isNaN(data.getTime())) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_date,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_date,
+        },
+        { data }
+      );
 
       return INVALID;
     }
@@ -867,8 +980,11 @@ export class ZodDate extends ZodType<Date, ZodDateDef> {
     return OK(new Date((data as Date).getTime()));
   }
 
-  static create = (): ZodDate => {
-    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
+  static create = (params?: RawCreateParams): ZodDate => {
+    return new ZodDate({
+      typeName: ZodFirstPartyTypeKind.ZodDate,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -890,19 +1006,27 @@ export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<undefined> {
     if (parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.undefined,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     return OK(data);
   }
+  params?: RawCreateParams;
 
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
+  static create = (params?: RawCreateParams): ZodUndefined => {
+    return new ZodUndefined({
+      typeName: ZodFirstPartyTypeKind.ZodUndefined,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -924,18 +1048,25 @@ export class ZodNull extends ZodType<null, ZodNullDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<null> {
     if (parsedType !== ZodParsedType.null) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.null,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     return OK(data);
   }
-  static create = (): ZodNull => {
-    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
+  static create = (params?: RawCreateParams): ZodNull => {
+    return new ZodNull({
+      typeName: ZodFirstPartyTypeKind.ZodNull,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -960,8 +1091,11 @@ export class ZodAny extends ZodType<any, ZodAnyDef> {
   ): ParseReturnType<any> {
     return OK(data);
   }
-  static create = (): ZodAny => {
-    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
+  static create = (params?: RawCreateParams): ZodAny => {
+    return new ZodAny({
+      typeName: ZodFirstPartyTypeKind.ZodAny,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -987,8 +1121,11 @@ export class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
     return OK(data);
   }
 
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
+  static create = (params?: RawCreateParams): ZodUnknown => {
+    return new ZodUnknown({
+      typeName: ZodFirstPartyTypeKind.ZodUnknown,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -1009,15 +1146,22 @@ export class ZodNever extends ZodType<never, ZodNeverDef> {
     data: any,
     parsedType: ZodParsedType
   ): ParseReturnType<never> {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.never,
-      received: parsedType,
-    });
+    this._addIssue(
+      ctx,
+      {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      },
+      { data }
+    );
     return INVALID;
   }
-  static create = (): ZodNever => {
-    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
+  static create = (params?: RawCreateParams): ZodNever => {
+    return new ZodNever({
+      typeName: ZodFirstPartyTypeKind.ZodNever,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -1039,19 +1183,26 @@ export class ZodVoid extends ZodType<void, ZodVoidDef> {
     parsedType: ZodParsedType
   ): ParseReturnType<void> {
     if (parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.void,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
     return OK(data);
   }
 
-  static create = (): ZodVoid => {
-    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  static create = (params?: RawCreateParams): ZodVoid => {
+    return new ZodVoid({
+      typeName: ZodFirstPartyTypeKind.ZodVoid,
+      ...processCreateParams(params),
+    });
   };
 }
 
@@ -1070,140 +1221,145 @@ export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny>
   maxLength: { value: number; message?: string } | null;
 }
 
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
+export type ArrayCardinality = "many" | "atleastone";
+type arrayOutputType<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = "many"
+> = Cardinality extends "atleastone"
+  ? [T["_output"], ...T["_output"][]]
+  : T["_output"][];
 
-    return INVALID;
-  }
+export class ZodArray<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = "many"
+> extends ZodType<
+  arrayOutputType<T, Cardinality>,
+  ZodArrayDef<T>,
+  Cardinality extends "atleastone"
+    ? [T["_input"], ...T["_input"][]]
+    : T["_input"][]
+> {
+  _parse(
+    ctx: ParseContext,
+    _data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
 
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: "array",
-        inclusive: true,
-        message: def.minLength.message,
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
       });
-    }
-  }
 
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: "array",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
+      return INVALID;
     }
-  }
 
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
+    const data: any[] = _data;
 
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        // invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_small,
+            minimum: def.minLength.value,
+            type: "array",
+            inclusive: true,
+            message: def.minLength.message,
+          },
+          { data }
+        );
+      }
+    }
 
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        // invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_big,
+            maximum: def.maxLength.value,
+            type: "array",
+            inclusive: true,
+            message: def.maxLength.message,
+          },
+          { data }
+        );
+      }
+    }
 
-export type ArrayCardinality = "many" | "atleastone";
-type arrayOutputType<
-  T extends ZodTypeAny,
-  Cardinality extends ArrayCardinality = "many"
-> = Cardinality extends "atleastone"
-  ? [T["_output"], ...T["_output"][]]
-  : T["_output"][];
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
 
-export class ZodArray<
-  T extends ZodTypeAny,
-  Cardinality extends ArrayCardinality = "many"
-> extends ZodType<
-  arrayOutputType<T, Cardinality>,
-  ZodArrayDef<T>,
-  Cardinality extends "atleastone"
-    ? [T["_input"], ...T["_input"][]]
-    : T["_input"][]
-> {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
   }
 
   get element() {
     return this._def.type;
   }
 
-  min = (minLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  min(minLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
       ...this._def,
       minLength: { value: minLength, message: errorUtil.toString(message) },
     }) as any;
+  }
 
-  max = (maxLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  max(maxLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
       ...this._def,
       maxLength: { value: maxLength, message: errorUtil.toString(message) },
     }) as any;
+  }
 
-  length = (len: number, message?: errorUtil.ErrMessage): this =>
-    this.min(len, message).max(len, message) as any;
+  length(len: number, message?: errorUtil.ErrMessage): this {
+    return this.min(len, message).max(len, message) as any;
+  }
 
-  nonempty: (message?: errorUtil.ErrMessage) => ZodArray<T, "atleastone"> = (
-    message?: any
-  ) => {
+  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone"> {
     return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:"atleastone" });
-  };
+  }
 
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodArray<T> => {
     return new ZodArray({
       type: schema,
       minLength: null,
       maxLength: null,
       typeName: ZodFirstPartyTypeKind.ZodArray,
+      ...processCreateParams(params),
     });
   };
 }
@@ -1445,11 +1601,15 @@ export class ZodObject<
     parsedType: ZodParsedType
   ): ParseReturnType<Output> {
     if (parsedType !== ZodParsedType.object) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
@@ -1457,7 +1617,7 @@ export class ZodObject<
     const { shape, keys: shapeKeys } = this._getCached();
 
     let invalid = false;
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
     const resultObject: Record<string, any> = {};
 
     const handleParsed = (
@@ -1475,9 +1635,7 @@ export class ZodObject<
       } else if (isInvalid(parsedValue)) {
         invalid = true;
       } else {
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
       }
     };
 
@@ -1503,11 +1661,15 @@ export class ZodObject<
         const dataKeys = util.objectKeys(data);
         const extraKeys = dataKeys.filter((k) => !(k in shape));
         if (extraKeys.length > 0) {
-          invalid = true;
-          ctx.addIssue(data, {
-            code: ZodIssueCode.unrecognized_keys,
-            keys: extraKeys,
-          });
+          // invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            },
+            { data }
+          );
         }
       } else if (unknownKeys === "strip") {
       } else {
@@ -1526,12 +1688,9 @@ export class ZodObject<
         );
       }
     }
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
       );
     } else {
       return invalid ? INVALID : OK(resultObject as Output);
@@ -1542,23 +1701,26 @@ export class ZodObject<
     return this._def.shape();
   }
 
-  strict = (): ZodObject<T, "strict", Catchall> =>
-    new ZodObject({
+  strict(): ZodObject<T, "strict", Catchall> {
+    return new ZodObject({
       ...this._def,
       unknownKeys: "strict",
     }) as any;
+  }
 
-  strip = (): ZodObject<T, "strip", Catchall> =>
-    new ZodObject({
+  strip(): ZodObject<T, "strip", Catchall> {
+    return new ZodObject({
       ...this._def,
       unknownKeys: "strip",
     }) as any;
+  }
 
-  passthrough = (): ZodObject<T, "passthrough", Catchall> =>
-    new ZodObject({
+  passthrough(): ZodObject<T, "passthrough", Catchall> {
+    return new ZodObject({
       ...this._def,
       unknownKeys: "passthrough",
     }) as any;
+  }
 
   /**
    * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
@@ -1569,24 +1731,22 @@ export class ZodObject<
   augment = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
   extend = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
 
-  setKey = <Key extends string, Schema extends ZodTypeAny>(
+  setKey<Key extends string, Schema extends ZodTypeAny>(
     key: Key,
     schema: Schema
-  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> => {
+  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {
     return this.augment({ [key]: schema }) as any;
-  };
+  }
 
   /**
    * Prior to zod@1.0.12 there was a bug in the
    * inferred type of merged objects. Please
    * upgrade if you are experiencing issues.
    */
-  merge: <Incoming extends AnyZodObject>(
+  merge<Incoming extends AnyZodObject>(
     merging: Incoming
-  ) => //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
-  ZodObject<extendShape<T, Incoming["_shape"]>, UnknownKeys, Catchall> = (
-    merging
-  ) => {
+  ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
+  ZodObject<extendShape<T, Incoming["_shape"]>, UnknownKeys, Catchall> {
     const mergedShape = objectUtil.mergeShapes(
       this._def.shape(),
       merging._def.shape()
@@ -1599,24 +1759,24 @@ export class ZodObject<
       typeName: ZodFirstPartyTypeKind.ZodObject,
     }) as any;
     return merged;
-  };
+  }
 
-  catchall = <Index extends ZodTypeAny>(
+  catchall<Index extends ZodTypeAny>(
     index: Index
-  ): ZodObject<T, UnknownKeys, Index> => {
+  ): ZodObject<T, UnknownKeys, Index> {
     return new ZodObject({
       ...this._def,
       catchall: index,
     }) as any;
-  };
+  }
 
-  pick = <Mask extends { [k in keyof T]?: true }>(
+  pick<Mask extends { [k in keyof T]?: true }>(
     mask: Mask
   ): ZodObject<
     objectUtil.noNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
     UnknownKeys,
     Catchall
-  > => {
+  > {
     const shape: any = {};
     util.objectKeys(mask).map((key) => {
       shape[key] = this.shape[key];
@@ -1625,15 +1785,15 @@ export class ZodObject<
       ...this._def,
       shape: () => shape,
     }) as any;
-  };
+  }
 
-  omit = <Mask extends { [k in keyof T]?: true }>(
+  omit<Mask extends { [k in keyof T]?: true }>(
     mask: Mask
   ): ZodObject<
     objectUtil.noNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
     UnknownKeys,
     Catchall
-  > => {
+  > {
     const shape: any = {};
     util.objectKeys(this.shape).map((key) => {
       if (util.objectKeys(mask).indexOf(key) === -1) {
@@ -1644,35 +1804,61 @@ export class ZodObject<
       ...this._def,
       shape: () => shape,
     }) as any;
-  };
+  }
+
+  deepPartial(): partialUtil.DeepPartial<this> {
+    return deepPartialify(this) as any;
+  }
 
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k]["optional"]> },
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
+    UnknownKeys,
+    Catchall
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
     UnknownKeys,
     Catchall
-  > => {
+  >;
+  partial(mask?: any) {
     const newShape: any = {};
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
     }
+
     return new ZodObject({
       ...this._def,
       shape: () => newShape,
     }) as any;
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
 
-  required = (): ZodObject<
+  required(): ZodObject<
     { [k in keyof T]: deoptional<T[k]> },
     UnknownKeys,
     Catchall
-  > => {
+  > {
     const newShape: any = {};
     for (const key in this.shape) {
       const fieldSchema = this.shape[key];
@@ -1687,34 +1873,44 @@ export class ZodObject<
       ...this._def,
       shape: () => newShape,
     }) as any;
-  };
+  }
 
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+  static create = <T extends ZodRawShape>(
+    shape: T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
     return new ZodObject({
       shape: () => shape,
       unknownKeys: "strip",
       catchall: ZodNever.create(),
       typeName: ZodFirstPartyTypeKind.ZodObject,
+      ...processCreateParams(params),
     }) as any;
   };
 
   static strictCreate = <T extends ZodRawShape>(
-    shape: T
+    shape: T,
+    params?: RawCreateParams
   ): ZodObject<T, "strict"> => {
     return new ZodObject({
       shape: () => shape,
       unknownKeys: "strict",
       catchall: ZodNever.create(),
       typeName: ZodFirstPartyTypeKind.ZodObject,
+      ...processCreateParams(params),
     }) as any;
   };
 
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends ZodRawShape>(
+    shape: () => T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
     return new ZodObject({
       shape,
       unknownKeys: "strip",
       catchall: ZodNever.create(),
       typeName: ZodFirstPartyTypeKind.ZodObject,
+      ...processCreateParams(params),
     }) as any;
   };
 }
@@ -1768,19 +1964,23 @@ export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
         // TODO encapsulate
         nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
       } else {
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_union,
-          unionErrors,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_union,
+            unionErrors,
+          },
+          { data }
+        );
       }
       return INVALID;
     };
 
-    if (ctx.params.async) {
+    if (ctx.async) {
       const contexts = options.map(
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
       );
-      return PseudoPromise.all(
+      return Promise.all(
         options.map((option, index) =>
           option._parse(contexts[index], data, parsedType)
         )
@@ -1795,7 +1995,7 @@ export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
     } else {
       const allIssues: ZodIssue[][] = [];
       for (const option of options) {
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
         const parsedOption = option._parseSync(optionCtx, data, parsedType);
         if (isInvalid(parsedOption)) {
           allIssues.push(optionCtx.issues);
@@ -1812,11 +2012,13 @@ export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
   }
 
   static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
-    types: T
+    types: T,
+    params?: RawCreateParams
   ): ZodUnion<T> => {
     return new ZodUnion({
       options: types,
       typeName: ZodFirstPartyTypeKind.ZodUnion,
+      ...processCreateParams(params),
     });
   };
 }
@@ -1879,7 +2081,7 @@ export class ZodIntersection<
     ctx: ParseContext,
     data: any,
     parsedType: ZodParsedType
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T["_output"] & U["_output"]> {
     const handleParsed = (
       parsedLeft: SyncParseReturnType<T>,
       parsedRight: SyncParseReturnType<U>
@@ -1890,16 +2092,20 @@ export class ZodIntersection<
 
       const merged = mergeValues(parsedLeft.value, parsedRight.value);
       if (!merged.valid) {
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_intersection_types,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_intersection_types,
+          },
+          { data }
+        );
         return INVALID;
       }
       return OK(merged.data);
     };
 
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
         this._def.left._parse(ctx, data, parsedType),
         this._def.right._parse(ctx, data, parsedType),
       ]).then(([left, right]: any) => handleParsed(left, right));
@@ -1913,12 +2119,14 @@ export class ZodIntersection<
 
   static create = <T extends ZodTypeAny, U extends ZodTypeAny>(
     left: T,
-    right: U
+    right: U,
+    params?: RawCreateParams
   ): ZodIntersection<T, U> => {
     return new ZodIntersection({
       left: left,
       right: right,
       typeName: ZodFirstPartyTypeKind.ZodIntersection,
+      ...processCreateParams(params),
     });
   };
 }
@@ -1931,58 +2139,100 @@ export class ZodIntersection<
 ////////////////////////////////////////
 ////////////////////////////////////////
 export type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
-};
-
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
-};
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
+  }
+>;
+export type OutputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...OutputTypeOfTuple<T>, ...Rest["_output"][]]
+  : OutputTypeOfTuple<T>;
 
-export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
-  extends ZodTypeDef {
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
+  }
+>;
+export type InputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...InputTypeOfTuple<T>, ...Rest["_input"][]]
+  : InputTypeOfTuple<T>;
+
+export interface ZodTupleDef<
+  T extends ZodTupleItems | [] = ZodTupleItems,
+  Rest extends ZodTypeAny | null = null
+> extends ZodTypeDef {
   items: T;
+  rest: Rest;
   typeName: ZodFirstPartyTypeKind.ZodTuple;
 }
 
 export class ZodTuple<
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
+  Rest extends ZodTypeAny | null = null
+> extends ZodType<
+  OutputTypeOfTupleWithRest<T, Rest>,
+  ZodTupleDef<T, Rest>,
+  InputTypeOfTupleWithRest<T, Rest>
+> {
   _parse(
     ctx: ParseContext,
     data: any,
     parsedType: ZodParsedType
   ): ParseReturnType<any> {
     if (parsedType !== ZodParsedType.array) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data }
+      );
       return INVALID;
     }
 
-    if (data.length > this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: this._def.items.length,
-        inclusive: true,
-        type: "array",
-      });
+    const rest = this._def.rest;
+
+    if (!rest && data.length > this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_big,
+          maximum: this._def.items.length,
+          inclusive: true,
+          type: "array",
+        },
+        { data }
+      );
       return INVALID;
-    } else if (data.length < this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: this._def.items.length,
-        inclusive: true,
-        type: "array",
-      });
+    }
+
+    if (data.length < this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_small,
+          minimum: this._def.items.length,
+          inclusive: true,
+          type: "array",
+        },
+        { data }
+      );
       return INVALID;
     }
 
-    const tasks = createTasks(ctx);
-    const items = this._def.items as ZodType<any>[];
-    const parseResult: any[] = new Array(items.length);
+    const tasks: Promise<unknown>[] = [];
+    const items = this._def.items as ZodType<any, any, any>[];
+
+    const parseResult: any[] = new Array(data.length);
     let invalid = false;
 
     const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
@@ -1991,9 +2241,7 @@ export class ZodTuple<
       } else if (isInvalid(parsedItem)) {
         invalid = true;
       } else {
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
       }
     };
 
@@ -2008,9 +2256,20 @@ export class ZodTuple<
       );
     });
 
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (rest) {
+      const restData: any[] = data.slice(items.length);
+      restData.forEach((dataItem, _index) => {
+        const index = _index + items.length;
+        handleParsed(
+          index,
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+        );
+      });
+    }
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
       );
     } else {
       return invalid ? INVALID : OK(parseResult);
@@ -2021,12 +2280,22 @@ export class ZodTuple<
     return this._def.items;
   }
 
+  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
+    return new ZodTuple({
+      ...this._def,
+      rest,
+    });
+  }
+
   static create = <T extends [ZodTypeAny, ...ZodTypeAny[]] | []>(
-    schemas: T
-  ): ZodTuple<T> => {
+    schemas: T,
+    params?: RawCreateParams
+  ): ZodTuple<T, null> => {
     return new ZodTuple({
       items: schemas,
       typeName: ZodFirstPartyTypeKind.ZodTuple,
+      rest: null,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2038,74 +2307,116 @@ export class ZodTuple<
 //////////                     //////////
 /////////////////////////////////////////
 /////////////////////////////////////////
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
   valueType: Value;
+  keyType: Key;
   typeName: ZodFirstPartyTypeKind.ZodRecord;
 }
 
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value["_output"]>,
-  ZodRecordDef<Value>,
-  Record<string, Value["_input"]>
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Record<Key["_output"], Value["_output"]>,
+  ZodRecordDef<Key, Value>,
+  Record<Key["_input"], Value["_input"]>
 > {
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
   _parse(
     ctx: ParseContext,
     data: any,
     parsedType: ZodParsedType
-  ): ParseReturnType<Record<string, any>> {
+  ): ParseReturnType<Record<any, any>> {
     if (parsedType !== ZodParsedType.object) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
       return INVALID;
     }
 
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
+    const keyType = this._def.keyType;
     const valueType = this._def.valueType;
     const parseResult: Record<string, ParseReturnType<any>> = {};
     let invalid = false;
     const handleParsed = (
-      key: string,
-      parsedKey: ParseReturnType<any>
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
     ): void => {
-      if (isOk(parsedKey)) {
-        parseResult[key] = parsedKey.value;
-      } else if (isInvalid(parsedKey)) {
-        invalid = true;
-      } else {
-        tasks?.push(
-          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+      if (isOk(parsedKey) && isOk(parsedValue)) {
+        parseResult[parsedKey.value] = parsedValue.value;
+      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+            handleParsed(k, v)
+          )
         );
+      } else {
+        invalid = true;
       }
     };
 
     for (const key in data) {
       handleParsed(
-        key,
+        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
         valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
       );
     }
 
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
       );
     } else {
       return invalid ? INVALID : OK(parseResult);
     }
   }
 
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
+  get element() {
+    return this._def.valueType;
+  }
+
+  static create<Value extends ZodTypeAny>(
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<ZodString, Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
+    keySchema: Keys,
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<Keys, Value>;
+  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
+    if (second instanceof ZodType) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+        ...processCreateParams(third),
+      });
+    }
+
     return new ZodRecord({
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
       typeName: ZodFirstPartyTypeKind.ZodRecord,
+      ...processCreateParams(second),
     });
-  };
+  }
 }
 
 //////////////////////////////////////
@@ -2138,11 +2449,15 @@ export class ZodMap<
     parsedType: ZodParsedType
   ): ParseReturnType<Map<any, any>> {
     if (parsedType !== ZodParsedType.map) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.map,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
@@ -2151,15 +2466,15 @@ export class ZodMap<
     const valueType = this._def.valueType;
     const dataMap: Map<unknown, unknown> = data;
     const parseResult = new Map();
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
     let invalid = false;
     const handleParsed = (
       parsedKey: ParseReturnType<any>,
       parsedValue: ParseReturnType<any>
     ): void => {
       if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
             handleParsed(k, v)
           )
         );
@@ -2185,9 +2500,9 @@ export class ZodMap<
       handleParsed(parsedKey, parsedValue);
     });
 
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
       );
     } else {
       return invalid ? INVALID : OK(parseResult);
@@ -2198,12 +2513,14 @@ export class ZodMap<
     Value extends ZodTypeAny = ZodTypeAny
   >(
     keyType: Key,
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
   ): ZodMap<Key, Value> => {
     return new ZodMap({
       valueType,
       keyType,
       typeName: ZodFirstPartyTypeKind.ZodMap,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2232,11 +2549,15 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
     parsedType: ZodParsedType
   ): ParseReturnType<Set<any>> {
     if (parsedType !== ZodParsedType.set) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.set,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
@@ -2244,7 +2565,7 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
     const dataSet: Set<unknown> = data;
     const valueType = this._def.valueType;
     const parsedSet = new Set();
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
     let invalid = false;
 
     const handleParsed = (parsedItem: ParseReturnType<any>): void => {
@@ -2253,7 +2574,7 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
       } else if (isInvalid(parsedItem)) {
         invalid = true;
       } else {
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
       }
     };
 
@@ -2261,21 +2582,21 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
       handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
     );
 
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
     } else {
       return invalid ? INVALID : OK(parsedSet);
     }
   }
 
   static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
   ): ZodSet<Value> => {
     return new ZodSet({
       valueType,
       typeName: ZodFirstPartyTypeKind.ZodSet,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2288,7 +2609,7 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
 ///////////////////////////////////////////
 ///////////////////////////////////////////
 export interface ZodFunctionDef<
-  Args extends ZodTuple<any> = ZodTuple<any>,
+  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
   Returns extends ZodTypeAny = ZodTypeAny
 > extends ZodTypeDef {
   args: Args;
@@ -2297,21 +2618,21 @@ export interface ZodFunctionDef<
 }
 
 export type OuterTypeOfFunction<
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
   Returns extends ZodTypeAny
 > = Args["_input"] extends Array<any>
   ? (...args: Args["_input"]) => Returns["_output"]
   : never;
 
 export type InnerTypeOfFunction<
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
   Returns extends ZodTypeAny
 > = Args["_output"] extends Array<any>
   ? (...args: Args["_output"]) => Returns["_input"]
   : never;
 
 export class ZodFunction<
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
   Returns extends ZodTypeAny
 > extends ZodType<
   OuterTypeOfFunction<Args, Returns>,
@@ -2324,30 +2645,44 @@ export class ZodFunction<
     parsedType: ZodParsedType
   ): ParseReturnType<any> {
     if (parsedType !== ZodParsedType.function) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.function,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
 
     function makeArgsIssue(args: any, error: ZodError): ZodIssue {
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_arguments,
-        argumentsError: error,
+      return makeIssue({
+        data: args,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_arguments,
+          argumentsError: error,
+        },
       });
     }
 
     function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_return_type,
-        returnTypeError: error,
+      return makeIssue({
+        data: returns,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_return_type,
+          returnTypeError: error,
+        },
       });
     }
 
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
     const fn = data;
 
     if (this._def.returns instanceof ZodPromise) {
@@ -2392,49 +2727,53 @@ export class ZodFunction<
     return this._def.returns;
   }
 
-  args = <Items extends Parameters<typeof ZodTuple["create"]>[0]>(
+  args<Items extends Parameters<typeof ZodTuple["create"]>[0]>(
     ...items: Items
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
+  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {
     return new ZodFunction({
       ...this._def,
-      args: ZodTuple.create(items),
+      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
     });
-  };
+  }
 
-  returns = <NewReturnType extends ZodType<any, any>>(
+  returns<NewReturnType extends ZodType<any, any>>(
     returnType: NewReturnType
-  ): ZodFunction<Args, NewReturnType> => {
+  ): ZodFunction<Args, NewReturnType> {
     return new ZodFunction({
       ...this._def,
       returns: returnType,
     });
-  };
+  }
 
-  implement = <F extends InnerTypeOfFunction<Args, Returns>>(func: F): F => {
+  implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): F {
     const validatedFunc = this.parse(func);
     return validatedFunc as any;
-  };
+  }
 
-  strictImplement = (
+  strictImplement(
     func: InnerTypeOfFunction<Args, Returns>
-  ): InnerTypeOfFunction<Args, Returns> => {
+  ): InnerTypeOfFunction<Args, Returns> {
     const validatedFunc = this.parse(func);
     return validatedFunc as any;
-  };
+  }
 
   validate = this.implement;
 
   static create = <
-    T extends ZodTuple<any> = ZodTuple<[]>,
+    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
     U extends ZodTypeAny = ZodUnknown
   >(
     args?: T,
-    returns?: U
+    returns?: U,
+    params?: RawCreateParams
   ): ZodFunction<T, U> => {
     return new ZodFunction({
-      args: args || ZodTuple.create([]),
+      args: (args
+        ? args.rest(ZodUnknown.create())
+        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
       returns: returns || ZodUnknown.create(),
       typeName: ZodFirstPartyTypeKind.ZodFunction,
+      ...processCreateParams(params),
     }) as any;
   };
 }
@@ -2470,10 +2809,14 @@ export class ZodLazy<T extends ZodTypeAny> extends ZodType<
     return lazySchema._parse(ctx, data, parsedType);
   }
 
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+  static create = <T extends ZodTypeAny>(
+    getter: () => T,
+    params?: RawCreateParams
+  ): ZodLazy<T> => {
     return new ZodLazy({
       getter: getter,
       typeName: ZodFirstPartyTypeKind.ZodLazy,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2497,11 +2840,15 @@ export class ZodLiteral<T extends any> extends ZodType<T, ZodLiteralDef<T>> {
     _parsedType: ZodParsedType
   ): ParseReturnType<T> {
     if (data !== this._def.value) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: this._def.value as any,
-        received: data,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: this._def.value as any,
+          received: data,
+        },
+        { data }
+      );
       return INVALID;
     }
     return OK(data);
@@ -2511,10 +2858,14 @@ export class ZodLiteral<T extends any> extends ZodType<T, ZodLiteralDef<T>> {
     return this._def.value;
   }
 
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends Primitive>(
+    value: T,
+    params?: RawCreateParams
+  ): ZodLiteral<T> => {
     return new ZodLiteral({
       value: value,
       typeName: ZodFirstPartyTypeKind.ZodLiteral,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2566,10 +2917,14 @@ export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
     _parsedType: ZodParsedType
   ): ParseReturnType<T[number]> {
     if (this._def.values.indexOf(data) === -1) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: this._def.values,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: this._def.values,
+        },
+        { data }
+      );
       return INVALID;
     }
     return OK(data);
@@ -2632,18 +2987,26 @@ export class ZodNativeEnum<T extends EnumLike> extends ZodType<
   ): ParseReturnType<T[keyof T]> {
     const nativeEnumValues = util.getValidEnumValues(this._def.values);
     if (nativeEnumValues.indexOf(data) === -1) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: util.objectValues(nativeEnumValues),
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        },
+        { data }
+      );
       return INVALID;
     }
     return OK(data);
   }
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+  static create = <T extends EnumLike>(
+    values: T,
+    params?: RawCreateParams
+  ): ZodNativeEnum<T> => {
     return new ZodNativeEnum({
       values: values,
       typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2671,12 +3034,16 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
     data: any,
     parsedType: ZodParsedType
   ): ParseReturnType<Promise<T["_output"]>> {
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.promise,
-        received: parsedType,
-      });
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        },
+        { data }
+      );
 
       return INVALID;
     }
@@ -2688,16 +3055,20 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
       promisified.then((data: any) => {
         return this._def.type.parseAsync(data, {
           path: pathToArray(ctx.path),
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
         });
       })
     );
   }
 
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodPromise<T> => {
     return new ZodPromise({
       type: schema,
       typeName: ZodFirstPartyTypeKind.ZodPromise,
+      ...processCreateParams(params),
     });
   };
 }
@@ -2709,34 +3080,39 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
 //////////                          //////////
 //////////////////////////////////////////////
 //////////////////////////////////////////////
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T["_output"]>;
 
 export type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
 export type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
   type: "refinement";
   refinement: (arg: T, ctx: RefinementCtx) => any;
 };
-export type Mod<T> = {
+export type TransformEffect<T> = {
   type: "transform";
   transform: (arg: T) => any;
 };
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: "preprocess";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
 
 export interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny>
   extends ZodTypeDef {
   schema: T;
   typeName: ZodFirstPartyTypeKind.ZodEffects;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
 }
 
 export class ZodEffects<
   T extends ZodTypeAny,
-  Output = T["_type"]
-> extends ZodType<Output, ZodEffectsDef<T>, T["_input"]> {
+  Output = T["_output"],
+  Input = T["_input"]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
   innerType() {
     return this._def.schema;
   }
@@ -2746,137 +3122,135 @@ export class ZodEffects<
     initialData: any,
     initialParsedType: ZodParsedType
   ): ParseReturnType<Output> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
 
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
+    if (effect.type === "preprocess") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            "Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead."
+          );
+        return result;
+      }
+    }
 
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+    if (effect.type === "refinement") {
+      const invalid = false;
 
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case "refinement":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                "You can't use .parse() on a schema containing async refinements. Use .parseAsync instead."
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case "transform":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
             throw new Error(
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
             );
           }
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const _addIssue = (arg: IssueData) => {
+        // don't abort early on refinement issues
+        // invalid = true;
+        this._addIssue(ctx, arg, { data });
+      };
+      const checkCtx: RefinementCtx = {
+        addIssue: _addIssue,
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
 
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
         return invalid ? INVALID : OK(result);
       } else {
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
       }
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === "transform") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
           );
-        } else {
-          return invalid ? INVALID : OK(result);
         }
+        return transformed;
       };
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
       } else {
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
             if (isInvalid(base)) return INVALID;
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
           })
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
       }
     }
-  }
 
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested.");
-    // }
+    util.assertNever(effect);
   }
 
   static create = <I extends ZodTypeAny>(
-    schema: I
+    schema: I,
+    effect: Effect<I["_output"]>,
+    params?: RawCreateParams
   ): ZodEffects<I, I["_output"]> => {
-    const newTx = new ZodEffects({
+    return new ZodEffects({
       schema,
       typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect,
+      ...processCreateParams(params),
     });
-
-    return newTx;
   };
 
   static createWithPreprocess = <I extends ZodTypeAny>(
     preprocess: (arg: unknown) => unknown,
-    schema: I
+    schema: I,
+    params?: RawCreateParams
   ): ZodEffects<I, I["_output"]> => {
-    const newTx = new ZodEffects({
+    return new ZodEffects({
       schema,
-      preprocess: { type: "transform", transform: preprocess },
+      effect: { type: "preprocess", transform: preprocess },
       typeName: ZodFirstPartyTypeKind.ZodEffects,
+      ...processCreateParams(params),
     });
-
-    return newTx;
   };
 }
 
@@ -2917,10 +3291,14 @@ export class ZodOptional<T extends ZodTypeAny> extends ZodType<
     return this._def.innerType;
   }
 
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
     return new ZodOptional({
       innerType: type,
       typeName: ZodFirstPartyTypeKind.ZodOptional,
+      ...processCreateParams(params),
     }) as any;
   };
 }
@@ -2960,10 +3338,14 @@ export class ZodNullable<T extends ZodTypeAny> extends ZodType<
     return this._def.innerType;
   }
 
-  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodNullable<T> => {
     return new ZodNullable({
       innerType: type,
       typeName: ZodFirstPartyTypeKind.ZodNullable,
+      ...processCreateParams(params),
     }) as any;
   };
 }
@@ -3002,10 +3384,14 @@ export class ZodDefault<T extends ZodTypeAny> extends ZodType<
     return this._def.innerType;
   }
 
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
     return new ZodOptional({
       innerType: type,
       typeName: ZodFirstPartyTypeKind.ZodOptional,
+      ...processCreateParams(params),
     }) as any;
   };
 }
diff --git a/yarn.lock b/yarn.lock
index 377289db7..779abe251 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -5392,10 +5392,10 @@ typedarray-to-buffer@^3.1.5:
   dependencies:
     is-typedarray "^1.0.0"
 
-typescript@^4.3.2:
-  version "4.3.2"
-  resolved "https://registry.yarnpkg.com/typescript/-/typescript-4.3.2.tgz#399ab18aac45802d6f2498de5054fcbbe716a805"
-  integrity sha512-zZ4hShnmnoVnAHpVHWpTcxdv7dWP60S2FsydQLV8V5PbS3FifjWFFRiHSWpDJahly88PRyV5teTSLoq4eG7mKw==
+typescript@4.3:
+  version "4.3.5"
+  resolved "https://registry.yarnpkg.com/typescript/-/typescript-4.3.5.tgz#4d1c37cc16e893973c45a06886b7113234f119f4"
+  integrity sha512-DqQgihaQ9cUrskJo9kIyW/+g0Vxsk8cDtZ52a3NGh0YNTfpUSArXSohyUGnvbPazEPLu398C0UxmKSOrPumUzA==
 
 uglify-js@^3.1.4:
   version "3.12.1"
