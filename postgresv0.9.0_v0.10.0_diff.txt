diff --git a/README.md b/README.md
index 6a3fb27a..96de480f 100644
--- a/README.md
+++ b/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 [![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)](https://deno-postgres.com)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.9.0/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.10.0/mod.ts)
 [![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)](LICENSE)
 
 A lightweight PostgreSQL driver for Deno focused on user experience
diff --git a/client.ts b/client.ts
index 325d1274..81134ddd 100644
--- a/client.ts
+++ b/client.ts
@@ -15,9 +15,14 @@ import {
   ResultType,
   templateStringToQuery,
 } from "./query/query.ts";
+import { Transaction, TransactionOptions } from "./query/transaction.ts";
 import { isTemplateString } from "./utils.ts";
 
 export class QueryClient {
+  get current_transaction(): string | null {
+    return null;
+  }
+
   /**
    * This function is meant to be replaced when being extended
    * 
@@ -44,7 +49,10 @@ export class QueryClient {
    * const {rows} = await my_client.queryArray(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<unknown[]>
+   * ```
    * 
+   * You can pass type arguments to the query in order to hint TypeScript what the return value will be
+   * ```ts
    * const {rows} = await my_client.queryArray<[number, string]>(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<[number, string]>
@@ -74,6 +82,12 @@ export class QueryClient {
     query_template_or_config: TemplateStringsArray | string | QueryConfig,
     ...args: QueryArguments
   ): Promise<QueryArrayResult<T>> {
+    if (this.current_transaction !== null) {
+      throw new Error(
+        `This connection is currently locked by the "${this.current_transaction}" transaction`,
+      );
+    }
+
     let query: Query<ResultType.ARRAY>;
     if (typeof query_template_or_config === "string") {
       query = new Query(query_template_or_config, ResultType.ARRAY, ...args);
@@ -151,6 +165,12 @@ export class QueryClient {
       | TemplateStringsArray,
     ...args: QueryArguments
   ): Promise<QueryObjectResult<T>> {
+    if (this.current_transaction !== null) {
+      throw new Error(
+        `This connection is currently locked by the "${this.current_transaction}" transaction`,
+      );
+    }
+
     let query: Query<ResultType.OBJECT>;
     if (typeof query_template_or_config === "string") {
       query = new Query(query_template_or_config, ResultType.OBJECT, ...args);
@@ -172,45 +192,251 @@ export class QueryClient {
 }
 
 export class Client extends QueryClient {
-  protected _connection: Connection;
+  #connection: Connection;
+  #current_transaction: string | null = null;
 
   constructor(config?: ConnectionOptions | ConnectionString) {
     super();
-    this._connection = new Connection(createParams(config));
+    this.#connection = new Connection(createParams(config));
   }
 
   _executeQuery(query: Query<ResultType.ARRAY>): Promise<QueryArrayResult>;
   _executeQuery(query: Query<ResultType.OBJECT>): Promise<QueryObjectResult>;
   _executeQuery(query: Query<ResultType>): Promise<QueryResult> {
-    return this._connection.query(query);
+    return this.#connection.query(query);
   }
 
   async connect(): Promise<void> {
-    await this._connection.startup();
+    await this.#connection.startup();
+  }
+
+  /**
+   * Transactions are a powerful feature that guarantees safe operations by allowing you to control
+   * the outcome of a series of statements and undo, reset, and step back said operations to
+   * your liking
+   * 
+   * In order to create a transaction, use the `createTransaction` method in your client as follows:
+   * 
+   * ```ts
+   * const transaction = client.createTransaction("my_transaction_name");
+   * await transaction.begin();
+   * // All statements between begin and commit will happen inside the transaction
+   * await transaction.commit(); // All changes are saved
+   * ```
+   * 
+   * All statements that fail in query execution will cause the current transaction to abort and release
+   * the client without applying any of the changes that took place inside it
+   * 
+   * ```ts
+   * await transaction.begin();
+   * await transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES ${"some_value"}`;
+   * try {
+   *   await transaction.queryArray`SELECT []`; // Invalid syntax, transaction aborted, changes won't be applied
+   * }catch(e){
+   *   await transaction.commit(); // Will throw, current transaction has already finished
+   * }
+   * ```
+   * 
+   * This however, only happens if the error is of execution in nature, validation errors won't abort
+   * the transaction
+   * 
+   * ```ts
+   * await transaction.begin();
+   * await transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES ${"some_value"}`;
+   * try {
+   *   await transaction.rollback("unexistent_savepoint"); // Validation error
+   * }catch(e){
+   *   await transaction.commit(); // Transaction will end, changes will be saved
+   * }
+   * ```
+   * 
+   * A transaction has many options to ensure modifications made to the database are safe and
+   * have the expected outcome, which is a hard thing to accomplish in a database with many concurrent users,
+   * and it does so by allowing you to set local levels of isolation to the transaction you are about to begin
+   * 
+   * Each transaction can execute with the following levels of isolation:
+   * 
+   * - Read committed: This is the normal behavior of a transaction. External changes to the database
+   *   will be visible inside the transaction once they are committed.
+   * 
+   * - Repeatable read: This isolates the transaction in a way that any external changes to the data we are reading
+   *   won't be visible inside the transaction until it has finished
+   *   ```ts
+   *   const transaction = await client.createTransaction("my_transaction", { isolation_level: "repeatable_read" });
+   *   ```
+   * 
+   * - Serializable: This isolation level prevents the current transaction from making persistent changes
+   *   if the data they were reading at the beginning of the transaction has been modified (recommended)
+   *   ```ts
+   *   const transaction = await client.createTransaction("my_transaction", { isolation_level: "serializable" });
+   *   ```
+   * 
+   * Additionally, each transaction allows you to set two levels of access to the data:
+   * 
+   * - Read write: This is the default mode, it allows you to execute all commands you have access to normally
+   * 
+   * - Read only: Disables all commands that can make changes to the database. Main use for the read only mode
+   *   is to in conjuction with the repeatable read isolation, ensuring the data you are reading does not change
+   *   during the transaction, specially useful for data extraction
+   *   ```ts
+   *   const transaction = await client.createTransaction("my_transaction", { read_only: true });
+   *   ```
+   * 
+   * Last but not least, transactions allow you to share starting point snapshots between them.
+   * For example, if you initialized a repeatable read transaction before a particularly sensible change
+   * in the database, and you would like to start several transactions with that same before the change state
+   * you can do the following:
+   * 
+   * ```ts
+   * const snapshot = await transaction_1.getSnapshot();
+   * const transaction_2 = client_2.createTransaction("new_transaction", { isolation_level: "repeatable_read", snapshot });
+   * // transaction_2 now shares the same starting state that transaction_1 had
+   * ```
+   * 
+   * https://www.postgresql.org/docs/13/tutorial-transactions.html
+   * https://www.postgresql.org/docs/13/sql-set-transaction.html
+   */
+  createTransaction(name: string, options?: TransactionOptions): Transaction {
+    return new Transaction(
+      name,
+      options,
+      this,
+      (name: string | null) => {
+        this.#current_transaction = name;
+      },
+    );
+  }
+
+  get current_transaction() {
+    return this.#current_transaction;
   }
 
   async end(): Promise<void> {
-    await this._connection.end();
+    await this.#connection.end();
+    this.#current_transaction = null;
   }
 }
 
 export class PoolClient extends QueryClient {
-  protected _connection: Connection;
-  private _releaseCallback: () => void;
+  #connection: Connection;
+  #current_transaction: string | null = null;
+  #release: () => void;
 
   constructor(connection: Connection, releaseCallback: () => void) {
     super();
-    this._connection = connection;
-    this._releaseCallback = releaseCallback;
+    this.#connection = connection;
+    this.#release = releaseCallback;
+  }
+
+  get current_transaction() {
+    return this.#current_transaction;
   }
 
   _executeQuery(query: Query<ResultType.ARRAY>): Promise<QueryArrayResult>;
   _executeQuery(query: Query<ResultType.OBJECT>): Promise<QueryObjectResult>;
   _executeQuery(query: Query<ResultType>): Promise<QueryResult> {
-    return this._connection.query(query);
+    return this.#connection.query(query);
+  }
+
+  /**
+   * Transactions are a powerful feature that guarantees safe operations by allowing you to control
+   * the outcome of a series of statements and undo, reset, and step back said operations to
+   * your liking
+   * 
+   * In order to create a transaction, use the `createTransaction` method in your client as follows:
+   * 
+   * ```ts
+   * const transaction = client.createTransaction("my_transaction_name");
+   * await transaction.begin();
+   * // All statements between begin and commit will happen inside the transaction
+   * await transaction.commit(); // All changes are saved
+   * ```
+   * 
+   * All statements that fail in query execution will cause the current transaction to abort and release
+   * the client without applying any of the changes that took place inside it
+   * 
+   * ```ts
+   * await transaction.begin();
+   * await transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES ${"some_value"}`;
+   * try {
+   *   await transaction.queryArray`SELECT []`; // Invalid syntax, transaction aborted, changes won't be applied
+   * }catch(e){
+   *   await transaction.commit(); // Will throw, current transaction has already finished
+   * }
+   * ```
+   * 
+   * This however, only happens if the error is of execution in nature, validation errors won't abort
+   * the transaction
+   * 
+   * ```ts
+   * await transaction.begin();
+   * await transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES ${"some_value"}`;
+   * try {
+   *   await transaction.rollback("unexistent_savepoint"); // Validation error
+   * }catch(e){
+   *   await transaction.commit(); // Transaction will end, changes will be saved
+   * }
+   * ```
+   * 
+   * A transaction has many options to ensure modifications made to the database are safe and
+   * have the expected outcome, which is a hard thing to accomplish in a database with many concurrent users,
+   * and it does so by allowing you to set local levels of isolation to the transaction you are about to begin
+   * 
+   * Each transaction can execute with the following levels of isolation:
+   * 
+   * - Read committed: This is the normal behavior of a transaction. External changes to the database
+   *   will be visible inside the transaction once they are committed.
+   * 
+   * - Repeatable read: This isolates the transaction in a way that any external changes to the data we are reading
+   *   won't be visible inside the transaction until it has finished
+   *   ```ts
+   *   const transaction = await client.createTransaction("my_transaction", { isolation_level: "repeatable_read" });
+   *   ```
+   * 
+   * - Serializable: This isolation level prevents the current transaction from making persistent changes
+   *   if the data they were reading at the beginning of the transaction has been modified (recommended)
+   *   ```ts
+   *   const transaction = await client.createTransaction("my_transaction", { isolation_level: "serializable" });
+   *   ```
+   * 
+   * Additionally, each transaction allows you to set two levels of access to the data:
+   * 
+   * - Read write: This is the default mode, it allows you to execute all commands you have access to normally
+   * 
+   * - Read only: Disables all commands that can make changes to the database. Main use for the read only mode
+   *   is to in conjuction with the repeatable read isolation, ensuring the data you are reading does not change
+   *   during the transaction, specially useful for data extraction
+   *   ```ts
+   *   const transaction = await client.createTransaction("my_transaction", { read_only: true });
+   *   ```
+   * 
+   * Last but not least, transactions allow you to share starting point snapshots between them.
+   * For example, if you initialized a repeatable read transaction before a particularly sensible change
+   * in the database, and you would like to start several transactions with that same before the change state
+   * you can do the following:
+   * 
+   * ```ts
+   * const snapshot = await transaction_1.getSnapshot();
+   * const transaction_2 = client_2.createTransaction("new_transaction", { isolation_level: "repeatable_read", snapshot });
+   * // transaction_2 now shares the same starting state that transaction_1 had
+   * ```
+   * 
+   * https://www.postgresql.org/docs/13/tutorial-transactions.html
+   * https://www.postgresql.org/docs/13/sql-set-transaction.html
+   */
+  createTransaction(name: string, options?: TransactionOptions): Transaction {
+    return new Transaction(
+      name,
+      options,
+      this,
+      (name: string | null) => {
+        this.#current_transaction = name;
+      },
+    );
   }
 
   async release(): Promise<void> {
-    await this._releaseCallback();
+    await this.#release();
+    this.#current_transaction = null;
   }
 }
diff --git a/connection/warning.ts b/connection/warning.ts
index fe46cf5a..bd0339ed 100644
--- a/connection/warning.ts
+++ b/connection/warning.ts
@@ -30,6 +30,20 @@ export class PostgresError extends Error {
   }
 }
 
+// TODO
+// Use error cause once it's added to JavaScript
+export class TransactionError extends Error {
+  constructor(
+    // deno-lint-ignore camelcase
+    transaction_name: string,
+    public cause: PostgresError,
+  ) {
+    super(
+      `The transaction "${transaction_name}" has been aborted due to \`${cause}\`. Check the "cause" property to get more details`,
+    );
+  }
+}
+
 export function parseError(msg: Message): PostgresError {
   return new PostgresError(parseWarning(msg));
 }
diff --git a/docs/README.md b/docs/README.md
index c95c95dd..89bd205a 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -3,9 +3,13 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 ![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.9.0/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.10.0/mod.ts)
 ![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)
 
+`deno-postgres` is a lightweight PostgreSQL driver for Deno focused on user
+experience. It provides abstractions for most common operations such as typed
+queries, prepared statements, connection pools and transactions.
+
 ```ts
 import { Client } from "https://deno.land/x/postgres/mod.ts";
 
@@ -226,7 +230,7 @@ However, a limitation of template strings is that you can't pass any parameters
 provided by the `QueryOptions` interface, so the only options you have available
 are really `text` and `args` to execute your query
 
-### Generic Parameters
+#### Generic Parameters
 
 Both the `queryArray` and `queryObject` functions have a generic implementation
 that allow users to type the result of the query
@@ -263,7 +267,7 @@ that allow users to type the result of the query
 }
 ```
 
-### Object query
+#### Object query
 
 The `queryObject` function allows you to return the results of the executed
 query as a set objects, allowing easy management with interface like types.
@@ -358,3 +362,444 @@ Other aspects to take into account when using the `fields` argument:
   );
 }
 ```
+
+### Transactions
+
+A lot of effort was put into abstracting Transactions in the library, and the
+final result is an API that is both simple to use and offers all of the options
+and features that you would get by executing SQL statements, plus and extra
+layer of abstraction that helps you catch mistakes ahead of time.
+
+#### Creating a transaction
+
+Both simple clients and connection pools are capable of creating transactions,
+and they work in a similar fashion internally.
+
+```ts
+const transaction = my_client.createTransaction("transaction_1", {
+  isolation_level: "repeatable_read",
+});
+
+await transaction.begin();
+// Safe operations that can be rolled back if the result is not the expected
+await transaction.queryArray`UPDATE TABLE X SET Y = 1`;
+// All changes are saved
+await transaction.commit();
+```
+
+#### Transaction operations vs client operations
+
+##### Transaction locks
+
+Due to how SQL transactions work, everytime you begin a transaction all queries
+you do in your session will run inside that transaction context. This is a
+problem for query execution since it might cause queries that are meant to do
+persistent changes to the database to live inside this context, making them
+susceptible to be rolled back unintentionally. We will call this kind of queries
+**unsafe operations**.
+
+Everytime you create a transaction the client you use will get a lock, with the
+purpose of blocking any external queries from running while a transaction takes
+course, effectively avoiding all unsafe operations.
+
+```ts
+const transaction = my_client.createTransaction("transaction_1");
+
+await transaction.begin();
+await transaction.queryArray`UPDATE TABLE X SET Y = 1`;
+// Oops, the client is locked out, this operation will throw
+await my_client.queryArray`DELETE TABLE X`;
+// Client is released after the transaction ends
+await transaction.commit();
+
+// Operations in the main client can now be executed normally
+await client.queryArray`DELETE TABLE X`;
+```
+
+For this very reason however, if you are using transactions in an application
+with concurrent access like an API, it is recommended that you don't use the
+Client API at all. If you do so, the client will be blocked from executing other
+queries until the transaction has finished. Instead of that, use a connection
+pool, that way all your operations will be executed in a different context
+without locking the main client.
+
+```ts
+const client_1 = await pool.connect();
+const client_2 = await pool.connect();
+
+const transaction = client_1.createTransaction("transaction_1");
+
+await transaction.begin();
+await transaction.queryArray`UPDATE TABLE X SET Y = 1`;
+// Code that is meant to be executed concurrently, will run normally
+await client_2.queryArray`DELETE TABLE Z`;
+await transaction.commit();
+
+await client_1.release();
+await client_2.release();
+```
+
+##### Transaction errors
+
+When you are inside a Transaction block in PostgreSQL, reaching an error is
+terminal for the transaction. Executing the following in PostgreSQL will cause
+all changes to be undone and the transaction to become unusable until it has
+ended.
+
+```sql
+BEGIN;
+
+UPDATE MY_TABLE SET NAME = 'Nicolas';
+SELECT []; -- Syntax error, transaction will abort
+SELECT ID FROM MY_TABLE; -- Will attempt to execute, but will fail cause transaction was aborted
+
+COMMIT; -- Transaction will end, but no changes to MY_TABLE will be made
+```
+
+However, due to how JavaScript works we can handle this kinds of errors in a
+more fashionable way. All failed queries inside a transaction will automatically
+end it and release the main client.
+
+```ts
+/**
+ * This function will return a boolean regarding the transaction completion status
+ */
+function executeMyTransaction() {
+  try {
+    const transaction = client.createTransaction("abortable");
+    await transaction.begin();
+
+    await transaction.queryArray`UPDATE MY_TABLE SET NAME = 'Nicolas'`;
+    await transaction.queryArray`SELECT []`; // Error will be thrown, transaction will be aborted
+    await transaction.queryArray`SELECT ID FROM MY_TABLE`; // Won't even attempt to execute
+
+    await transaction.commit(); // Don't even need it, transaction was already ended
+  } catch (e) {
+    return false;
+  }
+
+  return true;
+}
+```
+
+This limits only to database related errors though, regular errors won't end the
+connection and may allow the user to execute a different code path. This is
+specially good for ahead of time validation errors such as the ones found in the
+rollback and savepoint features.
+
+```ts
+const transaction = client.createTransaction("abortable");
+await transaction.begin();
+
+let savepoint;
+try{
+  // Oops, savepoints can't start with a number
+  // Validation error, transaction won't be ended
+  savepoint = await transaction.savepoint("1");
+}catch(e){
+  // We validate the error was not related to transaction execution
+  if(!(e instance of TransactionError)){
+    // We create a good savepoint we can use
+    savepoint = await transaction.savepoint("a_valid_name");
+  }else{
+    throw e;
+  }
+}
+
+// Transaction is still open and good to go
+await transaction.queryArray`UPDATE MY_TABLE SET NAME = 'Nicolas'`;
+await transaction.rollback(savepoint); // Undo changes after the savepoint creation
+
+await transaction.commit();
+```
+
+#### Transaction options
+
+PostgreSQL provides many options to customize the behavior of transactions, such
+as isolation level, read modes and startup snapshot. All this options can be set
+by passing a second argument to the `startTransaction` method
+
+```ts
+const transaction = client.createTransaction("ts_1", {
+  isolation_level: "serializable",
+  read_only: true,
+  snapshot: "snapshot_code",
+});
+```
+
+##### Isolation Level
+
+Setting an isolation level protects your transaction from operations that took
+place _after_ the transaction had begun.
+
+The following is a demonstration. A sensible transaction that loads a table with
+some very important test results and the students that passed said test. This is
+a long running operation, and in the meanwhile someone is tasked to cleanup the
+results from the tests table because it's taking too much space in the database.
+
+If the transaction were to be executed as it follows, the test results would be
+lost before the graduated students could be extracted from the original table,
+causing a mismatch in the data.
+
+```ts
+const client_1 = await pool.connect();
+const client_2 = await pool.connect();
+
+const transaction = client_1.createTransaction("transaction_1");
+
+await transaction.begin();
+
+await transaction.queryArray
+  `CREATE TABLE TEST_RESULTS (USER_ID INTEGER, GRADE NUMERIC(10,2))`;
+await transaction.queryArray`CREATE TABLE GRADUATED_STUDENTS (USER_ID INTEGER)`;
+
+// This operation takes several minutes
+await transaction.queryArray`INSERT INTO TEST_RESULTS
+  SELECT
+    USER_ID, GRADE
+  FROM TESTS
+  WHERE TEST_TYPE = 'final_test'`;
+
+// A third party, whose task is to clean up the test results
+// executes this query while the operation above still takes place
+await client_2.queryArray`DELETE FROM TESTS WHERE TEST_TYPE = 'final_test'`;
+
+// Test information is gone, no data will be loaded into the graduated students table
+await transaction.queryArray`INSERT INTO GRADUATED_STUDENTS
+  SELECT
+    USER_ID
+  FROM TESTS
+  WHERE TEST_TYPE = 'final_test'
+  AND GRADE >= 3.0`;
+
+await transaction.commit();
+
+await client_1.release();
+await client_2.release();
+```
+
+In order to ensure scenarios like the above don't happen, Postgres provides the
+following levels of transaction isolation:
+
+- Read committed: This is the normal behavior of a transaction. External changes
+  to the database will be visible inside the transaction once they are
+  committed.
+
+- Repeatable read: This isolates the transaction in a way that any external
+  changes to the data we are reading won't be visible inside the transaction
+  until it has finished
+  ```ts
+  const client_1 = await pool.connect();
+  const client_2 = await pool.connect();
+
+  const transaction = await client_1.createTransaction("isolated_transaction", {
+    isolation_level: "repeatable_read",
+  });
+
+  await transaction.begin();
+  // This locks the current value of IMPORTANT_TABLE
+  // Up to this point, all other external changes will be included
+  const { rows: query_1 } = await transaction.queryObject<{ password: string }>
+    `SELECT PASSWORD FROM IMPORTANT_TABLE WHERE ID = ${my_id}`;
+  const password_1 = rows[0].password;
+
+  // Concurrent operation executed by a different user in a different part of the code
+  await client_2.queryArray
+    `UPDATE IMPORTANT_TABLE SET PASSWORD = 'something_else' WHERE ID = ${the_same_id}`;
+
+  const { rows: query_2 } = await transaction.queryObject<{ password: string }>
+    `SELECT PASSWORD FROM IMPORTANT_TABLE WHERE ID = ${my_id}`;
+  const password_2 = rows[0].password;
+
+  // Database state is not updated while the transaction is ongoing
+  assertEquals(password_1, password_2);
+
+  // Transaction finishes, changes executed outside the transaction are now visible
+  await transaction.commit();
+
+  await client_1.release();
+  await client_2.release();
+  ```
+
+- Serializable: Just like the repeatable read mode, all external changes won't
+  be visible until the transaction has finished. However this also prevents the
+  current transaction from making persistent changes if the data they were
+  reading at the beginning of the transaction has been modified (recommended)
+  ```ts
+  const client_1 = await pool.connect();
+  const client_2 = await pool.connect();
+
+  const transaction = await client_1.createTransaction("isolated_transaction", {
+    isolation_level: "serializable",
+  });
+
+  await transaction.begin();
+  // This locks the current value of IMPORTANT_TABLE
+  // Up to this point, all other external changes will be included
+  await transaction.queryObject<{ password: string }>
+    `SELECT PASSWORD FROM IMPORTANT_TABLE WHERE ID = ${my_id}`;
+
+  // Concurrent operation executed by a different user in a different part of the code
+  await client_2.queryArray
+    `UPDATE IMPORTANT_TABLE SET PASSWORD = 'something_else' WHERE ID = ${the_same_id}`;
+
+  // This statement will throw
+  // Target was modified outside of the transaction
+  // User may not be aware of the changes
+  await transaction.queryArray
+    `UPDATE IMPORTANT_TABLE SET PASSWORD = 'shiny_new_password' WHERE ID = ${the_same_id}`;
+
+  // Transaction is aborted, no need to end it
+
+  await client_1.release();
+  await client_2.release();
+  ```
+
+##### Read modes
+
+In many cases, and specially when allowing third parties to access data inside
+your database it might be a good choice to prevent queries from modifying the
+database in the course of the transaction. You can revoke this write privileges
+by setting `read_only: true` in the transaction options. The default for all
+transactions will be to enable write permission.
+
+```ts
+const transaction = await client.createTransaction("my_transaction", {
+  read_only: true,
+});
+```
+
+##### Snapshots
+
+One of the most interesting features that Postgres transactions have it's the
+ability to share starting point snapshots between them. For example, if you
+initialized a repeatable read transaction before a particularly sensible change
+in the database, and you would like to start several transactions with that same
+before-the-change state you can do the following:
+
+```ts
+const snapshot = await ongoing_transaction.getSnapshot();
+
+const new_transaction = client.createTransaction("new_transaction", {
+  isolation_level: "repeatable_read",
+  snapshot,
+});
+// new_transaction now shares the same starting state that ongoing_transaction had
+```
+
+#### Transaction features
+
+##### Commit
+
+Committing a transaction will persist all changes made inside it, releasing the
+client from which the transaction spawned and allowing for normal operations to
+take place.
+
+```ts
+const transaction = client.createTransaction("successful_transaction");
+await transaction.begin();
+await transaction.queryArray`TRUNCATE TABLE DELETE_ME`;
+await transaction.queryArray`INSERT INTO DELETE_ME VALUES (1)`;
+await transaction.commit(); // All changes are persisted, client is released
+```
+
+However, what if we intended to commit the previous changes without ending the
+transaction? The `commit` method provides a `chain` option that allows us to
+continue in the transaction after the changes have been persisted as
+demonstrated here:
+
+```ts
+const transaction = client.createTransaction("successful_transaction");
+await transaction.begin();
+
+await transaction.queryArray`TRUNCATE TABLE DELETE_ME`;
+await transaction.commit({ chain: true }); // Changes are committed
+
+// Still inside the transaction
+// Rolling back or aborting here won't affect the previous operation
+await transaction.queryArray`INSERT INTO DELETE_ME VALUES (1)`;
+await transaction.commit(); // Changes are committed, client is released
+```
+
+##### Savepoints
+
+Savepoints are a powerful feature that allows us to keep track of transaction
+operations, and if we want to, undo said specific changes without having to
+reset the whole transaction.
+
+```ts
+const transaction = client.createTransaction("successful_transaction");
+await transaction.begin();
+
+await transaction.queryArray`INSERT INTO DONT_DELETE_ME VALUES (1)`;
+const savepoint = await transaction.savepoint("before_delete");
+
+await transaction.queryArray`TRUNCATE TABLE DONT_DELETE_ME`; // Oops, I didn't mean that
+await transaction.rollback(savepoint); // Truncate is undone, insert is still applied
+
+// Transaction goes on as usual
+await transaction.commit();
+```
+
+A savepoint can also have multiple positions inside a transaction, and we can
+accomplish that by using the `update` method of a savepoint.
+
+```ts
+await transaction.queryArray`INSERT INTO DONT_DELETE_ME VALUES (1)`;
+const savepoint = await transaction.savepoint("before_delete");
+
+await transaction.queryArray`TRUNCATE TABLE DONT_DELETE_ME`;
+await savepoint.update(savepoint); // If I rollback savepoint now, it won't undo the truncate
+```
+
+However, if we wanted to undo one of these updates we could use the `release`
+method in the savepoint to undo the last update and access the previous point of
+that savepoint.
+
+```ts
+await transaction.queryArray`INSERT INTO DONT_DELETE_ME VALUES (1)`;
+const savepoint = await transaction.savepoint("before_delete");
+
+await transaction.queryArray`TRUNCATE TABLE DONT_DELETE_ME`;
+await savepoint.update(savepoint); // Actually, I didn't meant this
+
+await savepoint.release(); // The savepoint is again the first one we set
+await transaction.rollback(savepoint); // Truncate gets undone
+```
+
+##### Rollback
+
+A rollback allows the user to end the transaction without persisting the changes
+made to the database, preventing that way any unwanted operation to take place.
+
+```ts
+const transaction = client.createTransaction("rolled_back_transaction");
+await transaction.queryArray`TRUNCATE TABLE DONT_DELETE_ME`; // Oops, wrong table
+await transaction.rollback(); // No changes are applied, transaction ends
+```
+
+You can also localize those changes to be undone using the savepoint feature as
+explained above in the `Savepoint` documentation.
+
+```ts
+const transaction = client.createTransaction(
+  "partially_rolled_back_transaction",
+);
+await transaction.savepoint("undo");
+await transaction.queryArray`TRUNCATE TABLE DONT_DELETE_ME`; // Oops, wrong table
+await transaction.rollback("undo"); // Truncate is rolled back, transaction continues
+await transaction.end();
+```
+
+If we intended to rollback all changes but still continue in the current
+transaction, we can use the `chain` option in a similar fashion to how we would
+do it in the `commit` method.
+
+```ts
+const transaction = client.createTransaction("rolled_back_transaction");
+await transaction.queryArray`INSERT INTO DONT_DELETE_ME VALUES (1)`;
+await transaction.queryArray`TRUNCATE TABLE DONT_DELETE_ME`;
+await transaction.rollback({ chain: true }); // All changes get undone
+await transaction.queryArray`INSERT INTO DONT_DELETE_ME VALUES (2)`; // Still inside the transaction
+await transaction.end();
+```
diff --git a/pool.ts b/pool.ts
index ae743403..2a9e083a 100644
--- a/pool.ts
+++ b/pool.ts
@@ -15,6 +15,8 @@ import {
   ResultType,
 } from "./query/query.ts";
 
+// TODO
+// Remove query execution methods from main pool
 export class Pool extends QueryClient {
   private _connectionParams: ConnectionParams;
   private _connections!: Array<Connection>;
diff --git a/query/transaction.ts b/query/transaction.ts
new file mode 100644
index 00000000..c23f20c7
--- /dev/null
+++ b/query/transaction.ts
@@ -0,0 +1,693 @@
+import type { QueryClient } from "../client.ts";
+import {
+  Query,
+  QueryArguments,
+  QueryArrayResult,
+  QueryConfig,
+  QueryObjectConfig,
+  QueryObjectResult,
+  ResultType,
+  templateStringToQuery,
+} from "./query.ts";
+import { isTemplateString } from "../utils.ts";
+import { PostgresError, TransactionError } from "../connection/warning.ts";
+
+class Savepoint {
+  /**
+   * This is the count of the current savepoint instances in the transaction
+   */
+  #instance_count = 0;
+  #release_callback: (name: string) => Promise<void>;
+  #update_callback: (name: string) => Promise<void>;
+
+  constructor(
+    public readonly name: string,
+    // deno-lint-ignore camelcase
+    update_callback: (name: string) => Promise<void>,
+    // deno-lint-ignore camelcase
+    release_callback: (name: string) => Promise<void>,
+  ) {
+    this.#release_callback = release_callback;
+    this.#update_callback = update_callback;
+  }
+
+  get instances() {
+    return this.#instance_count;
+  }
+
+  /**
+   * Releasing a savepoint will remove it's last instance in the transaction
+   * 
+   * ```ts
+   * const savepoint = await transaction.savepoint("n1");
+   * await savepoint.release();
+   * transaction.rollback(savepoint); // Error, can't rollback because the savepoint was released
+   * ```
+   * 
+   * It will also allow you to set the savepoint to the position it had before the last update
+   * 
+   * * ```ts
+   * const savepoint = await transaction.savepoint("n1");
+   * await savepoint.update();
+   * await savepoint.release(); // This drops the update of the last statement
+   * transaction.rollback(savepoint); // Will rollback to the first instance of the savepoint
+   * ```
+   * 
+   * This function will throw if there are no savepoint instances to drop
+   */
+  async release() {
+    if (this.#instance_count === 0) {
+      throw new Error("This savepoint has no instances to release");
+    }
+
+    await this.#release_callback(this.name);
+    --this.#instance_count;
+  }
+
+  /**
+   * Updating a savepoint will update its position in the transaction execution
+   * 
+   * ```ts
+   * const savepoint = await transaction.savepoint("n1");
+   * transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES (${my_value})`;
+   * await savepoint.update(); // Rolling back will now return you to this point on the transaction
+   * ```
+   * 
+   * You can also undo a savepoint update by using the `release` method
+   * 
+   * ```ts
+   * const savepoint = await transaction.savepoint("n1");
+   * transaction.queryArray`DELETE FROM VERY_IMPORTANT_TABLE`;
+   * await savepoint.update(); // Oops, shouldn't have updated the savepoint
+   * await savepoint.release(); // This will undo the last update and return the savepoint to the first instance
+   * await transaction.rollback(); // Will rollback before the table was deleted
+   * ```
+   * */
+  async update() {
+    await this.#update_callback(this.name);
+    ++this.#instance_count;
+  }
+}
+
+type IsolationLevel = "read_committed" | "repeatable_read" | "serializable";
+
+export type TransactionOptions = {
+  // deno-lint-ignore camelcase
+  isolation_level?: IsolationLevel;
+  // deno-lint-ignore camelcase
+  read_only?: boolean;
+  snapshot?: string;
+};
+
+export class Transaction {
+  #client: QueryClient;
+  #isolation_level: IsolationLevel;
+  #read_only: boolean;
+  #updateClientLock: (name: string | null) => void;
+  #savepoints: Savepoint[] = [];
+  #snapshot?: string;
+
+  constructor(
+    public name: string,
+    options: TransactionOptions | undefined,
+    client: QueryClient,
+    // deno-lint-ignore camelcase
+    update_client_lock_callback: (name: string | null) => void,
+  ) {
+    this.#client = client;
+    this.#isolation_level = options?.isolation_level ?? "read_committed";
+    this.#read_only = options?.read_only ?? false;
+    this.#updateClientLock = update_client_lock_callback;
+    this.#snapshot = options?.snapshot;
+  }
+
+  get isolation_level() {
+    return this.#isolation_level;
+  }
+
+  get savepoints() {
+    return this.#savepoints;
+  }
+
+  /**
+   * This method will throw if the transaction opened in the client doesn't match this one
+   */
+  #assertTransactionOpen = () => {
+    if (this.#client.current_transaction !== this.name) {
+      throw new Error(
+        `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+      );
+    }
+  };
+
+  #resetTransaction = () => {
+    this.#savepoints = [];
+  };
+
+  /**
+   * The begin method will officially begin the transaction, and it must be called before
+   * any query or transaction operation is executed in order to lock the session
+   * ```ts
+   * const transaction = client.createTransaction("transaction_name");
+   * await transaction.begin(); // Session is locked, transaction operations are now safe
+   * // Important operations
+   * await transaction.commit(); // Session is unlocked, external operations can now take place
+   * ```
+   * https://www.postgresql.org/docs/13/sql-begin.html
+   */
+  async begin() {
+    if (this.#client.current_transaction !== null) {
+      if (this.#client.current_transaction === this.name) {
+        throw new Error(
+          "This transaction is already open",
+        );
+      }
+
+      throw new Error(
+        `This client already has an ongoing transaction "${this.#client.current_transaction}"`,
+      );
+    }
+
+    // deno-lint-ignore camelcase
+    let isolation_level;
+    switch (this.#isolation_level) {
+      case "read_committed": {
+        isolation_level = "READ COMMITTED";
+        break;
+      }
+      case "repeatable_read": {
+        isolation_level = "REPEATABLE READ";
+        break;
+      }
+      case "serializable": {
+        isolation_level = "SERIALIZABLE";
+        break;
+      }
+      default:
+        throw new Error(
+          `Unexpected isolation level "${this.#isolation_level}"`,
+        );
+    }
+
+    let permissions;
+    if (this.#read_only) {
+      permissions = "READ ONLY";
+    } else {
+      permissions = "READ WRITE";
+    }
+
+    let snapshot = "";
+    if (this.#snapshot) {
+      snapshot = `SET TRANSACTION SNAPSHOT '${this.#snapshot}'`;
+    }
+
+    try {
+      await this.#client.queryArray(
+        `BEGIN ${permissions} ISOLATION LEVEL ${isolation_level};${snapshot}`,
+      );
+    } catch (e) {
+      if (e instanceof PostgresError) {
+        throw new TransactionError(this.name, e);
+      } else {
+        throw e;
+      }
+    }
+
+    this.#updateClientLock(this.name);
+  }
+
+  /**
+   * The commit method will make permanent all changes made to the database in the
+   * current transaction and end the current transaction
+   * 
+   * ```ts
+   * await transaction.begin();
+   * // Important operations
+   * await transaction.commit(); // Will terminate the transaction and save all changes
+   * ```
+   * 
+   * The commit method allows you to specify a "chain" option, that allows you to both commit the current changes and
+   * start a new with the same transaction parameters in a single statement
+   * 
+   * ```ts
+   * // ...
+   * // Transaction operations I want to commit
+   * await transaction.commit({ chain: true }); // All changes are saved, following statements will be executed inside a transaction
+   * await transaction.query`DELETE SOMETHING FROM SOMEWHERE`; // Still inside the transaction
+   * await transaction.commit(); // The transaction finishes for good
+   * ```
+   * 
+   * https://www.postgresql.org/docs/13/sql-commit.html
+   */
+  async commit(options?: { chain?: boolean }) {
+    this.#assertTransactionOpen();
+
+    const chain = options?.chain ?? false;
+
+    try {
+      await this.queryArray(`COMMIT ${chain ? "AND CHAIN" : ""}`);
+    } catch (e) {
+      if (e instanceof PostgresError) {
+        throw new TransactionError(this.name, e);
+      } else {
+        throw e;
+      }
+    }
+
+    this.#resetTransaction();
+    if (!chain) {
+      this.#updateClientLock(null);
+    }
+  }
+
+  /**
+   * This method will search for the provided savepoint name and return a
+   * reference to the requested savepoint, otherwise it will return undefined
+   */
+  getSavepoint(name: string): Savepoint | undefined {
+    return this.#savepoints.find((sv) => sv.name === name.toLowerCase());
+  }
+
+  /**
+   * This method will list you all of the active savepoints in this transaction
+   */
+  getSavepoints(): string[] {
+    return this.#savepoints
+      .filter(({ instances }) => instances > 0)
+      .map(({ name }) => name);
+  }
+
+  /**
+   * This method returns the snapshot id of the on going transaction, allowing you to share
+   * the snapshot state between two transactions
+   * 
+   * ```ts
+   * const snapshot = await transaction_1.getSnapshot();
+   * const transaction_2 = client_2.createTransaction("new_transaction", { isolation_level: "repeatable_read", snapshot });
+   * // transaction_2 now shares the same starting state that transaction_1 had
+   * ```
+   * https://www.postgresql.org/docs/13/functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION
+   */
+  async getSnapshot(): Promise<string> {
+    this.#assertTransactionOpen();
+
+    const { rows } = await this.queryObject<{ snapshot: string }>
+      `SELECT PG_EXPORT_SNAPSHOT() AS SNAPSHOT;`;
+    return rows[0].snapshot;
+  }
+
+  /**
+   * This method allows executed queries to be retrieved as array entries.
+   * It supports a generic interface in order to type the entries retrieved by the query
+   * 
+   * ```ts
+   * const {rows} = await transaction.queryArray(
+   *  "SELECT ID, NAME FROM CLIENTS"
+   * ); // Array<unknown[]>
+   * ```
+   * 
+   * You can pass type arguments to the query in order to hint TypeScript what the return value will be
+   * ```ts
+   * const {rows} = await transaction.queryArray<[number, string]>(
+   *  "SELECT ID, NAME FROM CLIENTS"
+   * ); // Array<[number, string]>
+   * ```
+   * 
+   * It also allows you to execute prepared stamements with template strings
+   * 
+   * ```ts
+   * const id = 12;
+   * // Array<[number, string]>
+   * const {rows} = await transaction.queryArray<[number, string]>`SELECT ID, NAME FROM CLIENTS WHERE ID = ${id}`;
+   * ```
+   */
+  async queryArray<T extends Array<unknown>>(
+    query: string,
+    ...args: QueryArguments
+  ): Promise<QueryArrayResult<T>>;
+  async queryArray<T extends Array<unknown>>(
+    config: QueryConfig,
+  ): Promise<QueryArrayResult<T>>;
+  async queryArray<T extends Array<unknown>>(
+    strings: TemplateStringsArray,
+    ...args: QueryArguments
+  ): Promise<QueryArrayResult<T>>;
+  async queryArray<T extends Array<unknown> = Array<unknown>>(
+    // deno-lint-ignore camelcase
+    query_template_or_config: TemplateStringsArray | string | QueryConfig,
+    ...args: QueryArguments
+  ): Promise<QueryArrayResult<T>> {
+    this.#assertTransactionOpen();
+
+    let query: Query<ResultType.ARRAY>;
+    if (typeof query_template_or_config === "string") {
+      query = new Query(query_template_or_config, ResultType.ARRAY, ...args);
+    } else if (isTemplateString(query_template_or_config)) {
+      query = templateStringToQuery(
+        query_template_or_config,
+        args,
+        ResultType.ARRAY,
+      );
+    } else {
+      query = new Query(query_template_or_config, ResultType.ARRAY);
+    }
+
+    try {
+      return await this.#client._executeQuery(query);
+    } catch (e) {
+      // deno-lint-ignore no-unreachable
+      if (e instanceof PostgresError) {
+        // deno-lint-ignore no-unreachable
+        await this.commit();
+        // deno-lint-ignore no-unreachable
+        throw new TransactionError(this.name, e);
+      } else {
+        // deno-lint-ignore no-unreachable
+        throw e;
+      }
+    }
+  }
+
+  /**
+   * This method allows executed queries to be retrieved as object entries.
+   * It supports a generic interface in order to type the entries retrieved by the query
+   * 
+   * ```ts
+   * const {rows} = await transaction.queryObject(
+   *  "SELECT ID, NAME FROM CLIENTS"
+   * ); // Record<string, unknown>
+   * 
+   * const {rows} = await transaction.queryObject<{id: number, name: string}>(
+   *  "SELECT ID, NAME FROM CLIENTS"
+   * ); // Array<{id: number, name: string}>
+   * ```
+   * 
+   * You can also map the expected results to object fields using the configuration interface.
+   * This will be assigned in the order they were provided
+   * 
+   * ```ts
+   * const {rows} = await transaction.queryObject(
+   *  "SELECT ID, NAME FROM CLIENTS"
+   * );
+   * 
+   * console.log(rows); // [{id: 78, name: "Frank"}, {id: 15, name: "Sarah"}]
+   * 
+   * const {rows} = await transaction.queryObject({
+   *  text: "SELECT ID, NAME FROM CLIENTS",
+   *  fields: ["personal_id", "complete_name"],
+   * });
+   * 
+   * console.log(rows); // [{personal_id: 78, complete_name: "Frank"}, {personal_id: 15, complete_name: "Sarah"}]
+   * ```
+   * 
+   * It also allows you to execute prepared stamements with template strings
+   * 
+   * ```ts
+   * const id = 12;
+   * // Array<{id: number, name: string}>
+   * const {rows} = await transaction.queryObject<{id: number, name: string}>`SELECT ID, NAME FROM CLIENTS WHERE ID = ${id}`;
+   * ```
+   */
+  async queryObject<T extends Record<string, unknown>>(
+    query: string,
+    ...args: QueryArguments
+  ): Promise<QueryObjectResult<T>>;
+  async queryObject<T extends Record<string, unknown>>(
+    config: QueryObjectConfig,
+  ): Promise<QueryObjectResult<T>>;
+  async queryObject<T extends Record<string, unknown>>(
+    query: TemplateStringsArray,
+    ...args: QueryArguments
+  ): Promise<QueryObjectResult<T>>;
+  async queryObject<
+    T extends Record<string, unknown> = Record<string, unknown>,
+  >(
+    // deno-lint-ignore camelcase
+    query_template_or_config:
+      | string
+      | QueryObjectConfig
+      | TemplateStringsArray,
+    ...args: QueryArguments
+  ): Promise<QueryObjectResult<T>> {
+    this.#assertTransactionOpen();
+
+    let query: Query<ResultType.OBJECT>;
+    if (typeof query_template_or_config === "string") {
+      query = new Query(query_template_or_config, ResultType.OBJECT, ...args);
+    } else if (isTemplateString(query_template_or_config)) {
+      query = templateStringToQuery(
+        query_template_or_config,
+        args,
+        ResultType.OBJECT,
+      );
+    } else {
+      query = new Query(
+        query_template_or_config as QueryObjectConfig,
+        ResultType.OBJECT,
+      );
+    }
+
+    try {
+      return await this.#client._executeQuery<T>(query);
+    } catch (e) {
+      // deno-lint-ignore no-unreachable
+      if (e instanceof PostgresError) {
+        // deno-lint-ignore no-unreachable
+        await this.commit();
+        // deno-lint-ignore no-unreachable
+        throw new TransactionError(this.name, e);
+      } else {
+        // deno-lint-ignore no-unreachable
+        throw e;
+      }
+    }
+  }
+
+  /**
+   * Rollbacks are a mechanism to undo transaction operations without compromising the data that was modified during
+   * the transaction
+   * 
+   * A rollback can be executed the following way
+   * ```ts
+   * // ...
+   * // Very very important operations that went very, very wrong
+   * await transaction.rollback(); // Like nothing ever happened
+   * ```
+   * 
+   * Calling a rollback without arguments will terminate the current transaction and undo all changes,
+   * but it can be used in conjuction with the savepoint feature to rollback specific changes like the following
+   * 
+   * ```ts
+   * // ...
+   * // Important operations I don't want to rollback
+   * const savepoint = await transaction.savepoint("before_disaster");
+   * await transaction.queryArray`UPDATE MY_TABLE SET X = 0`; // Oops, update without where
+   * await transaction.rollback(savepoint); // "before_disaster" would work as well
+   * // Everything that happened between the savepoint and the rollback gets undone
+   * await transaction.commit(); // Commits all other changes
+   * ```
+   * 
+   * The rollback method allows you to specify a "chain" option, that allows you to not only undo the current transaction
+   * but to restart it with the same parameters in a single statement
+   * 
+   * ```ts
+   * // ...
+   * // Transaction operations I want to undo
+   * await transaction.rollback({ chain: true }); // All changes are undone, but the following statements will be executed inside a transaction as well
+   * await transaction.query`DELETE SOMETHING FROM SOMEWHERE`; // Still inside the transaction
+   * await transaction.commit(); // The transaction finishes for good
+   * ```
+   * 
+   * However, the "chain" option can't be used alongside a savepoint, even though they are similar
+   * 
+   * A savepoint is meant to reset progress up to a certain point, while a chained rollback is meant to reset all progress
+   * and start from scratch
+   * 
+   * ```ts
+   * await transaction.rollback({ chain: true, savepoint: my_savepoint }); // Error, can't both return to savepoint and reset transaction
+   * ```
+   * https://www.postgresql.org/docs/13/sql-rollback.html
+   */
+  async rollback(savepoint?: string | Savepoint): Promise<void>;
+  async rollback(options?: { savepoint?: string | Savepoint }): Promise<void>;
+  async rollback(options?: { chain?: boolean }): Promise<void>;
+  async rollback(
+    // deno-lint-ignore camelcase
+    savepoint_or_options?: string | Savepoint | {
+      savepoint?: string | Savepoint;
+    } | { chain?: boolean },
+  ): Promise<void> {
+    this.#assertTransactionOpen();
+
+    // deno-lint-ignore camelcase
+    let savepoint_option: Savepoint | string | undefined;
+    if (
+      typeof savepoint_or_options === "string" ||
+      savepoint_or_options instanceof Savepoint
+    ) {
+      savepoint_option = savepoint_or_options;
+    } else {
+      savepoint_option =
+        (savepoint_or_options as { savepoint?: string | Savepoint })?.savepoint;
+    }
+
+    // deno-lint-ignore camelcase
+    let savepoint_name: string | undefined;
+    if (savepoint_option instanceof Savepoint) {
+      savepoint_name = savepoint_option.name;
+    } else if (typeof savepoint_option === "string") {
+      savepoint_name = savepoint_option.toLowerCase();
+    }
+
+    // deno-lint-ignore camelcase
+    let chain_option = false;
+    if (typeof savepoint_or_options === "object") {
+      chain_option = (savepoint_or_options as { chain?: boolean })?.chain ??
+        false;
+    }
+
+    if (chain_option && savepoint_name) {
+      throw new Error(
+        "The chain option can't be used alongside a savepoint on a rollback operation",
+      );
+    }
+
+    // If a savepoint is provided, rollback to that savepoint, continue the transaction
+    if (typeof savepoint_option !== "undefined") {
+      // deno-lint-ignore camelcase
+      const ts_savepoint = this.#savepoints.find(({ name }) =>
+        name === savepoint_name
+      );
+      if (!ts_savepoint) {
+        throw new Error(
+          `There is no "${savepoint_name}" savepoint registered in this transaction`,
+        );
+      }
+      if (!ts_savepoint.instances) {
+        throw new Error(
+          `There are no savepoints of "${savepoint_name}" left to rollback to`,
+        );
+      }
+
+      await this.queryArray(`ROLLBACK TO ${savepoint_name}`);
+      return;
+    }
+
+    // If no savepoint is provided, rollback the whole transaction and check for the chain operator
+    // in order to decide whether to restart the transaction or end it
+    try {
+      await this.queryArray(`ROLLBACK ${chain_option ? "AND CHAIN" : ""}`);
+    } catch (e) {
+      if (e instanceof PostgresError) {
+        await this.commit();
+        throw new TransactionError(this.name, e);
+      } else {
+        throw e;
+      }
+    }
+
+    this.#resetTransaction();
+    if (!chain_option) {
+      this.#updateClientLock(null);
+    }
+  }
+
+  /**
+   * This method will generate a savepoint, which will allow you to reset transaction states
+   * to a previous point of time
+   * 
+   * Each savepoint has a unique name used to identify it, and it must abide the following rules
+   * 
+   * - Savepoint names must start with a letter or an underscore
+   * - Savepoint names are case insensitive
+   * - Savepoint names can't be longer than 63 characters
+   * - Savepoint names can only have alphanumeric characters
+   * 
+   * A savepoint can be easily created like this
+   * ```ts
+   * const savepoint = await transaction.save("MY_savepoint"); // returns a `Savepoint` with name "my_savepoint"
+   * await transaction.rollback(savepoint);
+   * await savepoint.release(); // The savepoint will be removed
+   * ```
+   * All savepoints can have multiple positions in a transaction, and you can change or update
+   * this positions by using the `update` and `release` methods
+   * ```ts
+   * const savepoint = await transaction.save("n1");
+   * await transaction.queryArray`INSERT INTO MY_TABLE VALUES (${'A'}, ${2})`;
+   * await savepoint.update(); // The savepoint will continue from here
+   * await transaction.queryArray`DELETE FROM MY_TABLE`;
+   * await transaction.rollback(savepoint); // The transaction will rollback before the delete, but after the insert
+   * await savepoint.release(); // The last savepoint will be removed, the original one will remain
+   * await transaction.rollback(savepoint); // It rolls back before the insert
+   * await savepoint.release(); // All savepoints are released
+   * ```
+   * 
+   * Creating a new savepoint with an already used name will return you a reference to
+   * the original savepoint
+   * ```ts
+   * const savepoint_a = await transaction.save("a");
+   * await transaction.queryArray`DELETE FROM MY_TABLE`;
+   * const savepoint_b = await transaction.save("a"); // They will be the same savepoint, but the savepoint will be updated to this position
+   * await transaction.rollback(savepoint_a); // Rolls back to savepoint_b
+   * ```
+   * https://www.postgresql.org/docs/13/sql-savepoint.html
+   */
+  async savepoint(name: string): Promise<Savepoint> {
+    this.#assertTransactionOpen();
+
+    if (!/^[a-zA-Z_]{1}[\w]{0,62}$/.test(name)) {
+      if (!Number.isNaN(Number(name[0]))) {
+        throw new Error("The savepoint name can't begin with a number");
+      }
+      if (name.length > 63) {
+        throw new Error(
+          "The savepoint name can't be longer than 63 characters",
+        );
+      }
+      throw new Error(
+        "The savepoint name can only contain alphanumeric characters",
+      );
+    }
+
+    name = name.toLowerCase();
+
+    let savepoint = this.#savepoints.find((sv) => sv.name === name);
+
+    if (savepoint) {
+      try {
+        await savepoint.update();
+      } catch (e) {
+        if (e instanceof PostgresError) {
+          await this.commit();
+          throw new TransactionError(this.name, e);
+        } else {
+          throw e;
+        }
+      }
+    } else {
+      savepoint = new Savepoint(
+        name,
+        async (name: string) => {
+          await this.queryArray(`SAVEPOINT ${name}`);
+        },
+        async (name: string) => {
+          await this.queryArray(`RELEASE SAVEPOINT ${name}`);
+        },
+      );
+
+      try {
+        await savepoint.update();
+      } catch (e) {
+        if (e instanceof PostgresError) {
+          await this.commit();
+          throw new TransactionError(this.name, e);
+        } else {
+          throw e;
+        }
+      }
+      this.#savepoints.push(savepoint);
+    }
+
+    return savepoint;
+  }
+}
diff --git a/tests/pool_test.ts b/tests/pool_test.ts
index b203d3c8..22e1cf21 100644
--- a/tests/pool_test.ts
+++ b/tests/pool_test.ts
@@ -147,27 +147,540 @@ testPool(async function manyQueries(POOL) {
 
 testPool(async function transaction(POOL) {
   const client = await POOL.connect();
-  let errored;
-  let released;
-  assertEquals(POOL.available, 9);
+  // deno-lint-ignore camelcase
+  const transaction_name = "x";
+  const transaction = client.createTransaction(transaction_name);
 
-  try {
-    await client.queryArray("BEGIN");
-    await client.queryArray(
-      "INSERT INTO timestamps(dt) values($1);",
-      new Date(),
-    );
-    await client.queryArray("INSERT INTO ids(id) VALUES(3);");
-    await client.queryArray("COMMIT");
-  } catch (e) {
-    await client.queryArray("ROLLBACK");
-    errored = true;
-    throw e;
-  } finally {
-    client.release();
-    released = true;
-  }
-  assertEquals(errored, undefined);
-  assertEquals(released, true);
-  assertEquals(POOL.available, 10);
+  await transaction.begin();
+  assertEquals(
+    client.current_transaction,
+    transaction_name,
+    "Client is locked out during transaction",
+  );
+  await transaction.queryArray`CREATE TEMP TABLE TEST (X INTEGER)`;
+  const savepoint = await transaction.savepoint("table_creation");
+  await transaction.queryArray`INSERT INTO TEST (X) VALUES (1)`;
+  // deno-lint-ignore camelcase
+  const query_1 = await transaction.queryObject<{ x: number }>
+    `SELECT X FROM TEST`;
+  assertEquals(
+    query_1.rows[0].x,
+    1,
+    "Operation was not executed inside transaction",
+  );
+  await transaction.rollback(savepoint);
+  // deno-lint-ignore camelcase
+  const query_2 = await transaction.queryObject<{ x: number }>
+    `SELECT X FROM TEST`;
+  assertEquals(
+    query_2.rowCount,
+    0,
+    "Rollback was not succesful inside transaction",
+  );
+  await transaction.commit();
+  assertEquals(
+    client.current_transaction,
+    null,
+    "Client was not released after transaction",
+  );
+  await client.release();
+});
+
+testPool(async function transactionIsolationLevelRepeatableRead(POOL) {
+  // deno-lint-ignore camelcase
+  const client_1 = await POOL.connect();
+  // deno-lint-ignore camelcase
+  const client_2 = await POOL.connect();
+
+  await client_1.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
+  await client_1.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
+  await client_1.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
+  // deno-lint-ignore camelcase
+  const transaction_rr = client_1.createTransaction(
+    "transactionIsolationLevelRepeatableRead",
+    { isolation_level: "repeatable_read" },
+  );
+  await transaction_rr.begin();
+
+  // This locks the current value of the test table
+  await transaction_rr.queryObject<{ x: number }>
+    `SELECT X FROM FOR_TRANSACTION_TEST`;
+
+  // Modify data outside the transaction
+  await client_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
+  // deno-lint-ignore camelcase
+  const { rows: query_1 } = await client_2.queryObject<{ x: number }>
+    `SELECT X FROM FOR_TRANSACTION_TEST`;
+  assertEquals(query_1, [{ x: 2 }]);
+
+  // deno-lint-ignore camelcase
+  const { rows: query_2 } = await transaction_rr.queryObject<
+    { x: number }
+  >`SELECT X FROM FOR_TRANSACTION_TEST`;
+  assertEquals(
+    query_2,
+    [{ x: 1 }],
+    "Repeatable read transaction should not be able to observe changes that happened after the transaction start",
+  );
+
+  await transaction_rr.commit();
+
+  // deno-lint-ignore camelcase
+  const { rows: query_3 } = await client_1.queryObject<{ x: number }>
+    `SELECT X FROM FOR_TRANSACTION_TEST`;
+  assertEquals(
+    query_3,
+    [{ x: 2 }],
+    "Main session should be able to observe changes after transaction ended",
+  );
+
+  await client_1.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
+
+  await client_1.release();
+  await client_2.release();
+});
+
+testPool(async function transactionIsolationLevelSerializable(POOL) {
+  // deno-lint-ignore camelcase
+  const client_1 = await POOL.connect();
+  // deno-lint-ignore camelcase
+  const client_2 = await POOL.connect();
+
+  await client_1.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
+  await client_1.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
+  await client_1.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
+  // deno-lint-ignore camelcase
+  const transaction_rr = client_1.createTransaction(
+    "transactionIsolationLevelRepeatableRead",
+    { isolation_level: "serializable" },
+  );
+  await transaction_rr.begin();
+
+  // This locks the current value of the test table
+  await transaction_rr.queryObject<{ x: number }>
+    `SELECT X FROM FOR_TRANSACTION_TEST`;
+
+  // Modify data outside the transaction
+  await client_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
+
+  await assertThrowsAsync(
+    () => transaction_rr.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 3`,
+    undefined,
+    undefined,
+    "A serializable transaction should throw if the data read in the transaction has been modified externally",
+  );
+
+  // deno-lint-ignore camelcase
+  const { rows: query_3 } = await client_1.queryObject<{ x: number }>
+    `SELECT X FROM FOR_TRANSACTION_TEST`;
+  assertEquals(
+    query_3,
+    [{ x: 2 }],
+    "Main session should be able to observe changes after transaction ended",
+  );
+
+  await client_1.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
+
+  await client_1.release();
+  await client_2.release();
+});
+
+testPool(async function transactionReadOnly(POOL) {
+  const client = await POOL.connect();
+
+  await client.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
+  await client.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
+  const transaction = client.createTransaction("transactionReadOnly", {
+    read_only: true,
+  });
+  await transaction.begin();
+
+  await assertThrowsAsync(
+    () => transaction.queryArray`DELETE FROM FOR_TRANSACTION_TEST`,
+    undefined,
+    "cannot execute DELETE in a read-only transaction",
+  );
+
+  await client.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
+
+  await client.release();
+});
+
+testPool(async function transactionSnapshot(POOL) {
+  // deno-lint-ignore camelcase
+  const client_1 = await POOL.connect();
+  // deno-lint-ignore camelcase
+  const client_2 = await POOL.connect();
+
+  await client_1.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
+  await client_1.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
+  await client_1.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
+  // deno-lint-ignore camelcase
+  const transaction_1 = client_1.createTransaction(
+    "transactionSnapshot1",
+    { isolation_level: "repeatable_read" },
+  );
+  await transaction_1.begin();
+
+  // This locks the current value of the test table
+  await transaction_1.queryObject<{ x: number }>
+    `SELECT X FROM FOR_TRANSACTION_TEST`;
+
+  // Modify data outside the transaction
+  await client_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
+
+  // deno-lint-ignore camelcase
+  const { rows: query_1 } = await transaction_1.queryObject<{ x: number }>
+    `SELECT X FROM FOR_TRANSACTION_TEST`;
+  assertEquals(
+    query_1,
+    [{ x: 1 }],
+    "External changes shouldn't affect repeatable read transaction",
+  );
+
+  const snapshot = await transaction_1.getSnapshot();
+
+  // deno-lint-ignore camelcase
+  const transaction_2 = client_2.createTransaction(
+    "transactionSnapshot2",
+    { isolation_level: "repeatable_read", snapshot },
+  );
+  await transaction_2.begin();
+
+  // deno-lint-ignore camelcase
+  const { rows: query_2 } = await transaction_2.queryObject<{ x: number }>
+    `SELECT X FROM FOR_TRANSACTION_TEST`;
+  assertEquals(
+    query_2,
+    [{ x: 1 }],
+    "External changes shouldn't affect repeatable read transaction with previous snapshot",
+  );
+
+  await transaction_1.commit();
+  await transaction_2.commit();
+
+  await client_1.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
+
+  await client_1.release();
+  await client_2.release();
+});
+
+testPool(async function transactionLock(POOL) {
+  const client = await POOL.connect();
+
+  const transaction = client.createTransaction("x");
+
+  await transaction.begin();
+  await transaction.queryArray`SELECT 1`;
+  await assertThrowsAsync(
+    () => client.queryArray`SELECT 1`,
+    undefined,
+    "This connection is currently locked",
+    "The connection is not being locked by the transaction",
+  );
+  await transaction.commit();
+
+  await client.queryArray`SELECT 1`;
+  assertEquals(
+    client.current_transaction,
+    null,
+    "Client was not released after transaction",
+  );
+
+  await client.release();
+});
+
+testPool(async function transactionCommitChain(POOL) {
+  const client = await POOL.connect();
+
+  const name = "transactionCommitChain";
+  const transaction = client.createTransaction(name);
+
+  await transaction.begin();
+
+  await transaction.commit({ chain: true });
+  assertEquals(
+    client.current_transaction,
+    name,
+    "Client shouldn't have been released on chained commit",
+  );
+
+  await transaction.commit();
+  assertEquals(
+    client.current_transaction,
+    null,
+    "Client was not released after transaction ended",
+  );
+
+  await client.release();
+});
+
+testPool(async function transactionLockIsReleasedOnSavepointLessRollback(POOL) {
+  const client = await POOL.connect();
+
+  const name = "transactionLockIsReleasedOnRollback";
+  const transaction = client.createTransaction(name);
+
+  await client.queryArray`CREATE TEMP TABLE MY_TEST (X INTEGER)`;
+  await transaction.begin();
+  await transaction.queryArray`INSERT INTO MY_TEST (X) VALUES (1)`;
+  // deno-lint-ignore camelcase
+  const { rows: query_1 } = await transaction.queryObject<{ x: number }>
+    `SELECT X FROM MY_TEST`;
+  assertEquals(query_1, [{ x: 1 }]);
+
+  await transaction.rollback({ chain: true });
+
+  assertEquals(
+    client.current_transaction,
+    name,
+    "Client shouldn't have been released after chained rollback",
+  );
+
+  await transaction.rollback();
+
+  // deno-lint-ignore camelcase
+  const { rowCount: query_2 } = await client.queryObject<{ x: number }>
+    `SELECT X FROM MY_TEST`;
+  assertEquals(query_2, 0);
+
+  assertEquals(
+    client.current_transaction,
+    null,
+    "Client was not released after rollback",
+  );
+
+  await client.release();
+});
+
+testPool(async function transactionRollbackValidations(POOL) {
+  const client = await POOL.connect();
+
+  const transaction = client.createTransaction(
+    "transactionRollbackValidations",
+  );
+  await transaction.begin();
+
+  await assertThrowsAsync(
+    // @ts-ignore This is made to check the two properties aren't passed at once
+    () => transaction.rollback({ savepoint: "unexistent", chain: true }),
+    undefined,
+    "The chain option can't be used alongside a savepoint on a rollback operation",
+  );
+
+  await transaction.commit();
+
+  await client.release();
+});
+
+testPool(async function transactionLockIsReleasedOnUnrecoverableError(POOL) {
+  const client = await POOL.connect();
+
+  const name = "transactionLockIsReleasedOnUnrecoverableError";
+  const transaction = client.createTransaction(name);
+
+  await transaction.begin();
+  await assertThrowsAsync(
+    () => transaction.queryArray`SELECT []`,
+    undefined,
+    `The transaction "${name}" has been aborted due to \`PostgresError:`,
+  );
+  assertEquals(client.current_transaction, null);
+
+  await transaction.begin();
+  await assertThrowsAsync(
+    () => transaction.queryObject`SELECT []`,
+    undefined,
+    `The transaction "${name}" has been aborted due to \`PostgresError:`,
+  );
+  assertEquals(client.current_transaction, null);
+
+  await client.release();
+});
+
+testPool(async function transactionSavepoints(POOL) {
+  const client = await POOL.connect();
+
+  // deno-lint-ignore camelcase
+  const savepoint_name = "a1";
+  const transaction = client.createTransaction("x");
+
+  await transaction.begin();
+  await transaction.queryArray`CREATE TEMP TABLE X (Y INT)`;
+  await transaction.queryArray`INSERT INTO X VALUES (1)`;
+  // deno-lint-ignore camelcase
+  const { rows: query_1 } = await transaction.queryObject<{ y: number }>
+    `SELECT Y FROM X`;
+  assertEquals(query_1, [{ y: 1 }]);
+
+  const savepoint = await transaction.savepoint(savepoint_name);
+
+  await transaction.queryArray`DELETE FROM X`;
+  // deno-lint-ignore camelcase
+  const { rowCount: query_2 } = await transaction.queryObject<{ y: number }>
+    `SELECT Y FROM X`;
+  assertEquals(query_2, 0);
+
+  await savepoint.update();
+
+  await transaction.queryArray`INSERT INTO X VALUES (2)`;
+  // deno-lint-ignore camelcase
+  const { rows: query_3 } = await transaction.queryObject<{ y: number }>
+    `SELECT Y FROM X`;
+  assertEquals(query_3, [{ y: 2 }]);
+
+  await transaction.rollback(savepoint);
+  // deno-lint-ignore camelcase
+  const { rowCount: query_4 } = await transaction.queryObject<{ y: number }>
+    `SELECT Y FROM X`;
+  assertEquals(query_4, 0);
+
+  assertEquals(
+    savepoint.instances,
+    2,
+    "An incorrect number of instances were created for a transaction savepoint",
+  );
+  await savepoint.release();
+  assertEquals(
+    savepoint.instances,
+    1,
+    "The instance for the savepoint was not released",
+  );
+
+  // This checks that the savepoint can be called by name as well
+  await transaction.rollback(savepoint_name);
+  // deno-lint-ignore camelcase
+  const { rows: query_5 } = await transaction.queryObject<{ y: number }>
+    `SELECT Y FROM X`;
+  assertEquals(query_5, [{ y: 1 }]);
+
+  await transaction.commit();
+
+  await client.release();
+});
+
+testPool(async function transactionSavepointValidations(POOL) {
+  const client = await POOL.connect();
+
+  const transaction = client.createTransaction("x");
+  await transaction.begin();
+
+  await assertThrowsAsync(
+    () => transaction.savepoint("1"),
+    undefined,
+    "The savepoint name can't begin with a number",
+  );
+
+  await assertThrowsAsync(
+    () =>
+      transaction.savepoint(
+        "this_savepoint_is_going_to_be_longer_than_sixty_three_characters",
+      ),
+    undefined,
+    "The savepoint name can't be longer than 63 characters",
+  );
+
+  await assertThrowsAsync(
+    () => transaction.savepoint("+"),
+    undefined,
+    "The savepoint name can only contain alphanumeric characters",
+  );
+
+  const savepoint = await transaction.savepoint("ABC1");
+  assertEquals(savepoint.name, "abc1");
+
+  assertEquals(
+    savepoint,
+    await transaction.savepoint("abc1"),
+    "Creating a savepoint with the same name should return the original one",
+  );
+  await savepoint.release();
+
+  await savepoint.release();
+
+  await assertThrowsAsync(
+    () => savepoint.release(),
+    undefined,
+    "This savepoint has no instances to release",
+  );
+
+  await assertThrowsAsync(
+    () => transaction.rollback(savepoint),
+    undefined,
+    `There are no savepoints of "abc1" left to rollback to`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction.rollback("UNEXISTENT"),
+    undefined,
+    `There is no "unexistent" savepoint registered in this transaction`,
+  );
+
+  await transaction.commit();
+
+  await client.release();
+});
+
+testPool(async function transactionOperationsThrowIfTransactionNotBegun(POOL) {
+  const client = await POOL.connect();
+
+  // deno-lint-ignore camelcase
+  const transaction_x = client.createTransaction("x");
+  // deno-lint-ignore camelcase
+  const transaction_y = client.createTransaction("y");
+
+  await transaction_x.begin();
+
+  await assertThrowsAsync(
+    () => transaction_y.begin(),
+    undefined,
+    `This client already has an ongoing transaction "x"`,
+  );
+
+  await transaction_x.commit();
+  await transaction_y.begin();
+  await assertThrowsAsync(
+    () => transaction_y.begin(),
+    undefined,
+    "This transaction is already open",
+  );
+
+  await transaction_y.commit();
+  await assertThrowsAsync(
+    () => transaction_y.commit(),
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction_y.commit(),
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction_y.queryArray`SELECT 1`,
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction_y.queryObject`SELECT 1`,
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction_y.rollback(),
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction_y.savepoint("SOME"),
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await client.release();
 });
diff --git a/tests/queries_test.ts b/tests/queries_test.ts
index e254ba01..c1c33c0f 100644
--- a/tests/queries_test.ts
+++ b/tests/queries_test.ts
@@ -5,6 +5,7 @@ import { getMainConfiguration } from "./config.ts";
 import { getTestClient } from "./helpers.ts";
 
 const CLIENT = new Client(getMainConfiguration());
+const CLIENT_2 = new Client(getMainConfiguration());
 
 const testClient = getTestClient(CLIENT, DEFAULT_SETUP);
 
@@ -212,3 +213,499 @@ testClient(async function templateStringQueryArray() {
 
   assertEquals(rows[0], [value_1, value_2]);
 });
+
+testClient(async function transaction() {
+  // deno-lint-ignore camelcase
+  const transaction_name = "x";
+  const transaction = CLIENT.createTransaction(transaction_name);
+
+  await transaction.begin();
+  assertEquals(
+    CLIENT.current_transaction,
+    transaction_name,
+    "Client is locked out during transaction",
+  );
+  await transaction.queryArray`CREATE TEMP TABLE TEST (X INTEGER)`;
+  const savepoint = await transaction.savepoint("table_creation");
+  await transaction.queryArray`INSERT INTO TEST (X) VALUES (1)`;
+  // deno-lint-ignore camelcase
+  const query_1 = await transaction.queryObject<{ x: number }>
+    `SELECT X FROM TEST`;
+  assertEquals(
+    query_1.rows[0].x,
+    1,
+    "Operation was not executed inside transaction",
+  );
+  await transaction.rollback(savepoint);
+  // deno-lint-ignore camelcase
+  const query_2 = await transaction.queryObject<{ x: number }>
+    `SELECT X FROM TEST`;
+  assertEquals(
+    query_2.rowCount,
+    0,
+    "Rollback was not succesful inside transaction",
+  );
+  await transaction.commit();
+  assertEquals(
+    CLIENT.current_transaction,
+    null,
+    "Client was not released after transaction",
+  );
+});
+
+testClient(async function transactionIsolationLevelRepeatableRead() {
+  await CLIENT_2.connect();
+
+  try {
+    await CLIENT.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
+    await CLIENT.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
+    await CLIENT.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
+    // deno-lint-ignore camelcase
+    const transaction_rr = CLIENT.createTransaction(
+      "transactionIsolationLevelRepeatableRead",
+      { isolation_level: "repeatable_read" },
+    );
+    await transaction_rr.begin();
+
+    // This locks the current value of the test table
+    await transaction_rr.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+
+    // Modify data outside the transaction
+    await CLIENT_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
+    // deno-lint-ignore camelcase
+    const { rows: query_1 } = await CLIENT_2.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+    assertEquals(query_1, [{ x: 2 }]);
+
+    // deno-lint-ignore camelcase
+    const { rows: query_2 } = await transaction_rr.queryObject<
+      { x: number }
+    >`SELECT X FROM FOR_TRANSACTION_TEST`;
+    assertEquals(
+      query_2,
+      [{ x: 1 }],
+      "Repeatable read transaction should not be able to observe changes that happened after the transaction start",
+    );
+
+    await transaction_rr.commit();
+
+    // deno-lint-ignore camelcase
+    const { rows: query_3 } = await CLIENT.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+    assertEquals(
+      query_3,
+      [{ x: 2 }],
+      "Main session should be able to observe changes after transaction ended",
+    );
+
+    await CLIENT.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
+  } finally {
+    await CLIENT_2.end();
+  }
+});
+
+testClient(async function transactionIsolationLevelSerializable() {
+  await CLIENT_2.connect();
+
+  try {
+    await CLIENT.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
+    await CLIENT.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
+    await CLIENT.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
+    // deno-lint-ignore camelcase
+    const transaction_rr = CLIENT.createTransaction(
+      "transactionIsolationLevelRepeatableRead",
+      { isolation_level: "serializable" },
+    );
+    await transaction_rr.begin();
+
+    // This locks the current value of the test table
+    await transaction_rr.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+
+    // Modify data outside the transaction
+    await CLIENT_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
+
+    await assertThrowsAsync(
+      () => transaction_rr.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 3`,
+      undefined,
+      undefined,
+      "A serializable transaction should throw if the data read in the transaction has been modified externally",
+    );
+
+    // deno-lint-ignore camelcase
+    const { rows: query_3 } = await CLIENT.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+    assertEquals(
+      query_3,
+      [{ x: 2 }],
+      "Main session should be able to observe changes after transaction ended",
+    );
+
+    await CLIENT.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
+  } finally {
+    await CLIENT_2.end();
+  }
+});
+
+testClient(async function transactionReadOnly() {
+  await CLIENT.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
+  await CLIENT.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
+  const transaction = CLIENT.createTransaction("transactionReadOnly", {
+    read_only: true,
+  });
+  await transaction.begin();
+
+  await assertThrowsAsync(
+    () => transaction.queryArray`DELETE FROM FOR_TRANSACTION_TEST`,
+    undefined,
+    "cannot execute DELETE in a read-only transaction",
+  );
+
+  await CLIENT.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
+});
+
+testClient(async function transactionSnapshot() {
+  await CLIENT_2.connect();
+
+  try {
+    await CLIENT.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
+    await CLIENT.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
+    await CLIENT.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
+    // deno-lint-ignore camelcase
+    const transaction_1 = CLIENT.createTransaction(
+      "transactionSnapshot1",
+      { isolation_level: "repeatable_read" },
+    );
+    await transaction_1.begin();
+
+    // This locks the current value of the test table
+    await transaction_1.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+
+    // Modify data outside the transaction
+    await CLIENT_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
+
+    // deno-lint-ignore camelcase
+    const { rows: query_1 } = await transaction_1.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+    assertEquals(
+      query_1,
+      [{ x: 1 }],
+      "External changes shouldn't affect repeatable read transaction",
+    );
+
+    const snapshot = await transaction_1.getSnapshot();
+
+    // deno-lint-ignore camelcase
+    const transaction_2 = CLIENT_2.createTransaction(
+      "transactionSnapshot2",
+      { isolation_level: "repeatable_read", snapshot },
+    );
+    await transaction_2.begin();
+
+    // deno-lint-ignore camelcase
+    const { rows: query_2 } = await transaction_2.queryObject<{ x: number }>
+      `SELECT X FROM FOR_TRANSACTION_TEST`;
+    assertEquals(
+      query_2,
+      [{ x: 1 }],
+      "External changes shouldn't affect repeatable read transaction with previous snapshot",
+    );
+
+    await transaction_1.commit();
+    await transaction_2.commit();
+
+    await CLIENT.queryArray`DROP TABLE FOR_TRANSACTION_TEST`;
+  } finally {
+    await CLIENT_2.end();
+  }
+});
+
+testClient(async function transactionLock() {
+  const transaction = CLIENT.createTransaction("x");
+
+  await transaction.begin();
+  await transaction.queryArray`SELECT 1`;
+  await assertThrowsAsync(
+    () => CLIENT.queryArray`SELECT 1`,
+    undefined,
+    "This connection is currently locked",
+    "The connection is not being locked by the transaction",
+  );
+  await transaction.commit();
+
+  await CLIENT.queryArray`SELECT 1`;
+  assertEquals(
+    CLIENT.current_transaction,
+    null,
+    "Client was not released after transaction",
+  );
+});
+
+testClient(async function transactionCommitChain() {
+  const name = "transactionCommitChain";
+  const transaction = CLIENT.createTransaction(name);
+
+  await transaction.begin();
+
+  await transaction.commit({ chain: true });
+  assertEquals(
+    CLIENT.current_transaction,
+    name,
+    "Client shouldn't have been released on chained commit",
+  );
+
+  await transaction.commit();
+  assertEquals(
+    CLIENT.current_transaction,
+    null,
+    "Client was not released after transaction ended",
+  );
+});
+
+testClient(async function transactionLockIsReleasedOnSavepointLessRollback() {
+  const name = "transactionLockIsReleasedOnRollback";
+  const transaction = CLIENT.createTransaction(name);
+
+  await CLIENT.queryArray`CREATE TEMP TABLE MY_TEST (X INTEGER)`;
+  await transaction.begin();
+  await transaction.queryArray`INSERT INTO MY_TEST (X) VALUES (1)`;
+  // deno-lint-ignore camelcase
+  const { rows: query_1 } = await transaction.queryObject<{ x: number }>
+    `SELECT X FROM MY_TEST`;
+  assertEquals(query_1, [{ x: 1 }]);
+
+  await transaction.rollback({ chain: true });
+
+  assertEquals(
+    CLIENT.current_transaction,
+    name,
+    "Client shouldn't have been released after chained rollback",
+  );
+
+  await transaction.rollback();
+
+  // deno-lint-ignore camelcase
+  const { rowCount: query_2 } = await CLIENT.queryObject<{ x: number }>
+    `SELECT X FROM MY_TEST`;
+  assertEquals(query_2, 0);
+
+  assertEquals(
+    CLIENT.current_transaction,
+    null,
+    "Client was not released after rollback",
+  );
+});
+
+testClient(async function transactionRollbackValidations() {
+  const transaction = CLIENT.createTransaction(
+    "transactionRollbackValidations",
+  );
+  await transaction.begin();
+
+  await assertThrowsAsync(
+    // @ts-ignore This is made to check the two properties aren't passed at once
+    () => transaction.rollback({ savepoint: "unexistent", chain: true }),
+    undefined,
+    "The chain option can't be used alongside a savepoint on a rollback operation",
+  );
+
+  await transaction.commit();
+});
+
+testClient(async function transactionLockIsReleasedOnUnrecoverableError() {
+  const name = "transactionLockIsReleasedOnUnrecoverableError";
+  const transaction = CLIENT.createTransaction(name);
+
+  await transaction.begin();
+  await assertThrowsAsync(
+    () => transaction.queryArray`SELECT []`,
+    undefined,
+    `The transaction "${name}" has been aborted due to \`PostgresError:`,
+  );
+  assertEquals(CLIENT.current_transaction, null);
+
+  await transaction.begin();
+  await assertThrowsAsync(
+    () => transaction.queryObject`SELECT []`,
+    undefined,
+    `The transaction "${name}" has been aborted due to \`PostgresError:`,
+  );
+  assertEquals(CLIENT.current_transaction, null);
+});
+
+testClient(async function transactionSavepoints() {
+  // deno-lint-ignore camelcase
+  const savepoint_name = "a1";
+  const transaction = CLIENT.createTransaction("x");
+
+  await transaction.begin();
+  await transaction.queryArray`CREATE TEMP TABLE X (Y INT)`;
+  await transaction.queryArray`INSERT INTO X VALUES (1)`;
+  // deno-lint-ignore camelcase
+  const { rows: query_1 } = await transaction.queryObject<{ y: number }>
+    `SELECT Y FROM X`;
+  assertEquals(query_1, [{ y: 1 }]);
+
+  const savepoint = await transaction.savepoint(savepoint_name);
+
+  await transaction.queryArray`DELETE FROM X`;
+  // deno-lint-ignore camelcase
+  const { rowCount: query_2 } = await transaction.queryObject<{ y: number }>
+    `SELECT Y FROM X`;
+  assertEquals(query_2, 0);
+
+  await savepoint.update();
+
+  await transaction.queryArray`INSERT INTO X VALUES (2)`;
+  // deno-lint-ignore camelcase
+  const { rows: query_3 } = await transaction.queryObject<{ y: number }>
+    `SELECT Y FROM X`;
+  assertEquals(query_3, [{ y: 2 }]);
+
+  await transaction.rollback(savepoint);
+  // deno-lint-ignore camelcase
+  const { rowCount: query_4 } = await transaction.queryObject<{ y: number }>
+    `SELECT Y FROM X`;
+  assertEquals(query_4, 0);
+
+  assertEquals(
+    savepoint.instances,
+    2,
+    "An incorrect number of instances were created for a transaction savepoint",
+  );
+  await savepoint.release();
+  assertEquals(
+    savepoint.instances,
+    1,
+    "The instance for the savepoint was not released",
+  );
+
+  // This checks that the savepoint can be called by name as well
+  await transaction.rollback(savepoint_name);
+  // deno-lint-ignore camelcase
+  const { rows: query_5 } = await transaction.queryObject<{ y: number }>
+    `SELECT Y FROM X`;
+  assertEquals(query_5, [{ y: 1 }]);
+
+  await transaction.commit();
+});
+
+testClient(async function transactionSavepointValidations() {
+  const transaction = CLIENT.createTransaction("x");
+  await transaction.begin();
+
+  await assertThrowsAsync(
+    () => transaction.savepoint("1"),
+    undefined,
+    "The savepoint name can't begin with a number",
+  );
+
+  await assertThrowsAsync(
+    () =>
+      transaction.savepoint(
+        "this_savepoint_is_going_to_be_longer_than_sixty_three_characters",
+      ),
+    undefined,
+    "The savepoint name can't be longer than 63 characters",
+  );
+
+  await assertThrowsAsync(
+    () => transaction.savepoint("+"),
+    undefined,
+    "The savepoint name can only contain alphanumeric characters",
+  );
+
+  const savepoint = await transaction.savepoint("ABC1");
+  assertEquals(savepoint.name, "abc1");
+
+  assertEquals(
+    savepoint,
+    await transaction.savepoint("abc1"),
+    "Creating a savepoint with the same name should return the original one",
+  );
+  await savepoint.release();
+
+  await savepoint.release();
+
+  await assertThrowsAsync(
+    () => savepoint.release(),
+    undefined,
+    "This savepoint has no instances to release",
+  );
+
+  await assertThrowsAsync(
+    () => transaction.rollback(savepoint),
+    undefined,
+    `There are no savepoints of "abc1" left to rollback to`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction.rollback("UNEXISTENT"),
+    undefined,
+    `There is no "unexistent" savepoint registered in this transaction`,
+  );
+
+  await transaction.commit();
+});
+
+testClient(async function transactionOperationsThrowIfTransactionNotBegun() {
+  // deno-lint-ignore camelcase
+  const transaction_x = CLIENT.createTransaction("x");
+  // deno-lint-ignore camelcase
+  const transaction_y = CLIENT.createTransaction("y");
+
+  await transaction_x.begin();
+
+  await assertThrowsAsync(
+    () => transaction_y.begin(),
+    undefined,
+    `This client already has an ongoing transaction "x"`,
+  );
+
+  await transaction_x.commit();
+  await transaction_y.begin();
+  await assertThrowsAsync(
+    () => transaction_y.begin(),
+    undefined,
+    "This transaction is already open",
+  );
+
+  await transaction_y.commit();
+  await assertThrowsAsync(
+    () => transaction_y.commit(),
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction_y.commit(),
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction_y.queryArray`SELECT 1`,
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction_y.queryObject`SELECT 1`,
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction_y.rollback(),
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+
+  await assertThrowsAsync(
+    () => transaction_y.savepoint("SOME"),
+    undefined,
+    `This transaction has not been started yet, make sure to use the "begin" method to do so`,
+  );
+});
