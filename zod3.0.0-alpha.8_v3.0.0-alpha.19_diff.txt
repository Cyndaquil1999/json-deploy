diff --git a/.eslintrc.js b/.eslintrc.js
index 9401ebdda..b19858a0b 100644
--- a/.eslintrc.js
+++ b/.eslintrc.js
@@ -36,6 +36,7 @@ module.exports = {
     "@typescript-eslint/no-empty-function": "off",
     "@typescript-eslint/ban-ts-comment": "off",
     "@typescript-eslint/no-non-null-assertion": "off",
+    "@typescript-eslint/no-empty-interface": "off",
     /**
      * ESLint core rules @see https://eslint.org/docs/rules/
      */
diff --git a/CHANGELOG.md b/CHANGELOG.md
index f7d712896..c2799a8d2 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,13 @@
 # Changelog
 
+### zod@3.0.0-alpha.9
+
+- Added `z.strictCreate`
+
+### zod@3.0.0-alpha.8
+
+- Allowing optional default values on ZodOptional
+
 ### zod@3.0.0-alpha.5
 
 March 17, 2021
diff --git a/README.md b/README.md
index 3bfb4ceb0..ba4c4957c 100644
--- a/README.md
+++ b/README.md
@@ -303,7 +303,7 @@ z.string().nonempty();
 
 > Check out [validator.js](https://github.com/validatorjs/validator.js) for a bunch of other useful string validation functions.
 
-### Custom error messages
+#### Custom error messages
 
 Optionally, you can pass in a second argument to provide a custom error message.
 
@@ -478,7 +478,7 @@ const deepPartialUser = user.deepPartial();
 
 > Important limitation: deep partials only work as expected in direct hierarchies of object schemas. A nested object schema can't be optional, nullable, contain refinements, contain transforms, etc.
 
-### Unrecognized keys
+#### Unrecognized keys
 
 By default Zod objects schemas strip out unrecognized keys during parsing.
 
@@ -786,7 +786,7 @@ const FishEnum = z.enum(fish);
 
 In that case, Zod isn't able to infer the individual enum elements; instead the inferred type will be `string` instead of `'Salmon' | 'Tuna' | 'Trout'`
 
-#### Autocompletion
+**Autocompletion**
 
 To get autocompletion with a Zod enum, use the `.enum` property of your schema:
 
@@ -943,7 +943,7 @@ const Category: z.ZodSchema<Category> = BaseCategory.merge(
 );
 ``` -->
 
-### JSON type
+#### JSON type
 
 If you want to validate any JSON value, you can use the snippet below.
 
@@ -960,7 +960,7 @@ jsonSchema.parse(data);
 
 Thanks to [ggoodman](https://github.com/ggoodman) for suggesting this.
 
-### Cyclical objects
+#### Cyclical objects
 
 Despite supporting recursive schemas, passing an cyclical data into Zod will cause an infinite loop.
 
diff --git a/coverage.svg b/coverage.svg
index 1a6699f17..8de378603 100644
--- a/coverage.svg
+++ b/coverage.svg
@@ -1 +1 @@
-<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="110" height="20" role="img" aria-label="Coverage: 94.2%"><title>Coverage: 94.2%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="110" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="47" height="20" fill="#4c1"/><rect width="110" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="855" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="370">94.2%</text><text x="855" y="140" transform="scale(.1)" fill="#fff" textLength="370">94.2%</text></g></svg>
\ No newline at end of file
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 94.06%"><title>Coverage: 94.06%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#4c1"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">94.06%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">94.06%</text></g></svg>
\ No newline at end of file
diff --git a/deno/lib/__tests__/default.test.ts b/deno/lib/__tests__/default.test.ts
index 3c6d6a225..b96d254e0 100644
--- a/deno/lib/__tests__/default.test.ts
+++ b/deno/lib/__tests__/default.test.ts
@@ -29,15 +29,18 @@ test("default with transform", () => {
   f2;
 });
 
-test("default on optional", () => {
+test("default on existing optional", () => {
   const stringWithDefault = z.string().optional().default("asdf");
   expect(stringWithDefault.parse(undefined)).toBe("asdf");
   expect(stringWithDefault).toBeInstanceOf(z.ZodOptional);
-  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodString);
+  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodOptional);
+  expect(stringWithDefault._def.innerType._def.innerType).toBeInstanceOf(
+    z.ZodString
+  );
   type inp = z.input<typeof stringWithDefault>;
   const f1: util.AssertEqual<inp, string | undefined> = true;
   type out = z.output<typeof stringWithDefault>;
-  const f2: util.AssertEqual<out, string> = true;
+  const f2: util.AssertEqual<out, string | undefined> = true;
   f1;
   f2;
 });
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 4e456fa23..fef7f80a2 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -41,9 +41,7 @@ export type output<T extends ZodType<any>> = T["_output"];
 export type { TypeOf as infer };
 
 export type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
-export interface ZodTypeDef {
-  accepts?: ZodType<any, any>;
-}
+export interface ZodTypeDef {}
 
 type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
 type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
@@ -357,25 +355,24 @@ export abstract class ZodType<
     return returnType;
   }
 
-  default<T extends util.noUndefined<Input>, This extends this = this>(
+  default<T extends Input, This extends this = this>(
     def: T
-  ): addDefaultToOptional<ZodOptionalType<This>>;
+  ): ZodOptional<This, true>;
   default<T extends () => Input, This extends this = this>(
     def: T
-  ): addDefaultToOptional<ZodOptionalType<This>>;
+  ): ZodOptional<This, true>;
   default(def: any) {
     const defaultValueFunc = typeof def === "function" ? def : () => def;
-    if (this instanceof ZodOptional) {
-      return new ZodOptional({
-        ...this._def,
-        defaultValue: defaultValueFunc,
-      }) as any;
-    }
-
+    // if (this instanceof ZodOptional) {
+    //   return new ZodOptional({
+    //     ...this._def,
+    //     defaultValue: defaultValueFunc,
+    //   }) as any;
+    // }
     return new ZodOptional({
       innerType: this,
       defaultValue: defaultValueFunc,
-    });
+    }) as any;
   }
 
   isOptional: () => boolean = () => this.safeParse(undefined).success;
@@ -1529,6 +1526,16 @@ export class ZodObject<
     }) as any;
   };
 
+  static strictCreate = <T extends ZodRawShape>(
+    shape: T
+  ): ZodObject<T, "strict"> => {
+    return new ZodObject({
+      shape: () => shape,
+      unknownKeys: "strict",
+      catchall: ZodNever.create(),
+    }) as any;
+  };
+
   static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
     return new ZodObject({
       shape,
@@ -2435,6 +2442,7 @@ export interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny>
 export type addDefaultToOptional<
   T extends ZodOptional<any, any>
 > = T extends ZodOptional<infer U, any> ? ZodOptional<U, true> : never;
+
 export type removeDefaultFromOptional<
   T extends ZodOptional<any, any>
 > = T extends ZodOptional<infer U, any> ? ZodOptional<U, false> : never;
@@ -2605,6 +2613,7 @@ const neverType = ZodNever.create;
 const voidType = ZodVoid.create;
 const arrayType = ZodArray.create;
 const objectType = ZodObject.create;
+const strictObjectType = ZodObject.strictCreate;
 const unionType = ZodUnion.create;
 const tupleType = ZodTuple.create;
 const recordType = ZodRecord.create;
@@ -2649,6 +2658,7 @@ export {
   promiseType as promise,
   recordType as record,
   setType as set,
+  strictObjectType as strictObject,
   stringType as string,
   effectsType as transformer,
   tupleType as tuple,
diff --git a/package.json b/package.json
index d628346b5..aa1f0d179 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.0.0-alpha.7",
+  "version": "3.0.0-alpha.19",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/cjs/index.js",
   "types": "./lib/cjs/index.d.ts",
@@ -65,6 +65,7 @@
     "eslint-config-prettier": "^7.1.0",
     "eslint-plugin-import": "^2.22.1",
     "eslint-plugin-simple-import-sort": "^7.0.0",
+    "eslint-plugin-unused-imports": "^1.1.0",
     "husky": "^4.3.4",
     "jest": "^26.6.3",
     "lint-staged": "^10.5.3",
@@ -85,8 +86,5 @@
       "yarn fix:lint",
       "yarn fix:format"
     ]
-  },
-  "dependencies": {
-    "eslint-plugin-unused-imports": "^1.1.0"
   }
 }
\ No newline at end of file
diff --git a/src/__tests__/default.test.ts b/src/__tests__/default.test.ts
index af745b6f9..2cc79f58a 100644
--- a/src/__tests__/default.test.ts
+++ b/src/__tests__/default.test.ts
@@ -28,15 +28,18 @@ test("default with transform", () => {
   f2;
 });
 
-test("default on optional", () => {
+test("default on existing optional", () => {
   const stringWithDefault = z.string().optional().default("asdf");
   expect(stringWithDefault.parse(undefined)).toBe("asdf");
   expect(stringWithDefault).toBeInstanceOf(z.ZodOptional);
-  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodString);
+  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodOptional);
+  expect(stringWithDefault._def.innerType._def.innerType).toBeInstanceOf(
+    z.ZodString
+  );
   type inp = z.input<typeof stringWithDefault>;
   const f1: util.AssertEqual<inp, string | undefined> = true;
   type out = z.output<typeof stringWithDefault>;
-  const f2: util.AssertEqual<out, string> = true;
+  const f2: util.AssertEqual<out, string | undefined> = true;
   f1;
   f2;
 });
diff --git a/src/types.ts b/src/types.ts
index 4158bd932..e3335ae60 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -41,9 +41,7 @@ export type output<T extends ZodType<any>> = T["_output"];
 export type { TypeOf as infer };
 
 export type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
-export interface ZodTypeDef {
-  accepts?: ZodType<any, any>;
-}
+export interface ZodTypeDef {}
 
 type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
 type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
@@ -357,25 +355,24 @@ export abstract class ZodType<
     return returnType;
   }
 
-  default<T extends util.noUndefined<Input>, This extends this = this>(
+  default<T extends Input, This extends this = this>(
     def: T
-  ): addDefaultToOptional<ZodOptionalType<This>>;
+  ): ZodOptional<This, true>;
   default<T extends () => Input, This extends this = this>(
     def: T
-  ): addDefaultToOptional<ZodOptionalType<This>>;
+  ): ZodOptional<This, true>;
   default(def: any) {
     const defaultValueFunc = typeof def === "function" ? def : () => def;
-    if (this instanceof ZodOptional) {
-      return new ZodOptional({
-        ...this._def,
-        defaultValue: defaultValueFunc,
-      }) as any;
-    }
-
+    // if (this instanceof ZodOptional) {
+    //   return new ZodOptional({
+    //     ...this._def,
+    //     defaultValue: defaultValueFunc,
+    //   }) as any;
+    // }
     return new ZodOptional({
       innerType: this,
       defaultValue: defaultValueFunc,
-    });
+    }) as any;
   }
 
   isOptional: () => boolean = () => this.safeParse(undefined).success;
@@ -1529,6 +1526,16 @@ export class ZodObject<
     }) as any;
   };
 
+  static strictCreate = <T extends ZodRawShape>(
+    shape: T
+  ): ZodObject<T, "strict"> => {
+    return new ZodObject({
+      shape: () => shape,
+      unknownKeys: "strict",
+      catchall: ZodNever.create(),
+    }) as any;
+  };
+
   static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
     return new ZodObject({
       shape,
@@ -2435,6 +2442,7 @@ export interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny>
 export type addDefaultToOptional<
   T extends ZodOptional<any, any>
 > = T extends ZodOptional<infer U, any> ? ZodOptional<U, true> : never;
+
 export type removeDefaultFromOptional<
   T extends ZodOptional<any, any>
 > = T extends ZodOptional<infer U, any> ? ZodOptional<U, false> : never;
@@ -2605,6 +2613,7 @@ const neverType = ZodNever.create;
 const voidType = ZodVoid.create;
 const arrayType = ZodArray.create;
 const objectType = ZodObject.create;
+const strictObjectType = ZodObject.strictCreate;
 const unionType = ZodUnion.create;
 const tupleType = ZodTuple.create;
 const recordType = ZodRecord.create;
@@ -2649,6 +2658,7 @@ export {
   promiseType as promise,
   recordType as record,
   setType as set,
+  strictObjectType as strictObject,
   stringType as string,
   effectsType as transformer,
   tupleType as tuple,
