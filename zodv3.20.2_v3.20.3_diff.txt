diff --git a/.github/stale.yml b/.github/stale.yml
index 84afe418b..46c8b7cef 100644
--- a/.github/stale.yml
+++ b/.github/stale.yml
@@ -1,10 +1,10 @@
 # Number of days of inactivity before an issue becomes stale
-daysUntilStale: 60
+daysUntilStale: 90
 # Number of days of inactivity before a stale issue is closed
-daysUntilClose: 7
+daysUntilClose: 30
 # Issues with these labels will never be considered stale
-# exemptLabels:
-#   - pinned
+exemptLabels:
+  - enhancement
 #   - security
 # Label to use when marking an issue as stale
 staleLabel: stale
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 0ec91d3bc..a18ea6f14 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,9 @@
 # Changelog
 
+## Release notes are now stored in Github Releases: https://github.com/colinhacks/zod/releases
+
+## Previous Releases
+
 ### 3.10
 
 - New parser that allows parsing to continue after non-fatal errors have occurred. This allows Zod to surface more errors to the user at once.
diff --git a/ERROR_HANDLING.md b/ERROR_HANDLING.md
index 22d61a61a..f2806f4ff 100644
--- a/ERROR_HANDLING.md
+++ b/ERROR_HANDLING.md
@@ -53,7 +53,7 @@ _Every_ ZodIssue has these fields:
 | ZodIssueCode.too_small           | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `minimum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the minimum is included in the range of acceptable values.<br>                                                                                                                   |
 | ZodIssueCode.too_big             | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `maximum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the maximum is included in the range of acceptable values.<br>                                                                                                                   |
 | ZodIssueCode.not_multiple_of     | `multipleOf: number` <br>The value the number should be a multiple of.<br>                                                                                                                                                                                                                                                                                           |
-| ZodIssueCode.custom              | `params: { [k: string]: any }` <br> This is the error code throw by refinements (unless you are using `superRefine` in which case it's possible to throw issues of any `code`). You are able to pass in a `params` object here that is available in your custom error maps (see [ZodErrorMap](#Customizing-errors-with-ZodErrorMap) below for details on error maps) |
+| ZodIssueCode.custom              | `params: { [k: string]: any }` <br> This is the error code throw by refinements (unless you are using `superRefine` in which case it's possible to throw issues of any `ZodIssueCode`). You are able to pass in a `params` object here that is available in your custom error maps (see [ZodErrorMap](#Customizing-errors-with-ZodErrorMap) below for details on error maps) |
 
 <!--
 | ZodIssueCode.nonempty_array_is_empty | _no additional properties_                                      |
@@ -178,7 +178,7 @@ z.setErrorMap(customErrorMap);
 
 - `ctx: { defaultError: string; data: any }`
 
-  - `ctx.default` is the error message generated by the default error map. If you only want to override the message for a single type of error, you can do that. Just return `defaultError` for everything
+  - `ctx.defaultError` is the error message generated by the default error map. If you only want to override the message for a single type of error, you can do that. Just return `{ message: ctx.defaultError }` for everything else.
 
   - `ctx.data` contains the data that was passed into `.parse`. You can use this to customize the error message.
 
@@ -192,7 +192,7 @@ But how is the value of `ctx.defaultError` determined?
 
 Error messages in Zod are generated by passing metadata about a validation issue through a chain of error maps. Error maps with higher priority override messages generated by maps with lower priority.
 
-The lowest priority map is the `defaultErrorMap`, which defined in [`src/ZodError.ts`](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts). This produces the default error message for all issues in Zod.
+The lowest priority map is the `defaultErrorMap`, which defined in [`src/errors.ts`](https://github.com/colinhacks/zod/blob/master/src/errors.ts). This produces the default error message for all issues in Zod.
 
 ### Global error map
 
@@ -200,7 +200,7 @@ This message is then passed as `ctx.defaultError` into `overrideErrorMap`. This
 
 ```ts
 const myErrorMap: z.ZodErrorMap = /* ... */;
-z.setErrorMap(errorMap);
+z.setErrorMap(myErrorMap);
 ```
 
 ### Schema-bound error map
@@ -352,8 +352,8 @@ As you can see, the result is an object that denormalizes the issues array into
 ```tsx
 const FormData = z.object({ ... });
 
-function Errors(props: {errors?: string[] }){
-  if(!errors.length) return null;
+function Errors(props: {errors?: string[]}){
+  if(!props.errors?.length) return null;
   return <div>{props.errors.map(err => <p>{err}</p>)}</div>
 }
 
diff --git a/README.md b/README.md
index 1267c8b05..6c2711ec5 100644
--- a/README.md
+++ b/README.md
@@ -47,10 +47,12 @@
   - [Sponsors](#sponsors)
   - [Ecosystem](#ecosystem)
 - [Installation](#installation)
-  - [Node/npm](#nodenpm)
-  - [Deno](#deno)
+  - [Requirements](#requirements)
+  - [Node/npm](#from-npm-nodebun)
+  - [Deno](#from-denolandx-deno)
 - [Basic usage](#basic-usage)
 - [Primitives](#primitives)
+- [Coercion for primitives](#coercion-for-primitives)
 - [Literals](#literals)
 - [Strings](#strings)
 - [Numbers](#numbers)
@@ -101,6 +103,7 @@
   - [.superRefine](#superRefine)
   - [.transform](#transform)
   - [.default](#default)
+  - [.describe](#describe)
   - [.catch](#catch)
   - [.optional](#optional)
   - [.nullable](#nullable)
@@ -355,12 +358,15 @@ There are a growing number of tools that are built atop or support Zod natively!
 #### Form integrations
 
 - [`react-hook-form`](https://github.com/react-hook-form/resolvers#zod): A first-party Zod resolver for React Hook Form.
-- [`zod-validation-error`](https://github.com/causaly/zod-validation-error): Generate user-friendly error messages from `ZodError`s
+- [`zod-validation-error`](https://github.com/causaly/zod-validation-error): Generate user-friendly error messages from `ZodError`s.
 - [`zod-formik-adapter`](https://github.com/robertLichtnow/zod-formik-adapter): A community-maintained Formik adapter for Zod.
 - [`react-zorm`](https://github.com/esamattis/react-zorm): Standalone `<form>` generation and validation for React using Zod.
 - [`zodix`](https://github.com/rileytomasek/zodix): Zod utilities for FormData and URLSearchParams in Remix loaders and actions.
+- [`remix-params-helper`](https://github.com/kiliman/remix-params-helper): Simplify integration of Zod with standard URLSearchParams and FormData for Remix apps.
 - [`formik-validator-zod`](https://github.com/glazy/formik-validator-zod): Formik-compliant validator library that simplifies using Zod with Formik.
 - [`zod-i18n-map`](https://github.com/aiji42/zod-i18n): Useful for translating Zod error messages.
+- [`@modular-forms/solid`](https://github.com/fabian-hiller/modular-forms): Modular form library for SolidJS that supports Zod for validation.
+- [`houseform`](https://github.com/crutchcorn/houseform/): A React form library that uses Zod for validation.
 
 #### Zod to X
 
@@ -379,15 +385,16 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`@runtyping/zod`](https://github.com/johngeorgewright/runtyping/tree/master/packages/zod): Generate Zod from static types & JSON schema.
 - [`json-schema-to-zod`](https://github.com/StefanTerdell/json-schema-to-zod): Convert your [JSON Schemas](https://json-schema.org/) into Zod schemas. [Live demo](https://StefanTerdell.github.io/json-schema-to-zod-react/).
 - [`json-to-zod`](https://github.com/rsinohara/json-to-zod): Convert JSON objects into Zod schemas. [Live demo](https://rsinohara.github.io/json-to-zod-react/).
-- [`graphql-codegen-typescript-validation-schema`](https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema): GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema
+- [`graphql-codegen-typescript-validation-schema`](https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema): GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema.
 - [`zod-prisma`](https://github.com/CarterGrimmeisen/zod-prisma): Generate Zod schemas from your Prisma schema.
 - [`Supervillain`](https://github.com/Southclaws/supervillain): Generate Zod schemas from your Go structs.
 - [`prisma-zod-generator`](https://github.com/omar-dulaimi/prisma-zod-generator): Emit Zod schemas from your Prisma schema.
 - [`prisma-trpc-generator`](https://github.com/omar-dulaimi/prisma-trpc-generator): Emit fully implemented tRPC routers and their validation schemas using Zod.
+- [`zod-prisma-types`](https://github.com/chrishoermann/zod-prisma-types) Create Zod types from your Prisma models.
 
 #### Mocking
 
-- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/Marak/Faker.js).
+- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/faker-js/faker).
 - [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.
 
 #### Powered by Zod
@@ -395,7 +402,11 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`slonik`](https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference): Node.js Postgres client with strong Zod integration.
 - [`soly`](https://github.com/mdbetancourt/soly): Create CLI applications with zod.
 - [`zod-xlsx`](https://github.com/sidwebworks/zod-xlsx): A xlsx based resource validator using Zod schemas.
-- [`znv`](https://github.com/lostfictions/znv): Type-safe environment parsing and validation for Node.js with Zod schemas
+- [`znv`](https://github.com/lostfictions/znv): Type-safe environment parsing and validation for Node.js with Zod schemas.
+
+#### Utilities for Zod
+
+- [`zod_utilz`](https://github.com/JacobWeisenburger/zod_utilz): Framework agnostic utilities for Zod.
 
 ## Installation
 
@@ -503,8 +514,53 @@ z.unknown();
 z.never();
 ```
 
+## Coercion for primitives
+
+Zod now provides a more convenient way to coerce primitive values.
+
+```ts
+const schema = z.coerce.string();
+schema.parse("tuna"); // => "tuna"
+schema.parse(12); // => "12"
+schema.parse(true); // => "true"
+```
+
+During the parsing step, the input is passed through the `String()` function, which is a JavaScript built-in for coercing data into strings. Note that the returned schema is a `ZodString` instance so you can use all string methods.
+
+```ts
+z.coerce.string().email().min(5);
+```
+
+All primitive types support coercion.
+
+```ts
+z.coerce.string(); // String(input)
+z.coerce.number(); // Number(input)
+z.coerce.boolean(); // Boolean(input)
+z.coerce.bigint(); // BigInt(input)
+z.coerce.date(); // new Date(input)
+```
+
+**Boolean coercion**
+
+Zod's boolean coercion is very simple! It passes the value into the `Boolean(value)` function, that's it. Any truthy value will resolve to `true`, any falsy value will resolve to `false`.
+
+```ts
+z.coerce.boolean().parse("tuna"); // => true
+z.coerce.boolean().parse("true"); // => true
+z.coerce.boolean().parse("false"); // => true
+z.coerce.boolean().parse(1); // => true
+z.coerce.boolean().parse([]); // => true
+
+z.coerce.boolean().parse(0); // => false
+z.coerce.boolean().parse(undefined); // => false
+z.coerce.boolean().parse(null); // => false
+```
+
 ## Literals
 
+Literal schemas represent a [literal type](https://www.typescriptlang.org/docs/handbook/literal-types.html), like `"hello world"` or `5`.
+
 ```ts
 const tuna = z.literal("tuna");
 const twelve = z.literal(12);
@@ -532,6 +588,7 @@ z.string().email();
 z.string().url();
 z.string().uuid();
 z.string().cuid();
+z.string().cuid2();
 z.string().regex(regex);
 z.string().startsWith(string);
 z.string().endsWith(string);
@@ -564,49 +621,6 @@ z.string().endsWith(".com", { message: "Only .com domains allowed" });
 z.string().datetime({ message: "Invalid datetime string! Must be UTC." });
 ```
 
-## Coercion for primitives
-
-Zod now provides a more convenient way to coerce primitive values.
-
-```ts
-const schema = z.coerce.string();
-schema.parse("tuna"); // => "tuna"
-schema.parse(12); // => "12"
-schema.parse(true); // => "true"
-```
-
-During the parsing step, the input is passed through the `String()` function, which is a JavaScript built-in for coercing data into strings. Note that the returned schema is a `ZodString` instance so you can use all string methods.
-
-```ts
-z.coerce.string().email().min(5);
-```
-
-All primitive types support coercion.
-
-```ts
-z.coerce.string(); // String(input)
-z.coerce.number(); // Number(input)
-z.coerce.boolean(); // Boolean(input)
-z.coerce.bigint(); // BigInt(input)
-z.coerce.date(); // new Date(input)
-```
-
-**Boolean coercion**
-
-Zod's boolean coercion is very simple! It passes the value into the `Boolean(value)` function, that's it. Any truthy value will resolve to `true`, any falsy value will resolve to `false`.
-
-```ts
-z.coerce.boolean().parse("tuna"); // => true
-z.coerce.boolean().parse("true"); // => true
-z.coerce.boolean().parse("false"); // => true
-z.coerce.boolean().parse(1); // => true
-z.coerce.boolean().parse([]); // => true
-
-z.coerce.boolean().parse(0); // => false
-z.coerce.boolean().parse(undefined); // => false
-z.coerce.boolean().parse(null); // => false
-```
-
 ### Datetime validation
 
 The `z.string().datetime()` method defaults to UTC validation: no timezone offsets with arbitrary sub-second decimal precision.
@@ -627,6 +641,8 @@ const datetime = z.string().datetime({ offset: true });
 
 datetime.parse("2020-01-01T00:00:00+02:00"); // pass
 datetime.parse("2020-01-01T00:00:00.123+02:00"); // pass (millis optional)
+datetime.parse("2020-01-01T00:00:00.123+0200"); // pass (millis optional)
+datetime.parse("2020-01-01T00:00:00.123+02"); // pass (only offset hours)
 datetime.parse("2020-01-01T00:00:00Z"); // pass (Z still supported)
 ```
 
@@ -724,21 +740,28 @@ z.date().min(new Date("1900-01-01"), { message: "Too old" });
 z.date().max(new Date(), { message: "Too young!" });
 ```
 
-**Supporting date strings**
+**Coercion to Date**
 
-To write a schema that accepts either a `Date` or a date string, use [`z.preprocess`](#preprocess).
+Since [zod 3.20](https://github.com/colinhacks/zod/releases/tag/v3.20), use [`z.coerce.date()`](#coercion-for-primitives) to pass the input through `new Date(input)`.
 
 ```ts
-const dateSchema = z.preprocess((arg) => {
-  if (typeof arg == "string" || arg instanceof Date) return new Date(arg);
-}, z.date());
+const dateSchema = z.coerce.date();
 type DateSchema = z.infer<typeof dateSchema>;
 // type DateSchema = Date
 
-dateSchema.safeParse(new Date("1/12/22")); // success: true
-dateSchema.safeParse("2022-01-12T00:00:00.000Z"); // success: true
+/* valid dates */
+console.log(dateSchema.safeParse("2023-01-10T00:00:00.000Z").success); // true
+console.log(dateSchema.safeParse("2023-01-10").success); // true
+console.log(dateSchema.safeParse("1/10/23").success); // true
+console.log(dateSchema.safeParse(new Date("1/10/23")).success); // true
+
+/* invalid dates */
+console.log(dateSchema.safeParse("2023-13-10").success); // false
+console.log(dateSchema.safeParse("0000-00-00").success); // false
 ```
 
+For older zod versions, use [`z.preprocess`](#preprocess) like [described in this thread](https://github.com/colinhacks/zod/discussions/879#discussioncomment-2036276).
+
 ## Zod enums
 
 ```ts
@@ -781,7 +804,7 @@ FishEnum.enum;
 You can also retrieve the list of options as a tuple with the `.options` property:
 
 ```ts
-FishEnum.options; // ["Salmon", "Tuna", "Trout"]);
+FishEnum.options; // ["Salmon", "Tuna", "Trout"];
 ```
 
 ## Native enums
@@ -1265,12 +1288,28 @@ stringOrNumber.parse(14); // passes
 
 Zod will test the input against each of the "options" in order and return the first value that validates successfully.
 
-For convenience, you can also use the `.or` method:
+For convenience, you can also use the [`.or` method](#or):
 
 ```ts
 const stringOrNumber = z.string().or(z.number());
 ```
 
+**Optional string validation:**
+
+To validate an optional form input, you can union the desired string validation with an empty string [literal](#literals).
+
+This example validates an input that is optional but needs to contain a [valid URL](#strings):
+
+```ts
+const optionalUrl = z.union([z.string().url().nullish(), z.literal("")]);
+
+console.log(optionalUrl.safeParse(undefined).success); // true
+console.log(optionalUrl.safeParse(null).success); // true
+console.log(optionalUrl.safeParse("").success); // true
+console.log(optionalUrl.safeParse("https://zod.dev").success); // true
+console.log(optionalUrl.safeParse("not a valid url").success); // false
+```
+
 ## Discriminated unions
 
 A discriminated union is a union of object schemas that all share a particular key.
@@ -1283,7 +1322,7 @@ type MyUnion =
 
 Such unions can be represented with the `z.discriminatedUnion` method. This enables faster evaluation, because Zod can check the _discriminator key_ (`status` in the example above) to determine which schema should be used to parse the input. This makes parsing more efficient and lets Zod report friendlier errors.
 
-With the basic union method the input is tested against each of the provided "options", and in the case of invalidity, issues for all the "options" are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the "options", testing against it, and showing only the issues related to this "option".
+With the basic union method, the input is tested against each of the provided "options", and in the case of invalidity, issues for all the "options" are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the "options", testing against it, and showing only the issues related to this "option".
 
 ```ts
 const myUnion = z.discriminatedUnion("status", [
@@ -1291,7 +1330,7 @@ const myUnion = z.discriminatedUnion("status", [
   z.object({ status: z.literal("failed"), error: z.instanceof(Error) }),
 ]);
 
-myUnion.parse({ type: "success", data: "yippie ki yay" });
+myUnion.parse({ status: "success", data: "yippie ki yay" });
 ```
 
 ## Records
@@ -1432,55 +1471,67 @@ type Teacher = z.infer<typeof Teacher>;
 You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a "type hint".
 
 ```ts
-interface Category {
-  name: string;
+const baseCategorySchema = z.object({
+  name: z.string(),
+});
+
+type Category = z.infer<typeof baseCategorySchema> & {
   subcategories: Category[];
-}
+};
 
-// cast to z.ZodType<Category>
-const Category: z.ZodType<Category> = z.lazy(() =>
-  z.object({
-    name: z.string(),
-    subcategories: z.array(Category),
-  })
-);
+const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
+  subcategories: z.lazy(() => categorySchema.array()),
+});
 
-Category.parse({
+categorySchema.parse({
   name: "People",
   subcategories: [
     {
       name: "Politicians",
-      subcategories: [{ name: "Presidents", subcategories: [] }],
+      subcategories: [
+        {
+          name: "Presidents",
+          subcategories: [],
+        },
+      ],
     },
   ],
 }); // passes
 ```
 
-Unfortunately this code is a bit duplicative, since you're declaring the types twice: once in the interface and again in the Zod definition.
+Thanks to [crasite](https://github.com/crasite) for this example.
+
+### ZodType with ZodEffects
 
-<!-- If your schema has lots of primitive fields, there's a way of reducing the amount of duplication:
+When using `z.ZodType` with `z.ZodEffects` (
+[`.refine`](https://github.com/colinhacks/zod#refine),
+[`.transform`](https://github.com/colinhacks/zod#transform),
+[`preprocess`](https://github.com/colinhacks/zod#preprocess),
+etc...
+), you will need to define the input and output types of the schema. `z.ZodType<Output, z.ZodTypeDef, Input>`
 
 ```ts
-// define all the non-recursive stuff here
-const BaseCategory = z.object({
-  name: z.string(),
-  tags: z.array(z.string()),
-  itemCount: z.number(),
+const isValidId = (id: string): id is `${string}/${string}` =>
+  id.split("/").length === 2;
+
+const baseSchema = z.object({
+  id: z.string().refine(isValidId),
 });
 
-// create an interface that extends the base schema
-interface Category extends z.infer<typeof BaseCategory> {
-  subcategories: Category[];
-}
+type Input = z.input<typeof baseSchema> & {
+  children: Input[];
+};
 
-// merge the base schema with
-// a new Zod schema containing relations
-const Category: z.ZodType<Category> = BaseCategory.merge(
-  z.object({
-    subcategories: z.lazy(() => z.array(Category)),
-  })
-);
-``` -->
+type Output = z.output<typeof baseSchema> & {
+  children: Output[];
+};
+
+const schema: z.ZodType<Output, z.ZodTypeDef, Input> = baseSchema.extend({
+  children: z.lazy(() => schema.array()),
+});
+```
+
+Thanks to [marcus13371337](https://github.com/marcus13371337) and [JoelBeeldi](https://github.com/JoelBeeldi) for this example.
 
 ### JSON type
 
@@ -1679,21 +1730,20 @@ Given any Zod schema, you can call its `.parse` method to check `data` is valid.
 const stringSchema = z.string();
 
 stringSchema.parse("fish"); // => returns "fish"
-stringSchema.parse(12); // throws Error('Non-string type: number');
+stringSchema.parse(12); // throws error
 ```
 
 ### `.parseAsync`
 
 `.parseAsync(data:unknown): Promise<T>`
 
-If you use asynchronous [refinements](#refine) or [transforms](#transform) (more on those later), you'll need to use `.parseAsync`
+If you use asynchronous [refinements](#refine) or [transforms](#transform) (more on those later), you'll need to use `.parseAsync`.
 
 ```ts
-const stringSchema1 = z.string().refine(async (val) => val.length < 20);
-const value1 = await stringSchema.parseAsync("hello"); // => hello
+const stringSchema = z.string().refine(async (val) => val.length <= 8);
 
-const stringSchema2 = z.string().refine(async (val) => val.length > 20);
-const value2 = await stringSchema.parseAsync("hello"); // => throws
+await stringSchema.parseAsync("hello"); // => returns "hello"
+await stringSchema.parseAsync("hello world"); // => throws error
 ```
 
 ### `.safeParse`
@@ -1710,7 +1760,7 @@ stringSchema.safeParse("billie");
 // => { success: true; data: 'billie' }
 ```
 
-The result is a _discriminated union_ so you can handle errors very conveniently:
+The result is a _discriminated union_, so you can handle errors very conveniently:
 
 ```ts
 const result = stringSchema.safeParse("billie");
@@ -1778,7 +1828,7 @@ type RefineParams = {
 };
 ```
 
-For advanced cases, the second argument can also be a function that returns `RefineParams`/
+For advanced cases, the second argument can also be a function that returns `RefineParams`.
 
 ```ts
 const longString = z.string().refine(
@@ -1889,7 +1939,7 @@ const Strings = z.array(z.string()).superRefine((val, ctx) => {
 
 You can add as many issues as you like. If `ctx.addIssue` is _not_ called during the execution of the function, validation passes.
 
-Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` you can create any issue of any code. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).
+Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` it's possible to throw issues of any `ZodIssueCode`. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).
 
 #### Abort early
 
@@ -1918,7 +1968,7 @@ const schema = z.number().superRefine((val, ctx) => {
 
 #### Type refinements
 
-If you provide a [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) to `.refine()` or `superRefine()`, the resulting type will be narrowed down to your predicate's type. This is useful if you are mixing multiple chained refinements and transformations:
+If you provide a [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) to `.refine()` or `.superRefine()`, the resulting type will be narrowed down to your predicate's type. This is useful if you are mixing multiple chained refinements and transformations:
 
 ```ts
 const schema = z
@@ -1933,15 +1983,15 @@ const schema = z
         code: z.ZodIssueCode.custom, // customize your issue
         message: "object should exist",
       });
-      return false;
     }
-    return true;
+
+    return z.NEVER; // The return value is not used, but we need to return something to satisfy the typing
   })
   // here, TS knows that arg is not null
   .refine((arg) => arg.first === "bob", "`first` is not `bob`!");
 ```
 
-> ⚠️ You must **still** call `ctx.addIssue()` if using `superRefine()` with a type predicate function. Otherwise the refinement won't be validated.
+> ⚠️ You **must** use `ctx.addIssue()` instead of returning a boolean value to indicate whether the validation passes. If `ctx.addIssue` is _not_ called during the execution of the function, validation passes.
 
 ### `.transform`
 
@@ -1968,12 +2018,12 @@ emailToDomain.parse("colinhacks@example.com"); // => example.com
 
 #### Validating during transform
 
-The `.transform` method can simultaneously validate and transform the value. This is often simpler and less duplicative than chaining `refine` and `validate`.
+The `.transform` method can simultaneously validate and transform the value. This is often simpler and less duplicative than chaining `transform` and `refine`.
 
-As with `.superRefine`, the transform function receives a `ctx` object with a `addIssue` method that can be used to register validation issues.
+As with `.superRefine`, the transform function receives a `ctx` object with an `addIssue` method that can be used to register validation issues.
 
 ```ts
-const Strings = z.string().transform((val, ctx) => {
+const numberInString = z.string().transform((val, ctx) => {
   const parsed = parseInt(val);
   if (isNaN(parsed)) {
     ctx.addIssue({
@@ -2044,6 +2094,19 @@ Conceptually, this is how Zod processes default values:
 1. If the input is `undefined`, the default value is returned
 2. Otherwise, the data is parsed using the base schema
 
+### `.describe`
+
+Use `.describe()` to add a `description` property to the resulting schema.
+
+```ts
+const documentedString = z
+  .string()
+  .describe("A useful bit of text, if you know what to do with it.");
+documentedString.description; // A useful bit of text…
+```
+
+This can be useful for documenting a field, for example in a JSON Schema using a library like [`zod-to-json-schema`](https://github.com/StefanTerdell/zod-to-json-schema)).
+
 ### `.catch`
 
 Use `.catch()` to provide a "catch value" to be returned in the event of a parsing error.
@@ -2127,7 +2190,7 @@ z.promise(z.string());
 
 ### `.or`
 
-A convenience method for union types.
+A convenience method for [union types](#unions).
 
 ```ts
 const stringOrNumber = z.string().or(z.number()); // string | number
@@ -2308,7 +2371,7 @@ if (!data.success) {
 
 > For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md)
 
-Zod's error reporting emphasizes _completeness_ and _correctness_. If you are looking to present a useful error message to the end user, you should either override Zod's error messages using an error map (described in detail in the Error Handling guide) or use a third party library like [`zod-validation-error`](https://github.com/causaly/zod-validation-error)
+Zod's error reporting emphasizes _completeness_ and _correctness_. If you are looking to present a useful error message to the end user, you should either override Zod's error messages using an error map (described in detail in the Error Handling guide) or use a third-party library like [`zod-validation-error`](https://github.com/causaly/zod-validation-error)
 
 ### Error formatting
 
@@ -2461,7 +2524,7 @@ This more declarative API makes schema definitions vastly more concise.
 
 [https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes)
 
-Good type inference support, but limited options for object type masking (no `.pick` , `.omit` , `.extend` , etc.). No support for `Record` s (their `Record` is equivalent to Zod's `object` ). They DO support branded and readonly types, which Zod does not.
+Good type inference support, but limited options for object type masking (no `.pick` , `.omit` , `.extend` , etc.). No support for `Record` s (their `Record` is equivalent to Zod's `object` ). They DO support readonly types, which Zod does not.
 
 - Supports "pattern matching": computed properties that distribute over unions
 - Supports readonly types
diff --git a/deno/lib/README.md b/deno/lib/README.md
index 1267c8b05..6c2711ec5 100644
--- a/deno/lib/README.md
+++ b/deno/lib/README.md
@@ -47,10 +47,12 @@
   - [Sponsors](#sponsors)
   - [Ecosystem](#ecosystem)
 - [Installation](#installation)
-  - [Node/npm](#nodenpm)
-  - [Deno](#deno)
+  - [Requirements](#requirements)
+  - [Node/npm](#from-npm-nodebun)
+  - [Deno](#from-denolandx-deno)
 - [Basic usage](#basic-usage)
 - [Primitives](#primitives)
+- [Coercion for primitives](#coercion-for-primitives)
 - [Literals](#literals)
 - [Strings](#strings)
 - [Numbers](#numbers)
@@ -101,6 +103,7 @@
   - [.superRefine](#superRefine)
   - [.transform](#transform)
   - [.default](#default)
+  - [.describe](#describe)
   - [.catch](#catch)
   - [.optional](#optional)
   - [.nullable](#nullable)
@@ -355,12 +358,15 @@ There are a growing number of tools that are built atop or support Zod natively!
 #### Form integrations
 
 - [`react-hook-form`](https://github.com/react-hook-form/resolvers#zod): A first-party Zod resolver for React Hook Form.
-- [`zod-validation-error`](https://github.com/causaly/zod-validation-error): Generate user-friendly error messages from `ZodError`s
+- [`zod-validation-error`](https://github.com/causaly/zod-validation-error): Generate user-friendly error messages from `ZodError`s.
 - [`zod-formik-adapter`](https://github.com/robertLichtnow/zod-formik-adapter): A community-maintained Formik adapter for Zod.
 - [`react-zorm`](https://github.com/esamattis/react-zorm): Standalone `<form>` generation and validation for React using Zod.
 - [`zodix`](https://github.com/rileytomasek/zodix): Zod utilities for FormData and URLSearchParams in Remix loaders and actions.
+- [`remix-params-helper`](https://github.com/kiliman/remix-params-helper): Simplify integration of Zod with standard URLSearchParams and FormData for Remix apps.
 - [`formik-validator-zod`](https://github.com/glazy/formik-validator-zod): Formik-compliant validator library that simplifies using Zod with Formik.
 - [`zod-i18n-map`](https://github.com/aiji42/zod-i18n): Useful for translating Zod error messages.
+- [`@modular-forms/solid`](https://github.com/fabian-hiller/modular-forms): Modular form library for SolidJS that supports Zod for validation.
+- [`houseform`](https://github.com/crutchcorn/houseform/): A React form library that uses Zod for validation.
 
 #### Zod to X
 
@@ -379,15 +385,16 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`@runtyping/zod`](https://github.com/johngeorgewright/runtyping/tree/master/packages/zod): Generate Zod from static types & JSON schema.
 - [`json-schema-to-zod`](https://github.com/StefanTerdell/json-schema-to-zod): Convert your [JSON Schemas](https://json-schema.org/) into Zod schemas. [Live demo](https://StefanTerdell.github.io/json-schema-to-zod-react/).
 - [`json-to-zod`](https://github.com/rsinohara/json-to-zod): Convert JSON objects into Zod schemas. [Live demo](https://rsinohara.github.io/json-to-zod-react/).
-- [`graphql-codegen-typescript-validation-schema`](https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema): GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema
+- [`graphql-codegen-typescript-validation-schema`](https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema): GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema.
 - [`zod-prisma`](https://github.com/CarterGrimmeisen/zod-prisma): Generate Zod schemas from your Prisma schema.
 - [`Supervillain`](https://github.com/Southclaws/supervillain): Generate Zod schemas from your Go structs.
 - [`prisma-zod-generator`](https://github.com/omar-dulaimi/prisma-zod-generator): Emit Zod schemas from your Prisma schema.
 - [`prisma-trpc-generator`](https://github.com/omar-dulaimi/prisma-trpc-generator): Emit fully implemented tRPC routers and their validation schemas using Zod.
+- [`zod-prisma-types`](https://github.com/chrishoermann/zod-prisma-types) Create Zod types from your Prisma models.
 
 #### Mocking
 
-- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/Marak/Faker.js).
+- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/faker-js/faker).
 - [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.
 
 #### Powered by Zod
@@ -395,7 +402,11 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`slonik`](https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference): Node.js Postgres client with strong Zod integration.
 - [`soly`](https://github.com/mdbetancourt/soly): Create CLI applications with zod.
 - [`zod-xlsx`](https://github.com/sidwebworks/zod-xlsx): A xlsx based resource validator using Zod schemas.
-- [`znv`](https://github.com/lostfictions/znv): Type-safe environment parsing and validation for Node.js with Zod schemas
+- [`znv`](https://github.com/lostfictions/znv): Type-safe environment parsing and validation for Node.js with Zod schemas.
+
+#### Utilities for Zod
+
+- [`zod_utilz`](https://github.com/JacobWeisenburger/zod_utilz): Framework agnostic utilities for Zod.
 
 ## Installation
 
@@ -503,8 +514,53 @@ z.unknown();
 z.never();
 ```
 
+## Coercion for primitives
+
+Zod now provides a more convenient way to coerce primitive values.
+
+```ts
+const schema = z.coerce.string();
+schema.parse("tuna"); // => "tuna"
+schema.parse(12); // => "12"
+schema.parse(true); // => "true"
+```
+
+During the parsing step, the input is passed through the `String()` function, which is a JavaScript built-in for coercing data into strings. Note that the returned schema is a `ZodString` instance so you can use all string methods.
+
+```ts
+z.coerce.string().email().min(5);
+```
+
+All primitive types support coercion.
+
+```ts
+z.coerce.string(); // String(input)
+z.coerce.number(); // Number(input)
+z.coerce.boolean(); // Boolean(input)
+z.coerce.bigint(); // BigInt(input)
+z.coerce.date(); // new Date(input)
+```
+
+**Boolean coercion**
+
+Zod's boolean coercion is very simple! It passes the value into the `Boolean(value)` function, that's it. Any truthy value will resolve to `true`, any falsy value will resolve to `false`.
+
+```ts
+z.coerce.boolean().parse("tuna"); // => true
+z.coerce.boolean().parse("true"); // => true
+z.coerce.boolean().parse("false"); // => true
+z.coerce.boolean().parse(1); // => true
+z.coerce.boolean().parse([]); // => true
+
+z.coerce.boolean().parse(0); // => false
+z.coerce.boolean().parse(undefined); // => false
+z.coerce.boolean().parse(null); // => false
+```
+
 ## Literals
 
+Literal schemas represent a [literal type](https://www.typescriptlang.org/docs/handbook/literal-types.html), like `"hello world"` or `5`.
+
 ```ts
 const tuna = z.literal("tuna");
 const twelve = z.literal(12);
@@ -532,6 +588,7 @@ z.string().email();
 z.string().url();
 z.string().uuid();
 z.string().cuid();
+z.string().cuid2();
 z.string().regex(regex);
 z.string().startsWith(string);
 z.string().endsWith(string);
@@ -564,49 +621,6 @@ z.string().endsWith(".com", { message: "Only .com domains allowed" });
 z.string().datetime({ message: "Invalid datetime string! Must be UTC." });
 ```
 
-## Coercion for primitives
-
-Zod now provides a more convenient way to coerce primitive values.
-
-```ts
-const schema = z.coerce.string();
-schema.parse("tuna"); // => "tuna"
-schema.parse(12); // => "12"
-schema.parse(true); // => "true"
-```
-
-During the parsing step, the input is passed through the `String()` function, which is a JavaScript built-in for coercing data into strings. Note that the returned schema is a `ZodString` instance so you can use all string methods.
-
-```ts
-z.coerce.string().email().min(5);
-```
-
-All primitive types support coercion.
-
-```ts
-z.coerce.string(); // String(input)
-z.coerce.number(); // Number(input)
-z.coerce.boolean(); // Boolean(input)
-z.coerce.bigint(); // BigInt(input)
-z.coerce.date(); // new Date(input)
-```
-
-**Boolean coercion**
-
-Zod's boolean coercion is very simple! It passes the value into the `Boolean(value)` function, that's it. Any truthy value will resolve to `true`, any falsy value will resolve to `false`.
-
-```ts
-z.coerce.boolean().parse("tuna"); // => true
-z.coerce.boolean().parse("true"); // => true
-z.coerce.boolean().parse("false"); // => true
-z.coerce.boolean().parse(1); // => true
-z.coerce.boolean().parse([]); // => true
-
-z.coerce.boolean().parse(0); // => false
-z.coerce.boolean().parse(undefined); // => false
-z.coerce.boolean().parse(null); // => false
-```
-
 ### Datetime validation
 
 The `z.string().datetime()` method defaults to UTC validation: no timezone offsets with arbitrary sub-second decimal precision.
@@ -627,6 +641,8 @@ const datetime = z.string().datetime({ offset: true });
 
 datetime.parse("2020-01-01T00:00:00+02:00"); // pass
 datetime.parse("2020-01-01T00:00:00.123+02:00"); // pass (millis optional)
+datetime.parse("2020-01-01T00:00:00.123+0200"); // pass (millis optional)
+datetime.parse("2020-01-01T00:00:00.123+02"); // pass (only offset hours)
 datetime.parse("2020-01-01T00:00:00Z"); // pass (Z still supported)
 ```
 
@@ -724,21 +740,28 @@ z.date().min(new Date("1900-01-01"), { message: "Too old" });
 z.date().max(new Date(), { message: "Too young!" });
 ```
 
-**Supporting date strings**
+**Coercion to Date**
 
-To write a schema that accepts either a `Date` or a date string, use [`z.preprocess`](#preprocess).
+Since [zod 3.20](https://github.com/colinhacks/zod/releases/tag/v3.20), use [`z.coerce.date()`](#coercion-for-primitives) to pass the input through `new Date(input)`.
 
 ```ts
-const dateSchema = z.preprocess((arg) => {
-  if (typeof arg == "string" || arg instanceof Date) return new Date(arg);
-}, z.date());
+const dateSchema = z.coerce.date();
 type DateSchema = z.infer<typeof dateSchema>;
 // type DateSchema = Date
 
-dateSchema.safeParse(new Date("1/12/22")); // success: true
-dateSchema.safeParse("2022-01-12T00:00:00.000Z"); // success: true
+/* valid dates */
+console.log(dateSchema.safeParse("2023-01-10T00:00:00.000Z").success); // true
+console.log(dateSchema.safeParse("2023-01-10").success); // true
+console.log(dateSchema.safeParse("1/10/23").success); // true
+console.log(dateSchema.safeParse(new Date("1/10/23")).success); // true
+
+/* invalid dates */
+console.log(dateSchema.safeParse("2023-13-10").success); // false
+console.log(dateSchema.safeParse("0000-00-00").success); // false
 ```
 
+For older zod versions, use [`z.preprocess`](#preprocess) like [described in this thread](https://github.com/colinhacks/zod/discussions/879#discussioncomment-2036276).
+
 ## Zod enums
 
 ```ts
@@ -781,7 +804,7 @@ FishEnum.enum;
 You can also retrieve the list of options as a tuple with the `.options` property:
 
 ```ts
-FishEnum.options; // ["Salmon", "Tuna", "Trout"]);
+FishEnum.options; // ["Salmon", "Tuna", "Trout"];
 ```
 
 ## Native enums
@@ -1265,12 +1288,28 @@ stringOrNumber.parse(14); // passes
 
 Zod will test the input against each of the "options" in order and return the first value that validates successfully.
 
-For convenience, you can also use the `.or` method:
+For convenience, you can also use the [`.or` method](#or):
 
 ```ts
 const stringOrNumber = z.string().or(z.number());
 ```
 
+**Optional string validation:**
+
+To validate an optional form input, you can union the desired string validation with an empty string [literal](#literals).
+
+This example validates an input that is optional but needs to contain a [valid URL](#strings):
+
+```ts
+const optionalUrl = z.union([z.string().url().nullish(), z.literal("")]);
+
+console.log(optionalUrl.safeParse(undefined).success); // true
+console.log(optionalUrl.safeParse(null).success); // true
+console.log(optionalUrl.safeParse("").success); // true
+console.log(optionalUrl.safeParse("https://zod.dev").success); // true
+console.log(optionalUrl.safeParse("not a valid url").success); // false
+```
+
 ## Discriminated unions
 
 A discriminated union is a union of object schemas that all share a particular key.
@@ -1283,7 +1322,7 @@ type MyUnion =
 
 Such unions can be represented with the `z.discriminatedUnion` method. This enables faster evaluation, because Zod can check the _discriminator key_ (`status` in the example above) to determine which schema should be used to parse the input. This makes parsing more efficient and lets Zod report friendlier errors.
 
-With the basic union method the input is tested against each of the provided "options", and in the case of invalidity, issues for all the "options" are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the "options", testing against it, and showing only the issues related to this "option".
+With the basic union method, the input is tested against each of the provided "options", and in the case of invalidity, issues for all the "options" are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the "options", testing against it, and showing only the issues related to this "option".
 
 ```ts
 const myUnion = z.discriminatedUnion("status", [
@@ -1291,7 +1330,7 @@ const myUnion = z.discriminatedUnion("status", [
   z.object({ status: z.literal("failed"), error: z.instanceof(Error) }),
 ]);
 
-myUnion.parse({ type: "success", data: "yippie ki yay" });
+myUnion.parse({ status: "success", data: "yippie ki yay" });
 ```
 
 ## Records
@@ -1432,55 +1471,67 @@ type Teacher = z.infer<typeof Teacher>;
 You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a "type hint".
 
 ```ts
-interface Category {
-  name: string;
+const baseCategorySchema = z.object({
+  name: z.string(),
+});
+
+type Category = z.infer<typeof baseCategorySchema> & {
   subcategories: Category[];
-}
+};
 
-// cast to z.ZodType<Category>
-const Category: z.ZodType<Category> = z.lazy(() =>
-  z.object({
-    name: z.string(),
-    subcategories: z.array(Category),
-  })
-);
+const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
+  subcategories: z.lazy(() => categorySchema.array()),
+});
 
-Category.parse({
+categorySchema.parse({
   name: "People",
   subcategories: [
     {
       name: "Politicians",
-      subcategories: [{ name: "Presidents", subcategories: [] }],
+      subcategories: [
+        {
+          name: "Presidents",
+          subcategories: [],
+        },
+      ],
     },
   ],
 }); // passes
 ```
 
-Unfortunately this code is a bit duplicative, since you're declaring the types twice: once in the interface and again in the Zod definition.
+Thanks to [crasite](https://github.com/crasite) for this example.
+
+### ZodType with ZodEffects
 
-<!-- If your schema has lots of primitive fields, there's a way of reducing the amount of duplication:
+When using `z.ZodType` with `z.ZodEffects` (
+[`.refine`](https://github.com/colinhacks/zod#refine),
+[`.transform`](https://github.com/colinhacks/zod#transform),
+[`preprocess`](https://github.com/colinhacks/zod#preprocess),
+etc...
+), you will need to define the input and output types of the schema. `z.ZodType<Output, z.ZodTypeDef, Input>`
 
 ```ts
-// define all the non-recursive stuff here
-const BaseCategory = z.object({
-  name: z.string(),
-  tags: z.array(z.string()),
-  itemCount: z.number(),
+const isValidId = (id: string): id is `${string}/${string}` =>
+  id.split("/").length === 2;
+
+const baseSchema = z.object({
+  id: z.string().refine(isValidId),
 });
 
-// create an interface that extends the base schema
-interface Category extends z.infer<typeof BaseCategory> {
-  subcategories: Category[];
-}
+type Input = z.input<typeof baseSchema> & {
+  children: Input[];
+};
 
-// merge the base schema with
-// a new Zod schema containing relations
-const Category: z.ZodType<Category> = BaseCategory.merge(
-  z.object({
-    subcategories: z.lazy(() => z.array(Category)),
-  })
-);
-``` -->
+type Output = z.output<typeof baseSchema> & {
+  children: Output[];
+};
+
+const schema: z.ZodType<Output, z.ZodTypeDef, Input> = baseSchema.extend({
+  children: z.lazy(() => schema.array()),
+});
+```
+
+Thanks to [marcus13371337](https://github.com/marcus13371337) and [JoelBeeldi](https://github.com/JoelBeeldi) for this example.
 
 ### JSON type
 
@@ -1679,21 +1730,20 @@ Given any Zod schema, you can call its `.parse` method to check `data` is valid.
 const stringSchema = z.string();
 
 stringSchema.parse("fish"); // => returns "fish"
-stringSchema.parse(12); // throws Error('Non-string type: number');
+stringSchema.parse(12); // throws error
 ```
 
 ### `.parseAsync`
 
 `.parseAsync(data:unknown): Promise<T>`
 
-If you use asynchronous [refinements](#refine) or [transforms](#transform) (more on those later), you'll need to use `.parseAsync`
+If you use asynchronous [refinements](#refine) or [transforms](#transform) (more on those later), you'll need to use `.parseAsync`.
 
 ```ts
-const stringSchema1 = z.string().refine(async (val) => val.length < 20);
-const value1 = await stringSchema.parseAsync("hello"); // => hello
+const stringSchema = z.string().refine(async (val) => val.length <= 8);
 
-const stringSchema2 = z.string().refine(async (val) => val.length > 20);
-const value2 = await stringSchema.parseAsync("hello"); // => throws
+await stringSchema.parseAsync("hello"); // => returns "hello"
+await stringSchema.parseAsync("hello world"); // => throws error
 ```
 
 ### `.safeParse`
@@ -1710,7 +1760,7 @@ stringSchema.safeParse("billie");
 // => { success: true; data: 'billie' }
 ```
 
-The result is a _discriminated union_ so you can handle errors very conveniently:
+The result is a _discriminated union_, so you can handle errors very conveniently:
 
 ```ts
 const result = stringSchema.safeParse("billie");
@@ -1778,7 +1828,7 @@ type RefineParams = {
 };
 ```
 
-For advanced cases, the second argument can also be a function that returns `RefineParams`/
+For advanced cases, the second argument can also be a function that returns `RefineParams`.
 
 ```ts
 const longString = z.string().refine(
@@ -1889,7 +1939,7 @@ const Strings = z.array(z.string()).superRefine((val, ctx) => {
 
 You can add as many issues as you like. If `ctx.addIssue` is _not_ called during the execution of the function, validation passes.
 
-Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` you can create any issue of any code. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).
+Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` it's possible to throw issues of any `ZodIssueCode`. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).
 
 #### Abort early
 
@@ -1918,7 +1968,7 @@ const schema = z.number().superRefine((val, ctx) => {
 
 #### Type refinements
 
-If you provide a [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) to `.refine()` or `superRefine()`, the resulting type will be narrowed down to your predicate's type. This is useful if you are mixing multiple chained refinements and transformations:
+If you provide a [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) to `.refine()` or `.superRefine()`, the resulting type will be narrowed down to your predicate's type. This is useful if you are mixing multiple chained refinements and transformations:
 
 ```ts
 const schema = z
@@ -1933,15 +1983,15 @@ const schema = z
         code: z.ZodIssueCode.custom, // customize your issue
         message: "object should exist",
       });
-      return false;
     }
-    return true;
+
+    return z.NEVER; // The return value is not used, but we need to return something to satisfy the typing
   })
   // here, TS knows that arg is not null
   .refine((arg) => arg.first === "bob", "`first` is not `bob`!");
 ```
 
-> ⚠️ You must **still** call `ctx.addIssue()` if using `superRefine()` with a type predicate function. Otherwise the refinement won't be validated.
+> ⚠️ You **must** use `ctx.addIssue()` instead of returning a boolean value to indicate whether the validation passes. If `ctx.addIssue` is _not_ called during the execution of the function, validation passes.
 
 ### `.transform`
 
@@ -1968,12 +2018,12 @@ emailToDomain.parse("colinhacks@example.com"); // => example.com
 
 #### Validating during transform
 
-The `.transform` method can simultaneously validate and transform the value. This is often simpler and less duplicative than chaining `refine` and `validate`.
+The `.transform` method can simultaneously validate and transform the value. This is often simpler and less duplicative than chaining `transform` and `refine`.
 
-As with `.superRefine`, the transform function receives a `ctx` object with a `addIssue` method that can be used to register validation issues.
+As with `.superRefine`, the transform function receives a `ctx` object with an `addIssue` method that can be used to register validation issues.
 
 ```ts
-const Strings = z.string().transform((val, ctx) => {
+const numberInString = z.string().transform((val, ctx) => {
   const parsed = parseInt(val);
   if (isNaN(parsed)) {
     ctx.addIssue({
@@ -2044,6 +2094,19 @@ Conceptually, this is how Zod processes default values:
 1. If the input is `undefined`, the default value is returned
 2. Otherwise, the data is parsed using the base schema
 
+### `.describe`
+
+Use `.describe()` to add a `description` property to the resulting schema.
+
+```ts
+const documentedString = z
+  .string()
+  .describe("A useful bit of text, if you know what to do with it.");
+documentedString.description; // A useful bit of text…
+```
+
+This can be useful for documenting a field, for example in a JSON Schema using a library like [`zod-to-json-schema`](https://github.com/StefanTerdell/zod-to-json-schema)).
+
 ### `.catch`
 
 Use `.catch()` to provide a "catch value" to be returned in the event of a parsing error.
@@ -2127,7 +2190,7 @@ z.promise(z.string());
 
 ### `.or`
 
-A convenience method for union types.
+A convenience method for [union types](#unions).
 
 ```ts
 const stringOrNumber = z.string().or(z.number()); // string | number
@@ -2308,7 +2371,7 @@ if (!data.success) {
 
 > For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md)
 
-Zod's error reporting emphasizes _completeness_ and _correctness_. If you are looking to present a useful error message to the end user, you should either override Zod's error messages using an error map (described in detail in the Error Handling guide) or use a third party library like [`zod-validation-error`](https://github.com/causaly/zod-validation-error)
+Zod's error reporting emphasizes _completeness_ and _correctness_. If you are looking to present a useful error message to the end user, you should either override Zod's error messages using an error map (described in detail in the Error Handling guide) or use a third-party library like [`zod-validation-error`](https://github.com/causaly/zod-validation-error)
 
 ### Error formatting
 
@@ -2461,7 +2524,7 @@ This more declarative API makes schema definitions vastly more concise.
 
 [https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes)
 
-Good type inference support, but limited options for object type masking (no `.pick` , `.omit` , `.extend` , etc.). No support for `Record` s (their `Record` is equivalent to Zod's `object` ). They DO support branded and readonly types, which Zod does not.
+Good type inference support, but limited options for object type masking (no `.pick` , `.omit` , `.extend` , etc.). No support for `Record` s (their `Record` is equivalent to Zod's `object` ). They DO support readonly types, which Zod does not.
 
 - Supports "pattern matching": computed properties that distribute over unions
 - Supports readonly types
diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index cf6f8b083..b6834a777 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -50,6 +50,7 @@ export interface ZodInvalidTypeIssue extends ZodIssueBase {
 export interface ZodInvalidLiteralIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.invalid_literal;
   expected: unknown;
+  received: unknown;
 }
 
 export interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
@@ -93,6 +94,7 @@ export type StringValidation =
   | "uuid"
   | "regex"
   | "cuid"
+  | "cuid2"
   | "datetime"
   | { startsWith: string }
   | { endsWith: string };
@@ -169,11 +171,11 @@ export const quotelessJson = (obj: any) => {
 export type ZodFormattedError<T, U = string> = {
   _errors: U[];
 } & (NonNullable<T> extends [any, ...any[]]
-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }
   : NonNullable<T> extends any[]
-  ? { [k: number]: ZodFormattedError<NonNullable<T>[number]> }
+  ? { [k: number]: ZodFormattedError<NonNullable<T>[number], U> }
   : NonNullable<T> extends object
-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }
   : unknown);
 
 export type inferFormattedError<
diff --git a/deno/lib/__tests__/array.test.ts b/deno/lib/__tests__/array.test.ts
index 6fe0f335f..8aed9d63f 100644
--- a/deno/lib/__tests__/array.test.ts
+++ b/deno/lib/__tests__/array.test.ts
@@ -64,3 +64,9 @@ test("continue parsing despite array size error", () => {
     expect(result.error.issues.length).toEqual(2);
   }
 });
+
+test("parse should fail given sparse array", () => {
+  const schema = z.array(z.string()).nonempty().min(1).max(3);
+
+  expect(() => schema.parse(new Array(3))).toThrow();
+});
diff --git a/deno/lib/__tests__/catch.test.ts b/deno/lib/__tests__/catch.test.ts
index 892ca12f0..d61c63191 100644
--- a/deno/lib/__tests__/catch.test.ts
+++ b/deno/lib/__tests__/catch.test.ts
@@ -48,7 +48,7 @@ test("catch with transform", () => {
   );
 
   type inp = z.input<typeof stringWithDefault>;
-  util.assertEqual<inp, string | undefined>(true);
+  util.assertEqual<inp, string>(true);
   type out = z.output<typeof stringWithDefault>;
   util.assertEqual<out, string>(true);
 });
@@ -66,7 +66,7 @@ test("catch on existing optional", () => {
   type inp = z.input<typeof stringWithDefault>;
   util.assertEqual<inp, string | undefined>(true);
   type out = z.output<typeof stringWithDefault>;
-  util.assertEqual<out, string>(true);
+  util.assertEqual<out, string | undefined>(true);
 });
 
 test("optional on catch", () => {
@@ -85,7 +85,7 @@ test("complex chain example", () => {
     .transform((val) => val + "!")
     .transform((val) => val.toUpperCase())
     .catch("qwer")
-    .removeDefault()
+    .removeCatch()
     .optional()
     .catch("asdfasdf");
 
@@ -94,8 +94,8 @@ test("complex chain example", () => {
   expect(complex.parse(true)).toBe("ASDF!");
 });
 
-test("removeDefault", () => {
-  const stringWithRemovedDefault = z.string().catch("asdf").removeDefault();
+test("removeCatch", () => {
+  const stringWithRemovedDefault = z.string().catch("asdf").removeCatch();
 
   type out = z.output<typeof stringWithRemovedDefault>;
   util.assertEqual<out, string>(true);
@@ -107,7 +107,7 @@ test("nested", () => {
     inner: "asdf",
   });
   type input = z.input<typeof outer>;
-  util.assertEqual<input, { inner?: string | undefined } | undefined>(true);
+  util.assertEqual<input, { inner: string }>(true);
   type out = z.output<typeof outer>;
   util.assertEqual<out, { inner: string }>(true);
   expect(outer.parse(undefined)).toEqual({ inner: "asdf" });
@@ -125,7 +125,7 @@ test("chained catch", () => {
 
 test("factory", () => {
   z.ZodCatch.create(z.string(), {
-    default: "asdf",
+    catch: "asdf",
   }).parse(undefined);
 });
 
@@ -152,3 +152,40 @@ test("enum", () => {
   expect(schema.parse({ fruit: true })).toEqual({ fruit: "apple" });
   expect(schema.parse({ fruit: 15 })).toEqual({ fruit: "apple" });
 });
+
+test("reported issues with nested usage", () => {
+  const schema = z.object({
+    string: z.string(),
+    obj: z.object({
+      sub: z.object({
+        lit: z.literal("a"),
+        subCatch: z.number().catch(23),
+      }),
+      midCatch: z.number().catch(42),
+    }),
+    number: z.number().catch(0),
+    bool: z.boolean(),
+  });
+
+  try {
+    schema.parse({
+      string: {},
+      obj: {
+        sub: {
+          lit: "b",
+          subCatch: "24",
+        },
+        midCatch: 444,
+      },
+      number: "",
+      bool: "yes",
+    });
+  } catch (error) {
+    const issues = (error as z.ZodError).issues;
+
+    expect(issues.length).toEqual(3);
+    expect(issues[0].message).toMatch("string");
+    expect(issues[1].message).toMatch("literal");
+    expect(issues[2].message).toMatch("boolean");
+  }
+});
diff --git a/deno/lib/__tests__/coerce.test.ts b/deno/lib/__tests__/coerce.test.ts
index 98072bb72..6acc5249b 100644
--- a/deno/lib/__tests__/coerce.test.ts
+++ b/deno/lib/__tests__/coerce.test.ts
@@ -7,40 +7,129 @@ import * as z from "../index.ts";
 test("string coercion", () => {
   const schema = z.coerce.string();
   expect(schema.parse("sup")).toEqual("sup");
+  expect(schema.parse("")).toEqual("");
   expect(schema.parse(12)).toEqual("12");
-  expect(schema.parse(true)).toEqual("true");
+  expect(schema.parse(0)).toEqual("0");
+  expect(schema.parse(-12)).toEqual("-12");
+  expect(schema.parse(3.14)).toEqual("3.14");
   expect(schema.parse(BigInt(15))).toEqual("15");
+  expect(schema.parse(NaN)).toEqual("NaN");
+  expect(schema.parse(Infinity)).toEqual("Infinity");
+  expect(schema.parse(-Infinity)).toEqual("-Infinity");
+  expect(schema.parse(true)).toEqual("true");
+  expect(schema.parse(false)).toEqual("false");
+  expect(schema.parse(null)).toEqual("null");
+  expect(schema.parse(undefined)).toEqual("undefined");
+  expect(schema.parse({ hello: "world!" })).toEqual("[object Object]");
+  expect(schema.parse(["item", "another_item"])).toEqual("item,another_item");
+  expect(schema.parse([])).toEqual("");
+  expect(schema.parse(new Date("2022-01-01T00:00:00.000Z"))).toEqual(
+    new Date("2022-01-01T00:00:00.000Z").toString()
+  );
 });
 
 test("number coercion", () => {
   const schema = z.coerce.number();
   expect(schema.parse("12")).toEqual(12);
+  expect(schema.parse("0")).toEqual(0);
+  expect(schema.parse("-12")).toEqual(-12);
+  expect(schema.parse("3.14")).toEqual(3.14);
+  expect(schema.parse("")).toEqual(0);
+  expect(() => schema.parse("NOT_A_NUMBER")).toThrow; // z.ZodError
   expect(schema.parse(12)).toEqual(12);
-  expect(schema.parse(true)).toEqual(1);
+  expect(schema.parse(0)).toEqual(0);
+  expect(schema.parse(-12)).toEqual(-12);
+  expect(schema.parse(3.14)).toEqual(3.14);
   expect(schema.parse(BigInt(15))).toEqual(15);
+  expect(() => schema.parse(NaN)).toThrow; // z.ZodError
+  expect(schema.parse(Infinity)).toEqual(Infinity);
+  expect(schema.parse(-Infinity)).toEqual(-Infinity);
+  expect(schema.parse(true)).toEqual(1);
+  expect(schema.parse(false)).toEqual(0);
+  expect(schema.parse(null)).toEqual(0);
+  expect(() => schema.parse(undefined)).toThrow; // z.ZodError
+  expect(() => schema.parse({ hello: "world!" })).toThrow; // z.ZodError
+  expect(() => schema.parse(["item", "another_item"])).toThrow; // z.ZodError
+  expect(schema.parse([])).toEqual(0);
   expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);
 });
 
 test("boolean coercion", () => {
   const schema = z.coerce.boolean();
+  expect(schema.parse("true")).toEqual(true);
+  expect(schema.parse("false")).toEqual(true);
+  expect(schema.parse("0")).toEqual(true);
+  expect(schema.parse("1")).toEqual(true);
   expect(schema.parse("")).toEqual(false);
-  expect(schema.parse("12")).toEqual(true);
+  expect(schema.parse(1)).toEqual(true);
   expect(schema.parse(0)).toEqual(false);
-  expect(schema.parse(12)).toEqual(true);
+  expect(schema.parse(-1)).toEqual(true);
+  expect(schema.parse(3.14)).toEqual(true);
+  expect(schema.parse(BigInt(15))).toEqual(true);
+  expect(schema.parse(NaN)).toEqual(false);
+  expect(schema.parse(Infinity)).toEqual(true);
+  expect(schema.parse(-Infinity)).toEqual(true);
   expect(schema.parse(true)).toEqual(true);
+  expect(schema.parse(false)).toEqual(false);
+  expect(schema.parse(null)).toEqual(false);
+  expect(schema.parse(undefined)).toEqual(false);
+  expect(schema.parse({ hello: "world!" })).toEqual(true);
+  expect(schema.parse(["item", "another_item"])).toEqual(true);
+  expect(schema.parse([])).toEqual(true);
+  expect(schema.parse(new Date(1670139203496))).toEqual(true);
 });
 
 test("bigint coercion", () => {
   const schema = z.coerce.bigint();
   expect(schema.parse("5")).toEqual(BigInt(5));
+  expect(schema.parse("0")).toEqual(BigInt(0));
+  expect(schema.parse("-5")).toEqual(BigInt(-5));
+  expect(() => schema.parse("3.14")).toThrow; // not a z.ZodError!
+  expect(schema.parse("")).toEqual(BigInt(0));
+  expect(() => schema.parse("NOT_A_NUMBER")).toThrow; // not a z.ZodError!
+  expect(schema.parse(5)).toEqual(BigInt(5));
   expect(schema.parse(0)).toEqual(BigInt(0));
+  expect(schema.parse(-5)).toEqual(BigInt(-5));
+  expect(() => schema.parse(3.14)).toThrow; // not a z.ZodError!
   expect(schema.parse(BigInt(5))).toEqual(BigInt(5));
+  expect(() => schema.parse(NaN)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(Infinity)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(-Infinity)).toThrow; // not a z.ZodError!
+  expect(schema.parse(true)).toEqual(BigInt(1));
+  expect(schema.parse(false)).toEqual(BigInt(0));
+  expect(() => schema.parse(null)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(undefined)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse({ hello: "world!" })).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(["item", "another_item"])).toThrow; // not a z.ZodError!
+  expect(schema.parse([])).toEqual(BigInt(0));
   expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));
 });
 
 test("date coercion", () => {
   const schema = z.coerce.date();
-  expect(schema.parse("5") instanceof Date).toEqual(true);
-  expect(schema.parse(0) instanceof Date).toEqual(true);
-  expect(schema.parse(new Date()) instanceof Date).toEqual(true);
+  expect(schema.parse(new Date().toDateString())).toBeInstanceOf(Date);
+  expect(schema.parse(new Date().toISOString())).toBeInstanceOf(Date);
+  expect(schema.parse(new Date().toUTCString())).toBeInstanceOf(Date);
+  expect(schema.parse("5")).toBeInstanceOf(Date);
+  expect(schema.parse("0")).toBeInstanceOf(Date);
+  expect(schema.parse("-5")).toBeInstanceOf(Date);
+  expect(schema.parse("3.14")).toBeInstanceOf(Date);
+  expect(() => schema.parse("")).toThrow; // z.ZodError
+  expect(() => schema.parse("NOT_A_DATE")).toThrow; // z.ZodError
+  expect(schema.parse(5)).toBeInstanceOf(Date);
+  expect(schema.parse(0)).toBeInstanceOf(Date);
+  expect(schema.parse(-5)).toBeInstanceOf(Date);
+  expect(schema.parse(3.14)).toBeInstanceOf(Date);
+  expect(() => schema.parse(BigInt(5))).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(NaN)).toThrow; // z.ZodError
+  expect(() => schema.parse(Infinity)).toThrow; // z.ZodError
+  expect(() => schema.parse(-Infinity)).toThrow; // z.ZodError
+  expect(schema.parse(true)).toBeInstanceOf(Date);
+  expect(schema.parse(false)).toBeInstanceOf(Date);
+  expect(schema.parse(null)).toBeInstanceOf(Date);
+  expect(() => schema.parse(undefined)).toThrow; // z.ZodError
+  expect(() => schema.parse({ hello: "world!" })).toThrow; // z.ZodError
+  expect(() => schema.parse(["item", "another_item"])).toThrow; // z.ZodError
+  expect(() => schema.parse([])).toThrow; // z.ZodError
+  expect(schema.parse(new Date())).toBeInstanceOf(Date);
 });
diff --git a/deno/lib/__tests__/description.test.ts b/deno/lib/__tests__/description.test.ts
index d10e60b61..63015eab9 100644
--- a/deno/lib/__tests__/description.test.ts
+++ b/deno/lib/__tests__/description.test.ts
@@ -4,8 +4,25 @@ const test = Deno.test;
 
 import * as z from "../index.ts";
 
-test("description", () => {
-  const schema: any = z.string();
-  const DESC = "asdlfkjasdf";
-  expect(schema.describe(DESC).description).toEqual(DESC);
+const description = "a description";
+
+test("passing `description` to schema should add a description", () => {
+  expect(z.string({ description }).description).toEqual(description);
+  expect(z.number({ description }).description).toEqual(description);
+  expect(z.boolean({ description }).description).toEqual(description);
+});
+
+test("`.describe` should add a description", () => {
+  expect(z.string().describe(description).description).toEqual(description);
+  expect(z.number().describe(description).description).toEqual(description);
+  expect(z.boolean().describe(description).description).toEqual(description);
+});
+
+test("description should carry over to chained schemas", () => {
+  const schema = z.string({ description });
+  expect(schema.description).toEqual(description);
+  expect(schema.optional().description).toEqual(description);
+  expect(schema.optional().nullable().default("default").description).toEqual(
+    description
+  );
 });
diff --git a/deno/lib/__tests__/discriminatedUnions.test.ts b/deno/lib/__tests__/discriminatedUnions.test.ts
index cc0f3bd28..4e472c8a8 100644
--- a/deno/lib/__tests__/discriminatedUnions.test.ts
+++ b/deno/lib/__tests__/discriminatedUnions.test.ts
@@ -1,3 +1,4 @@
+// @ts-ignore TS6133
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
diff --git a/deno/lib/__tests__/enum.test.ts b/deno/lib/__tests__/enum.test.ts
index 343e07ee7..ecd27d215 100644
--- a/deno/lib/__tests__/enum.test.ts
+++ b/deno/lib/__tests__/enum.test.ts
@@ -41,3 +41,20 @@ test("error params", () => {
     expect(result.error.issues[0].message).toEqual("REQUIRED");
   }
 });
+
+test("extract/exclude", () => {
+  const foods = ["Pasta", "Pizza", "Tacos", "Burgers", "Salad"] as const;
+  const FoodEnum = z.enum(foods);
+  const ItalianEnum = FoodEnum.extract(["Pasta", "Pizza"]);
+  const UnhealthyEnum = FoodEnum.exclude(["Salad"]);
+  const EmptyFoodEnum = FoodEnum.exclude(foods);
+
+  util.assertEqual<z.infer<typeof ItalianEnum>, "Pasta" | "Pizza">(true);
+  util.assertEqual<
+    z.infer<typeof UnhealthyEnum>,
+    "Pasta" | "Pizza" | "Tacos" | "Burgers"
+  >(true);
+  // @ts-expect-error TS2344
+  util.assertEqual<typeof EmptyFoodEnum, z.ZodEnum<[]>>(true);
+  util.assertEqual<z.infer<typeof EmptyFoodEnum>, never>(true);
+});
diff --git a/deno/lib/__tests__/firstparty.test.ts b/deno/lib/__tests__/firstparty.test.ts
index 4e49d1397..66ed29bdb 100644
--- a/deno/lib/__tests__/firstparty.test.ts
+++ b/deno/lib/__tests__/firstparty.test.ts
@@ -1,3 +1,4 @@
+// @ts-ignore TS6133
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
diff --git a/deno/lib/__tests__/literal.test.ts b/deno/lib/__tests__/literal.test.ts
new file mode 100644
index 000000000..b3f074162
--- /dev/null
+++ b/deno/lib/__tests__/literal.test.ts
@@ -0,0 +1,37 @@
+// @ts-ignore TS6133
+import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
+const test = Deno.test;
+
+import * as z from "../index.ts";
+
+const literalTuna = z.literal("tuna");
+const literalFortyTwo = z.literal(42);
+const literalTrue = z.literal(true);
+
+const terrificSymbol = Symbol("terrific");
+const literalTerrificSymbol = z.literal(terrificSymbol);
+
+test("passing validations", () => {
+  literalTuna.parse("tuna");
+  literalFortyTwo.parse(42);
+  literalTrue.parse(true);
+  literalTerrificSymbol.parse(terrificSymbol);
+});
+
+test("failing validations", () => {
+  expect(() => literalTuna.parse("shark")).toThrow();
+  expect(() => literalFortyTwo.parse(43)).toThrow();
+  expect(() => literalTrue.parse(false)).toThrow();
+  expect(() => literalTerrificSymbol.parse(Symbol("terrific"))).toThrow();
+});
+
+test("invalid_literal should have `received` field with data", () => {
+  const data = "shark";
+  const result = literalTuna.safeParse(data);
+  if (!result.success) {
+    const issue = result.error.issues[0];
+    if (issue.code === "invalid_literal") {
+      expect(issue.received).toBe(data);
+    }
+  }
+});
diff --git a/deno/lib/__tests__/number.test.ts b/deno/lib/__tests__/number.test.ts
index c7c634a0e..b1353977f 100644
--- a/deno/lib/__tests__/number.test.ts
+++ b/deno/lib/__tests__/number.test.ts
@@ -6,10 +6,17 @@ import * as z from "../index.ts";
 
 const gtFive = z.number().gt(5);
 const gteFive = z.number().gte(5);
+const minFive = z.number().min(5);
 const ltFive = z.number().lt(5);
 const lteFive = z.number().lte(5);
+const maxFive = z.number().max(5);
 const intNum = z.number().int();
+const positive = z.number().positive();
+const negative = z.number().negative();
+const nonpositive = z.number().nonpositive();
+const nonnegative = z.number().nonnegative();
 const multipleOfFive = z.number().multipleOf(5);
+const multipleOfNegativeFive = z.number().multipleOf(-5);
 const finite = z.number().finite();
 const stepPointOne = z.number().step(0.1);
 const stepPointZeroZeroZeroOne = z.number().step(0.0001);
@@ -24,11 +31,32 @@ test("passing validations", () => {
   z.number().parse(Infinity);
   z.number().parse(-Infinity);
   gtFive.parse(6);
+  gtFive.parse(Infinity);
   gteFive.parse(5);
+  gteFive.parse(Infinity);
+  minFive.parse(5);
+  minFive.parse(Infinity);
   ltFive.parse(4);
+  ltFive.parse(-Infinity);
   lteFive.parse(5);
+  lteFive.parse(-Infinity);
+  maxFive.parse(5);
+  maxFive.parse(-Infinity);
   intNum.parse(4);
+  positive.parse(1);
+  positive.parse(Infinity);
+  negative.parse(-1);
+  negative.parse(-Infinity);
+  nonpositive.parse(0);
+  nonpositive.parse(-1);
+  nonpositive.parse(-Infinity);
+  nonnegative.parse(0);
+  nonnegative.parse(1);
+  nonnegative.parse(Infinity);
   multipleOfFive.parse(15);
+  multipleOfFive.parse(-15);
+  multipleOfNegativeFive.parse(-15);
+  multipleOfNegativeFive.parse(15);
   finite.parse(123);
   stepPointOne.parse(6);
   stepPointOne.parse(6.1);
@@ -40,10 +68,21 @@ test("passing validations", () => {
 test("failing validations", () => {
   expect(() => ltFive.parse(5)).toThrow();
   expect(() => lteFive.parse(6)).toThrow();
+  expect(() => maxFive.parse(6)).toThrow();
   expect(() => gtFive.parse(5)).toThrow();
   expect(() => gteFive.parse(4)).toThrow();
+  expect(() => minFive.parse(4)).toThrow();
   expect(() => intNum.parse(3.14)).toThrow();
-  expect(() => multipleOfFive.parse(14.9)).toThrow();
+  expect(() => positive.parse(0)).toThrow();
+  expect(() => positive.parse(-1)).toThrow();
+  expect(() => negative.parse(0)).toThrow();
+  expect(() => negative.parse(1)).toThrow();
+  expect(() => nonpositive.parse(1)).toThrow();
+  expect(() => nonnegative.parse(-1)).toThrow();
+  expect(() => multipleOfFive.parse(7.5)).toThrow();
+  expect(() => multipleOfFive.parse(-7.5)).toThrow();
+  expect(() => multipleOfNegativeFive.parse(-7.5)).toThrow();
+  expect(() => multipleOfNegativeFive.parse(7.5)).toThrow();
   expect(() => finite.parse(Infinity)).toThrow();
   expect(() => finite.parse(-Infinity)).toThrow();
 
@@ -57,12 +96,73 @@ test("parse NaN", () => {
 });
 
 test("min max getters", () => {
-  expect(z.number().int().isInt).toEqual(true);
+  expect(z.number().minValue).toBeNull;
+  expect(ltFive.minValue).toBeNull;
+  expect(lteFive.minValue).toBeNull;
+  expect(maxFive.minValue).toBeNull;
+  expect(negative.minValue).toBeNull;
+  expect(nonpositive.minValue).toBeNull;
+  expect(intNum.minValue).toBeNull;
+  expect(multipleOfFive.minValue).toBeNull;
+  expect(finite.minValue).toBeNull;
+  expect(gtFive.minValue).toEqual(5);
+  expect(gteFive.minValue).toEqual(5);
+  expect(minFive.minValue).toEqual(5);
+  expect(minFive.min(10).minValue).toEqual(10);
+  expect(positive.minValue).toEqual(0);
+  expect(nonnegative.minValue).toEqual(0);
+
+  expect(z.number().maxValue).toBeNull;
+  expect(gtFive.maxValue).toBeNull;
+  expect(gteFive.maxValue).toBeNull;
+  expect(minFive.maxValue).toBeNull;
+  expect(positive.maxValue).toBeNull;
+  expect(nonnegative.maxValue).toBeNull;
+  expect(intNum.minValue).toBeNull;
+  expect(multipleOfFive.minValue).toBeNull;
+  expect(finite.minValue).toBeNull;
+  expect(ltFive.maxValue).toEqual(5);
+  expect(lteFive.maxValue).toEqual(5);
+  expect(maxFive.maxValue).toEqual(5);
+  expect(maxFive.max(1).maxValue).toEqual(1);
+  expect(negative.maxValue).toEqual(0);
+  expect(nonpositive.maxValue).toEqual(0);
+});
+
+test("int getter", () => {
   expect(z.number().isInt).toEqual(false);
+  expect(z.number().multipleOf(1.5).isInt).toEqual(false);
+  expect(gtFive.isInt).toEqual(false);
+  expect(gteFive.isInt).toEqual(false);
+  expect(minFive.isInt).toEqual(false);
+  expect(positive.isInt).toEqual(false);
+  expect(nonnegative.isInt).toEqual(false);
+  expect(finite.isInt).toEqual(false);
+  expect(ltFive.isInt).toEqual(false);
+  expect(lteFive.isInt).toEqual(false);
+  expect(maxFive.isInt).toEqual(false);
+  expect(negative.isInt).toEqual(false);
+  expect(nonpositive.isInt).toEqual(false);
+
+  expect(intNum.isInt).toEqual(true);
+  expect(multipleOfFive.isInt).toEqual(true);
+});
 
-  expect(z.number().min(5).minValue).toEqual(5);
-  expect(z.number().min(5).min(10).minValue).toEqual(10);
+test("finite getter", () => {
+  expect(z.number().isFinite).toEqual(false);
+  expect(gtFive.isFinite).toEqual(false);
+  expect(gteFive.isFinite).toEqual(false);
+  expect(minFive.isFinite).toEqual(false);
+  expect(positive.isFinite).toEqual(false);
+  expect(nonnegative.isFinite).toEqual(false);
+  expect(ltFive.isFinite).toEqual(false);
+  expect(lteFive.isFinite).toEqual(false);
+  expect(maxFive.isFinite).toEqual(false);
+  expect(negative.isFinite).toEqual(false);
+  expect(nonpositive.isFinite).toEqual(false);
 
-  expect(z.number().max(5).maxValue).toEqual(5);
-  expect(z.number().max(5).max(1).maxValue).toEqual(1);
+  expect(finite.isFinite).toEqual(true);
+  expect(intNum.isFinite).toEqual(true);
+  expect(multipleOfFive.isFinite).toEqual(true);
+  expect(z.number().min(5).max(10).isFinite).toEqual(true);
 });
diff --git a/deno/lib/__tests__/object.test.ts b/deno/lib/__tests__/object.test.ts
index 99b81c95d..382296788 100644
--- a/deno/lib/__tests__/object.test.ts
+++ b/deno/lib/__tests__/object.test.ts
@@ -29,6 +29,18 @@ test("unknown throw", () => {
   expect(() => Test.parse(asdf)).toThrow();
 });
 
+test("shape() should return schema of particular key", () => {
+  const f1Schema = Test.shape.f1;
+  const f2Schema = Test.shape.f2;
+  const f3Schema = Test.shape.f3;
+  const f4Schema = Test.shape.f4;
+
+  expect(f1Schema).toBeInstanceOf(z.ZodNumber);
+  expect(f2Schema).toBeInstanceOf(z.ZodOptional);
+  expect(f3Schema).toBeInstanceOf(z.ZodNullable);
+  expect(f4Schema).toBeInstanceOf(z.ZodArray);
+});
+
 test("correct parsing", () => {
   Test.parse({
     f1: 12,
@@ -389,3 +401,42 @@ test("unknownkeys merging", () => {
   util.assertEqual<mergedSchema["_def"]["catchall"], z.ZodString>(true);
   expect(mergedSchema._def.catchall instanceof z.ZodString).toEqual(true);
 });
+
+const personToExtend = z.object({
+  firstName: z.string(),
+  lastName: z.string(),
+});
+
+test("extend() should return schema with new key", () => {
+  const PersonWithNickname = personToExtend.extend({ nickName: z.string() });
+  type PersonWithNickname = z.infer<typeof PersonWithNickname>;
+
+  const expected = { firstName: "f", nickName: "n", lastName: "l" };
+  const actual = PersonWithNickname.parse(expected);
+
+  expect(actual).toEqual(expected);
+  util.assertEqual<
+    keyof PersonWithNickname,
+    "firstName" | "lastName" | "nickName"
+  >(true);
+  util.assertEqual<
+    PersonWithNickname,
+    { firstName: string; lastName: string; nickName: string }
+  >(true);
+});
+
+test("extend() should have power to override existing key", () => {
+  const PersonWithNumberAsLastName = personToExtend.extend({
+    lastName: z.number(),
+  });
+  type PersonWithNumberAsLastName = z.infer<typeof PersonWithNumberAsLastName>;
+
+  const expected = { firstName: "f", lastName: 42 };
+  const actual = PersonWithNumberAsLastName.parse(expected);
+
+  expect(actual).toEqual(expected);
+  util.assertEqual<
+    PersonWithNumberAsLastName,
+    { firstName: string; lastName: number }
+  >(true);
+});
diff --git a/deno/lib/__tests__/partials.test.ts b/deno/lib/__tests__/partials.test.ts
index 3cbc00ed4..67fb82050 100644
--- a/deno/lib/__tests__/partials.test.ts
+++ b/deno/lib/__tests__/partials.test.ts
@@ -185,21 +185,88 @@ test("required with mask", () => {
   expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);
 });
 
+test("required with mask containing a nonexistent key", () => {
+  const object = z.object({
+    name: z.string(),
+    age: z.number().optional(),
+    field: z.string().optional().default("asdf"),
+    country: z.string().optional(),
+  });
+  object.required({
+    age: true,
+    // @ts-expect-error should not accept unexpected keys.
+    doesntExist: true,
+  });
+});
+
+test("required with mask -- ignore falsy values", () => {
+  const object = z.object({
+    name: z.string(),
+    age: z.number().optional(),
+    field: z.string().optional().default("asdf"),
+    country: z.string().optional(),
+  });
+
+  // @ts-expect-error
+  const requiredObject = object.required({ age: true, country: false });
+  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);
+  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);
+  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);
+  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);
+});
+
 test("partial with mask", async () => {
   const object = z.object({
     name: z.string(),
     age: z.number().optional(),
     field: z.string().optional().default("asdf"),
+    country: z.string(),
   });
 
   const masked = object
-    .partial({
-      name: true,
-      age: true,
-      field: true,
-    })
+    .partial({ age: true, field: true, name: true })
     .strict();
 
-  masked.parse({});
-  await masked.parseAsync({});
+  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);
+  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);
+  expect(masked.shape.field).toBeInstanceOf(z.ZodOptional);
+  expect(masked.shape.country).toBeInstanceOf(z.ZodString);
+
+  masked.parse({ country: "US" });
+  await masked.parseAsync({ country: "US" });
+});
+
+test("partial with mask -- ignore falsy values", async () => {
+  const object = z.object({
+    name: z.string(),
+    age: z.number().optional(),
+    field: z.string().optional().default("asdf"),
+    country: z.string(),
+  });
+
+  // @ts-expect-error
+  const masked = object.partial({ name: true, country: false }).strict();
+
+  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);
+  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);
+  expect(masked.shape.field).toBeInstanceOf(z.ZodDefault);
+  expect(masked.shape.country).toBeInstanceOf(z.ZodString);
+
+  masked.parse({ country: "US" });
+  await masked.parseAsync({ country: "US" });
+});
+
+test("partial with mask containing a nonexistent key", () => {
+  const object = z.object({
+    name: z.string(),
+    age: z.number().optional(),
+    field: z.string().optional().default("asdf"),
+    country: z.string().optional(),
+  });
+
+  object.partial({
+    age: true,
+    // @ts-expect-error should not accept unexpected keys.
+    doesntExist: true,
+  });
 });
diff --git a/deno/lib/__tests__/pickomit.test.ts b/deno/lib/__tests__/pickomit.test.ts
index f19129995..d2eb28848 100644
--- a/deno/lib/__tests__/pickomit.test.ts
+++ b/deno/lib/__tests__/pickomit.test.ts
@@ -20,6 +20,10 @@ test("pick type inference", () => {
 test("pick parse - success", () => {
   const nameonlyFish = fish.pick({ name: true });
   nameonlyFish.parse({ name: "bob" });
+
+  // @ts-expect-error checking runtime picks `name` only.
+  const anotherNameonlyFish = fish.pick({ name: true, age: false });
+  anotherNameonlyFish.parse({ name: "bob" });
 });
 
 test("pick parse - fail", () => {
@@ -32,9 +36,14 @@ test("pick parse - fail", () => {
   const bad2 = () => nameonlyFish.parse({ name: "bob", age: 12 } as any);
   const bad3 = () => nameonlyFish.parse({ age: 12 } as any);
 
+  // @ts-expect-error checking runtime picks `name` only.
+  const anotherNameonlyFish = fish.pick({ name: true, age: false }).strict();
+  const bad4 = () => anotherNameonlyFish.parse({ name: "bob", age: 12 } as any);
+
   expect(bad1).toThrow();
   expect(bad2).toThrow();
   expect(bad3).toThrow();
+  expect(bad4).toThrow();
 });
 
 test("omit type inference", () => {
@@ -46,6 +55,10 @@ test("omit type inference", () => {
 test("omit parse - success", () => {
   const nonameFish = fish.omit({ name: true });
   nonameFish.parse({ age: 12, nested: {} });
+
+  // @ts-expect-error checking runtime omits `name` only.
+  const anotherNonameFish = fish.omit({ name: true, age: false });
+  anotherNonameFish.parse({ age: 12, nested: {} });
 });
 
 test("omit parse - fail", () => {
@@ -54,9 +67,14 @@ test("omit parse - fail", () => {
   const bad2 = () => nonameFish.parse({ age: 12 } as any);
   const bad3 = () => nonameFish.parse({} as any);
 
+  // @ts-expect-error checking runtime omits `name` only.
+  const anotherNonameFish = fish.omit({ name: true, age: false });
+  const bad4 = () => anotherNonameFish.parse({ nested: {} } as any);
+
   expect(bad1).toThrow();
   expect(bad2).toThrow();
   expect(bad3).toThrow();
+  expect(bad4).toThrow();
 });
 
 test("nonstrict inference", () => {
@@ -66,13 +84,13 @@ test("nonstrict inference", () => {
 });
 
 test("nonstrict parsing - pass", () => {
-  const laxfish = fish.nonstrict().pick({ name: true });
+  const laxfish = fish.passthrough().pick({ name: true });
   laxfish.parse({ name: "asdf", whatever: "asdf" });
   laxfish.parse({ name: "asdf", age: 12, nested: {} });
 });
 
 test("nonstrict parsing - fail", () => {
-  const laxfish = fish.nonstrict().pick({ name: true });
+  const laxfish = fish.passthrough().pick({ name: true });
   const bad = () => laxfish.parse({ whatever: "asdf" } as any);
   expect(bad).toThrow();
 });
@@ -85,6 +103,7 @@ test("pick a nonexistent key", () => {
 
   const pickedSchema = schema.pick({
     a: true,
+    // @ts-expect-error should not accept unexpected keys.
     doesntExist: true,
   });
 
@@ -92,3 +111,16 @@ test("pick a nonexistent key", () => {
     a: "value",
   });
 });
+
+test("omit a nonexistent key", () => {
+  const schema = z.object({
+    a: z.string(),
+    b: z.number(),
+  });
+
+  schema.omit({
+    a: true,
+    // @ts-expect-error should not accept unexpected keys.
+    doesntExist: true,
+  });
+});
diff --git a/deno/lib/__tests__/promise.test.ts b/deno/lib/__tests__/promise.test.ts
index 3bc288a01..383de22f1 100644
--- a/deno/lib/__tests__/promise.test.ts
+++ b/deno/lib/__tests__/promise.test.ts
@@ -87,3 +87,9 @@ test("async promise parsing", () => {
   const res = z.promise(z.number()).parseAsync(Promise.resolve(12));
   expect(res).toBeInstanceOf(Promise);
 });
+
+test("resolves", () => {
+  const foo = z.literal("foo");
+  const res = z.promise(foo);
+  expect(res.unwrap()).toEqual(foo);
+});
diff --git a/deno/lib/__tests__/string.test.ts b/deno/lib/__tests__/string.test.ts
index f45ec0ad8..8cac57112 100644
--- a/deno/lib/__tests__/string.test.ts
+++ b/deno/lib/__tests__/string.test.ts
@@ -38,24 +38,66 @@ test("email validations", () => {
   expect(() => email.parse("asdf")).toThrow();
   expect(() => email.parse("@lkjasdf.com")).toThrow();
   expect(() => email.parse("asdf@sdf.")).toThrow();
-  // expect(() => email.parse("asdf@asdf.com-")).toThrow();
-  // expect(() => email.parse("asdf@-asdf.com")).toThrow();
+  expect(() => email.parse("asdf@asdf.com-")).toThrow();
+  expect(() => email.parse("asdf@-asdf.com")).toThrow();
+  expect(() => email.parse("asdf@-a(sdf.com")).toThrow();
+  expect(() => email.parse("asdf@-asdf.com(")).toThrow();
+  expect(() =>
+    email.parse("pawan.anand@%9y83&#$%R&#$%R&%#$R%%^^%5rw3ewe.d.d.aaaa.wef.co")
+  ).toThrow();
 });
 
 test("more email validations", () => {
-  const data = [
-    `"josé.arrañoça"@domain.com`,
-    `"сайт"@domain.com`,
-    `"💩"@domain.com`,
-    `"🍺🕺🎉"@domain.com`,
-    `poop@💩.la`,
-    `"🌮"@i❤️tacos.ws`,
-    "sss--asd@i❤️tacos.ws",
+  const validEmails = [
+    `very.common@example.com`,
+    `disposable.style.email.with+symbol@example.com`,
+    `other.email-with-hyphen@example.com`,
+    `fully-qualified-domain@example.com`,
+    `user.name+tag+sorting@example.com`,
+    `x@example.com`,
+    `example-indeed@strange-example.com`,
+    `test/test@test.com`,
+    `example@s.example`,
+    `" "@example.org`,
+    `"john..doe"@example.org`,
+    `mailhost!username@example.org`,
+    `"very.(),:;<>[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com`,
+    `user%example.com@example.org`,
+    `user-@example.org`,
+    `postmaster@[123.123.123.123]`,
+    `user@my-example.com`,
+    `a@b.cd`,
+    `work+user@mail.com`,
+    `user@[68.185.127.196]`,
+    `ipv4@[85.129.96.247]`,
+    `valid@[79.208.229.53]`,
   ];
-  const email = z.string().email();
-  for (const datum of data) {
-    email.parse(datum);
-  }
+  const invalidEmails = [
+    `Abc.example.com`,
+    `A@b@c@example.com`,
+    `a"b(c)d,e:f;g<h>i[j\k]l@example.com`,
+    `just"not"right@example.com`,
+    `this is"not\allowed@example.com`,
+    `this\ still\"not\\allowed@example.com`,
+    `i_like_underscore@but_its_not_allowed_in_this_part.example.com`,
+    `QA[icon]CHOCOLATE[icon]@test.com`,
+    `invalid@-start.com`,
+    `invalid@end.com-`,
+    `a.b@c.d`,
+    `invalid@[1.1.1.-1]`,
+    `invalid@[68.185.127.196.55]`,
+    `temp@[192.168.1]`,
+    `temp@[9.18.122.]`,
+  ];
+  const emailSchema = z.string().email();
+  expect(
+    validEmails.every((email) => emailSchema.safeParse(email).success)
+  ).toBe(true);
+  expect(
+    invalidEmails.every(
+      (email) => emailSchema.safeParse(email).success === false
+    )
+  ).toBe(true);
 });
 
 test("url validations", () => {
@@ -120,6 +162,27 @@ test("cuid", () => {
   }
 });
 
+test("cuid2", () => {
+  const cuid2 = z.string().cuid2();
+  const validStrings = [
+    "a", // short string
+    "tz4a98xxat96iws9zmbrgj3a", // normal string
+    "kf5vz6ssxe4zjcb409rjgo747tc5qjazgptvotk6", // longer than require("@paralleldrive/cuid2").bigLength
+  ];
+  validStrings.forEach((s) => cuid2.parse(s));
+  const invalidStrings = [
+    "", // empty string
+    "1z4a98xxat96iws9zmbrgj3a", // starts with a number
+    "tz4a98xxat96iws9zMbrgj3a", // include uppercase
+    "tz4a98xxat96iws-zmbrgj3a", // involve symbols
+  ];
+  const results = invalidStrings.map((s) => cuid2.safeParse(s));
+  expect(results.every((r) => !r.success)).toEqual(true);
+  if (!results[0].success) {
+    expect(results[0].error.issues[0].message).toEqual("Invalid cuid2");
+  }
+});
+
 test("regex", () => {
   z.string()
     .regex(/^moo+$/)
@@ -154,21 +217,31 @@ test("checks getters", () => {
   expect(z.string().email().isEmail).toEqual(true);
   expect(z.string().email().isURL).toEqual(false);
   expect(z.string().email().isCUID).toEqual(false);
+  expect(z.string().email().isCUID2).toEqual(false);
   expect(z.string().email().isUUID).toEqual(false);
 
   expect(z.string().url().isEmail).toEqual(false);
   expect(z.string().url().isURL).toEqual(true);
   expect(z.string().url().isCUID).toEqual(false);
+  expect(z.string().url().isCUID2).toEqual(false);
   expect(z.string().url().isUUID).toEqual(false);
 
   expect(z.string().cuid().isEmail).toEqual(false);
   expect(z.string().cuid().isURL).toEqual(false);
   expect(z.string().cuid().isCUID).toEqual(true);
+  expect(z.string().cuid().isCUID2).toEqual(false);
   expect(z.string().cuid().isUUID).toEqual(false);
 
+  expect(z.string().cuid2().isEmail).toEqual(false);
+  expect(z.string().cuid2().isURL).toEqual(false);
+  expect(z.string().cuid2().isCUID).toEqual(false);
+  expect(z.string().cuid2().isCUID2).toEqual(true);
+  expect(z.string().cuid2().isUUID).toEqual(false);
+
   expect(z.string().uuid().isEmail).toEqual(false);
   expect(z.string().uuid().isURL).toEqual(false);
   expect(z.string().uuid().isCUID).toEqual(false);
+  expect(z.string().uuid().isCUID2).toEqual(false);
   expect(z.string().uuid().isUUID).toEqual(true);
 });
 
@@ -243,6 +316,8 @@ test("datetime parsing", () => {
   datetimeOffset.parse("2022-10-13T09:52:31.4Z");
   datetimeOffset.parse("2020-10-14T17:42:29+00:00");
   datetimeOffset.parse("2020-10-14T17:42:29+03:15");
+  datetimeOffset.parse("2020-10-14T17:42:29+0315");
+  datetimeOffset.parse("2020-10-14T17:42:29+03");
   expect(() => datetimeOffset.parse("tuna")).toThrow();
   expect(() => datetimeOffset.parse("2022-10-13T09:52:31.Z")).toThrow();
 
@@ -252,6 +327,8 @@ test("datetime parsing", () => {
   datetimeOffsetNoMs.parse("1970-01-01T00:00:00Z");
   datetimeOffsetNoMs.parse("2022-10-13T09:52:31Z");
   datetimeOffsetNoMs.parse("2020-10-14T17:42:29+00:00");
+  datetimeOffsetNoMs.parse("2020-10-14T17:42:29+0000");
+  datetimeOffsetNoMs.parse("2020-10-14T17:42:29+00");
   expect(() => datetimeOffsetNoMs.parse("tuna")).toThrow();
   expect(() => datetimeOffsetNoMs.parse("1970-01-01T00:00:00.000Z")).toThrow();
   expect(() => datetimeOffsetNoMs.parse("1970-01-01T00:00:00.Z")).toThrow();
@@ -263,6 +340,8 @@ test("datetime parsing", () => {
   const datetimeOffset4Ms = z.string().datetime({ offset: true, precision: 4 });
   datetimeOffset4Ms.parse("1970-01-01T00:00:00.1234Z");
   datetimeOffset4Ms.parse("2020-10-14T17:42:29.1234+00:00");
+  datetimeOffset4Ms.parse("2020-10-14T17:42:29.1234+0000");
+  datetimeOffset4Ms.parse("2020-10-14T17:42:29.1234+00");
   expect(() => datetimeOffset4Ms.parse("tuna")).toThrow();
   expect(() => datetimeOffset4Ms.parse("1970-01-01T00:00:00.123Z")).toThrow();
   expect(() =>
diff --git a/deno/lib/__tests__/tuple.test.ts b/deno/lib/__tests__/tuple.test.ts
index 2271df9d9..77d1845c0 100644
--- a/deno/lib/__tests__/tuple.test.ts
+++ b/deno/lib/__tests__/tuple.test.ts
@@ -89,6 +89,10 @@ test("tuple with rest schema", () => {
   util.assertEqual<t1, [string, number, ...boolean[]]>(true);
 });
 
+test("parse should fail given sparse array as tuple", () => {
+  expect(() => testTuple.parse(new Array(3))).toThrow();
+});
+
 // test('tuple with optional elements', () => {
 //   const result = z
 //     .tuple([z.string(), z.number().optional()])
diff --git a/deno/lib/__tests__/unions.test.ts b/deno/lib/__tests__/unions.test.ts
index 83475e171..3a73d975f 100644
--- a/deno/lib/__tests__/unions.test.ts
+++ b/deno/lib/__tests__/unions.test.ts
@@ -1,3 +1,4 @@
+// @ts-ignore TS6133
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
diff --git a/deno/lib/benchmarks/primitives.ts b/deno/lib/benchmarks/primitives.ts
index 003e2ebbb..c91b50114 100644
--- a/deno/lib/benchmarks/primitives.ts
+++ b/deno/lib/benchmarks/primitives.ts
@@ -1,7 +1,10 @@
 import Benchmark from "benchmark";
 
+import { Mocker } from "../__tests__/Mocker.ts";
 import { z } from "../index.ts";
 
+const val = new Mocker();
+
 const enumSuite = new Benchmark.Suite("z.enum");
 const enumSchema = z.enum(["a", "b", "c"]);
 
@@ -73,6 +76,63 @@ numberSuite
     console.log(`z.number: ${e.target}`);
   });
 
+const dateSuite = new Benchmark.Suite("z.date");
+
+const plainDate = z.date();
+const minMaxDate = z
+  .date()
+  .min(new Date("2021-01-01"))
+  .max(new Date("2030-01-01"));
+
+dateSuite
+  .add("valid", () => {
+    plainDate.parse(new Date());
+  })
+  .add("invalid", () => {
+    try {
+      plainDate.parse(1);
+    } catch (e) {}
+  })
+  .add("valid min and max", () => {
+    minMaxDate.parse(new Date("2023-01-01"));
+  })
+  .add("invalid min", () => {
+    try {
+      minMaxDate.parse(new Date("2019-01-01"));
+    } catch (e) {}
+  })
+  .add("invalid max", () => {
+    try {
+      minMaxDate.parse(new Date("2031-01-01"));
+    } catch (e) {}
+  })
+  .on("cycle", (e: Benchmark.Event) => {
+    console.log(`z.date: ${e.target}`);
+  });
+
+const symbolSuite = new Benchmark.Suite("z.symbol");
+const symbolSchema = z.symbol();
+
+symbolSuite
+  .add("valid", () => {
+    symbolSchema.parse(val.symbol);
+  })
+  .add("invalid", () => {
+    try {
+      symbolSchema.parse(1);
+    } catch (e) {}
+  })
+  .on("cycle", (e: Benchmark.Event) => {
+    console.log(`z.symbol: ${e.target}`);
+  });
+
 export default {
-  suites: [enumSuite, undefinedSuite, literalSuite, numberSuite],
+  suites: [
+    enumSuite,
+    undefinedSuite,
+    literalSuite,
+    numberSuite,
+    dateSuite,
+    symbolSuite,
+  ],
 };
diff --git a/deno/lib/helpers/parseUtil.ts b/deno/lib/helpers/parseUtil.ts
index 8be51d97c..68e7df6bc 100644
--- a/deno/lib/helpers/parseUtil.ts
+++ b/deno/lib/helpers/parseUtil.ts
@@ -175,4 +175,4 @@ export const isValid = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
 export const isAsync = <T>(
   x: ParseReturnType<T>
 ): x is AsyncParseReturnType<T> =>
-  typeof Promise !== undefined && x instanceof Promise;
+  typeof Promise !== "undefined" && x instanceof Promise;
diff --git a/deno/lib/helpers/util.ts b/deno/lib/helpers/util.ts
index 5660b72ef..5248d6521 100644
--- a/deno/lib/helpers/util.ts
+++ b/deno/lib/helpers/util.ts
@@ -67,7 +67,10 @@ export namespace util {
   };
 
   export type identity<T> = T;
-  export type flatten<T> = identity<{ [k in keyof T]: T[k] }>;
+  export type flatten<T> = identity<{
+    [k in keyof T]: T[k];
+  }>;
+
   export type noUndefined<T> = T extends undefined ? never : T;
 
   export const isInteger: NumberConstructor["isInteger"] =
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 59680c296..acf219487 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -390,33 +390,34 @@ export abstract class ZodType<
   }
 
   optional(): ZodOptional<this> {
-    return ZodOptional.create(this) as any;
+    return ZodOptional.create(this, this._def) as any;
   }
   nullable(): ZodNullable<this> {
-    return ZodNullable.create(this) as any;
+    return ZodNullable.create(this, this._def) as any;
   }
-  nullish(): ZodNullable<ZodOptional<this>> {
-    return this.optional().nullable();
+  nullish(): ZodOptional<ZodNullable<this>> {
+    return this.nullable().optional();
   }
   array(): ZodArray<this> {
-    return ZodArray.create(this);
+    return ZodArray.create(this, this._def);
   }
   promise(): ZodPromise<this> {
-    return ZodPromise.create(this);
+    return ZodPromise.create(this, this._def);
   }
 
   or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
-    return ZodUnion.create([this, option]) as any;
+    return ZodUnion.create([this, option], this._def) as any;
   }
 
   and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T> {
-    return ZodIntersection.create(this, incoming);
+    return ZodIntersection.create(this, incoming, this._def);
   }
 
   transform<NewOut>(
     transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>
   ): ZodEffects<this, NewOut> {
     return new ZodEffects({
+      ...processCreateParams(this._def),
       schema: this,
       typeName: ZodFirstPartyTypeKind.ZodEffects,
       effect: { type: "transform", transform },
@@ -429,6 +430,7 @@ export abstract class ZodType<
     const defaultValueFunc = typeof def === "function" ? def : () => def;
 
     return new ZodDefault({
+      ...processCreateParams(this._def),
       innerType: this,
       defaultValue: defaultValueFunc,
       typeName: ZodFirstPartyTypeKind.ZodDefault,
@@ -440,17 +442,19 @@ export abstract class ZodType<
     return new ZodBranded({
       typeName: ZodFirstPartyTypeKind.ZodBranded,
       type: this,
-      ...processCreateParams(undefined),
+      ...processCreateParams(this._def),
     });
   }
-  catch(def: Input): ZodCatch<this>;
-  catch(def: () => Input): ZodCatch<this>;
+
+  catch(def: Output): ZodCatch<this>;
+  catch(def: () => Output): ZodCatch<this>;
   catch(def: any) {
-    const defaultValueFunc = typeof def === "function" ? def : () => def;
+    const catchValueFunc = typeof def === "function" ? def : () => def;
 
     return new ZodCatch({
+      ...processCreateParams(this._def),
       innerType: this,
-      defaultValue: defaultValueFunc,
+      catchValue: catchValueFunc,
       typeName: ZodFirstPartyTypeKind.ZodCatch,
     }) as any;
   }
@@ -490,6 +494,7 @@ export type ZodStringCheck =
   | { kind: "url"; message?: string }
   | { kind: "uuid"; message?: string }
   | { kind: "cuid"; message?: string }
+  | { kind: "cuid2"; message?: string }
   | { kind: "startsWith"; value: string; message?: string }
   | { kind: "endsWith"; value: string; message?: string }
   | { kind: "regex"; regex: RegExp; message?: string }
@@ -508,14 +513,18 @@ export interface ZodStringDef extends ZodTypeDef {
 }
 
 const cuidRegex = /^c[^\s-]{8,}$/i;
+const cuid2Regex = /^[a-z][a-z0-9]*$/;
 const uuidRegex =
   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
 // from https://stackoverflow.com/a/46181/1550155
 // old version: too slow, didn't support unicode
 // const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
+//old email regex
+// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
 // eslint-disable-next-line
+
 const emailRegex =
-  /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
+  /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|([^-]([a-zA-Z0-9-]*\.)+[a-zA-Z]{2,}))$/;
 
 // interface IsDateStringOptions extends StringDateOptions {
 /**
@@ -529,7 +538,7 @@ const datetimeRegex = (args: { precision: number | null; offset: boolean }) => {
   if (args.precision) {
     if (args.offset) {
       return new RegExp(
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
       );
     } else {
       return new RegExp(
@@ -539,7 +548,7 @@ const datetimeRegex = (args: { precision: number | null; offset: boolean }) => {
   } else if (args.precision === 0) {
     if (args.offset) {
       return new RegExp(
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
       );
     } else {
       return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
@@ -547,7 +556,7 @@ const datetimeRegex = (args: { precision: number | null; offset: boolean }) => {
   } else {
     if (args.offset) {
       return new RegExp(
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`
       );
     } else {
       return new RegExp(
@@ -664,6 +673,16 @@ export class ZodString extends ZodType<string, ZodStringDef> {
           });
           status.dirty();
         }
+      } else if (check.kind === "cuid2") {
+        if (!cuid2Regex.test(input.data)) {
+          ctx = this._getOrReturnCtx(input, ctx);
+          addIssueToContext(ctx, {
+            validation: "cuid2",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
+        }
       } else if (check.kind === "url") {
         try {
           new URL(input.data);
@@ -760,6 +779,9 @@ export class ZodString extends ZodType<string, ZodStringDef> {
   cuid(message?: errorUtil.ErrMessage) {
     return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
   }
+  cuid2(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
+  }
   datetime(
     options?:
       | string
@@ -863,6 +885,9 @@ export class ZodString extends ZodType<string, ZodStringDef> {
   get isCUID() {
     return !!this._def.checks.find((ch) => ch.kind === "cuid");
   }
+  get isCUID2() {
+    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
+  }
 
   get minLength() {
     let min: number | null = null;
@@ -1150,7 +1175,30 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
   }
 
   get isInt() {
-    return !!this._def.checks.find((ch) => ch.kind === "int");
+    return !!this._def.checks.find(
+      (ch) =>
+        ch.kind === "int" ||
+        (ch.kind === "multipleOf" && util.isInteger(ch.value))
+    );
+  }
+
+  get isFinite() {
+    let max: number | null = null,
+      min: number | null = null;
+    for (const ch of this._def.checks) {
+      if (
+        ch.kind === "finite" ||
+        ch.kind === "int" ||
+        ch.kind === "multipleOf"
+      ) {
+        return true;
+      } else if (ch.kind === "min") {
+        if (min === null || ch.value > min) min = ch.value;
+      } else if (ch.kind === "max") {
+        if (max === null || ch.value < max) max = ch.value;
+      }
+    }
+    return Number.isFinite(min) && Number.isFinite(max);
   }
 }
 
@@ -1689,7 +1737,7 @@ export class ZodArray<
 
     if (ctx.common.async) {
       return Promise.all(
-        (ctx.data as any[]).map((item, i) => {
+        ([...ctx.data] as any[]).map((item, i) => {
           return def.type._parseAsync(
             new ParseInputLazyPath(ctx, item, ctx.path, i)
           );
@@ -1699,7 +1747,7 @@ export class ZodArray<
       });
     }
 
-    const result = (ctx.data as any[]).map((item, i) => {
+    const result = ([...ctx.data] as any[]).map((item, i) => {
       return def.type._parseSync(
         new ParseInputLazyPath(ctx, item, ctx.path, i)
       );
@@ -1874,11 +1922,15 @@ export type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>
 export type SomeZodObject = ZodObject<
   ZodRawShape,
   UnknownKeysParam,
-  ZodTypeAny,
-  any,
-  any
+  ZodTypeAny
 >;
 
+export type objectKeyMask<Obj> = { [k in keyof Obj]?: true };
+
+export type noUnrecognized<Obj extends object, Shape extends object> = {
+  [k in keyof Obj]: k extends keyof Shape ? Obj[k] : never;
+};
+
 function deepPartialify(schema: ZodTypeAny): any {
   if (schema instanceof ZodObject) {
     const newShape: any = {};
@@ -1908,7 +1960,7 @@ function deepPartialify(schema: ZodTypeAny): any {
 
 export class ZodObject<
   T extends ZodRawShape,
-  UnknownKeys extends UnknownKeysParam = "strip",
+  UnknownKeys extends UnknownKeysParam,
   Catchall extends ZodTypeAny = ZodTypeAny,
   Output = objectOutputType<T, Catchall>,
   Input = objectInputType<T, Catchall>
@@ -2122,29 +2174,34 @@ export class ZodObject<
     }) as any;
   }
 
-  pick<Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
+  pick<Mask extends objectKeyMask<T>>(
+    mask: noUnrecognized<Mask, T>
   ): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall> {
     const shape: any = {};
-    util.objectKeys(mask).map((key) => {
-      // only add to shape if key corresponds to an element of the current shape
-      if (this.shape[key]) shape[key] = this.shape[key];
+
+    util.objectKeys(mask).forEach((key) => {
+      if (mask[key] && this.shape[key]) {
+        shape[key] = this.shape[key];
+      }
     });
+
     return new ZodObject({
       ...this._def,
       shape: () => shape,
     }) as any;
   }
 
-  omit<Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
+  omit<Mask extends objectKeyMask<T>>(
+    mask: noUnrecognized<Mask, objectKeyMask<T>>
   ): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall> {
     const shape: any = {};
-    util.objectKeys(this.shape).map((key) => {
-      if (util.objectKeys(mask).indexOf(key) === -1) {
+
+    util.objectKeys(this.shape).forEach((key) => {
+      if (!mask[key]) {
         shape[key] = this.shape[key];
       }
     });
+
     return new ZodObject({
       ...this._def,
       shape: () => shape,
@@ -2160,8 +2217,8 @@ export class ZodObject<
     UnknownKeys,
     Catchall
   >;
-  partial<Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
+  partial<Mask extends objectKeyMask<T>>(
+    mask: noUnrecognized<Mask, objectKeyMask<T>>
   ): ZodObject<
     objectUtil.noNever<{
       [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
@@ -2171,24 +2228,16 @@ export class ZodObject<
   >;
   partial(mask?: any) {
     const newShape: any = {};
-    if (mask) {
-      util.objectKeys(this.shape).map((key) => {
-        if (util.objectKeys(mask).indexOf(key) === -1) {
-          newShape[key] = this.shape[key];
-        } else {
-          newShape[key] = this.shape[key].optional();
-        }
-      });
-      return new ZodObject({
-        ...this._def,
-        shape: () => newShape,
-      }) as any;
-    } else {
-      for (const key in this.shape) {
-        const fieldSchema = this.shape[key];
+
+    util.objectKeys(this.shape).forEach((key) => {
+      const fieldSchema = this.shape[key];
+
+      if (mask && !mask[key]) {
+        newShape[key] = fieldSchema;
+      } else {
         newShape[key] = fieldSchema.optional();
       }
-    }
+    });
 
     return new ZodObject({
       ...this._def,
@@ -2201,8 +2250,8 @@ export class ZodObject<
     UnknownKeys,
     Catchall
   >;
-  required<Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
+  required<Mask extends objectKeyMask<T>>(
+    mask: noUnrecognized<Mask, objectKeyMask<T>>
   ): ZodObject<
     objectUtil.noNever<{
       [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
@@ -2212,30 +2261,22 @@ export class ZodObject<
   >;
   required(mask?: any) {
     const newShape: any = {};
-    if (mask) {
-      util.objectKeys(this.shape).map((key) => {
-        if (util.objectKeys(mask).indexOf(key) === -1) {
-          newShape[key] = this.shape[key];
-        } else {
-          const fieldSchema = this.shape[key];
-          let newField = fieldSchema;
-          while (newField instanceof ZodOptional) {
-            newField = (newField as ZodOptional<any>)._def.innerType;
-          }
-          newShape[key] = newField;
-        }
-      });
-    } else {
-      for (const key in this.shape) {
+
+    util.objectKeys(this.shape).forEach((key) => {
+      if (mask && !mask[key]) {
+        newShape[key] = this.shape[key];
+      } else {
         const fieldSchema = this.shape[key];
         let newField = fieldSchema;
+
         while (newField instanceof ZodOptional) {
           newField = (newField as ZodOptional<any>)._def.innerType;
         }
 
         newShape[key] = newField;
       }
-    }
+    });
+
     return new ZodObject({
       ...this._def,
       shape: () => newShape,
@@ -2251,7 +2292,7 @@ export class ZodObject<
   static create = <T extends ZodRawShape>(
     shape: T,
     params?: RawCreateParams
-  ): ZodObject<T> => {
+  ): ZodObject<T, "strip"> => {
     return new ZodObject({
       shape: () => shape,
       unknownKeys: "strip",
@@ -2277,7 +2318,7 @@ export class ZodObject<
   static lazycreate = <T extends ZodRawShape>(
     shape: () => T,
     params?: RawCreateParams
-  ): ZodObject<T> => {
+  ): ZodObject<T, "strip"> => {
     return new ZodObject({
       shape,
       unknownKeys: "strip",
@@ -2465,11 +2506,15 @@ const getDiscriminator = <T extends ZodTypeAny>(
 };
 
 export type ZodDiscriminatedUnionOption<Discriminator extends string> =
-  ZodObject<{ [key in Discriminator]: ZodTypeAny } & ZodRawShape, any, any>;
+  ZodObject<
+    { [key in Discriminator]: ZodTypeAny } & ZodRawShape,
+    UnknownKeysParam,
+    ZodTypeAny
+  >;
 
 export interface ZodDiscriminatedUnionDef<
   Discriminator extends string,
-  Options extends ZodDiscriminatedUnionOption<any>[] = ZodDiscriminatedUnionOption<any>[]
+  Options extends ZodDiscriminatedUnionOption<string>[] = ZodDiscriminatedUnionOption<string>[]
 > extends ZodTypeDef {
   discriminator: Discriminator;
   options: Options;
@@ -2498,7 +2543,9 @@ export class ZodDiscriminatedUnion<
     }
 
     const discriminator = this.discriminator;
+
     const discriminatorValue: string = ctx.data[discriminator];
+
     const option = this.optionsMap.get(discriminatorValue);
 
     if (!option) {
@@ -2575,6 +2622,7 @@ export class ZodDiscriminatedUnion<
             )} has duplicate value ${String(value)}`
           );
         }
+
         optionsMap.set(value, type);
       }
     }
@@ -2827,7 +2875,7 @@ export class ZodTuple<
       status.dirty();
     }
 
-    const items = (ctx.data as any[])
+    const items = ([...ctx.data] as any[])
       .map((item, itemIndex) => {
         const schema = this._def.items[itemIndex] || this._def.rest;
         if (!schema) return null as any as SyncParseReturnType<any>;
@@ -3299,7 +3347,7 @@ export class ZodFunction<
           });
         const result = await fn(...(parsedArgs as any));
         const parsedReturns = await (
-          this._def.returns as ZodPromise<ZodTypeAny>
+          this._def.returns as unknown as ZodPromise<ZodTypeAny>
         )._def.type
           .parseAsync(result, params)
           .catch((e) => {
@@ -3453,6 +3501,7 @@ export class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>> {
     if (input.data !== this._def.value) {
       const ctx = this._getOrReturnCtx(input);
       addIssueToContext(ctx, {
+        received: ctx.data,
         code: ZodIssueCode.invalid_literal,
         expected: this._def.value,
       });
@@ -3501,6 +3550,14 @@ export interface ZodEnumDef<T extends EnumValues = EnumValues>
 
 export type Writeable<T> = { -readonly [P in keyof T]: T[P] };
 
+export type FilterEnum<Values, ToExclude> = Values extends []
+  ? []
+  : Values extends [infer Head, ...infer Rest]
+  ? Head extends ToExclude
+    ? FilterEnum<Rest, ToExclude>
+    : [Head, ...FilterEnum<Rest, ToExclude>]
+  : never;
+
 function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(
   values: T,
   params?: RawCreateParams
@@ -3575,6 +3632,23 @@ export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
     return enumValues as any;
   }
 
+  extract<ToExtract extends readonly [T[number], ...T[number][]]>(
+    values: ToExtract
+  ) {
+    return ZodEnum.create(values);
+  }
+
+  exclude<ToExclude extends readonly [T[number], ...T[number][]]>(
+    values: ToExclude
+  ) {
+    return ZodEnum.create(
+      this.options.filter((opt) => !values.includes(opt)) as FilterEnum<
+        T,
+        ToExclude[number]
+      >
+    );
+  }
+
   static create = createZodEnum;
 }
 
@@ -3661,6 +3735,10 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
   ZodPromiseDef<T>,
   Promise<T["_input"]>
 > {
+  unwrap() {
+    return this._def.type;
+  }
+
   _parse(input: ParseInput): ParseReturnType<this["_output"]> {
     const { ctx } = this._processInputParams(input);
     if (
@@ -4053,17 +4131,19 @@ export class ZodDefault<T extends ZodTypeAny> extends ZodType<
 //////////                      //////////
 //////////////////////////////////////////
 //////////////////////////////////////////
-export interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodCatchDef<
+  T extends ZodTypeAny = ZodTypeAny,
+  C extends T["_input"] = T["_input"]
+> extends ZodTypeDef {
   innerType: T;
-  defaultValue: () => T["_input"];
+  catchValue: () => C;
   typeName: ZodFirstPartyTypeKind.ZodCatch;
 }
 
 export class ZodCatch<T extends ZodTypeAny> extends ZodType<
-  util.noUndefined<T["_output"]>,
+  T["_output"],
   ZodCatchDef<T>,
-  T["_input"] | undefined
+  T["_input"]
 > {
   _parse(input: ParseInput): ParseReturnType<this["_output"]> {
     const { ctx } = this._processInputParams(input);
@@ -4071,7 +4151,13 @@ export class ZodCatch<T extends ZodTypeAny> extends ZodType<
     const result = this._def.innerType._parse({
       data: ctx.data,
       path: ctx.path,
-      parent: ctx,
+      parent: {
+        ...ctx,
+        common: {
+          ...ctx.common,
+          issues: [], // don't collect issues from inner type
+        },
+      },
     });
 
     if (isAsync(result)) {
@@ -4079,35 +4165,33 @@ export class ZodCatch<T extends ZodTypeAny> extends ZodType<
         return {
           status: "valid",
           value:
-            result.status === "valid" ? result.value : this._def.defaultValue(),
+            result.status === "valid" ? result.value : this._def.catchValue(),
         };
       });
     } else {
       return {
         status: "valid",
         value:
-          result.status === "valid" ? result.value : this._def.defaultValue(),
+          result.status === "valid" ? result.value : this._def.catchValue(),
       };
     }
   }
 
-  removeDefault() {
+  removeCatch() {
     return this._def.innerType;
   }
 
   static create = <T extends ZodTypeAny>(
     type: T,
     params: RawCreateParams & {
-      default: T["_input"] | (() => T["_input"]);
+      catch: T["_output"] | (() => T["_output"]);
     }
   ): ZodCatch<T> => {
     return new ZodCatch({
       innerType: type,
       typeName: ZodFirstPartyTypeKind.ZodCatch,
-      defaultValue:
-        typeof params.default === "function"
-          ? params.default
-          : () => params.default,
+      catchValue:
+        typeof params.catch === "function" ? params.catch : () => params.catch,
       ...processCreateParams(params),
     });
   };
@@ -4335,7 +4419,7 @@ export type ZodFirstPartySchemaTypes =
   | ZodNever
   | ZodVoid
   | ZodArray<any, any>
-  | ZodObject<any, any, any, any, any>
+  | ZodObject<any, any, any>
   | ZodUnion<any>
   | ZodDiscriminatedUnion<any, any>
   | ZodIntersection<any, any>
@@ -4414,7 +4498,10 @@ export const coerce = {
   number: ((arg) =>
     ZodNumber.create({ ...arg, coerce: true })) as typeof ZodNumber["create"],
   boolean: ((arg) =>
-    ZodBoolean.create({ ...arg, coerce: true })) as typeof ZodBoolean["create"],
+    ZodBoolean.create({
+      ...arg,
+      coerce: true,
+    })) as typeof ZodBoolean["create"],
   bigint: ((arg) =>
     ZodBigInt.create({ ...arg, coerce: true })) as typeof ZodBigInt["create"],
   date: ((arg) =>
diff --git a/index.html b/index.html
index 3fef5d853..358a82a58 100644
--- a/index.html
+++ b/index.html
@@ -96,6 +96,7 @@
       .markdown-section {
         max-width: 720px;
       }
+
       p > img {
         height: 200px;
       }
@@ -110,21 +111,119 @@
       .markdown-section h3 code {
         font-size: 80%;
       }
+      .sidebar {
+        padding-top: 24px;
+      }
+
+      .sidebar::-webkit-scrollbar {
+        width: 6px;
+      }
+
+      .theme-btn {
+        position: relative;
+        left: 15px;
+        width: 24px;
+        height: 24px;
+        margin-bottom: 14px;
+        background-image: url("./static/moon.svg");
+        background-repeat: no-repeat;
+        background-size: cover;
+        background-position: center;
+        cursor: pointer;
+        z-index: 100;
+      }
+    </style>
+    <!-- Theme: dark -->
+    <style>
+      .dark,
+      .dark .sidebar,
+      .dark blockquote,
+      .dark .sidebar a {
+        background-color: #283339;
+        color: #d3d3d3;
+      }
+
+      .dark .sidebar::-webkit-scrollbar-thumb {
+        background: hsla(0, 0%, 88%, 0.4);
+      }
+
+      .dark .sidebar::-webkit-scrollbar-track {
+        background: hsla(0, 0%, 53%, 0.1);
+      }
+
+      .dark .sidebar-toggle {
+        background-color: hsl(201deg 18% 19% / 80%) !important;
+      }
+
+      .dark .markdown-section h1,
+      .dark .markdown-section h2,
+      .dark .markdown-section h3,
+      .dark .markdown-section h4,
+      .dark .markdown-section strong,
+      .dark .anchor span {
+        color: #fff;
+      }
+
+      .dark .markdown-section tr:nth-child(2n) {
+        background-color: #1f282d;
+      }
+
+      .dark .markdown-section td,
+      .dark .markdown-section th {
+        border-color: #495e69;
+      }
+
+      .dark .markdown-section pre,
+      .dark .markdown-section code {
+        background-color: #34434b;
+      }
+
+      .dark .markdown-section code,
+      .dark .token.keyword,
+      .dark .token.function {
+        color: #f07178;
+      }
+
+      .dark .markdown-section pre > code,
+      .dark .token.punctuation {
+        color: #f3f3f3;
+      }
+
+      .dark .token.number,
+      .dark .token.boolean {
+        color: #ffcb6b;
+      }
+
+      .dark .github-corner svg {
+        color: #283339;
+      }
+
+      .dark .theme-btn {
+        background-image: url("./static/sun.svg");
+      }
     </style>
   </head>
 
   <body>
-    <nav
-      style="
-        display: flex;
-        flex-direction: row;
-        align-items: center;
-        justify-content: space-between;
-      "
-    ></nav>
+    <div class="theme-btn"></div>
+
     <div id="app"></div>
     <script src="//cdnjs.cloudflare.com/ajax/libs/docsify/4.12.2/docsify.min.js"></script>
     <script src="//cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-typescript.min.js"></script>
+    <script>
+      window
+        .matchMedia("(prefers-color-scheme: dark)")
+        .addEventListener("change", (e) => {
+          document.body.classList.toggle("dark", e.matches);
+        });
+
+      const themeBtn = document.querySelector(".theme-btn");
+
+      themeBtn.addEventListener("click", () => {
+        document.body.classList.toggle("dark");
+      });
+    </script>
+
     <script>
       window.$docsify = {
         subMaxLevel: 1,
@@ -145,5 +244,12 @@
         ],
       };
     </script>
+    <script>
+      window.addEventListener("DOMContentLoaded", () => {
+        document
+          .querySelector("aside")
+          .prepend(document.querySelector(".theme-btn"));
+      });
+    </script>
   </body>
 </html>
diff --git a/package.json b/package.json
index 9cfa81ca9..a4d128533 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.20.2",
+  "version": "3.20.3",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./index.d.ts",
@@ -29,7 +29,7 @@
   "bugs": {
     "url": "https://github.com/colinhacks/zod/issues"
   },
-  "homepage": "https://github.com/colinhacks/zod",
+  "homepage": "https://zod.dev",
   "funding": "https://github.com/sponsors/colinhacks",
   "support": {
     "backing": {
@@ -57,6 +57,7 @@
     "build:cjs": "tsc -p tsconfig.cjs.json",
     "build:types": "tsc -p tsconfig.types.json",
     "rollup": "rollup --config rollup.config.js",
+    "test:watch": "jest --watch",
     "test": "jest --coverage",
     "test:deno": "cd deno && deno test",
     "prepublishOnly": "npm run test && npm run build && npm run build:deno",
diff --git a/playground.ts b/playground.ts
index 1e4f7e0be..9710dde67 100644
--- a/playground.ts
+++ b/playground.ts
@@ -1,21 +1,17 @@
 import { z } from "./src";
 
-console.log(z.coerce.boolean().parse("tuna")); // => true
-console.log(z.coerce.boolean().parse("true")); // => true
-console.log(z.coerce.boolean().parse("false")); // => true
-console.log(z.coerce.boolean().parse(1)); // => true
-console.log(z.coerce.boolean().parse([])); // => true
+const schema = z.object({
+  a: z.string(),
+  b: z.string().catch("b"),
+});
 
-console.log(z.coerce.boolean().parse(0)); // => false
-console.log(z.coerce.boolean().parse(undefined)); // => false
-console.log(z.coerce.boolean().parse(null)); // => false
+const result = schema.safeParse({
+  a: {},
+  b: 3,
+});
 
-z.object({
-  first: z.string(),
-  last: z.string(),
-}).transform((val) => ({
-  ...val,
-  full: `${val.first} ${val.last}`,
-}));
+console.log(result);
 
-z.number().catch(() => (Array.isArray(e) ? e.length : -1));
+const r = z.any().transform((val) => String(val));
+type In = z.input<typeof r>;
+type Out = z.output<typeof r>;
diff --git a/src/ZodError.ts b/src/ZodError.ts
index 2a0770274..e8128c292 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -50,6 +50,7 @@ export interface ZodInvalidTypeIssue extends ZodIssueBase {
 export interface ZodInvalidLiteralIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.invalid_literal;
   expected: unknown;
+  received: unknown;
 }
 
 export interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
@@ -93,6 +94,7 @@ export type StringValidation =
   | "uuid"
   | "regex"
   | "cuid"
+  | "cuid2"
   | "datetime"
   | { startsWith: string }
   | { endsWith: string };
@@ -169,11 +171,11 @@ export const quotelessJson = (obj: any) => {
 export type ZodFormattedError<T, U = string> = {
   _errors: U[];
 } & (NonNullable<T> extends [any, ...any[]]
-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }
   : NonNullable<T> extends any[]
-  ? { [k: number]: ZodFormattedError<NonNullable<T>[number]> }
+  ? { [k: number]: ZodFormattedError<NonNullable<T>[number], U> }
   : NonNullable<T> extends object
-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }
   : unknown);
 
 export type inferFormattedError<
diff --git a/src/__tests__/array.test.ts b/src/__tests__/array.test.ts
index 00ae06618..21ae44bee 100644
--- a/src/__tests__/array.test.ts
+++ b/src/__tests__/array.test.ts
@@ -63,3 +63,9 @@ test("continue parsing despite array size error", () => {
     expect(result.error.issues.length).toEqual(2);
   }
 });
+
+test("parse should fail given sparse array", () => {
+  const schema = z.array(z.string()).nonempty().min(1).max(3);
+
+  expect(() => schema.parse(new Array(3))).toThrow();
+});
diff --git a/src/__tests__/catch.test.ts b/src/__tests__/catch.test.ts
index 99615f2f1..d7e6313fe 100644
--- a/src/__tests__/catch.test.ts
+++ b/src/__tests__/catch.test.ts
@@ -47,7 +47,7 @@ test("catch with transform", () => {
   );
 
   type inp = z.input<typeof stringWithDefault>;
-  util.assertEqual<inp, string | undefined>(true);
+  util.assertEqual<inp, string>(true);
   type out = z.output<typeof stringWithDefault>;
   util.assertEqual<out, string>(true);
 });
@@ -65,7 +65,7 @@ test("catch on existing optional", () => {
   type inp = z.input<typeof stringWithDefault>;
   util.assertEqual<inp, string | undefined>(true);
   type out = z.output<typeof stringWithDefault>;
-  util.assertEqual<out, string>(true);
+  util.assertEqual<out, string | undefined>(true);
 });
 
 test("optional on catch", () => {
@@ -84,7 +84,7 @@ test("complex chain example", () => {
     .transform((val) => val + "!")
     .transform((val) => val.toUpperCase())
     .catch("qwer")
-    .removeDefault()
+    .removeCatch()
     .optional()
     .catch("asdfasdf");
 
@@ -93,8 +93,8 @@ test("complex chain example", () => {
   expect(complex.parse(true)).toBe("ASDF!");
 });
 
-test("removeDefault", () => {
-  const stringWithRemovedDefault = z.string().catch("asdf").removeDefault();
+test("removeCatch", () => {
+  const stringWithRemovedDefault = z.string().catch("asdf").removeCatch();
 
   type out = z.output<typeof stringWithRemovedDefault>;
   util.assertEqual<out, string>(true);
@@ -106,7 +106,7 @@ test("nested", () => {
     inner: "asdf",
   });
   type input = z.input<typeof outer>;
-  util.assertEqual<input, { inner?: string | undefined } | undefined>(true);
+  util.assertEqual<input, { inner: string }>(true);
   type out = z.output<typeof outer>;
   util.assertEqual<out, { inner: string }>(true);
   expect(outer.parse(undefined)).toEqual({ inner: "asdf" });
@@ -124,7 +124,7 @@ test("chained catch", () => {
 
 test("factory", () => {
   z.ZodCatch.create(z.string(), {
-    default: "asdf",
+    catch: "asdf",
   }).parse(undefined);
 });
 
@@ -151,3 +151,40 @@ test("enum", () => {
   expect(schema.parse({ fruit: true })).toEqual({ fruit: "apple" });
   expect(schema.parse({ fruit: 15 })).toEqual({ fruit: "apple" });
 });
+
+test("reported issues with nested usage", () => {
+  const schema = z.object({
+    string: z.string(),
+    obj: z.object({
+      sub: z.object({
+        lit: z.literal("a"),
+        subCatch: z.number().catch(23),
+      }),
+      midCatch: z.number().catch(42),
+    }),
+    number: z.number().catch(0),
+    bool: z.boolean(),
+  });
+
+  try {
+    schema.parse({
+      string: {},
+      obj: {
+        sub: {
+          lit: "b",
+          subCatch: "24",
+        },
+        midCatch: 444,
+      },
+      number: "",
+      bool: "yes",
+    });
+  } catch (error) {
+    const issues = (error as z.ZodError).issues;
+
+    expect(issues.length).toEqual(3);
+    expect(issues[0].message).toMatch("string");
+    expect(issues[1].message).toMatch("literal");
+    expect(issues[2].message).toMatch("boolean");
+  }
+});
diff --git a/src/__tests__/coerce.test.ts b/src/__tests__/coerce.test.ts
index b83699e51..79d91d1fc 100644
--- a/src/__tests__/coerce.test.ts
+++ b/src/__tests__/coerce.test.ts
@@ -6,40 +6,129 @@ import * as z from "../index";
 test("string coercion", () => {
   const schema = z.coerce.string();
   expect(schema.parse("sup")).toEqual("sup");
+  expect(schema.parse("")).toEqual("");
   expect(schema.parse(12)).toEqual("12");
-  expect(schema.parse(true)).toEqual("true");
+  expect(schema.parse(0)).toEqual("0");
+  expect(schema.parse(-12)).toEqual("-12");
+  expect(schema.parse(3.14)).toEqual("3.14");
   expect(schema.parse(BigInt(15))).toEqual("15");
+  expect(schema.parse(NaN)).toEqual("NaN");
+  expect(schema.parse(Infinity)).toEqual("Infinity");
+  expect(schema.parse(-Infinity)).toEqual("-Infinity");
+  expect(schema.parse(true)).toEqual("true");
+  expect(schema.parse(false)).toEqual("false");
+  expect(schema.parse(null)).toEqual("null");
+  expect(schema.parse(undefined)).toEqual("undefined");
+  expect(schema.parse({ hello: "world!" })).toEqual("[object Object]");
+  expect(schema.parse(["item", "another_item"])).toEqual("item,another_item");
+  expect(schema.parse([])).toEqual("");
+  expect(schema.parse(new Date("2022-01-01T00:00:00.000Z"))).toEqual(
+    new Date("2022-01-01T00:00:00.000Z").toString()
+  );
 });
 
 test("number coercion", () => {
   const schema = z.coerce.number();
   expect(schema.parse("12")).toEqual(12);
+  expect(schema.parse("0")).toEqual(0);
+  expect(schema.parse("-12")).toEqual(-12);
+  expect(schema.parse("3.14")).toEqual(3.14);
+  expect(schema.parse("")).toEqual(0);
+  expect(() => schema.parse("NOT_A_NUMBER")).toThrow; // z.ZodError
   expect(schema.parse(12)).toEqual(12);
-  expect(schema.parse(true)).toEqual(1);
+  expect(schema.parse(0)).toEqual(0);
+  expect(schema.parse(-12)).toEqual(-12);
+  expect(schema.parse(3.14)).toEqual(3.14);
   expect(schema.parse(BigInt(15))).toEqual(15);
+  expect(() => schema.parse(NaN)).toThrow; // z.ZodError
+  expect(schema.parse(Infinity)).toEqual(Infinity);
+  expect(schema.parse(-Infinity)).toEqual(-Infinity);
+  expect(schema.parse(true)).toEqual(1);
+  expect(schema.parse(false)).toEqual(0);
+  expect(schema.parse(null)).toEqual(0);
+  expect(() => schema.parse(undefined)).toThrow; // z.ZodError
+  expect(() => schema.parse({ hello: "world!" })).toThrow; // z.ZodError
+  expect(() => schema.parse(["item", "another_item"])).toThrow; // z.ZodError
+  expect(schema.parse([])).toEqual(0);
   expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);
 });
 
 test("boolean coercion", () => {
   const schema = z.coerce.boolean();
+  expect(schema.parse("true")).toEqual(true);
+  expect(schema.parse("false")).toEqual(true);
+  expect(schema.parse("0")).toEqual(true);
+  expect(schema.parse("1")).toEqual(true);
   expect(schema.parse("")).toEqual(false);
-  expect(schema.parse("12")).toEqual(true);
+  expect(schema.parse(1)).toEqual(true);
   expect(schema.parse(0)).toEqual(false);
-  expect(schema.parse(12)).toEqual(true);
+  expect(schema.parse(-1)).toEqual(true);
+  expect(schema.parse(3.14)).toEqual(true);
+  expect(schema.parse(BigInt(15))).toEqual(true);
+  expect(schema.parse(NaN)).toEqual(false);
+  expect(schema.parse(Infinity)).toEqual(true);
+  expect(schema.parse(-Infinity)).toEqual(true);
   expect(schema.parse(true)).toEqual(true);
+  expect(schema.parse(false)).toEqual(false);
+  expect(schema.parse(null)).toEqual(false);
+  expect(schema.parse(undefined)).toEqual(false);
+  expect(schema.parse({ hello: "world!" })).toEqual(true);
+  expect(schema.parse(["item", "another_item"])).toEqual(true);
+  expect(schema.parse([])).toEqual(true);
+  expect(schema.parse(new Date(1670139203496))).toEqual(true);
 });
 
 test("bigint coercion", () => {
   const schema = z.coerce.bigint();
   expect(schema.parse("5")).toEqual(BigInt(5));
+  expect(schema.parse("0")).toEqual(BigInt(0));
+  expect(schema.parse("-5")).toEqual(BigInt(-5));
+  expect(() => schema.parse("3.14")).toThrow; // not a z.ZodError!
+  expect(schema.parse("")).toEqual(BigInt(0));
+  expect(() => schema.parse("NOT_A_NUMBER")).toThrow; // not a z.ZodError!
+  expect(schema.parse(5)).toEqual(BigInt(5));
   expect(schema.parse(0)).toEqual(BigInt(0));
+  expect(schema.parse(-5)).toEqual(BigInt(-5));
+  expect(() => schema.parse(3.14)).toThrow; // not a z.ZodError!
   expect(schema.parse(BigInt(5))).toEqual(BigInt(5));
+  expect(() => schema.parse(NaN)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(Infinity)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(-Infinity)).toThrow; // not a z.ZodError!
+  expect(schema.parse(true)).toEqual(BigInt(1));
+  expect(schema.parse(false)).toEqual(BigInt(0));
+  expect(() => schema.parse(null)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(undefined)).toThrow; // not a z.ZodError!
+  expect(() => schema.parse({ hello: "world!" })).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(["item", "another_item"])).toThrow; // not a z.ZodError!
+  expect(schema.parse([])).toEqual(BigInt(0));
   expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));
 });
 
 test("date coercion", () => {
   const schema = z.coerce.date();
-  expect(schema.parse("5") instanceof Date).toEqual(true);
-  expect(schema.parse(0) instanceof Date).toEqual(true);
-  expect(schema.parse(new Date()) instanceof Date).toEqual(true);
+  expect(schema.parse(new Date().toDateString())).toBeInstanceOf(Date);
+  expect(schema.parse(new Date().toISOString())).toBeInstanceOf(Date);
+  expect(schema.parse(new Date().toUTCString())).toBeInstanceOf(Date);
+  expect(schema.parse("5")).toBeInstanceOf(Date);
+  expect(schema.parse("0")).toBeInstanceOf(Date);
+  expect(schema.parse("-5")).toBeInstanceOf(Date);
+  expect(schema.parse("3.14")).toBeInstanceOf(Date);
+  expect(() => schema.parse("")).toThrow; // z.ZodError
+  expect(() => schema.parse("NOT_A_DATE")).toThrow; // z.ZodError
+  expect(schema.parse(5)).toBeInstanceOf(Date);
+  expect(schema.parse(0)).toBeInstanceOf(Date);
+  expect(schema.parse(-5)).toBeInstanceOf(Date);
+  expect(schema.parse(3.14)).toBeInstanceOf(Date);
+  expect(() => schema.parse(BigInt(5))).toThrow; // not a z.ZodError!
+  expect(() => schema.parse(NaN)).toThrow; // z.ZodError
+  expect(() => schema.parse(Infinity)).toThrow; // z.ZodError
+  expect(() => schema.parse(-Infinity)).toThrow; // z.ZodError
+  expect(schema.parse(true)).toBeInstanceOf(Date);
+  expect(schema.parse(false)).toBeInstanceOf(Date);
+  expect(schema.parse(null)).toBeInstanceOf(Date);
+  expect(() => schema.parse(undefined)).toThrow; // z.ZodError
+  expect(() => schema.parse({ hello: "world!" })).toThrow; // z.ZodError
+  expect(() => schema.parse(["item", "another_item"])).toThrow; // z.ZodError
+  expect(() => schema.parse([])).toThrow; // z.ZodError
+  expect(schema.parse(new Date())).toBeInstanceOf(Date);
 });
diff --git a/src/__tests__/description.test.ts b/src/__tests__/description.test.ts
index 9c2f7286c..5a8d73dc8 100644
--- a/src/__tests__/description.test.ts
+++ b/src/__tests__/description.test.ts
@@ -3,8 +3,25 @@ import { expect, test } from "@jest/globals";
 
 import * as z from "../index";
 
-test("description", () => {
-  const schema: any = z.string();
-  const DESC = "asdlfkjasdf";
-  expect(schema.describe(DESC).description).toEqual(DESC);
+const description = "a description";
+
+test("passing `description` to schema should add a description", () => {
+  expect(z.string({ description }).description).toEqual(description);
+  expect(z.number({ description }).description).toEqual(description);
+  expect(z.boolean({ description }).description).toEqual(description);
+});
+
+test("`.describe` should add a description", () => {
+  expect(z.string().describe(description).description).toEqual(description);
+  expect(z.number().describe(description).description).toEqual(description);
+  expect(z.boolean().describe(description).description).toEqual(description);
+});
+
+test("description should carry over to chained schemas", () => {
+  const schema = z.string({ description });
+  expect(schema.description).toEqual(description);
+  expect(schema.optional().description).toEqual(description);
+  expect(schema.optional().nullable().default("default").description).toEqual(
+    description
+  );
 });
diff --git a/src/__tests__/discriminatedUnions.test.ts b/src/__tests__/discriminatedUnions.test.ts
index dbce353e9..68a3f8fb9 100644
--- a/src/__tests__/discriminatedUnions.test.ts
+++ b/src/__tests__/discriminatedUnions.test.ts
@@ -1,3 +1,4 @@
+// @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
 import * as z from "../index";
diff --git a/src/__tests__/enum.test.ts b/src/__tests__/enum.test.ts
index 79d925bbd..158ac0a67 100644
--- a/src/__tests__/enum.test.ts
+++ b/src/__tests__/enum.test.ts
@@ -40,3 +40,20 @@ test("error params", () => {
     expect(result.error.issues[0].message).toEqual("REQUIRED");
   }
 });
+
+test("extract/exclude", () => {
+  const foods = ["Pasta", "Pizza", "Tacos", "Burgers", "Salad"] as const;
+  const FoodEnum = z.enum(foods);
+  const ItalianEnum = FoodEnum.extract(["Pasta", "Pizza"]);
+  const UnhealthyEnum = FoodEnum.exclude(["Salad"]);
+  const EmptyFoodEnum = FoodEnum.exclude(foods);
+
+  util.assertEqual<z.infer<typeof ItalianEnum>, "Pasta" | "Pizza">(true);
+  util.assertEqual<
+    z.infer<typeof UnhealthyEnum>,
+    "Pasta" | "Pizza" | "Tacos" | "Burgers"
+  >(true);
+  // @ts-expect-error TS2344
+  util.assertEqual<typeof EmptyFoodEnum, z.ZodEnum<[]>>(true);
+  util.assertEqual<z.infer<typeof EmptyFoodEnum>, never>(true);
+});
diff --git a/src/__tests__/firstparty.test.ts b/src/__tests__/firstparty.test.ts
index b8b51dec3..bd5f6986d 100644
--- a/src/__tests__/firstparty.test.ts
+++ b/src/__tests__/firstparty.test.ts
@@ -1,3 +1,4 @@
+// @ts-ignore TS6133
 import { test } from "@jest/globals";
 
 import { util } from "../helpers/util";
diff --git a/src/__tests__/literal.test.ts b/src/__tests__/literal.test.ts
new file mode 100644
index 000000000..140f728e6
--- /dev/null
+++ b/src/__tests__/literal.test.ts
@@ -0,0 +1,36 @@
+// @ts-ignore TS6133
+import { expect, test } from "@jest/globals";
+
+import * as z from "../index";
+
+const literalTuna = z.literal("tuna");
+const literalFortyTwo = z.literal(42);
+const literalTrue = z.literal(true);
+
+const terrificSymbol = Symbol("terrific");
+const literalTerrificSymbol = z.literal(terrificSymbol);
+
+test("passing validations", () => {
+  literalTuna.parse("tuna");
+  literalFortyTwo.parse(42);
+  literalTrue.parse(true);
+  literalTerrificSymbol.parse(terrificSymbol);
+});
+
+test("failing validations", () => {
+  expect(() => literalTuna.parse("shark")).toThrow();
+  expect(() => literalFortyTwo.parse(43)).toThrow();
+  expect(() => literalTrue.parse(false)).toThrow();
+  expect(() => literalTerrificSymbol.parse(Symbol("terrific"))).toThrow();
+});
+
+test("invalid_literal should have `received` field with data", () => {
+  const data = "shark";
+  const result = literalTuna.safeParse(data);
+  if (!result.success) {
+    const issue = result.error.issues[0];
+    if (issue.code === "invalid_literal") {
+      expect(issue.received).toBe(data);
+    }
+  }
+});
diff --git a/src/__tests__/number.test.ts b/src/__tests__/number.test.ts
index daf50545a..d044eb9c6 100644
--- a/src/__tests__/number.test.ts
+++ b/src/__tests__/number.test.ts
@@ -5,10 +5,17 @@ import * as z from "../index";
 
 const gtFive = z.number().gt(5);
 const gteFive = z.number().gte(5);
+const minFive = z.number().min(5);
 const ltFive = z.number().lt(5);
 const lteFive = z.number().lte(5);
+const maxFive = z.number().max(5);
 const intNum = z.number().int();
+const positive = z.number().positive();
+const negative = z.number().negative();
+const nonpositive = z.number().nonpositive();
+const nonnegative = z.number().nonnegative();
 const multipleOfFive = z.number().multipleOf(5);
+const multipleOfNegativeFive = z.number().multipleOf(-5);
 const finite = z.number().finite();
 const stepPointOne = z.number().step(0.1);
 const stepPointZeroZeroZeroOne = z.number().step(0.0001);
@@ -23,11 +30,32 @@ test("passing validations", () => {
   z.number().parse(Infinity);
   z.number().parse(-Infinity);
   gtFive.parse(6);
+  gtFive.parse(Infinity);
   gteFive.parse(5);
+  gteFive.parse(Infinity);
+  minFive.parse(5);
+  minFive.parse(Infinity);
   ltFive.parse(4);
+  ltFive.parse(-Infinity);
   lteFive.parse(5);
+  lteFive.parse(-Infinity);
+  maxFive.parse(5);
+  maxFive.parse(-Infinity);
   intNum.parse(4);
+  positive.parse(1);
+  positive.parse(Infinity);
+  negative.parse(-1);
+  negative.parse(-Infinity);
+  nonpositive.parse(0);
+  nonpositive.parse(-1);
+  nonpositive.parse(-Infinity);
+  nonnegative.parse(0);
+  nonnegative.parse(1);
+  nonnegative.parse(Infinity);
   multipleOfFive.parse(15);
+  multipleOfFive.parse(-15);
+  multipleOfNegativeFive.parse(-15);
+  multipleOfNegativeFive.parse(15);
   finite.parse(123);
   stepPointOne.parse(6);
   stepPointOne.parse(6.1);
@@ -39,10 +67,21 @@ test("passing validations", () => {
 test("failing validations", () => {
   expect(() => ltFive.parse(5)).toThrow();
   expect(() => lteFive.parse(6)).toThrow();
+  expect(() => maxFive.parse(6)).toThrow();
   expect(() => gtFive.parse(5)).toThrow();
   expect(() => gteFive.parse(4)).toThrow();
+  expect(() => minFive.parse(4)).toThrow();
   expect(() => intNum.parse(3.14)).toThrow();
-  expect(() => multipleOfFive.parse(14.9)).toThrow();
+  expect(() => positive.parse(0)).toThrow();
+  expect(() => positive.parse(-1)).toThrow();
+  expect(() => negative.parse(0)).toThrow();
+  expect(() => negative.parse(1)).toThrow();
+  expect(() => nonpositive.parse(1)).toThrow();
+  expect(() => nonnegative.parse(-1)).toThrow();
+  expect(() => multipleOfFive.parse(7.5)).toThrow();
+  expect(() => multipleOfFive.parse(-7.5)).toThrow();
+  expect(() => multipleOfNegativeFive.parse(-7.5)).toThrow();
+  expect(() => multipleOfNegativeFive.parse(7.5)).toThrow();
   expect(() => finite.parse(Infinity)).toThrow();
   expect(() => finite.parse(-Infinity)).toThrow();
 
@@ -56,12 +95,73 @@ test("parse NaN", () => {
 });
 
 test("min max getters", () => {
-  expect(z.number().int().isInt).toEqual(true);
+  expect(z.number().minValue).toBeNull;
+  expect(ltFive.minValue).toBeNull;
+  expect(lteFive.minValue).toBeNull;
+  expect(maxFive.minValue).toBeNull;
+  expect(negative.minValue).toBeNull;
+  expect(nonpositive.minValue).toBeNull;
+  expect(intNum.minValue).toBeNull;
+  expect(multipleOfFive.minValue).toBeNull;
+  expect(finite.minValue).toBeNull;
+  expect(gtFive.minValue).toEqual(5);
+  expect(gteFive.minValue).toEqual(5);
+  expect(minFive.minValue).toEqual(5);
+  expect(minFive.min(10).minValue).toEqual(10);
+  expect(positive.minValue).toEqual(0);
+  expect(nonnegative.minValue).toEqual(0);
+
+  expect(z.number().maxValue).toBeNull;
+  expect(gtFive.maxValue).toBeNull;
+  expect(gteFive.maxValue).toBeNull;
+  expect(minFive.maxValue).toBeNull;
+  expect(positive.maxValue).toBeNull;
+  expect(nonnegative.maxValue).toBeNull;
+  expect(intNum.minValue).toBeNull;
+  expect(multipleOfFive.minValue).toBeNull;
+  expect(finite.minValue).toBeNull;
+  expect(ltFive.maxValue).toEqual(5);
+  expect(lteFive.maxValue).toEqual(5);
+  expect(maxFive.maxValue).toEqual(5);
+  expect(maxFive.max(1).maxValue).toEqual(1);
+  expect(negative.maxValue).toEqual(0);
+  expect(nonpositive.maxValue).toEqual(0);
+});
+
+test("int getter", () => {
   expect(z.number().isInt).toEqual(false);
+  expect(z.number().multipleOf(1.5).isInt).toEqual(false);
+  expect(gtFive.isInt).toEqual(false);
+  expect(gteFive.isInt).toEqual(false);
+  expect(minFive.isInt).toEqual(false);
+  expect(positive.isInt).toEqual(false);
+  expect(nonnegative.isInt).toEqual(false);
+  expect(finite.isInt).toEqual(false);
+  expect(ltFive.isInt).toEqual(false);
+  expect(lteFive.isInt).toEqual(false);
+  expect(maxFive.isInt).toEqual(false);
+  expect(negative.isInt).toEqual(false);
+  expect(nonpositive.isInt).toEqual(false);
+
+  expect(intNum.isInt).toEqual(true);
+  expect(multipleOfFive.isInt).toEqual(true);
+});
 
-  expect(z.number().min(5).minValue).toEqual(5);
-  expect(z.number().min(5).min(10).minValue).toEqual(10);
+test("finite getter", () => {
+  expect(z.number().isFinite).toEqual(false);
+  expect(gtFive.isFinite).toEqual(false);
+  expect(gteFive.isFinite).toEqual(false);
+  expect(minFive.isFinite).toEqual(false);
+  expect(positive.isFinite).toEqual(false);
+  expect(nonnegative.isFinite).toEqual(false);
+  expect(ltFive.isFinite).toEqual(false);
+  expect(lteFive.isFinite).toEqual(false);
+  expect(maxFive.isFinite).toEqual(false);
+  expect(negative.isFinite).toEqual(false);
+  expect(nonpositive.isFinite).toEqual(false);
 
-  expect(z.number().max(5).maxValue).toEqual(5);
-  expect(z.number().max(5).max(1).maxValue).toEqual(1);
+  expect(finite.isFinite).toEqual(true);
+  expect(intNum.isFinite).toEqual(true);
+  expect(multipleOfFive.isFinite).toEqual(true);
+  expect(z.number().min(5).max(10).isFinite).toEqual(true);
 });
diff --git a/src/__tests__/object-in-es5-env.test.ts b/src/__tests__/object-in-es5-env.test.ts
index bfd3ad9c3..6d17a0964 100644
--- a/src/__tests__/object-in-es5-env.test.ts
+++ b/src/__tests__/object-in-es5-env.test.ts
@@ -1,3 +1,4 @@
+// @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
 import * as z from "../index";
diff --git a/src/__tests__/object.test.ts b/src/__tests__/object.test.ts
index e1e7fc532..78189530d 100644
--- a/src/__tests__/object.test.ts
+++ b/src/__tests__/object.test.ts
@@ -28,6 +28,18 @@ test("unknown throw", () => {
   expect(() => Test.parse(asdf)).toThrow();
 });
 
+test("shape() should return schema of particular key", () => {
+  const f1Schema = Test.shape.f1;
+  const f2Schema = Test.shape.f2;
+  const f3Schema = Test.shape.f3;
+  const f4Schema = Test.shape.f4;
+
+  expect(f1Schema).toBeInstanceOf(z.ZodNumber);
+  expect(f2Schema).toBeInstanceOf(z.ZodOptional);
+  expect(f3Schema).toBeInstanceOf(z.ZodNullable);
+  expect(f4Schema).toBeInstanceOf(z.ZodArray);
+});
+
 test("correct parsing", () => {
   Test.parse({
     f1: 12,
@@ -388,3 +400,42 @@ test("unknownkeys merging", () => {
   util.assertEqual<mergedSchema["_def"]["catchall"], z.ZodString>(true);
   expect(mergedSchema._def.catchall instanceof z.ZodString).toEqual(true);
 });
+
+const personToExtend = z.object({
+  firstName: z.string(),
+  lastName: z.string(),
+});
+
+test("extend() should return schema with new key", () => {
+  const PersonWithNickname = personToExtend.extend({ nickName: z.string() });
+  type PersonWithNickname = z.infer<typeof PersonWithNickname>;
+
+  const expected = { firstName: "f", nickName: "n", lastName: "l" };
+  const actual = PersonWithNickname.parse(expected);
+
+  expect(actual).toEqual(expected);
+  util.assertEqual<
+    keyof PersonWithNickname,
+    "firstName" | "lastName" | "nickName"
+  >(true);
+  util.assertEqual<
+    PersonWithNickname,
+    { firstName: string; lastName: string; nickName: string }
+  >(true);
+});
+
+test("extend() should have power to override existing key", () => {
+  const PersonWithNumberAsLastName = personToExtend.extend({
+    lastName: z.number(),
+  });
+  type PersonWithNumberAsLastName = z.infer<typeof PersonWithNumberAsLastName>;
+
+  const expected = { firstName: "f", lastName: 42 };
+  const actual = PersonWithNumberAsLastName.parse(expected);
+
+  expect(actual).toEqual(expected);
+  util.assertEqual<
+    PersonWithNumberAsLastName,
+    { firstName: string; lastName: number }
+  >(true);
+});
diff --git a/src/__tests__/partials.test.ts b/src/__tests__/partials.test.ts
index bf90791ea..f6d7fcf7d 100644
--- a/src/__tests__/partials.test.ts
+++ b/src/__tests__/partials.test.ts
@@ -184,21 +184,88 @@ test("required with mask", () => {
   expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);
 });
 
+test("required with mask containing a nonexistent key", () => {
+  const object = z.object({
+    name: z.string(),
+    age: z.number().optional(),
+    field: z.string().optional().default("asdf"),
+    country: z.string().optional(),
+  });
+  object.required({
+    age: true,
+    // @ts-expect-error should not accept unexpected keys.
+    doesntExist: true,
+  });
+});
+
+test("required with mask -- ignore falsy values", () => {
+  const object = z.object({
+    name: z.string(),
+    age: z.number().optional(),
+    field: z.string().optional().default("asdf"),
+    country: z.string().optional(),
+  });
+
+  // @ts-expect-error
+  const requiredObject = object.required({ age: true, country: false });
+  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);
+  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);
+  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);
+  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);
+});
+
 test("partial with mask", async () => {
   const object = z.object({
     name: z.string(),
     age: z.number().optional(),
     field: z.string().optional().default("asdf"),
+    country: z.string(),
   });
 
   const masked = object
-    .partial({
-      name: true,
-      age: true,
-      field: true,
-    })
+    .partial({ age: true, field: true, name: true })
     .strict();
 
-  masked.parse({});
-  await masked.parseAsync({});
+  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);
+  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);
+  expect(masked.shape.field).toBeInstanceOf(z.ZodOptional);
+  expect(masked.shape.country).toBeInstanceOf(z.ZodString);
+
+  masked.parse({ country: "US" });
+  await masked.parseAsync({ country: "US" });
+});
+
+test("partial with mask -- ignore falsy values", async () => {
+  const object = z.object({
+    name: z.string(),
+    age: z.number().optional(),
+    field: z.string().optional().default("asdf"),
+    country: z.string(),
+  });
+
+  // @ts-expect-error
+  const masked = object.partial({ name: true, country: false }).strict();
+
+  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);
+  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);
+  expect(masked.shape.field).toBeInstanceOf(z.ZodDefault);
+  expect(masked.shape.country).toBeInstanceOf(z.ZodString);
+
+  masked.parse({ country: "US" });
+  await masked.parseAsync({ country: "US" });
+});
+
+test("partial with mask containing a nonexistent key", () => {
+  const object = z.object({
+    name: z.string(),
+    age: z.number().optional(),
+    field: z.string().optional().default("asdf"),
+    country: z.string().optional(),
+  });
+
+  object.partial({
+    age: true,
+    // @ts-expect-error should not accept unexpected keys.
+    doesntExist: true,
+  });
 });
diff --git a/src/__tests__/pickomit.test.ts b/src/__tests__/pickomit.test.ts
index f5baa10c6..a6215a42c 100644
--- a/src/__tests__/pickomit.test.ts
+++ b/src/__tests__/pickomit.test.ts
@@ -19,6 +19,10 @@ test("pick type inference", () => {
 test("pick parse - success", () => {
   const nameonlyFish = fish.pick({ name: true });
   nameonlyFish.parse({ name: "bob" });
+
+  // @ts-expect-error checking runtime picks `name` only.
+  const anotherNameonlyFish = fish.pick({ name: true, age: false });
+  anotherNameonlyFish.parse({ name: "bob" });
 });
 
 test("pick parse - fail", () => {
@@ -31,9 +35,14 @@ test("pick parse - fail", () => {
   const bad2 = () => nameonlyFish.parse({ name: "bob", age: 12 } as any);
   const bad3 = () => nameonlyFish.parse({ age: 12 } as any);
 
+  // @ts-expect-error checking runtime picks `name` only.
+  const anotherNameonlyFish = fish.pick({ name: true, age: false }).strict();
+  const bad4 = () => anotherNameonlyFish.parse({ name: "bob", age: 12 } as any);
+
   expect(bad1).toThrow();
   expect(bad2).toThrow();
   expect(bad3).toThrow();
+  expect(bad4).toThrow();
 });
 
 test("omit type inference", () => {
@@ -45,6 +54,10 @@ test("omit type inference", () => {
 test("omit parse - success", () => {
   const nonameFish = fish.omit({ name: true });
   nonameFish.parse({ age: 12, nested: {} });
+
+  // @ts-expect-error checking runtime omits `name` only.
+  const anotherNonameFish = fish.omit({ name: true, age: false });
+  anotherNonameFish.parse({ age: 12, nested: {} });
 });
 
 test("omit parse - fail", () => {
@@ -53,9 +66,14 @@ test("omit parse - fail", () => {
   const bad2 = () => nonameFish.parse({ age: 12 } as any);
   const bad3 = () => nonameFish.parse({} as any);
 
+  // @ts-expect-error checking runtime omits `name` only.
+  const anotherNonameFish = fish.omit({ name: true, age: false });
+  const bad4 = () => anotherNonameFish.parse({ nested: {} } as any);
+
   expect(bad1).toThrow();
   expect(bad2).toThrow();
   expect(bad3).toThrow();
+  expect(bad4).toThrow();
 });
 
 test("nonstrict inference", () => {
@@ -65,13 +83,13 @@ test("nonstrict inference", () => {
 });
 
 test("nonstrict parsing - pass", () => {
-  const laxfish = fish.nonstrict().pick({ name: true });
+  const laxfish = fish.passthrough().pick({ name: true });
   laxfish.parse({ name: "asdf", whatever: "asdf" });
   laxfish.parse({ name: "asdf", age: 12, nested: {} });
 });
 
 test("nonstrict parsing - fail", () => {
-  const laxfish = fish.nonstrict().pick({ name: true });
+  const laxfish = fish.passthrough().pick({ name: true });
   const bad = () => laxfish.parse({ whatever: "asdf" } as any);
   expect(bad).toThrow();
 });
@@ -84,6 +102,7 @@ test("pick a nonexistent key", () => {
 
   const pickedSchema = schema.pick({
     a: true,
+    // @ts-expect-error should not accept unexpected keys.
     doesntExist: true,
   });
 
@@ -91,3 +110,16 @@ test("pick a nonexistent key", () => {
     a: "value",
   });
 });
+
+test("omit a nonexistent key", () => {
+  const schema = z.object({
+    a: z.string(),
+    b: z.number(),
+  });
+
+  schema.omit({
+    a: true,
+    // @ts-expect-error should not accept unexpected keys.
+    doesntExist: true,
+  });
+});
diff --git a/src/__tests__/promise.test.ts b/src/__tests__/promise.test.ts
index cda9d711f..e0c9d3cc0 100644
--- a/src/__tests__/promise.test.ts
+++ b/src/__tests__/promise.test.ts
@@ -86,3 +86,9 @@ test("async promise parsing", () => {
   const res = z.promise(z.number()).parseAsync(Promise.resolve(12));
   expect(res).toBeInstanceOf(Promise);
 });
+
+test("resolves", () => {
+  const foo = z.literal("foo");
+  const res = z.promise(foo);
+  expect(res.unwrap()).toEqual(foo);
+});
diff --git a/src/__tests__/string.test.ts b/src/__tests__/string.test.ts
index 28e4049a9..cb075cf75 100644
--- a/src/__tests__/string.test.ts
+++ b/src/__tests__/string.test.ts
@@ -37,24 +37,66 @@ test("email validations", () => {
   expect(() => email.parse("asdf")).toThrow();
   expect(() => email.parse("@lkjasdf.com")).toThrow();
   expect(() => email.parse("asdf@sdf.")).toThrow();
-  // expect(() => email.parse("asdf@asdf.com-")).toThrow();
-  // expect(() => email.parse("asdf@-asdf.com")).toThrow();
+  expect(() => email.parse("asdf@asdf.com-")).toThrow();
+  expect(() => email.parse("asdf@-asdf.com")).toThrow();
+  expect(() => email.parse("asdf@-a(sdf.com")).toThrow();
+  expect(() => email.parse("asdf@-asdf.com(")).toThrow();
+  expect(() =>
+    email.parse("pawan.anand@%9y83&#$%R&#$%R&%#$R%%^^%5rw3ewe.d.d.aaaa.wef.co")
+  ).toThrow();
 });
 
 test("more email validations", () => {
-  const data = [
-    `"josé.arrañoça"@domain.com`,
-    `"сайт"@domain.com`,
-    `"💩"@domain.com`,
-    `"🍺🕺🎉"@domain.com`,
-    `poop@💩.la`,
-    `"🌮"@i❤️tacos.ws`,
-    "sss--asd@i❤️tacos.ws",
+  const validEmails = [
+    `very.common@example.com`,
+    `disposable.style.email.with+symbol@example.com`,
+    `other.email-with-hyphen@example.com`,
+    `fully-qualified-domain@example.com`,
+    `user.name+tag+sorting@example.com`,
+    `x@example.com`,
+    `example-indeed@strange-example.com`,
+    `test/test@test.com`,
+    `example@s.example`,
+    `" "@example.org`,
+    `"john..doe"@example.org`,
+    `mailhost!username@example.org`,
+    `"very.(),:;<>[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com`,
+    `user%example.com@example.org`,
+    `user-@example.org`,
+    `postmaster@[123.123.123.123]`,
+    `user@my-example.com`,
+    `a@b.cd`,
+    `work+user@mail.com`,
+    `user@[68.185.127.196]`,
+    `ipv4@[85.129.96.247]`,
+    `valid@[79.208.229.53]`,
   ];
-  const email = z.string().email();
-  for (const datum of data) {
-    email.parse(datum);
-  }
+  const invalidEmails = [
+    `Abc.example.com`,
+    `A@b@c@example.com`,
+    `a"b(c)d,e:f;g<h>i[j\k]l@example.com`,
+    `just"not"right@example.com`,
+    `this is"not\allowed@example.com`,
+    `this\ still\"not\\allowed@example.com`,
+    `i_like_underscore@but_its_not_allowed_in_this_part.example.com`,
+    `QA[icon]CHOCOLATE[icon]@test.com`,
+    `invalid@-start.com`,
+    `invalid@end.com-`,
+    `a.b@c.d`,
+    `invalid@[1.1.1.-1]`,
+    `invalid@[68.185.127.196.55]`,
+    `temp@[192.168.1]`,
+    `temp@[9.18.122.]`,
+  ];
+  const emailSchema = z.string().email();
+  expect(
+    validEmails.every((email) => emailSchema.safeParse(email).success)
+  ).toBe(true);
+  expect(
+    invalidEmails.every(
+      (email) => emailSchema.safeParse(email).success === false
+    )
+  ).toBe(true);
 });
 
 test("url validations", () => {
@@ -119,6 +161,27 @@ test("cuid", () => {
   }
 });
 
+test("cuid2", () => {
+  const cuid2 = z.string().cuid2();
+  const validStrings = [
+    "a", // short string
+    "tz4a98xxat96iws9zmbrgj3a", // normal string
+    "kf5vz6ssxe4zjcb409rjgo747tc5qjazgptvotk6", // longer than require("@paralleldrive/cuid2").bigLength
+  ];
+  validStrings.forEach((s) => cuid2.parse(s));
+  const invalidStrings = [
+    "", // empty string
+    "1z4a98xxat96iws9zmbrgj3a", // starts with a number
+    "tz4a98xxat96iws9zMbrgj3a", // include uppercase
+    "tz4a98xxat96iws-zmbrgj3a", // involve symbols
+  ];
+  const results = invalidStrings.map((s) => cuid2.safeParse(s));
+  expect(results.every((r) => !r.success)).toEqual(true);
+  if (!results[0].success) {
+    expect(results[0].error.issues[0].message).toEqual("Invalid cuid2");
+  }
+});
+
 test("regex", () => {
   z.string()
     .regex(/^moo+$/)
@@ -153,21 +216,31 @@ test("checks getters", () => {
   expect(z.string().email().isEmail).toEqual(true);
   expect(z.string().email().isURL).toEqual(false);
   expect(z.string().email().isCUID).toEqual(false);
+  expect(z.string().email().isCUID2).toEqual(false);
   expect(z.string().email().isUUID).toEqual(false);
 
   expect(z.string().url().isEmail).toEqual(false);
   expect(z.string().url().isURL).toEqual(true);
   expect(z.string().url().isCUID).toEqual(false);
+  expect(z.string().url().isCUID2).toEqual(false);
   expect(z.string().url().isUUID).toEqual(false);
 
   expect(z.string().cuid().isEmail).toEqual(false);
   expect(z.string().cuid().isURL).toEqual(false);
   expect(z.string().cuid().isCUID).toEqual(true);
+  expect(z.string().cuid().isCUID2).toEqual(false);
   expect(z.string().cuid().isUUID).toEqual(false);
 
+  expect(z.string().cuid2().isEmail).toEqual(false);
+  expect(z.string().cuid2().isURL).toEqual(false);
+  expect(z.string().cuid2().isCUID).toEqual(false);
+  expect(z.string().cuid2().isCUID2).toEqual(true);
+  expect(z.string().cuid2().isUUID).toEqual(false);
+
   expect(z.string().uuid().isEmail).toEqual(false);
   expect(z.string().uuid().isURL).toEqual(false);
   expect(z.string().uuid().isCUID).toEqual(false);
+  expect(z.string().uuid().isCUID2).toEqual(false);
   expect(z.string().uuid().isUUID).toEqual(true);
 });
 
@@ -242,6 +315,8 @@ test("datetime parsing", () => {
   datetimeOffset.parse("2022-10-13T09:52:31.4Z");
   datetimeOffset.parse("2020-10-14T17:42:29+00:00");
   datetimeOffset.parse("2020-10-14T17:42:29+03:15");
+  datetimeOffset.parse("2020-10-14T17:42:29+0315");
+  datetimeOffset.parse("2020-10-14T17:42:29+03");
   expect(() => datetimeOffset.parse("tuna")).toThrow();
   expect(() => datetimeOffset.parse("2022-10-13T09:52:31.Z")).toThrow();
 
@@ -251,6 +326,8 @@ test("datetime parsing", () => {
   datetimeOffsetNoMs.parse("1970-01-01T00:00:00Z");
   datetimeOffsetNoMs.parse("2022-10-13T09:52:31Z");
   datetimeOffsetNoMs.parse("2020-10-14T17:42:29+00:00");
+  datetimeOffsetNoMs.parse("2020-10-14T17:42:29+0000");
+  datetimeOffsetNoMs.parse("2020-10-14T17:42:29+00");
   expect(() => datetimeOffsetNoMs.parse("tuna")).toThrow();
   expect(() => datetimeOffsetNoMs.parse("1970-01-01T00:00:00.000Z")).toThrow();
   expect(() => datetimeOffsetNoMs.parse("1970-01-01T00:00:00.Z")).toThrow();
@@ -262,6 +339,8 @@ test("datetime parsing", () => {
   const datetimeOffset4Ms = z.string().datetime({ offset: true, precision: 4 });
   datetimeOffset4Ms.parse("1970-01-01T00:00:00.1234Z");
   datetimeOffset4Ms.parse("2020-10-14T17:42:29.1234+00:00");
+  datetimeOffset4Ms.parse("2020-10-14T17:42:29.1234+0000");
+  datetimeOffset4Ms.parse("2020-10-14T17:42:29.1234+00");
   expect(() => datetimeOffset4Ms.parse("tuna")).toThrow();
   expect(() => datetimeOffset4Ms.parse("1970-01-01T00:00:00.123Z")).toThrow();
   expect(() =>
diff --git a/src/__tests__/tuple.test.ts b/src/__tests__/tuple.test.ts
index a1e4aa50e..364881c4e 100644
--- a/src/__tests__/tuple.test.ts
+++ b/src/__tests__/tuple.test.ts
@@ -88,6 +88,10 @@ test("tuple with rest schema", () => {
   util.assertEqual<t1, [string, number, ...boolean[]]>(true);
 });
 
+test("parse should fail given sparse array as tuple", () => {
+  expect(() => testTuple.parse(new Array(3))).toThrow();
+});
+
 // test('tuple with optional elements', () => {
 //   const result = z
 //     .tuple([z.string(), z.number().optional()])
diff --git a/src/__tests__/unions.test.ts b/src/__tests__/unions.test.ts
index fcae2459a..e7b30bcef 100644
--- a/src/__tests__/unions.test.ts
+++ b/src/__tests__/unions.test.ts
@@ -1,3 +1,4 @@
+// @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
 import * as z from "../index";
diff --git a/src/benchmarks/primitives.ts b/src/benchmarks/primitives.ts
index 7e4a99eac..5b0034f1d 100644
--- a/src/benchmarks/primitives.ts
+++ b/src/benchmarks/primitives.ts
@@ -1,7 +1,10 @@
 import Benchmark from "benchmark";
 
+import { Mocker } from "../__tests__/Mocker";
 import { z } from "../index";
 
+const val = new Mocker();
+
 const enumSuite = new Benchmark.Suite("z.enum");
 const enumSchema = z.enum(["a", "b", "c"]);
 
@@ -73,6 +76,63 @@ numberSuite
     console.log(`z.number: ${e.target}`);
   });
 
+const dateSuite = new Benchmark.Suite("z.date");
+
+const plainDate = z.date();
+const minMaxDate = z
+  .date()
+  .min(new Date("2021-01-01"))
+  .max(new Date("2030-01-01"));
+
+dateSuite
+  .add("valid", () => {
+    plainDate.parse(new Date());
+  })
+  .add("invalid", () => {
+    try {
+      plainDate.parse(1);
+    } catch (e) {}
+  })
+  .add("valid min and max", () => {
+    minMaxDate.parse(new Date("2023-01-01"));
+  })
+  .add("invalid min", () => {
+    try {
+      minMaxDate.parse(new Date("2019-01-01"));
+    } catch (e) {}
+  })
+  .add("invalid max", () => {
+    try {
+      minMaxDate.parse(new Date("2031-01-01"));
+    } catch (e) {}
+  })
+  .on("cycle", (e: Benchmark.Event) => {
+    console.log(`z.date: ${e.target}`);
+  });
+
+const symbolSuite = new Benchmark.Suite("z.symbol");
+const symbolSchema = z.symbol();
+
+symbolSuite
+  .add("valid", () => {
+    symbolSchema.parse(val.symbol);
+  })
+  .add("invalid", () => {
+    try {
+      symbolSchema.parse(1);
+    } catch (e) {}
+  })
+  .on("cycle", (e: Benchmark.Event) => {
+    console.log(`z.symbol: ${e.target}`);
+  });
+
 export default {
-  suites: [enumSuite, undefinedSuite, literalSuite, numberSuite],
+  suites: [
+    enumSuite,
+    undefinedSuite,
+    literalSuite,
+    numberSuite,
+    dateSuite,
+    symbolSuite,
+  ],
 };
diff --git a/src/helpers/parseUtil.ts b/src/helpers/parseUtil.ts
index 3edd467e9..eb6690ef8 100644
--- a/src/helpers/parseUtil.ts
+++ b/src/helpers/parseUtil.ts
@@ -175,4 +175,4 @@ export const isValid = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
 export const isAsync = <T>(
   x: ParseReturnType<T>
 ): x is AsyncParseReturnType<T> =>
-  typeof Promise !== undefined && x instanceof Promise;
+  typeof Promise !== "undefined" && x instanceof Promise;
diff --git a/src/helpers/util.ts b/src/helpers/util.ts
index 5660b72ef..5248d6521 100644
--- a/src/helpers/util.ts
+++ b/src/helpers/util.ts
@@ -67,7 +67,10 @@ export namespace util {
   };
 
   export type identity<T> = T;
-  export type flatten<T> = identity<{ [k in keyof T]: T[k] }>;
+  export type flatten<T> = identity<{
+    [k in keyof T]: T[k];
+  }>;
+
   export type noUndefined<T> = T extends undefined ? never : T;
 
   export const isInteger: NumberConstructor["isInteger"] =
diff --git a/src/types.ts b/src/types.ts
index ef27ec585..30a93488a 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -390,33 +390,34 @@ export abstract class ZodType<
   }
 
   optional(): ZodOptional<this> {
-    return ZodOptional.create(this) as any;
+    return ZodOptional.create(this, this._def) as any;
   }
   nullable(): ZodNullable<this> {
-    return ZodNullable.create(this) as any;
+    return ZodNullable.create(this, this._def) as any;
   }
-  nullish(): ZodNullable<ZodOptional<this>> {
-    return this.optional().nullable();
+  nullish(): ZodOptional<ZodNullable<this>> {
+    return this.nullable().optional();
   }
   array(): ZodArray<this> {
-    return ZodArray.create(this);
+    return ZodArray.create(this, this._def);
   }
   promise(): ZodPromise<this> {
-    return ZodPromise.create(this);
+    return ZodPromise.create(this, this._def);
   }
 
   or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
-    return ZodUnion.create([this, option]) as any;
+    return ZodUnion.create([this, option], this._def) as any;
   }
 
   and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T> {
-    return ZodIntersection.create(this, incoming);
+    return ZodIntersection.create(this, incoming, this._def);
   }
 
   transform<NewOut>(
     transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>
   ): ZodEffects<this, NewOut> {
     return new ZodEffects({
+      ...processCreateParams(this._def),
       schema: this,
       typeName: ZodFirstPartyTypeKind.ZodEffects,
       effect: { type: "transform", transform },
@@ -429,6 +430,7 @@ export abstract class ZodType<
     const defaultValueFunc = typeof def === "function" ? def : () => def;
 
     return new ZodDefault({
+      ...processCreateParams(this._def),
       innerType: this,
       defaultValue: defaultValueFunc,
       typeName: ZodFirstPartyTypeKind.ZodDefault,
@@ -440,17 +442,19 @@ export abstract class ZodType<
     return new ZodBranded({
       typeName: ZodFirstPartyTypeKind.ZodBranded,
       type: this,
-      ...processCreateParams(undefined),
+      ...processCreateParams(this._def),
     });
   }
-  catch(def: Input): ZodCatch<this>;
-  catch(def: () => Input): ZodCatch<this>;
+
+  catch(def: Output): ZodCatch<this>;
+  catch(def: () => Output): ZodCatch<this>;
   catch(def: any) {
-    const defaultValueFunc = typeof def === "function" ? def : () => def;
+    const catchValueFunc = typeof def === "function" ? def : () => def;
 
     return new ZodCatch({
+      ...processCreateParams(this._def),
       innerType: this,
-      defaultValue: defaultValueFunc,
+      catchValue: catchValueFunc,
       typeName: ZodFirstPartyTypeKind.ZodCatch,
     }) as any;
   }
@@ -490,6 +494,7 @@ export type ZodStringCheck =
   | { kind: "url"; message?: string }
   | { kind: "uuid"; message?: string }
   | { kind: "cuid"; message?: string }
+  | { kind: "cuid2"; message?: string }
   | { kind: "startsWith"; value: string; message?: string }
   | { kind: "endsWith"; value: string; message?: string }
   | { kind: "regex"; regex: RegExp; message?: string }
@@ -508,14 +513,18 @@ export interface ZodStringDef extends ZodTypeDef {
 }
 
 const cuidRegex = /^c[^\s-]{8,}$/i;
+const cuid2Regex = /^[a-z][a-z0-9]*$/;
 const uuidRegex =
   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
 // from https://stackoverflow.com/a/46181/1550155
 // old version: too slow, didn't support unicode
 // const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
+//old email regex
+// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
 // eslint-disable-next-line
+
 const emailRegex =
-  /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
+  /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|([^-]([a-zA-Z0-9-]*\.)+[a-zA-Z]{2,}))$/;
 
 // interface IsDateStringOptions extends StringDateOptions {
 /**
@@ -529,7 +538,7 @@ const datetimeRegex = (args: { precision: number | null; offset: boolean }) => {
   if (args.precision) {
     if (args.offset) {
       return new RegExp(
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
       );
     } else {
       return new RegExp(
@@ -539,7 +548,7 @@ const datetimeRegex = (args: { precision: number | null; offset: boolean }) => {
   } else if (args.precision === 0) {
     if (args.offset) {
       return new RegExp(
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
       );
     } else {
       return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
@@ -547,7 +556,7 @@ const datetimeRegex = (args: { precision: number | null; offset: boolean }) => {
   } else {
     if (args.offset) {
       return new RegExp(
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`
       );
     } else {
       return new RegExp(
@@ -664,6 +673,16 @@ export class ZodString extends ZodType<string, ZodStringDef> {
           });
           status.dirty();
         }
+      } else if (check.kind === "cuid2") {
+        if (!cuid2Regex.test(input.data)) {
+          ctx = this._getOrReturnCtx(input, ctx);
+          addIssueToContext(ctx, {
+            validation: "cuid2",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
+        }
       } else if (check.kind === "url") {
         try {
           new URL(input.data);
@@ -760,6 +779,9 @@ export class ZodString extends ZodType<string, ZodStringDef> {
   cuid(message?: errorUtil.ErrMessage) {
     return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
   }
+  cuid2(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
+  }
   datetime(
     options?:
       | string
@@ -863,6 +885,9 @@ export class ZodString extends ZodType<string, ZodStringDef> {
   get isCUID() {
     return !!this._def.checks.find((ch) => ch.kind === "cuid");
   }
+  get isCUID2() {
+    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
+  }
 
   get minLength() {
     let min: number | null = null;
@@ -1150,7 +1175,30 @@ export class ZodNumber extends ZodType<number, ZodNumberDef> {
   }
 
   get isInt() {
-    return !!this._def.checks.find((ch) => ch.kind === "int");
+    return !!this._def.checks.find(
+      (ch) =>
+        ch.kind === "int" ||
+        (ch.kind === "multipleOf" && util.isInteger(ch.value))
+    );
+  }
+
+  get isFinite() {
+    let max: number | null = null,
+      min: number | null = null;
+    for (const ch of this._def.checks) {
+      if (
+        ch.kind === "finite" ||
+        ch.kind === "int" ||
+        ch.kind === "multipleOf"
+      ) {
+        return true;
+      } else if (ch.kind === "min") {
+        if (min === null || ch.value > min) min = ch.value;
+      } else if (ch.kind === "max") {
+        if (max === null || ch.value < max) max = ch.value;
+      }
+    }
+    return Number.isFinite(min) && Number.isFinite(max);
   }
 }
 
@@ -1689,7 +1737,7 @@ export class ZodArray<
 
     if (ctx.common.async) {
       return Promise.all(
-        (ctx.data as any[]).map((item, i) => {
+        ([...ctx.data] as any[]).map((item, i) => {
           return def.type._parseAsync(
             new ParseInputLazyPath(ctx, item, ctx.path, i)
           );
@@ -1699,7 +1747,7 @@ export class ZodArray<
       });
     }
 
-    const result = (ctx.data as any[]).map((item, i) => {
+    const result = ([...ctx.data] as any[]).map((item, i) => {
       return def.type._parseSync(
         new ParseInputLazyPath(ctx, item, ctx.path, i)
       );
@@ -1874,11 +1922,15 @@ export type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>
 export type SomeZodObject = ZodObject<
   ZodRawShape,
   UnknownKeysParam,
-  ZodTypeAny,
-  any,
-  any
+  ZodTypeAny
 >;
 
+export type objectKeyMask<Obj> = { [k in keyof Obj]?: true };
+
+export type noUnrecognized<Obj extends object, Shape extends object> = {
+  [k in keyof Obj]: k extends keyof Shape ? Obj[k] : never;
+};
+
 function deepPartialify(schema: ZodTypeAny): any {
   if (schema instanceof ZodObject) {
     const newShape: any = {};
@@ -1908,7 +1960,7 @@ function deepPartialify(schema: ZodTypeAny): any {
 
 export class ZodObject<
   T extends ZodRawShape,
-  UnknownKeys extends UnknownKeysParam = "strip",
+  UnknownKeys extends UnknownKeysParam,
   Catchall extends ZodTypeAny = ZodTypeAny,
   Output = objectOutputType<T, Catchall>,
   Input = objectInputType<T, Catchall>
@@ -2122,29 +2174,34 @@ export class ZodObject<
     }) as any;
   }
 
-  pick<Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
+  pick<Mask extends objectKeyMask<T>>(
+    mask: noUnrecognized<Mask, T>
   ): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall> {
     const shape: any = {};
-    util.objectKeys(mask).map((key) => {
-      // only add to shape if key corresponds to an element of the current shape
-      if (this.shape[key]) shape[key] = this.shape[key];
+
+    util.objectKeys(mask).forEach((key) => {
+      if (mask[key] && this.shape[key]) {
+        shape[key] = this.shape[key];
+      }
     });
+
     return new ZodObject({
       ...this._def,
       shape: () => shape,
     }) as any;
   }
 
-  omit<Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
+  omit<Mask extends objectKeyMask<T>>(
+    mask: noUnrecognized<Mask, objectKeyMask<T>>
   ): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall> {
     const shape: any = {};
-    util.objectKeys(this.shape).map((key) => {
-      if (util.objectKeys(mask).indexOf(key) === -1) {
+
+    util.objectKeys(this.shape).forEach((key) => {
+      if (!mask[key]) {
         shape[key] = this.shape[key];
       }
     });
+
     return new ZodObject({
       ...this._def,
       shape: () => shape,
@@ -2160,8 +2217,8 @@ export class ZodObject<
     UnknownKeys,
     Catchall
   >;
-  partial<Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
+  partial<Mask extends objectKeyMask<T>>(
+    mask: noUnrecognized<Mask, objectKeyMask<T>>
   ): ZodObject<
     objectUtil.noNever<{
       [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
@@ -2171,24 +2228,16 @@ export class ZodObject<
   >;
   partial(mask?: any) {
     const newShape: any = {};
-    if (mask) {
-      util.objectKeys(this.shape).map((key) => {
-        if (util.objectKeys(mask).indexOf(key) === -1) {
-          newShape[key] = this.shape[key];
-        } else {
-          newShape[key] = this.shape[key].optional();
-        }
-      });
-      return new ZodObject({
-        ...this._def,
-        shape: () => newShape,
-      }) as any;
-    } else {
-      for (const key in this.shape) {
-        const fieldSchema = this.shape[key];
+
+    util.objectKeys(this.shape).forEach((key) => {
+      const fieldSchema = this.shape[key];
+
+      if (mask && !mask[key]) {
+        newShape[key] = fieldSchema;
+      } else {
         newShape[key] = fieldSchema.optional();
       }
-    }
+    });
 
     return new ZodObject({
       ...this._def,
@@ -2201,8 +2250,8 @@ export class ZodObject<
     UnknownKeys,
     Catchall
   >;
-  required<Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
+  required<Mask extends objectKeyMask<T>>(
+    mask: noUnrecognized<Mask, objectKeyMask<T>>
   ): ZodObject<
     objectUtil.noNever<{
       [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
@@ -2212,30 +2261,22 @@ export class ZodObject<
   >;
   required(mask?: any) {
     const newShape: any = {};
-    if (mask) {
-      util.objectKeys(this.shape).map((key) => {
-        if (util.objectKeys(mask).indexOf(key) === -1) {
-          newShape[key] = this.shape[key];
-        } else {
-          const fieldSchema = this.shape[key];
-          let newField = fieldSchema;
-          while (newField instanceof ZodOptional) {
-            newField = (newField as ZodOptional<any>)._def.innerType;
-          }
-          newShape[key] = newField;
-        }
-      });
-    } else {
-      for (const key in this.shape) {
+
+    util.objectKeys(this.shape).forEach((key) => {
+      if (mask && !mask[key]) {
+        newShape[key] = this.shape[key];
+      } else {
         const fieldSchema = this.shape[key];
         let newField = fieldSchema;
+
         while (newField instanceof ZodOptional) {
           newField = (newField as ZodOptional<any>)._def.innerType;
         }
 
         newShape[key] = newField;
       }
-    }
+    });
+
     return new ZodObject({
       ...this._def,
       shape: () => newShape,
@@ -2251,7 +2292,7 @@ export class ZodObject<
   static create = <T extends ZodRawShape>(
     shape: T,
     params?: RawCreateParams
-  ): ZodObject<T> => {
+  ): ZodObject<T, "strip"> => {
     return new ZodObject({
       shape: () => shape,
       unknownKeys: "strip",
@@ -2277,7 +2318,7 @@ export class ZodObject<
   static lazycreate = <T extends ZodRawShape>(
     shape: () => T,
     params?: RawCreateParams
-  ): ZodObject<T> => {
+  ): ZodObject<T, "strip"> => {
     return new ZodObject({
       shape,
       unknownKeys: "strip",
@@ -2465,11 +2506,15 @@ const getDiscriminator = <T extends ZodTypeAny>(
 };
 
 export type ZodDiscriminatedUnionOption<Discriminator extends string> =
-  ZodObject<{ [key in Discriminator]: ZodTypeAny } & ZodRawShape, any, any>;
+  ZodObject<
+    { [key in Discriminator]: ZodTypeAny } & ZodRawShape,
+    UnknownKeysParam,
+    ZodTypeAny
+  >;
 
 export interface ZodDiscriminatedUnionDef<
   Discriminator extends string,
-  Options extends ZodDiscriminatedUnionOption<any>[] = ZodDiscriminatedUnionOption<any>[]
+  Options extends ZodDiscriminatedUnionOption<string>[] = ZodDiscriminatedUnionOption<string>[]
 > extends ZodTypeDef {
   discriminator: Discriminator;
   options: Options;
@@ -2498,7 +2543,9 @@ export class ZodDiscriminatedUnion<
     }
 
     const discriminator = this.discriminator;
+
     const discriminatorValue: string = ctx.data[discriminator];
+
     const option = this.optionsMap.get(discriminatorValue);
 
     if (!option) {
@@ -2575,6 +2622,7 @@ export class ZodDiscriminatedUnion<
             )} has duplicate value ${String(value)}`
           );
         }
+
         optionsMap.set(value, type);
       }
     }
@@ -2827,7 +2875,7 @@ export class ZodTuple<
       status.dirty();
     }
 
-    const items = (ctx.data as any[])
+    const items = ([...ctx.data] as any[])
       .map((item, itemIndex) => {
         const schema = this._def.items[itemIndex] || this._def.rest;
         if (!schema) return null as any as SyncParseReturnType<any>;
@@ -3299,7 +3347,7 @@ export class ZodFunction<
           });
         const result = await fn(...(parsedArgs as any));
         const parsedReturns = await (
-          this._def.returns as ZodPromise<ZodTypeAny>
+          this._def.returns as unknown as ZodPromise<ZodTypeAny>
         )._def.type
           .parseAsync(result, params)
           .catch((e) => {
@@ -3453,6 +3501,7 @@ export class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>> {
     if (input.data !== this._def.value) {
       const ctx = this._getOrReturnCtx(input);
       addIssueToContext(ctx, {
+        received: ctx.data,
         code: ZodIssueCode.invalid_literal,
         expected: this._def.value,
       });
@@ -3501,6 +3550,14 @@ export interface ZodEnumDef<T extends EnumValues = EnumValues>
 
 export type Writeable<T> = { -readonly [P in keyof T]: T[P] };
 
+export type FilterEnum<Values, ToExclude> = Values extends []
+  ? []
+  : Values extends [infer Head, ...infer Rest]
+  ? Head extends ToExclude
+    ? FilterEnum<Rest, ToExclude>
+    : [Head, ...FilterEnum<Rest, ToExclude>]
+  : never;
+
 function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(
   values: T,
   params?: RawCreateParams
@@ -3575,6 +3632,23 @@ export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
     return enumValues as any;
   }
 
+  extract<ToExtract extends readonly [T[number], ...T[number][]]>(
+    values: ToExtract
+  ) {
+    return ZodEnum.create(values);
+  }
+
+  exclude<ToExclude extends readonly [T[number], ...T[number][]]>(
+    values: ToExclude
+  ) {
+    return ZodEnum.create(
+      this.options.filter((opt) => !values.includes(opt)) as FilterEnum<
+        T,
+        ToExclude[number]
+      >
+    );
+  }
+
   static create = createZodEnum;
 }
 
@@ -3661,6 +3735,10 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
   ZodPromiseDef<T>,
   Promise<T["_input"]>
 > {
+  unwrap() {
+    return this._def.type;
+  }
+
   _parse(input: ParseInput): ParseReturnType<this["_output"]> {
     const { ctx } = this._processInputParams(input);
     if (
@@ -4053,17 +4131,19 @@ export class ZodDefault<T extends ZodTypeAny> extends ZodType<
 //////////                      //////////
 //////////////////////////////////////////
 //////////////////////////////////////////
-export interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodCatchDef<
+  T extends ZodTypeAny = ZodTypeAny,
+  C extends T["_input"] = T["_input"]
+> extends ZodTypeDef {
   innerType: T;
-  defaultValue: () => T["_input"];
+  catchValue: () => C;
   typeName: ZodFirstPartyTypeKind.ZodCatch;
 }
 
 export class ZodCatch<T extends ZodTypeAny> extends ZodType<
-  util.noUndefined<T["_output"]>,
+  T["_output"],
   ZodCatchDef<T>,
-  T["_input"] | undefined
+  T["_input"]
 > {
   _parse(input: ParseInput): ParseReturnType<this["_output"]> {
     const { ctx } = this._processInputParams(input);
@@ -4071,7 +4151,13 @@ export class ZodCatch<T extends ZodTypeAny> extends ZodType<
     const result = this._def.innerType._parse({
       data: ctx.data,
       path: ctx.path,
-      parent: ctx,
+      parent: {
+        ...ctx,
+        common: {
+          ...ctx.common,
+          issues: [], // don't collect issues from inner type
+        },
+      },
     });
 
     if (isAsync(result)) {
@@ -4079,35 +4165,33 @@ export class ZodCatch<T extends ZodTypeAny> extends ZodType<
         return {
           status: "valid",
           value:
-            result.status === "valid" ? result.value : this._def.defaultValue(),
+            result.status === "valid" ? result.value : this._def.catchValue(),
         };
       });
     } else {
       return {
         status: "valid",
         value:
-          result.status === "valid" ? result.value : this._def.defaultValue(),
+          result.status === "valid" ? result.value : this._def.catchValue(),
       };
     }
   }
 
-  removeDefault() {
+  removeCatch() {
     return this._def.innerType;
   }
 
   static create = <T extends ZodTypeAny>(
     type: T,
     params: RawCreateParams & {
-      default: T["_input"] | (() => T["_input"]);
+      catch: T["_output"] | (() => T["_output"]);
     }
   ): ZodCatch<T> => {
     return new ZodCatch({
       innerType: type,
       typeName: ZodFirstPartyTypeKind.ZodCatch,
-      defaultValue:
-        typeof params.default === "function"
-          ? params.default
-          : () => params.default,
+      catchValue:
+        typeof params.catch === "function" ? params.catch : () => params.catch,
       ...processCreateParams(params),
     });
   };
@@ -4335,7 +4419,7 @@ export type ZodFirstPartySchemaTypes =
   | ZodNever
   | ZodVoid
   | ZodArray<any, any>
-  | ZodObject<any, any, any, any, any>
+  | ZodObject<any, any, any>
   | ZodUnion<any>
   | ZodDiscriminatedUnion<any, any>
   | ZodIntersection<any, any>
@@ -4414,7 +4498,10 @@ export const coerce = {
   number: ((arg) =>
     ZodNumber.create({ ...arg, coerce: true })) as typeof ZodNumber["create"],
   boolean: ((arg) =>
-    ZodBoolean.create({ ...arg, coerce: true })) as typeof ZodBoolean["create"],
+    ZodBoolean.create({
+      ...arg,
+      coerce: true,
+    })) as typeof ZodBoolean["create"],
   bigint: ((arg) =>
     ZodBigInt.create({ ...arg, coerce: true })) as typeof ZodBigInt["create"],
   date: ((arg) =>
diff --git a/static/moon.svg b/static/moon.svg
new file mode 100644
index 000000000..ee737124a
--- /dev/null
+++ b/static/moon.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#1D1D1B"
+  stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
+  <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />
+</svg>
\ No newline at end of file
diff --git a/static/sun.svg b/static/sun.svg
new file mode 100644
index 000000000..33bbc8b29
--- /dev/null
+++ b/static/sun.svg
@@ -0,0 +1,13 @@
+<?xml version="1.0" ?>
+<svg class="feather feather-sun" fill="none" height="24" stroke="#fff" stroke-linecap="round" stroke-linejoin="round"
+  stroke-width="2" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
+  <circle cx="12" cy="12" r="5" />
+  <line x1="12" x2="12" y1="1" y2="3" />
+  <line x1="12" x2="12" y1="21" y2="23" />
+  <line x1="4.22" x2="5.64" y1="4.22" y2="5.64" />
+  <line x1="18.36" x2="19.78" y1="18.36" y2="19.78" />
+  <line x1="1" x2="3" y1="12" y2="12" />
+  <line x1="21" x2="23" y1="12" y2="12" />
+  <line x1="4.22" x2="5.64" y1="19.78" y2="18.36" />
+  <line x1="18.36" x2="19.78" y1="5.64" y2="4.22" />
+</svg>
\ No newline at end of file
