diff --git a/CHANGELOG.md b/CHANGELOG.md
index 35902c68c..5afb7e4e6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,9 @@
 # Changelog
 
+### 3.0.0-alpha.33
+
+- Added `.returnType` and `.parameters` methods to ZodFunction
+
 ### 3.0.0-alpha.32
 
 - Added `.required()` method to ZodObject
diff --git a/README.md b/README.md
index a714039f8..e5012b2c7 100644
--- a/README.md
+++ b/README.md
@@ -114,10 +114,10 @@ if you're happy and you know it, star this repo ‚≠ê
   const test = z
     .string()
     .transform((val) => val.length)
-    .refine((val) => val > 5, { message: 'Input is too short' })
+    .refine((val) => val > 5, { message: "Input is too short" })
     .transform((val) => val * 2);
 
-  test.parse('12characters'); // => 24
+  test.parse("12characters"); // => 24
   ```
 
 - **Type guards** (the `.check()` method) have been removed. Type guards interact with transformers in unintuitive ways so they were removed. Use `.safeParse` instead.
@@ -227,18 +227,18 @@ npm install zod@next
 Creating a simple string schema
 
 ```ts
-import { z } from 'zod';
+import { z } from "zod";
 
 // creating a schema for strings
 const mySchema = z.string();
-mySchema.parse('tuna'); // => "tuna"
+mySchema.parse("tuna"); // => "tuna"
 mySchema.parse(12); // => throws ZodError
 ```
 
 Creating an object schema
 
 ```ts
-import { z } from 'zod';
+import { z } from "zod";
 
 const User = z.object({
   username: z.string(),
@@ -256,7 +256,7 @@ type User = z.infer<typeof User>;
 ## Primitives
 
 ```ts
-import { z } from 'zod';
+import { z } from "zod";
 
 // primitive values
 z.string();
@@ -283,7 +283,7 @@ z.never();
 ## Literals
 
 ```ts
-const tuna = z.literal('tuna');
+const tuna = z.literal("tuna");
 const twelve = z.literal(12);
 const tru = z.literal(true);
 ```
@@ -314,12 +314,12 @@ z.string().nonempty();
 Optionally, you can pass in a second argument to provide a custom error message.
 
 ```ts
-z.string().min(5, { message: 'Must be 5 or more characters long' });
-z.string().max(5, { message: 'Must be 5 or fewer characters long' });
-z.string().length(5, { message: 'Must be exactly 5 characters long' });
-z.string().email({ message: 'Invalid email address.' });
-z.string().url({ message: 'Invalid url' });
-z.string().uuid({ message: 'Invalid UUID' });
+z.string().min(5, { message: "Must be 5 or more characters long" });
+z.string().max(5, { message: "Must be 5 or fewer characters long" });
+z.string().length(5, { message: "Must be exactly 5 characters long" });
+z.string().email({ message: "Invalid email address." });
+z.string().url({ message: "Invalid url" });
+z.string().uuid({ message: "Invalid UUID" });
 ```
 
 ## Numbers
@@ -341,7 +341,7 @@ z.number().nonpositive(); //  <= 0
 Optionally, you can pass in a second argument to provide a custom error message.
 
 ```ts
-z.number().max(5, { message: 'thisüëèisüëètooüëèbig' });
+z.number().max(5, { message: "thisüëèisüëètooüëèbig" });
 ```
 
 ## Objects
@@ -485,7 +485,7 @@ const person = z.object({
 });
 
 person.parse({
-  name: 'bob dylan',
+  name: "bob dylan",
   extraKey: 61,
 });
 // => { name: "bob dylan" }
@@ -498,7 +498,7 @@ Instead, if you want to pass through unknown keys, use `.passthrough()` .
 
 ```ts
 person.passthrough().parse({
-  name: 'bob dylan',
+  name: "bob dylan",
   extraKey: 61,
 });
 // => { name: "bob dylan", extraKey: 61 }
@@ -516,7 +516,7 @@ const person = z
   .strict();
 
 person.parse({
-  name: 'bob dylan',
+  name: "bob dylan",
   extraKey: 61,
 });
 // => throws ZodError
@@ -538,12 +538,12 @@ const person = z
   .catchall(z.number());
 
 person.parse({
-  name: 'bob dylan',
+  name: "bob dylan",
   validExtraKey: 61, // works fine
 });
 
 person.parse({
-  name: 'bob dylan',
+  name: "bob dylan",
   validExtraKey: false, // fails
 });
 // => throws ZodError
@@ -577,7 +577,7 @@ const nonEmptyStrings = z.string().array().nonempty();
 // [string, ...string[]]
 
 nonEmptyStrings.parse([]); // throws: "Array cannot be empty"
-nonEmptyStrings.parse(['Ariana Grande']); // passes
+nonEmptyStrings.parse(["Ariana Grande"]); // passes
 ```
 
 ### `.min/.max/.length`
@@ -597,7 +597,7 @@ Zod includes a built-in `z.union` method for composing "OR" types.
 ```ts
 const stringOrNumber = z.union([z.string(), z.number()]);
 
-stringOrNumber.parse('foo'); // passes
+stringOrNumber.parse("foo"); // passes
 stringOrNumber.parse(14); // passes
 ```
 
@@ -643,7 +643,7 @@ Similarly, you can create nullable types like so:
 
 ```ts
 const nullableString = z.nullable(z.string());
-nullableString.parse('asdf'); // => "asdf"
+nullableString.parse("asdf"); // => "asdf"
 nullableString.parse(null); // => null
 ```
 
@@ -700,12 +700,12 @@ This is particularly useful for storing or caching items by ID.
 ```ts
 const userStore: UserStore = {};
 
-userStore['77d2586b-9e8e-4ecf-8b21-ea7e0530eadd'] = {
-  name: 'Carlotta',
+userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
+  name: "Carlotta",
 }; // passes
 
-userStore['77d2586b-9e8e-4ecf-8b21-ea7e0530eadd'] = {
-  whatever: 'Ice cream sundae',
+userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
+  whatever: "Ice cream sundae",
 }; // TypeError
 ```
 
@@ -717,7 +717,7 @@ As it turns out, TypeScript's behavior surrounding `[k: number]` is a little uni
 
 ```ts
 const testMap: { [k: number]: string } = {
-  1: 'one',
+  1: "one",
 };
 
 for (const key in testMap) {
@@ -769,7 +769,7 @@ FishEnum.parse("Flounder"); // => throws
 For convenience Zod provides a built-in `z.enum()` function. Here's is the equivalent code: -->
 
 ```ts
-const FishEnum = z.enum(['Salmon', 'Tuna', 'Trout']);
+const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
 type FishEnum = z.infer<typeof FishEnum>;
 // 'Salmon' | 'Tuna' | 'Trout'
 ```
@@ -777,7 +777,7 @@ type FishEnum = z.infer<typeof FishEnum>;
 You must pass the array of values directly into `z.enum()`. This does not work:
 
 ```ts
-const fish = ['Salmon', 'Tuna', 'Trout'];
+const fish = ["Salmon", "Tuna", "Trout"];
 const FishEnum = z.enum(fish);
 ```
 
@@ -832,8 +832,8 @@ FruitEnum.parse(3); // fails
 
 ```ts
 enum Fruits {
-  Apple = 'apple',
-  Banana = 'banana',
+  Apple = "apple",
+  Banana = "banana",
   Cantaloupe, // you can mix numerical and string enums
 }
 
@@ -842,10 +842,10 @@ type FruitEnum = z.infer<typeof FruitEnum>; // Fruits
 
 FruitEnum.parse(Fruits.Apple); // passes
 FruitEnum.parse(Fruits.Cantaloupe); // passes
-FruitEnum.parse('apple'); // passes
-FruitEnum.parse('banana'); // passes
+FruitEnum.parse("apple"); // passes
+FruitEnum.parse("banana"); // passes
 FruitEnum.parse(0); // passes
-FruitEnum.parse('Cantaloupe'); // fails
+FruitEnum.parse("Cantaloupe"); // fails
 ```
 
 **Const enums**
@@ -854,18 +854,18 @@ The `.nativeEnum()` function works for `as const` objects as well. ‚ö†Ô∏è `as co
 
 ```ts
 const Fruits = {
-  Apple: 'apple',
-  Banana: 'banana',
+  Apple: "apple",
+  Banana: "banana",
   Cantaloupe: 3,
 } as const;
 
 const FruitEnum = z.nativeEnum(Fruits);
 type FruitEnum = z.infer<typeof FruitEnum>; // "apple" | "banana" | 3
 
-FruitEnum.parse('apple'); // passes
-FruitEnum.parse('banana'); // passes
+FruitEnum.parse("apple"); // passes
+FruitEnum.parse("banana"); // passes
 FruitEnum.parse(3); // passes
-FruitEnum.parse('Cantaloupe'); // fails
+FruitEnum.parse("Cantaloupe"); // fails
 ```
 
 ## Intersections
@@ -940,11 +940,11 @@ const Category: z.ZodSchema<Category> = z.lazy(() =>
 );
 
 Category.parse({
-  name: 'People',
+  name: "People",
   subcategories: [
     {
-      name: 'Politicians',
-      subcategories: [{ name: 'Presidents', subcategories: [] }],
+      name: "Politicians",
+      subcategories: [{ name: "Presidents", subcategories: [] }],
     },
   ],
 }); // passes
@@ -1009,14 +1009,14 @@ const numberPromise = z.promise(z.number());
 2. Zod uses `.then` to attach an additional validation step onto the existing Promise. You'll have to use `.catch` on the returned Promise to handle validation failures.
 
 ```ts
-numberPromise.parse('tuna');
+numberPromise.parse("tuna");
 // ZodError: Non-Promise type: string
 
-numberPromise.parse(Promise.resolve('tuna'));
+numberPromise.parse(Promise.resolve("tuna"));
 // => Promise<number>
 
 const test = async () => {
-  await numberPromise.parse(Promise.resolve('tuna'));
+  await numberPromise.parse(Promise.resolve("tuna"));
   // ZodError: Non-number type: string
 
   await numberPromise.parse(Promise.resolve(3.14));
@@ -1039,9 +1039,9 @@ class Test {
 
 const TestSchema = z.instanceof(Test);
 
-const blob: any = 'whatever';
+const blob: any = "whatever";
 TestSchema.parse(new Test()); // passes
-TestSchema.parse('blob'); // throws
+TestSchema.parse("blob"); // throws
 ```
 
 ## Function schemas
@@ -1057,7 +1057,7 @@ type myFunction = z.infer<typeof myFunction>;
 // => ()=>unknown
 ```
 
-You can use the `.args` and `.returns` methods to refine your function schema:
+**Define inputs and output**
 
 ```ts
 const myFunction = z
@@ -1068,6 +1068,17 @@ type myFunction = z.infer<typeof myFunction>;
 // => (arg0: string, arg1: number)=>boolean
 ```
 
+**Extract the input and output schemas**
+You can extract the parameters and return type of a function schema.
+
+```ts
+myFunction.parameters();
+// => ZodTuple<[ZodString, ZodNumber]>
+
+myFunction.returnType();
+// => ZodBoolean
+```
+
 <!-- `z.function()` accepts two arguments:
 
 * `args: ZodTuple` The first argument is a tuple (created with `z.tuple([...])` and defines the schema of the arguments to your function. If the function doesn't accept arguments, you can pass an empty tuple (`z.tuple([])`).
@@ -1099,8 +1110,8 @@ const trimmedLength = z
     return x.trim().length;
   });
 
-trimmedLength('sandwich'); // => 8
-trimmedLength(' asdf '); // => 4
+trimmedLength("sandwich"); // => 8
+trimmedLength(" asdf "); // => 4
 ```
 
 If you only care about validating inputs, that's fine:
@@ -1129,7 +1140,7 @@ Given any Zod schema, you can call its `.parse` method to check `data` is valid.
 
 ```ts
 const stringSchema = z.string();
-stringSchema.parse('fish'); // => returns "fish"
+stringSchema.parse("fish"); // => returns "fish"
 stringSchema.parse(12); // throws Error('Non-string type: number');
 ```
 
@@ -1141,7 +1152,7 @@ If you use asynchronous [refinements](#refinements) or [transforms](#transformer
 
 ```ts
 const stringSchema = z.string().refine(async (val) => val.length > 20);
-const value = await stringSchema.parseAsync('hello'); // => hello
+const value = await stringSchema.parseAsync("hello"); // => hello
 ```
 
 ### `.safeParse`
@@ -1154,14 +1165,14 @@ If you don't want Zod to throw errors when validation fails, use `.safeParse`. T
 stringSchema.safeParse(12);
 // => { success: false; error: ZodError }
 
-stringSchema.safeParse('billie');
+stringSchema.safeParse("billie");
 // => { success: true; data: 'billie' }
 ```
 
 The result is a _discriminated union_ so you can handle errors very conveniently:
 
 ```ts
-const result = stringSchema.safeParse('billie');
+const result = stringSchema.safeParse("billie");
 if (!result.success) {
   // handle error then return
   result.error;
@@ -1178,13 +1189,13 @@ if (!result.success) {
 An asynchronous version of `safeParse`.
 
 ```ts
-await stringSchema.safeParseAsync('billie');
+await stringSchema.safeParseAsync("billie");
 ```
 
 For convenience, this has been aliased to `.spa`:
 
 ```ts
-await stringSchema.spa('billie');
+await stringSchema.spa("billie");
 ```
 
 ### `.refine`
@@ -1245,9 +1256,9 @@ const passwordForm = z
   })
   .refine((data) => data.password === data.confirm, {
     message: "Passwords don't match",
-    path: ['confirm'], // path of error
+    path: ["confirm"], // path of error
   })
-  .parse({ password: 'asdf', confirm: 'qwer' });
+  .parse({ password: "asdf", confirm: "qwer" });
 ```
 
 Because you provided a `path` parameter, the resulting error will be:
@@ -1316,7 +1327,7 @@ To transform data after parsing, use the `transform` method.
 
 ```ts
 const stringToNumber = z.string().transform((val) => myString.length);
-stringToNumber.parse('string'); // => 6
+stringToNumber.parse("string"); // => 6
 ```
 
 > ‚ö†Ô∏è Transformation functions must not throw. Make sure to use refinements before the transformer to make sure the input can be parsed by the transformer.
@@ -1329,9 +1340,9 @@ Note that `stringToNumber` above is an instance of the `ZodEffects` subclass. It
 const emailToDomain = z
   .string()
   .email()
-  .transform((val) => val.split('@')[1]);
+  .transform((val) => val.split("@")[1]);
 
-emailToDomain.parse('colinhacks@example.com'); // => example.com
+emailToDomain.parse("colinhacks@example.com"); // => example.com
 ```
 
 #### Relationship to refinements
@@ -1365,7 +1376,7 @@ const IdToUser = z.transformer(
 You can use transformers to implement the concept of "default values" in Zod.
 
 ```ts
-const stringWithDefault = z.string().default('tuna');
+const stringWithDefault = z.string().default("tuna");
 
 stringWithDefault.parse(undefined); // => "tuna"
 ```
@@ -1444,7 +1455,7 @@ const A = z.string();
 type A = z.infer<typeof A>; // string
 
 const u: A = 12; // TypeError
-const u: A = 'asdf'; // compiles
+const u: A = "asdf"; // compiles
 ```
 
 #### What about transforms?
@@ -1585,7 +1596,7 @@ io-ts is an excellent library by gcanti. The API of io-ts heavily inspired the d
 In our experience, io-ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-ts particularly hard to integrate into an existing codebase with a more procedural or object-oriented bias. For instance, consider how to define an object with optional properties in io-ts:
 
 ```ts
-import * as t from 'io-ts';
+import * as t from "io-ts";
 
 const A = t.type({
   foo: t.string,
diff --git a/coverage.svg b/coverage.svg
index a020c924b..54566e156 100644
--- a/coverage.svg
+++ b/coverage.svg
@@ -1 +1 @@
-<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="110" height="20" role="img" aria-label="Coverage: 92.7%"><title>Coverage: 92.7%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="110" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="47" height="20" fill="#4c1"/><rect width="110" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="855" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="370">92.7%</text><text x="855" y="140" transform="scale(.1)" fill="#fff" textLength="370">92.7%</text></g></svg>
\ No newline at end of file
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 92.58%"><title>Coverage: 92.58%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#4c1"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">92.58%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">92.58%</text></g></svg>
\ No newline at end of file
diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index 54249f9a3..854a589ac 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -266,7 +266,7 @@ type ErrorMapCtx = {
 };
 
 export type ZodErrorMap = typeof defaultErrorMap;
-export let defaultErrorMap = (
+export const defaultErrorMap = (
   error: ZodIssueOptionalMessage,
   _ctx: ErrorMapCtx
 ): { message: string } => {
@@ -365,6 +365,8 @@ export let defaultErrorMap = (
   // return `Invalid input.`;
 };
 
+export let overrideErrorMap = defaultErrorMap;
+
 export const setErrorMap = (map: ZodErrorMap) => {
-  defaultErrorMap = map;
+  overrideErrorMap = map;
 };
diff --git a/deno/lib/helpers/parseUtil.ts b/deno/lib/helpers/parseUtil.ts
index e6f58d990..db117f3a5 100644
--- a/deno/lib/helpers/parseUtil.ts
+++ b/deno/lib/helpers/parseUtil.ts
@@ -74,12 +74,13 @@ export const issueHelpers = (error: ZodError, params: ParseParams) => {
     };
 
     const defaultError =
-      defaultErrorMap === params.errorMap
-        ? { message: `Invalid value` }
-        : defaultErrorMap(errorArg, {
-            data: params.data,
-            defaultError: `Invalid value`,
-          });
+      // defaultErrorMap === params.errorMap
+      //   ? { message: `Invalid value` }
+      //   :
+      defaultErrorMap(errorArg, {
+        data: params.data,
+        defaultError: `Invalid value`,
+      });
     const issue = {
       ...errorData,
       path: [...params.path, ...(errorData.path || [])],
diff --git a/deno/lib/playground.ts b/deno/lib/playground.ts
index 0bad2b805..f96b6e003 100644
--- a/deno/lib/playground.ts
+++ b/deno/lib/playground.ts
@@ -7,14 +7,3 @@ const run = async () => {
 run();
 
 export {};
-
-const object = z.object({
-  name: z.string(),
-  age: z.number().optional(),
-  field: z.string().optional().default(undefined),
-});
-
-const requiredObject = object.required();
-console.log(requiredObject.shape.name instanceof z.ZodString);
-console.log(requiredObject.shape.age instanceof z.ZodNumber);
-console.log(requiredObject.shape.field instanceof z.ZodString);
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 32a6b41de..3c00cf4d8 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -13,8 +13,8 @@ import { partialUtil } from "./helpers/partialUtil.ts";
 import { INVALID, util } from "./helpers/util.ts";
 import { NOSET, PseudoPromise } from "./PseudoPromise.ts";
 import {
-  defaultErrorMap,
   MakeErrorData,
+  overrideErrorMap,
   StringValidation,
   ZodCustomIssue,
   ZodError,
@@ -117,7 +117,7 @@ export abstract class ZodType<
       data: params.data,
       path: params.path || [],
       parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || defaultErrorMap,
+      errorMap: params.errorMap || overrideErrorMap,
       async: params.async ?? false,
     };
 
@@ -2149,6 +2149,14 @@ export class ZodFunction<
     return validatedFunction;
   }
 
+  parameters() {
+    return this._def.args;
+  }
+
+  returnType() {
+    return this._def.returns;
+  }
+
   args = <Items extends Parameters<typeof ZodTuple["create"]>[0]>(
     ...items: Items
   ): ZodFunction<ZodTuple<Items>, Returns> => {
@@ -2725,7 +2733,7 @@ export type ZodFirstPartySchemaTypes =
   | ZodEnum<any>
   | ZodEffects<any>
   | ZodNativeEnum<any>
-  | ZodOptional<any>
+  | ZodOptional<any, any>
   | ZodNullable<any>
   | ZodPromise<any>;
 
diff --git a/package.json b/package.json
index 737a3d764..62d2f274a 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.0.0-alpha.32",
+  "version": "3.0.0-alpha.33",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./lib/index.d.ts",
diff --git a/src/ZodError.ts b/src/ZodError.ts
index d239dfc89..f09d53544 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -266,7 +266,7 @@ type ErrorMapCtx = {
 };
 
 export type ZodErrorMap = typeof defaultErrorMap;
-export let defaultErrorMap = (
+export const defaultErrorMap = (
   error: ZodIssueOptionalMessage,
   _ctx: ErrorMapCtx
 ): { message: string } => {
@@ -365,6 +365,8 @@ export let defaultErrorMap = (
   // return `Invalid input.`;
 };
 
+export let overrideErrorMap = defaultErrorMap;
+
 export const setErrorMap = (map: ZodErrorMap) => {
-  defaultErrorMap = map;
+  overrideErrorMap = map;
 };
diff --git a/src/helpers/parseUtil.ts b/src/helpers/parseUtil.ts
index 909ed1ec2..ce32edf0c 100644
--- a/src/helpers/parseUtil.ts
+++ b/src/helpers/parseUtil.ts
@@ -74,12 +74,13 @@ export const issueHelpers = (error: ZodError, params: ParseParams) => {
     };
 
     const defaultError =
-      defaultErrorMap === params.errorMap
-        ? { message: `Invalid value` }
-        : defaultErrorMap(errorArg, {
-            data: params.data,
-            defaultError: `Invalid value`,
-          });
+      // defaultErrorMap === params.errorMap
+      //   ? { message: `Invalid value` }
+      //   :
+      defaultErrorMap(errorArg, {
+        data: params.data,
+        defaultError: `Invalid value`,
+      });
     const issue = {
       ...errorData,
       path: [...params.path, ...(errorData.path || [])],
diff --git a/src/playground.ts b/src/playground.ts
index dbf6ffb3e..746f94e03 100644
--- a/src/playground.ts
+++ b/src/playground.ts
@@ -7,14 +7,3 @@ const run = async () => {
 run();
 
 export {};
-
-const object = z.object({
-  name: z.string(),
-  age: z.number().optional(),
-  field: z.string().optional().default(undefined),
-});
-
-const requiredObject = object.required();
-console.log(requiredObject.shape.name instanceof z.ZodString);
-console.log(requiredObject.shape.age instanceof z.ZodNumber);
-console.log(requiredObject.shape.field instanceof z.ZodString);
diff --git a/src/types.ts b/src/types.ts
index 4e70b3909..e27aad8fa 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -13,8 +13,8 @@ import { partialUtil } from "./helpers/partialUtil";
 import { INVALID, util } from "./helpers/util";
 import { NOSET, PseudoPromise } from "./PseudoPromise";
 import {
-  defaultErrorMap,
   MakeErrorData,
+  overrideErrorMap,
   StringValidation,
   ZodCustomIssue,
   ZodError,
@@ -117,7 +117,7 @@ export abstract class ZodType<
       data: params.data,
       path: params.path || [],
       parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || defaultErrorMap,
+      errorMap: params.errorMap || overrideErrorMap,
       async: params.async ?? false,
     };
 
@@ -2149,6 +2149,14 @@ export class ZodFunction<
     return validatedFunction;
   }
 
+  parameters() {
+    return this._def.args;
+  }
+
+  returnType() {
+    return this._def.returns;
+  }
+
   args = <Items extends Parameters<typeof ZodTuple["create"]>[0]>(
     ...items: Items
   ): ZodFunction<ZodTuple<Items>, Returns> => {
@@ -2725,7 +2733,7 @@ export type ZodFirstPartySchemaTypes =
   | ZodEnum<any>
   | ZodEffects<any>
   | ZodNativeEnum<any>
-  | ZodOptional<any>
+  | ZodOptional<any, any>
   | ZodNullable<any>
   | ZodPromise<any>;
 
