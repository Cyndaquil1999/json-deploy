diff --git a/.eslintrc.js b/.eslintrc.js
index 5a79a8f5b..b5ab55ef5 100644
--- a/.eslintrc.js
+++ b/.eslintrc.js
@@ -48,10 +48,23 @@ module.exports = {
 
     "ban/ban": [
       2,
-      { "name": ["Object", "keys"], "message": "Object.keys() is not supported in legacy browsers, use objectKeys()" },
-      { "name": ["Object", "setPrototypeOf"], "message": "Object.setPrototypeOf() is not supported in legacy browsers" },
-      { "name": ["Number", "isNaN"], "message": "Number.isNaN() is not supported in legacy browsers" },
-      { "name": ["Number", "isInteger"], "message": "Number.isInteger() is not supported in legacy browsers" },
-    ]
+      {
+        name: ["Object", "keys"],
+        message:
+          "Object.keys() is not supported in legacy browsers, use objectKeys()",
+      },
+      {
+        name: ["Object", "setPrototypeOf"],
+        message: "Object.setPrototypeOf() is not supported in legacy browsers",
+      },
+      {
+        name: ["Number", "isNaN"],
+        message: "Number.isNaN() is not supported in legacy browsers",
+      },
+      {
+        name: ["Number", "isInteger"],
+        message: "Number.isInteger() is not supported in legacy browsers",
+      },
+    ],
   },
 };
diff --git a/.github/workflows/test.yaml b/.github/workflows/test.yaml
index 822715a02..bfd3007a4 100644
--- a/.github/workflows/test.yaml
+++ b/.github/workflows/test.yaml
@@ -30,7 +30,7 @@ jobs:
     runs-on: Ubuntu-20.04
     strategy:
       matrix:
-        deno: [ "v1.7.1", "v1.x" ]
+        deno: [ "v1.x" ]
     name: Test with Deno ${{ matrix.deno }}
     steps:
       - uses: actions/checkout@v2
diff --git a/CHANGELOG.md b/CHANGELOG.md
index c3235a006..059ba0bf8 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,9 @@
 # Changelog
 
+### 3.10
+
+- New parser that allows parsing to continue after non-fatal errors have occured. This allows Zod to surface more errors to the user at once.
+
 ### 3.9
 
 - Custom error messages in schemas
diff --git a/README.md b/README.md
index aeee09355..74e39285a 100644
--- a/README.md
+++ b/README.md
@@ -18,6 +18,8 @@
 
 <br/>
 
+This docs have been translated into [Chinese](./README_ZH.md).
+
 # Table of contents
 
 - [What is Zod](#what-is-zod)
@@ -553,7 +555,7 @@ You can make an existing schema nullable with the `nullable` method:
 
 ```ts
 const E = z.string().nullable(); // equivalent to D
-type E = z.infer<typeof D>; // string | null
+type E = z.infer<typeof E>; // string | null
 ```
 
 #### `.unwrap`
@@ -1426,7 +1428,7 @@ const Strings = z.array(z.string()).superRefine((val, ctx) => {
 
 You can add as many issues as you like. If `ctx.addIssue` is NOT called during the execution of the function, validation passes.
 
-Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` you can create any issue of any code. Each issue code is described in detail in the Error Handling guide (ERROR_HANDLING.md).
+Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` you can create any issue of any code. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).
 
 ### `.transform`
 
diff --git a/README_ZH.md b/README_ZH.md
index 14614be5a..310fab088 100644
--- a/README_ZH.md
+++ b/README_ZH.md
@@ -668,7 +668,7 @@ nullableString.parse(null); // => null
 
 ```ts
 const E = z.string().nullable(); // equivalent to D
-type E = z.infer<typeof D>; // string | null
+type E = z.infer<typeof E>; // string | null
 ```
 
 #### `.unwrap`
@@ -1379,7 +1379,7 @@ const Strings = z.array(z.string()).superRefine((val, ctx) => {
 
 你可以随心所欲地添加问题(issues)。如果`ctx.addIssue`在函数的执行过程中没有被调用，则验证通过。
 
-通常情况下，细化总是创建具有`ZodIssueCode.custom`错误代码的问题，但通过`superRefine`你可以创建任何代码的任何问题。每个问题代码在错误处理指南（ERROR_HANDLING.md）中都有详细描述。
+通常情况下，细化总是创建具有`ZodIssueCode.custom`错误代码的问题，但通过`superRefine`你可以创建任何代码的任何问题。每个问题代码在错误处理指南 [ERROR_HANDLING.md](ERROR_HANDLING.md) 中都有详细描述。
 
 ### `.transform`
 
diff --git a/coverage.svg b/coverage.svg
index b17efe4b6..256dcafe3 100644
--- a/coverage.svg
+++ b/coverage.svg
@@ -1 +1 @@
-<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 89.43%"><title>Coverage: 89.43%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#dfb317"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">89.43%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">89.43%</text></g></svg>
\ No newline at end of file
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 94.53%"><title>Coverage: 94.53%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#4c1"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">94.53%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">94.53%</text></g></svg>
\ No newline at end of file
diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index 077a2a23d..b232a5796 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -17,6 +17,15 @@ export const ZodIssueCode = util.arrayToEnum([
   "not_multiple_of",
 ]);
 
+export const FATAL_CODES = [
+  ZodIssueCode.invalid_type,
+  ZodIssueCode.invalid_date,
+  ZodIssueCode.invalid_intersection_types,
+  ZodIssueCode.invalid_return_type,
+  ZodIssueCode.invalid_arguments,
+  ZodIssueCode.invalid_enum_value,
+];
+
 export type ZodIssueCode = keyof typeof ZodIssueCode;
 
 export type ZodIssueBase = {
diff --git a/deno/lib/__tests__/default.test.ts b/deno/lib/__tests__/default.test.ts
index 46f321f2f..db55629f7 100644
--- a/deno/lib/__tests__/default.test.ts
+++ b/deno/lib/__tests__/default.test.ts
@@ -102,3 +102,7 @@ test("chained defaults", () => {
   const result = stringWithDefault.parse(undefined);
   expect(result).toEqual("outer");
 });
+
+test("factory", () => {
+  z.ZodDefault.create(z.string()).parse(undefined);
+});
diff --git a/deno/lib/__tests__/error.test.ts b/deno/lib/__tests__/error.test.ts
index e635759c0..f0768963c 100644
--- a/deno/lib/__tests__/error.test.ts
+++ b/deno/lib/__tests__/error.test.ts
@@ -231,6 +231,25 @@ test("custom path", () => {
   }
 });
 
+test("custom path", () => {
+  const schema = z
+    .object({
+      password: z.string().min(6),
+      confirm: z.string().min(6),
+    })
+    .refine((val) => val.confirm === val.password);
+
+  const result = schema.safeParse({
+    password: "qwer",
+    confirm: "asdf",
+  });
+
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues.length).toEqual(3);
+  }
+});
+
 const schema = z.object({
   inner: z.object({
     name: z
@@ -249,7 +268,7 @@ test("no abort early on refinements", () => {
   const result1 = schema.safeParse(invalidItem);
   expect(result1.success).toEqual(false);
   if (!result1.success) {
-    expect(result1.error.issues.length).toEqual(1);
+    expect(result1.error.issues.length).toEqual(2);
   }
 });
 test("formatting", () => {
@@ -368,6 +387,16 @@ test("invalid and required and errorMap", () => {
   }).toThrow();
 });
 
+test("strict error message", () => {
+  const errorMsg = "Invalid object";
+  const obj = z.object({ x: z.string() }).strict(errorMsg);
+  const result = obj.safeParse({ x: "a", y: "b" });
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual(errorMsg);
+  }
+});
+
 // test("dont short circuit on continuable errors", () => {
 //   const user = z
 //     .object({
diff --git a/deno/lib/__tests__/function.test.ts b/deno/lib/__tests__/function.test.ts
index dd23063f8..cb57613b9 100644
--- a/deno/lib/__tests__/function.test.ts
+++ b/deno/lib/__tests__/function.test.ts
@@ -205,3 +205,10 @@ test("allow extra parameters", () => {
   ].filter(maxLength5);
   expect(filteredList.length).toEqual(2);
 });
+
+test("params and returnType getters", () => {
+  const func = z.function().args(z.string()).returns(z.string());
+
+  func.parameters().items[0].parse("asdf");
+  func.returnType().parse("asdf");
+});
diff --git a/deno/lib/__tests__/intersection.test.ts b/deno/lib/__tests__/intersection.test.ts
index 37f29faea..9e647ffa0 100644
--- a/deno/lib/__tests__/intersection.test.ts
+++ b/deno/lib/__tests__/intersection.test.ts
@@ -44,7 +44,7 @@ test("deep intersection", () => {
   expect(cat.properties).toEqual({ is_animal: true, jumped: true });
 });
 
-test("deep intersection of arrays", () => {
+test("deep intersection of arrays", async () => {
   const Author = z.object({
     posts: z.array(
       z.object({
@@ -68,4 +68,54 @@ test("deep intersection of arrays", () => {
   ];
   const cat = Registry.parse({ posts });
   expect(cat.posts).toEqual(posts);
+  const asyncCat = await Registry.parseAsync({ posts });
+  expect(asyncCat.posts).toEqual(posts);
+});
+
+test("invalid intersection types", async () => {
+  const numberIntersection = z.intersection(
+    z.number(),
+    z.number().transform((x) => x + 1)
+  );
+
+  const syncResult = numberIntersection.safeParse(1234);
+  expect(syncResult.success).toEqual(false);
+  if (!syncResult.success) {
+    expect(syncResult.error.issues[0].code).toEqual(
+      z.ZodIssueCode.invalid_intersection_types
+    );
+  }
+
+  const asyncResult = await numberIntersection.spa(1234);
+  expect(asyncResult.success).toEqual(false);
+  if (!asyncResult.success) {
+    expect(asyncResult.error.issues[0].code).toEqual(
+      z.ZodIssueCode.invalid_intersection_types
+    );
+  }
+});
+
+test("invalid array merge", async () => {
+  const stringArrInt = z.intersection(
+    z.string().array(),
+    z
+      .string()
+      .array()
+      .transform((val) => [...val, "asdf"])
+  );
+  const syncResult = stringArrInt.safeParse(["asdf", "qwer"]);
+  expect(syncResult.success).toEqual(false);
+  if (!syncResult.success) {
+    expect(syncResult.error.issues[0].code).toEqual(
+      z.ZodIssueCode.invalid_intersection_types
+    );
+  }
+
+  const asyncResult = await stringArrInt.spa(["asdf", "qwer"]);
+  expect(asyncResult.success).toEqual(false);
+  if (!asyncResult.success) {
+    expect(asyncResult.error.issues[0].code).toEqual(
+      z.ZodIssueCode.invalid_intersection_types
+    );
+  }
 });
diff --git a/deno/lib/__tests__/map.test.ts b/deno/lib/__tests__/map.test.ts
index ae5eacbea..a77424364 100644
--- a/deno/lib/__tests__/map.test.ts
+++ b/deno/lib/__tests__/map.test.ts
@@ -14,7 +14,7 @@ test("type inference", () => {
   f1;
 });
 
-test("doesn’t throw when a valid value is given", () => {
+test("valid parse", () => {
   const result = stringMap.safeParse(
     new Map([
       ["first", "foo"],
@@ -22,6 +22,28 @@ test("doesn’t throw when a valid value is given", () => {
     ])
   );
   expect(result.success).toEqual(true);
+  if (result.success) {
+    expect(result.data.has("first")).toEqual(true);
+    expect(result.data.has("second")).toEqual(true);
+    expect(result.data.get("first")).toEqual("foo");
+    expect(result.data.get("second")).toEqual("bar");
+  }
+});
+
+test("valid parse async", async () => {
+  const result = await stringMap.spa(
+    new Map([
+      ["first", "foo"],
+      ["second", "bar"],
+    ])
+  );
+  expect(result.success).toEqual(true);
+  if (result.success) {
+    expect(result.data.has("first")).toEqual(true);
+    expect(result.data.has("second")).toEqual(true);
+    expect(result.data.get("first")).toEqual("foo");
+    expect(result.data.get("second")).toEqual("bar");
+  }
 });
 
 test("throws when a Set is given", () => {
@@ -65,3 +87,26 @@ test("throws when the given map has multiple invalid entries", () => {
     expect(result.error.issues[1].path).toEqual([1, "value"]);
   }
 });
+
+test("dirty", async () => {
+  const map = z.map(
+    z.string().refine((val) => val === val.toUpperCase(), {
+      message: "Keys must be uppercase",
+    }),
+    z.string()
+  );
+  const result = await map.spa(
+    new Map([
+      ["first", "foo"],
+      ["second", "bar"],
+    ])
+  );
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues.length).toEqual(2);
+    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
+    expect(result.error.issues[0].message).toEqual("Keys must be uppercase");
+    expect(result.error.issues[1].code).toEqual(z.ZodIssueCode.custom);
+    expect(result.error.issues[1].message).toEqual("Keys must be uppercase");
+  }
+});
diff --git a/deno/lib/__tests__/number.test.ts b/deno/lib/__tests__/number.test.ts
index 882ec970c..33c6d43a7 100644
--- a/deno/lib/__tests__/number.test.ts
+++ b/deno/lib/__tests__/number.test.ts
@@ -35,3 +35,14 @@ test("failing validations", () => {
 test("parse NaN", () => {
   expect(() => z.number().parse(NaN)).toThrow();
 });
+
+test("min max getters", () => {
+  expect(z.number().int().isInt).toEqual(true);
+  expect(z.number().isInt).toEqual(false);
+
+  expect(z.number().min(5).minValue).toEqual(5);
+  expect(z.number().min(5).min(10).minValue).toEqual(10);
+
+  expect(z.number().max(5).maxValue).toEqual(5);
+  expect(z.number().max(5).max(1).maxValue).toEqual(1);
+});
diff --git a/deno/lib/__tests__/object.test.ts b/deno/lib/__tests__/object.test.ts
index 71b02b41f..dd4ec05af 100644
--- a/deno/lib/__tests__/object.test.ts
+++ b/deno/lib/__tests__/object.test.ts
@@ -235,3 +235,37 @@ test("inferred type for unknown/any keys", () => {
   > = true;
   _f1;
 });
+
+test("setKey", () => {
+  const base = z.object({ name: z.string() });
+  const withNewKey = base.setKey("age", z.number());
+
+  type withNewKey = z.infer<typeof withNewKey>;
+  const _t1: util.AssertEqual<withNewKey, { name: string; age: number }> = true;
+  _t1;
+  withNewKey.parse({ name: "asdf", age: 1234 });
+});
+
+test("strictcreate", async () => {
+  const strictObj = z.strictObject({
+    name: z.string(),
+  });
+
+  const syncResult = strictObj.safeParse({ name: "asdf", unexpected: 13 });
+  expect(syncResult.success).toEqual(false);
+
+  const asyncResult = await strictObj.spa({ name: "asdf", unexpected: 13 });
+  expect(asyncResult.success).toEqual(false);
+});
+
+test("object with refine", async () => {
+  const schema = z
+    .object({
+      a: z.string().default("foo"),
+      b: z.number(),
+    })
+    .refine(() => true);
+  expect(schema.parse({ b: 5 })).toEqual({ b: 5, a: "foo" });
+  const result = await schema.parseAsync({ b: 5 });
+  expect(result).toEqual({ b: 5, a: "foo" });
+});
diff --git a/deno/lib/__tests__/parseUtil.test.ts b/deno/lib/__tests__/parseUtil.test.ts
index 50e773fc0..6be849310 100644
--- a/deno/lib/__tests__/parseUtil.test.ts
+++ b/deno/lib/__tests__/parseUtil.test.ts
@@ -2,11 +2,28 @@
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
-import { INVALID, isInvalid } from "../helpers/parseUtil.ts";
+import {
+  isAborted,
+  isDirty,
+  isValid,
+  SyncParseReturnType,
+} from "../helpers/parseUtil.ts";
 
 test("parseUtil isInvalid should use structural typing", () => {
   // Test for issue #556: https://github.com/colinhacks/zod/issues/556
-  const newInstance: INVALID = Object.freeze({ valid: false });
-  expect(isInvalid(newInstance)).toBe(true);
-  expect(isInvalid(INVALID)).toBe(true);
+  const aborted: SyncParseReturnType = { status: "aborted" };
+  const dirty: SyncParseReturnType = { status: "dirty", value: "whatever" };
+  const valid: SyncParseReturnType = { status: "valid", value: "whatever" };
+
+  expect(isAborted(aborted)).toBe(true);
+  expect(isAborted(dirty)).toBe(false);
+  expect(isAborted(valid)).toBe(false);
+
+  expect(isDirty(aborted)).toBe(false);
+  expect(isDirty(dirty)).toBe(true);
+  expect(isDirty(valid)).toBe(false);
+
+  expect(isValid(aborted)).toBe(false);
+  expect(isValid(dirty)).toBe(false);
+  expect(isValid(valid)).toBe(true);
 });
diff --git a/deno/lib/__tests__/partials.test.ts b/deno/lib/__tests__/partials.test.ts
index b5166ac86..8646d82e3 100644
--- a/deno/lib/__tests__/partials.test.ts
+++ b/deno/lib/__tests__/partials.test.ts
@@ -146,3 +146,22 @@ test("required", () => {
   expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);
   expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);
 });
+
+test("with mask", async () => {
+  const object = z.object({
+    name: z.string(),
+    age: z.number().optional(),
+    field: z.string().optional().default("asdf"),
+  });
+
+  const masked = object
+    .partial({
+      name: true,
+      age: true,
+      field: true,
+    })
+    .strict();
+
+  masked.parse({});
+  await masked.parseAsync({});
+});
diff --git a/deno/lib/__tests__/primitive.test.ts b/deno/lib/__tests__/primitive.test.ts
index 94d554c13..1d38ddad6 100644
--- a/deno/lib/__tests__/primitive.test.ts
+++ b/deno/lib/__tests__/primitive.test.ts
@@ -412,3 +412,13 @@ test("primitive inference", () => {
     dateSchemaNullableTest,
   ];
 });
+
+test("get literal value", () => {
+  expect(literalStringSchema.value).toEqual("asdf");
+});
+
+test("optional convenience methd", () => {
+  z.ostring().parse(undefined);
+  z.onumber().parse(undefined);
+  z.oboolean().parse(undefined);
+});
diff --git a/deno/lib/__tests__/record.test.ts b/deno/lib/__tests__/record.test.ts
index 396435c76..8ea322ff3 100644
--- a/deno/lib/__tests__/record.test.ts
+++ b/deno/lib/__tests__/record.test.ts
@@ -112,3 +112,11 @@ test("key schema", () => {
 // test("record element", () => {
 //   expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);
 // });
+
+test("key and value getters", () => {
+  const rec = z.record(z.string(), z.number());
+
+  rec.keySchema.parse("asdf");
+  rec.valueSchema.parse(1234);
+  rec.element.parse(1234);
+});
diff --git a/deno/lib/__tests__/recursive.test.ts b/deno/lib/__tests__/recursive.test.ts
index 0d72635cc..2a4a84857 100644
--- a/deno/lib/__tests__/recursive.test.ts
+++ b/deno/lib/__tests__/recursive.test.ts
@@ -47,6 +47,9 @@ test("recursion with z.lazy", () => {
   Category.parse(testCategory);
 });
 
+test("schema getter", () => {
+  z.lazy(() => z.string()).schema.parse("asdf");
+});
 // interface A {
 //   val: number;
 //   b: B;
diff --git a/deno/lib/__tests__/refine.test.ts b/deno/lib/__tests__/refine.test.ts
index 22e423f9b..6069f77d7 100644
--- a/deno/lib/__tests__/refine.test.ts
+++ b/deno/lib/__tests__/refine.test.ts
@@ -50,16 +50,16 @@ test("refinement 2", () => {
 });
 
 test("custom path", async () => {
-  try {
-    await z
-      .object({
-        password: z.string(),
-        confirm: z.string(),
-      })
-      .refine((data) => data.confirm === data.password, { path: ["confirm"] })
-      .parseAsync({ password: "asdf", confirm: "qewr" });
-  } catch (err) {
-    expect((err as z.ZodError).issues[0].path).toEqual(["confirm"]);
+  const result = await z
+    .object({
+      password: z.string(),
+      confirm: z.string(),
+    })
+    .refine((data) => data.confirm === data.password, { path: ["confirm"] })
+    .spa({ password: "asdf", confirm: "qewr" });
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].path).toEqual(["confirm"]);
   }
 });
 
@@ -82,8 +82,6 @@ test("use path in refinement context", async () => {
 
   const t1 = await noNested.spa("asdf");
   const t2 = await data.spa({ foo: "asdf" });
-  // console.log(t1);
-  // console.log(t2);
 
   expect(t1.success).toBe(true);
   expect(t2.success).toBe(false);
@@ -121,3 +119,39 @@ test("superRefine", () => {
 
   Strings.parse(["asfd", "qwer"]);
 });
+
+test("get inner type", () => {
+  z.string()
+    .refine(() => true)
+    .innerType()
+    .parse("asdf");
+});
+
+test("chained refinements", () => {
+  const objectSchema = z
+    .object({
+      length: z.number(),
+      size: z.number(),
+    })
+    .refine(({ length }) => length > 5, {
+      path: ["length"],
+      message: "length greater than 5",
+    })
+    .refine(({ size }) => size > 7, {
+      path: ["size"],
+      message: "size greater than 7",
+    });
+  const r1 = objectSchema.safeParse({
+    length: 4,
+    size: 9,
+  });
+  expect(r1.success).toEqual(false);
+  if (!r1.success) expect(r1.error.issues.length).toEqual(1);
+
+  const r2 = objectSchema.safeParse({
+    length: 4,
+    size: 3,
+  });
+  expect(r2.success).toEqual(false);
+  if (!r2.success) expect(r2.error.issues.length).toEqual(2);
+});
diff --git a/deno/lib/__tests__/set.test.ts b/deno/lib/__tests__/set.test.ts
index adb08812a..abf3f1972 100644
--- a/deno/lib/__tests__/set.test.ts
+++ b/deno/lib/__tests__/set.test.ts
@@ -14,9 +14,32 @@ test("type inference", () => {
   f1;
 });
 
-test("doesn’t throw when a valid value is given", () => {
+test("valid parse", () => {
   const result = stringSet.safeParse(new Set(["first", "second"]));
   expect(result.success).toEqual(true);
+  if (result.success) {
+    expect(result.data.has("first")).toEqual(true);
+    expect(result.data.has("second")).toEqual(true);
+    expect(result.data.has("third")).toEqual(false);
+  }
+});
+
+test("valid parse async", async () => {
+  const result = await stringSet.spa(new Set(["first", "second"]));
+  expect(result.success).toEqual(true);
+  if (result.success) {
+    expect(result.data.has("first")).toEqual(true);
+    expect(result.data.has("second")).toEqual(true);
+    expect(result.data.has("third")).toEqual(false);
+  }
+
+  const asyncResult = await stringSet.safeParse(new Set(["first", "second"]));
+  expect(asyncResult.success).toEqual(true);
+  if (asyncResult.success) {
+    expect(asyncResult.data.has("first")).toEqual(true);
+    expect(asyncResult.data.has("second")).toEqual(true);
+    expect(asyncResult.data.has("third")).toEqual(false);
+  }
 });
 
 test("doesn’t throw when an empty set is given", () => {
diff --git a/deno/lib/__tests__/string.test.ts b/deno/lib/__tests__/string.test.ts
index 8f0ea8123..f624e31b5 100644
--- a/deno/lib/__tests__/string.test.ts
+++ b/deno/lib/__tests__/string.test.ts
@@ -57,9 +57,7 @@ test("url validations", () => {
     expect(() => url.parse("asdf")).toThrow();
     expect(() => url.parse("https:/")).toThrow();
     expect(() => url.parse("asdfj@lkjsdf.com")).toThrow();
-  } catch (err) {
-    // console.log(JSON.stringify(err, null, 2));
-  }
+  } catch (err) {}
 });
 
 test("url error overrides", () => {
@@ -142,8 +140,31 @@ test("regex lastIndex reset", () => {
 });
 
 test("checks getters", () => {
-  expect(z.string().uuid().isUUID).toEqual(true);
-  expect(z.string().uuid().isCUID).toEqual(false);
-  expect(z.string().cuid().isUUID).toEqual(false);
+  expect(z.string().email().isEmail).toEqual(true);
+  expect(z.string().email().isURL).toEqual(false);
+  expect(z.string().email().isCUID).toEqual(false);
+  expect(z.string().email().isUUID).toEqual(false);
+
+  expect(z.string().url().isEmail).toEqual(false);
+  expect(z.string().url().isURL).toEqual(true);
+  expect(z.string().url().isCUID).toEqual(false);
+  expect(z.string().url().isUUID).toEqual(false);
+
+  expect(z.string().cuid().isEmail).toEqual(false);
+  expect(z.string().cuid().isURL).toEqual(false);
   expect(z.string().cuid().isCUID).toEqual(true);
+  expect(z.string().cuid().isUUID).toEqual(false);
+
+  expect(z.string().uuid().isEmail).toEqual(false);
+  expect(z.string().uuid().isURL).toEqual(false);
+  expect(z.string().uuid().isCUID).toEqual(false);
+  expect(z.string().uuid().isUUID).toEqual(true);
+});
+
+test("min max getters", () => {
+  expect(z.string().min(5).minLength).toEqual(5);
+  expect(z.string().min(5).min(10).minLength).toEqual(10);
+
+  expect(z.string().max(5).maxLength).toEqual(5);
+  expect(z.string().max(5).max(1).maxLength).toEqual(1);
 });
diff --git a/deno/lib/__tests__/transformer.test.ts b/deno/lib/__tests__/transformer.test.ts
index d3b5b855f..2f69041df 100644
--- a/deno/lib/__tests__/transformer.test.ts
+++ b/deno/lib/__tests__/transformer.test.ts
@@ -130,3 +130,39 @@ test("async preprocess", async () => {
   const value = await schema.parseAsync("asdf");
   expect(value).toEqual(["asdf"]);
 });
+
+test("short circuit on dirty", () => {
+  const schema = z
+    .string()
+    .refine(() => false)
+    .transform((val) => val.toUpperCase());
+  const result = schema.safeParse("asdf");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
+  }
+
+  const result2 = schema.safeParse(1234);
+  expect(result2.success).toEqual(false);
+  if (!result2.success) {
+    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
+  }
+});
+
+test("async short circuit on dirty", async () => {
+  const schema = z
+    .string()
+    .refine(() => false)
+    .transform((val) => val.toUpperCase());
+  const result = await schema.spa("asdf");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
+  }
+
+  const result2 = await schema.spa(1234);
+  expect(result2.success).toEqual(false);
+  if (!result2.success) {
+    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
+  }
+});
diff --git a/deno/lib/__tests__/unions.test.ts b/deno/lib/__tests__/unions.test.ts
new file mode 100644
index 000000000..0e3d5e1b0
--- /dev/null
+++ b/deno/lib/__tests__/unions.test.ts
@@ -0,0 +1,57 @@
+import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
+const test = Deno.test;
+
+import * as z from "../index.ts";
+
+test("function parsing", () => {
+  const schema = z.union([
+    z.string().refine(() => false),
+    z.number().refine(() => false),
+  ]);
+  const result = schema.safeParse("asdf");
+  expect(result.success).toEqual(false);
+});
+
+test("union 2", () => {
+  const result = z
+    .union([z.number(), z.string().refine(() => false)])
+    .safeParse("a");
+  expect(result.success).toEqual(false);
+});
+
+test("return valid over invalid", () => {
+  const schema = z.union([
+    z.object({
+      email: z.string().email(),
+    }),
+    z.string(),
+  ]);
+  expect(schema.parse("asdf")).toEqual("asdf");
+  expect(schema.parse({ email: "asdlkjf@lkajsdf.com" })).toEqual({
+    email: "asdlkjf@lkajsdf.com",
+  });
+});
+
+test("return dirty result over aborted", () => {
+  const result = z
+    .union([z.number(), z.string().refine(() => false)])
+    .safeParse("a");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues).toEqual([
+      {
+        code: "custom",
+        message: "Invalid input",
+        path: [],
+      },
+    ]);
+  }
+});
+
+test("options getter", async () => {
+  const union = z.union([z.string(), z.number()]);
+  union.options[0].parse("asdf");
+  union.options[1].parse(1234);
+  await union.options[0].parseAsync("asdf");
+  await union.options[1].parseAsync(1234);
+});
diff --git a/deno/lib/helpers/parseUtil.ts b/deno/lib/helpers/parseUtil.ts
index 338221d63..6bea30c8e 100644
--- a/deno/lib/helpers/parseUtil.ts
+++ b/deno/lib/helpers/parseUtil.ts
@@ -32,59 +32,82 @@ export const ZodParsedType = util.arrayToEnum([
 
 export type ZodParsedType = keyof typeof ZodParsedType;
 
-export const getParsedType = (data: any): ZodParsedType => {
+function cacheAndReturn(
+  data: any,
+  parsedType: ZodParsedType,
+  cache?: Map<any, ZodParsedType>
+) {
+  if (cache) cache.set(data, parsedType);
+  return parsedType;
+}
+
+export const getParsedType = (
+  data: any,
+  cache?: Map<any, ZodParsedType>
+): ZodParsedType => {
+  if (cache && cache.has(data)) return cache.get(data)!;
   const t = typeof data;
+
   switch (t) {
     case "undefined":
-      return ZodParsedType.undefined;
+      return cacheAndReturn(data, ZodParsedType.undefined, cache);
+
     case "string":
-      return ZodParsedType.string;
+      return cacheAndReturn(data, ZodParsedType.string, cache);
+
     case "number":
-      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
+      return cacheAndReturn(
+        data,
+        isNaN(data) ? ZodParsedType.nan : ZodParsedType.number,
+        cache
+      );
+
     case "boolean":
-      return ZodParsedType.boolean;
+      return cacheAndReturn(data, ZodParsedType.boolean, cache);
+
     case "function":
-      return ZodParsedType.function;
+      return cacheAndReturn(data, ZodParsedType.function, cache);
+
     case "bigint":
-      return ZodParsedType.bigint;
+      return cacheAndReturn(data, ZodParsedType.bigint, cache);
+
     case "object":
-      if (Array.isArray(data)) return ZodParsedType.array;
-      if (data === null) return ZodParsedType.null;
+      if (Array.isArray(data)) {
+        return cacheAndReturn(data, ZodParsedType.array, cache);
+      }
+      if (data === null) {
+        return cacheAndReturn(data, ZodParsedType.null, cache);
+      }
       if (
         data.then &&
         typeof data.then === "function" &&
         data.catch &&
         typeof data.catch === "function"
       ) {
-        return ZodParsedType.promise;
+        return cacheAndReturn(data, ZodParsedType.promise, cache);
       }
       if (data instanceof Map) {
-        return ZodParsedType.map;
+        return cacheAndReturn(data, ZodParsedType.map, cache);
       }
       if (data instanceof Set) {
-        return ZodParsedType.set;
+        return cacheAndReturn(data, ZodParsedType.set, cache);
       }
       if (data instanceof Date) {
-        return ZodParsedType.date;
+        return cacheAndReturn(data, ZodParsedType.date, cache);
       }
-      return ZodParsedType.object;
+      return cacheAndReturn(data, ZodParsedType.object, cache);
+
     default:
-      return ZodParsedType.unknown;
+      return cacheAndReturn(data, ZodParsedType.unknown, cache);
   }
 };
 
-export const makeIssue = (
-  params: {
-    data: any;
-    path: (string | number)[];
-    errorMaps: (ZodErrorMap | undefined)[];
-    issueData: IssueData;
-  }
-  // data: any,
-  // path: (string | number)[],
-  // errorMap: ZodErrorMap,
-  // issueData: IssueData
-): ZodIssue => {
+export const makeIssue = (params: {
+  data: any;
+  path: (string | number)[];
+  errorMaps: ZodErrorMap[];
+  issueData: IssueData;
+}): ZodIssue => {
   const { data, path, errorMaps, issueData } = params;
   const fullPath = [...path, ...(issueData.path || [])];
   const fullIssue = {
@@ -109,124 +132,144 @@ export const makeIssue = (
 };
 
 export type ParseParams = {
-  // data: any;
   path: (string | number)[];
   errorMap: ZodErrorMap;
   async: boolean;
 };
 
-export type ParseParamsNoData = Omit<ParseParams, "data">;
-
 export type ParsePathComponent = string | number;
+export type ParsePath = ParsePathComponent[];
+export const EMPTY_PATH: ParsePath = [];
 
-export type ParsePath = null | {
-  readonly component: ParsePathComponent;
-  readonly parent: ParsePath;
-  readonly count: number;
-};
-
-export const EMPTY_PATH: ParsePath = null;
-
-export const pathToArray = (path: ParsePath): ParsePathComponent[] => {
-  if (path === null) return [];
-  const arr: ParsePathComponent[] = new Array(path.count);
-  while (path !== null) {
-    arr[path.count - 1] = path.component;
-    path = path.parent;
-  }
-  return arr;
-};
-
-export const pathFromArray = (arr: ParsePathComponent[]): ParsePath => {
-  let path: ParsePath = null;
-  for (let i = 0; i < arr.length; i++) {
-    path = { parent: path, component: arr[i], count: i + 1 };
-  }
-  return path;
-};
-
-export type ParseContextParameters = {
-  errorMap: ZodErrorMap;
-  async: boolean;
-};
-
-interface ParseContextDef {
+export interface ParseContext {
   readonly path: ParsePath;
   readonly issues: ZodIssue[];
-  readonly errorMap?: ZodErrorMap;
+  readonly schemaErrorMap?: ZodErrorMap;
+  readonly contextualErrorMap?: ZodErrorMap;
   readonly async: boolean;
+  readonly parent: ParseContext | null;
+  readonly typeCache: Map<any, ZodParsedType>;
+  readonly data: any;
+  readonly parsedType: ZodParsedType;
 }
 
-export class ParseContext {
-  // public readonly path: ParsePath;
-  // public readonly issues: ZodIssue[];
-  // public readonly errorMap: ZodErrorMap;
-  public readonly def: ParseContextDef;
+export type ParseInput = {
+  data: any;
+  path: (string | number)[];
+  parent: ParseContext;
+};
 
-  constructor(def: ParseContextDef) {
-    this.def = def;
-  }
-  get path() {
-    return this.def.path;
-  }
-  get issues() {
-    return this.def.issues;
+export function addIssueToContext(
+  ctx: ParseContext,
+  issueData: IssueData
+): void {
+  const issue = makeIssue({
+    issueData: issueData,
+    data: ctx.data,
+    path: ctx.path,
+    errorMaps: [
+      ctx.contextualErrorMap, // contextual error map is first priority
+      ctx.schemaErrorMap, // then schema-bound map if available
+      overrideErrorMap, // then global override map
+      defaultErrorMap, // then global default map
+    ].filter((x) => !!x) as ZodErrorMap[],
+  });
+  ctx.issues.push(issue);
+}
+
+export type ObjectPair = {
+  key: SyncParseReturnType<any>;
+  value: SyncParseReturnType<any>;
+};
+export class ParseStatus {
+  value: "aborted" | "dirty" | "valid" = "valid";
+  dirty() {
+    if (this.value === "valid") this.value = "dirty";
   }
-  get errorMap() {
-    return this.def.errorMap;
+  abort() {
+    if (this.value !== "aborted") this.value = "aborted";
   }
-  get async() {
-    return this.def.async;
+
+  static mergeArray(
+    status: ParseStatus,
+    results: SyncParseReturnType<any>[]
+  ): SyncParseReturnType {
+    const arrayValue: any[] = [];
+    for (const s of results) {
+      if (s.status === "aborted") return INVALID;
+      if (s.status === "dirty") status.dirty();
+      arrayValue.push(s.value);
+    }
+
+    return { status: status.value, value: arrayValue };
   }
 
-  stepInto(component: ParsePathComponent): ParseContext {
-    return new ParseContext({
-      ...this.def,
-      path:
-        this.path === null
-          ? { parent: null, count: 1, component }
-          : { parent: this.path, count: this.path.count + 1, component },
-    });
+  static async mergeObjectAsync(
+    status: ParseStatus,
+    pairs: { key: ParseReturnType<any>; value: ParseReturnType<any> }[]
+  ): Promise<SyncParseReturnType<any>> {
+    const syncPairs: ObjectPair[] = [];
+    for (const pair of pairs) {
+      syncPairs.push({
+        key: await pair.key,
+        value: await pair.value,
+      });
+    }
+    return ParseStatus.mergeObjectSync(status, syncPairs);
   }
 
-  _addIssue(
-    data: any,
-    issueData: IssueData,
-    params: { schemaErrorMap?: ZodErrorMap } = {}
-  ): void {
-    const issue = makeIssue({
-      data,
-      issueData,
-      path: pathToArray(this.path),
-      errorMaps: [
-        this.def.errorMap, // contextual error map is first priority
-        params.schemaErrorMap, // then schema-bound map if available
-        overrideErrorMap, // then global override map
-        defaultErrorMap, // then global default map
-      ],
-      // errorMaps: [this.errorMap],
-      // issueData,
-    });
-    this.issues.push(issue);
+  static mergeObjectSync(
+    status: ParseStatus,
+    pairs: {
+      key: SyncParseReturnType<any>;
+      value: SyncParseReturnType<any>;
+      alwaysSet?: boolean;
+    }[]
+  ): SyncParseReturnType {
+    const finalObject: any = {};
+    for (const pair of pairs) {
+      const { key, value } = pair;
+      if (key.status === "aborted") return INVALID;
+      if (value.status === "aborted") return INVALID;
+      if (key.status === "dirty") status.dirty();
+      if (value.status === "dirty") status.dirty();
+
+      if (typeof value.value !== "undefined" || pair.alwaysSet) {
+        finalObject[key.value] = value.value;
+      }
+    }
+
+    return { status: status.value, value: finalObject };
   }
 }
+export interface ParseResult {
+  status: "aborted" | "dirty" | "valid";
+  data: any;
+}
+
+export type INVALID = { status: "aborted" };
+export const INVALID: INVALID = Object.freeze({
+  status: "aborted",
+});
 
-export type INVALID = { valid: false };
-export const INVALID: INVALID = Object.freeze({ valid: false });
+export type DIRTY<T> = { status: "dirty"; value: T };
+export const DIRTY = <T>(value: T): DIRTY<T> => ({ status: "dirty", value });
 
-export type OK<T> = { valid: true; value: T };
-export const OK = <T>(value: T): OK<T> => ({ valid: true, value });
+export type OK<T> = { status: "valid"; value: T };
+export const OK = <T>(value: T): OK<T> => ({ status: "valid", value });
 
-export type SyncParseReturnType<T> = OK<T> | INVALID;
+export type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
 export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
 export type ParseReturnType<T> =
   | SyncParseReturnType<T>
   | AsyncParseReturnType<T>;
 
-export const isInvalid = (x: ParseReturnType<any>): x is INVALID =>
-  (x as any).valid === false;
-export const isOk = <T>(x: ParseReturnType<T>): x is OK<T> =>
-  (x as any).valid === true;
+export const isAborted = (x: ParseReturnType<any>): x is INVALID =>
+  (x as any).status === "aborted";
+export const isDirty = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
+  (x as any).status === "dirty";
+export const isValid = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
+  (x as any).status === "valid";
 export const isAsync = <T>(
   x: ParseReturnType<T>
 ): x is AsyncParseReturnType<T> => x instanceof Promise;
diff --git a/deno/lib/index.ts b/deno/lib/index.ts
index 77368b4b5..0ab1ee020 100644
--- a/deno/lib/index.ts
+++ b/deno/lib/index.ts
@@ -1,3 +1,3 @@
-import * as z from "./external.ts";
+import * as mod from "./external.ts";
 export * from "./external.ts";
-export { z };
+export { mod as z };
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 575e4eb8e..d7a1fdb24 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -1,25 +1,30 @@
+import { FATAL_CODES } from "./index.ts";
 import { errorUtil } from "./helpers/errorUtil.ts";
 import {
+  addIssueToContext,
   AsyncParseReturnType,
   getParsedType,
   INVALID,
+  isAborted,
   isAsync,
-  isInvalid,
-  isOk,
+  isDirty,
+  isValid,
   makeIssue,
   OK,
   ParseContext,
-  ParseParamsNoData,
+  ParseInput,
+  ParseParams,
   ParseReturnType,
-  pathFromArray,
-  pathToArray,
+  ParseStatus,
   SyncParseReturnType,
   ZodParsedType,
 } from "./helpers/parseUtil.ts";
 import { partialUtil } from "./helpers/partialUtil.ts";
 import { util } from "./helpers/util.ts";
 import {
+  defaultErrorMap,
   IssueData,
+  overrideErrorMap,
   StringValidation,
   ZodCustomIssue,
   ZodError,
@@ -52,43 +57,21 @@ export interface ZodTypeDef {
   errorMap?: ZodErrorMap;
 }
 
-// function customErrorMap(arg: string | ZodErrorMap | undefined) {
-//   if (typeof arg === "string") {
-//     const map: ZodErrorMap = (iss, ctx) => {
-//       if (iss.code === ZodIssueCode.invalid_type) {
-//         return { message: arg };
-//       }
-//       return { message: ctx.defaultError };
-//     };
-//   }
-// }
-
-const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
-  new ParseContext({
-    path: pathFromArray(params.path || []),
-    issues: [],
-    errorMap: params.errorMap,
-    async: params.async ?? false,
-  });
-
 const handleResult = <Input, Output>(
   ctx: ParseContext,
   result: SyncParseReturnType<Output>
 ):
   | { success: true; data: Output }
   | { success: false; error: ZodError<Input> } => {
-  if (isOk(result) && !ctx.issues.length) {
+  if (isValid(result)) {
     return { success: true, data: result.value };
   } else {
+    if (!ctx.issues.length) {
+      throw new Error("Validation failed but no issues detected.");
+    }
     const error = new ZodError(ctx.issues);
     return { success: false, error };
   }
-  // if (isOk(result)) {
-  //   return { success: true, data: result.value };
-  // } else {
-  //   const error = new ZodError(ctx.issues);
-  //   return { success: false, error };
-  // }
 };
 
 type RawCreateParams =
@@ -128,44 +111,39 @@ export abstract class ZodType<
   readonly _input!: Input;
   readonly _def!: Def;
 
-  abstract _parse(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<Output>;
+  abstract _parse(input: ParseInput): ParseReturnType<Output>;
 
-  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx._addIssue(params.data, issueData, {
-      schemaErrorMap: this._def.errorMap,
-    });
+  _processInputParams(
+    input: ParseInput
+  ): { status: ParseStatus; ctx: ParseContext } {
+    return {
+      status: new ParseStatus(),
+      ctx: {
+        ...input.parent,
+        data: input.data,
+        parsedType: getParsedType(input.data, input.parent.typeCache),
+        schemaErrorMap: this._def.errorMap,
+        path: input.path,
+        parent: input.parent,
+      },
+    };
   }
 
-  _parseSync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): SyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
+  _parseSync(input: ParseInput): SyncParseReturnType<Output> {
+    const result = this._parse(input);
     if (isAsync(result)) {
       throw new Error("Synchronous parse encountered promise.");
     }
     return result;
   }
 
-  _parseAsync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): AsyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
-    // if (isAsync(result)) {
-    //   return result;
-    // }
+  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {
+    const result = this._parse(input);
 
     return Promise.resolve(result);
   }
 
-  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
+  parse(data: unknown, params?: Partial<ParseParams>): Output {
     const result = this.safeParse(data, params);
     if (result.success) return result.data;
     throw result.error;
@@ -173,18 +151,29 @@ export abstract class ZodType<
 
   safeParse(
     data: unknown,
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
   ):
     | { success: true; data: Output }
     | { success: false; error: ZodError<Input> } {
-    const ctx = createRootContext({ ...params, async: false });
-    const result = this._parseSync(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: params?.async ?? false,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
+
     return handleResult(ctx, result);
   }
 
   async parseAsync(
     data: unknown,
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
   ): Promise<Output> {
     const result = await this.safeParseAsync(data, params);
     if (result.success) return result.data;
@@ -193,12 +182,23 @@ export abstract class ZodType<
 
   async safeParseAsync(
     data: unknown,
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
   ): Promise<
     { success: true; data: Output } | { success: false; error: ZodError }
   > {
-    const ctx = createRootContext({ ...params, async: true });
-    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: true,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+
+    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
     const result = await (isAsync(maybeAsyncResult)
       ? maybeAsyncResult
       : Promise.resolve(maybeAsyncResult));
@@ -326,12 +326,7 @@ export abstract class ZodType<
   default(def: () => util.noUndefined<Input>): ZodDefault<this>;
   default(def: any) {
     const defaultValueFunc = typeof def === "function" ? def : () => def;
-    // if (this instanceof ZodOptional) {
-    //   return new ZodOptional({
-    //     ...this._def,
-    //     defaultValue: defaultValueFunc,
-    //   }) as any;
-    // }
+
     return new ZodDefault({
       innerType: this,
       defaultValue: defaultValueFunc,
@@ -377,132 +372,98 @@ const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-
 const emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
 
 export class ZodString extends ZodType<string, ZodStringDef> {
-  _parse(
-    ctx: ParseContext,
-    data: string,
-    parsedType: ZodParsedType
-  ): ParseReturnType<string> {
-    if (parsedType !== ZodParsedType.string) {
-      this.addIssue(
+  _parse(input: ParseInput): ParseReturnType<string> {
+    const { status, ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.string) {
+      addIssueToContext(
         ctx,
         {
           code: ZodIssueCode.invalid_type,
           expected: ZodParsedType.string,
-          received: parsedType,
-        },
-        { data }
+          received: ctx.parsedType,
+        }
+        //
       );
       return INVALID;
     }
-    let invalid = false;
 
     for (const check of this._def.checks) {
       if (check.kind === "min") {
-        if (data.length < check.value) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: "string",
-              inclusive: true,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data.length < check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: "string",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "max") {
-        if (data.length > check.value) {
-          invalid = true;
-
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: "string",
-              inclusive: true,
-              message: check.message,
-              // ...errorUtil.errToObj(this._def.maxLength.message),
-            },
-            { data }
-          );
+        if (ctx.data.length > check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: "string",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "email") {
-        if (!emailRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: "email",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!emailRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: "email",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "uuid") {
-        if (!uuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: "uuid",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!uuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: "uuid",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "cuid") {
-        if (!cuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: "cuid",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!cuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: "cuid",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "url") {
         try {
-          new URL(data);
+          new URL(ctx.data);
         } catch {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: "url",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: "url",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "regex") {
-        // clear regex state
         check.regex.lastIndex = 0;
-        const testResult = check.regex.test(data);
+        const testResult = check.regex.test(ctx.data);
         if (!testResult) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: "regex",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: "regex",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
         }
       }
     }
 
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
   }
 
   protected _regex = (
@@ -632,98 +593,71 @@ export interface ZodNumberDef extends ZodTypeDef {
 }
 
 export class ZodNumber extends ZodType<number, ZodNumberDef> {
-  _parse(
-    ctx: ParseContext,
-    data: number,
-    parsedType: ZodParsedType
-  ): ParseReturnType<number> {
-    if (parsedType !== ZodParsedType.number) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.number,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<number> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.number) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.number,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
-    let invalid = false;
-
     for (const check of this._def.checks) {
       if (check.kind === "int") {
-        if (!util.isInteger(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.invalid_type,
-              expected: "integer",
-              received: "float",
-              message: check.message,
-            },
-            { data }
-          );
+        if (!util.isInteger(ctx.data)) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.invalid_type,
+            expected: "integer",
+            received: "float",
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "min") {
-        // const MIN = check.value;
         const tooSmall = check.inclusive
-          ? data < check.value
-          : data <= check.value;
+          ? ctx.data < check.value
+          : ctx.data <= check.value;
         if (tooSmall) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: "number",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: "number",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "max") {
         const tooBig = check.inclusive
-          ? data > check.value
-          : data >= check.value;
+          ? ctx.data > check.value
+          : ctx.data >= check.value;
         if (tooBig) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: "number",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: "number",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "multipleOf") {
-        if (data % check.value !== 0) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.not_multiple_of,
-              multipleOf: check.value,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data % check.value !== 0) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else {
         util.assertNever(check);
       }
     }
 
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
   }
 
   static create = (params?: RawCreateParams): ZodNumber => {
@@ -871,25 +805,17 @@ export interface ZodBigIntDef extends ZodTypeDef {
 }
 
 export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
-  _parse(
-    ctx: ParseContext,
-    data: bigint,
-    parsedType: ZodParsedType
-  ): ParseReturnType<bigint> {
-    if (parsedType !== ZodParsedType.bigint) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.bigint,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<bigint> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.bigint) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.bigint,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
 
   static create = (params?: RawCreateParams): ZodBigInt => {
@@ -912,25 +838,17 @@ export interface ZodBooleanDef extends ZodTypeDef {
 }
 
 export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
-  _parse(
-    ctx: ParseContext,
-    data: boolean,
-    parsedType: ZodParsedType
-  ): ParseReturnType<boolean> {
-    if (parsedType !== ZodParsedType.boolean) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.boolean,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<boolean> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.boolean) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.boolean,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
 
   static create = (params?: RawCreateParams): ZodBoolean => {
@@ -953,37 +871,27 @@ export interface ZodDateDef extends ZodTypeDef {
 }
 
 export class ZodDate extends ZodType<Date, ZodDateDef> {
-  _parse(
-    ctx: ParseContext,
-    data: Date,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Date> {
-    if (parsedType !== ZodParsedType.date) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.date,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.date) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.date,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    if (isNaN(data.getTime())) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_date,
-        },
-        { data }
-      );
-
+    if (isNaN(ctx.data.getTime())) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_date,
+      });
       return INVALID;
     }
 
-    return OK(new Date((data as Date).getTime()));
+    return {
+      status: status.value,
+      value: new Date((ctx.data as Date).getTime()),
+    };
   }
 
   static create = (params?: RawCreateParams): ZodDate => {
@@ -1006,25 +914,17 @@ export interface ZodUndefinedDef extends ZodTypeDef {
 }
 
 export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
-  _parse(
-    ctx: ParseContext,
-    data: undefined,
-    parsedType: ZodParsedType
-  ): ParseReturnType<undefined> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.undefined,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.undefined,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
   params?: RawCreateParams;
 
@@ -1048,25 +948,17 @@ export interface ZodNullDef extends ZodTypeDef {
 }
 
 export class ZodNull extends ZodType<null, ZodNullDef> {
-  _parse(
-    ctx: ParseContext,
-    data: null,
-    parsedType: ZodParsedType
-  ): ParseReturnType<null> {
-    if (parsedType !== ZodParsedType.null) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.null,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.null) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.null,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
   static create = (params?: RawCreateParams): ZodNull => {
     return new ZodNull({
@@ -1090,12 +982,9 @@ export interface ZodAnyDef extends ZodTypeDef {
 export class ZodAny extends ZodType<any, ZodAnyDef> {
   // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
   _any: true = true;
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
   }
   static create = (params?: RawCreateParams): ZodAny => {
     return new ZodAny({
@@ -1119,12 +1008,9 @@ export interface ZodUnknownDef extends ZodTypeDef {
 export class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
   // required
   _unknown: true = true;
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<unknown> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
   }
 
   static create = (params?: RawCreateParams): ZodUnknown => {
@@ -1147,20 +1033,13 @@ export interface ZodNeverDef extends ZodTypeDef {
 }
 
 export class ZodNever extends ZodType<never, ZodNeverDef> {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<never> {
-    this.addIssue(
-      ctx,
-      {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.never,
-        received: parsedType,
-      },
-      { data }
-    );
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    addIssueToContext(ctx, {
+      code: ZodIssueCode.invalid_type,
+      expected: ZodParsedType.never,
+      received: ctx.parsedType,
+    });
     return INVALID;
   }
   static create = (params?: RawCreateParams): ZodNever => {
@@ -1183,25 +1062,17 @@ export interface ZodVoidDef extends ZodTypeDef {
 }
 
 export class ZodVoid extends ZodType<void, ZodVoidDef> {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<void> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.void,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.void,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
 
   static create = (params?: RawCreateParams): ZodVoid => {
@@ -1245,93 +1116,69 @@ export class ZodArray<
     ? [T["_input"], ...T["_input"][]]
     : T["_input"][]
 > {
-  _parse(
-    ctx: ParseContext,
-    _data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
-    // return parseArray(ctx, data, parsedType, this._def) as any;
-    const def = this._def;
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
 
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data: _data }
-      );
+    const def = this._def;
 
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
-    const data: any[] = _data;
-
-    let invalid = false;
     if (def.minLength !== null) {
-      if (data.length < def.minLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_small,
-            minimum: def.minLength.value,
-            type: "array",
-            inclusive: true,
-            message: def.minLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length < def.minLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minLength.value,
+          type: "array",
+          inclusive: true,
+          message: def.minLength.message,
+        });
+        status.dirty();
       }
     }
 
     if (def.maxLength !== null) {
-      if (data.length > def.maxLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_big,
-            maximum: def.maxLength.value,
-            type: "array",
-            inclusive: true,
-            message: def.maxLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length > def.maxLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxLength.value,
+          type: "array",
+          inclusive: true,
+          message: def.maxLength.message,
+        });
+        status.dirty();
       }
     }
 
-    const tasks: Promise<any>[] = [];
-    const result: any = new Array(data.length);
-    const type = def.type;
-    const handleParsed = (
-      index: number,
-      parsedItem: ParseReturnType<T>
-    ): void => {
-      if (isOk(parsedItem)) {
-        result[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
+    if (ctx.async) {
+      return Promise.all(
+        (ctx.data as any[]).map((item, i) => {
+          return def.type._parseAsync({
+            parent: ctx,
+            path: [...ctx.path, i],
+            data: item,
+          });
+        })
+      ).then((result) => {
+        return ParseStatus.mergeArray(status, result);
+      });
+    }
 
-    data.forEach((item, index) => {
-      handleParsed(
-        index,
-        type._parse(ctx.stepInto(index), item, getParsedType(item))
-      );
+    const result = (ctx.data as any[]).map((item, i) => {
+      return def.type._parseSync({
+        parent: ctx,
+        path: [...ctx.path, i],
+        data: item,
+      });
     });
 
-    if (ctx.async) {
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
-    } else {
-      return invalid ? INVALID : OK(result);
-    }
+    return ParseStatus.mergeArray(status, result);
   }
 
   get element() {
@@ -1357,7 +1204,7 @@ export class ZodArray<
   }
 
   nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone"> {
-    return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:"atleastone" });
+    return this.min(1, message) as any;
   }
 
   static create = <T extends ZodTypeAny>(
@@ -1423,48 +1270,7 @@ export namespace objectUtil {
       ...second, // second overwrites first
     };
   };
-
-  export const intersectShapes = <U extends ZodRawShape, T extends ZodRawShape>(
-    first: U,
-    second: T
-  ): T & U => {
-    const firstKeys = util.objectKeys(first);
-    const secondKeys = util.objectKeys(second);
-    const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
-
-    const sharedShape: any = {};
-    for (const k of sharedKeys) {
-      sharedShape[k] = ZodIntersection.create(first[k], second[k]);
-    }
-    return {
-      ...(first as object),
-      ...(second as object),
-      ...sharedShape,
-    };
-  };
 }
-export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-  Second extends AnyZodObject
->(
-  second: Second
-): ZodObject<
-  First["_shape"] & Second["_shape"],
-  First["_unknownKeys"],
-  First["_catchall"]
-> => {
-  const mergedShape = objectUtil.mergeShapes(
-    first._def.shape(),
-    second._def.shape()
-  );
-  const merged: any = new ZodObject({
-    // effects: [...(first._def.effects || []), ...(second._def.effects || [])],
-    unknownKeys: first._def.unknownKeys,
-    catchall: first._def.catchall,
-    shape: () => mergedShape,
-    typeName: ZodFirstPartyTypeKind.ZodObject,
-  }) as any;
-  return merged;
-};
 
 export type extendShape<A, B> = {
   [k in Exclude<keyof A, keyof B>]: A[k];
@@ -1477,13 +1283,6 @@ const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
   augmentation: Augmentation
 ): ZodObject<
   extendShape<ReturnType<Def["shape"]>, Augmentation>,
-  // {
-  //   [k in Exclude<
-  //     keyof ReturnType<Def["shape"]>,
-  //     keyof Augmentation
-  //   >]: ReturnType<Def["shape"]>[k];
-  // } &
-  //   { [k in keyof Augmentation]: Augmentation[k] },
   Def["unknownKeys"],
   Def["catchall"]
 > => {
@@ -1605,81 +1404,57 @@ export class ZodObject<
     return (this._cached = { shape, keys });
   }
 
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
     const { shape, keys: shapeKeys } = this._getCached();
-
-    let invalid = false;
-    const tasks: Promise<any>[] = [];
-    const resultObject: Record<string, any> = {};
-
-    const handleParsed = (
-      key: string,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedValue)) {
-        const value = parsedValue.value;
-        if (typeof value !== "undefined" || key in data) {
-          // key was valid but result was undefined: add it to the result object
-          // only if key was in the input data object - if it wasn't, then it's
-          // an optional key that should not be added
-          resultObject[key] = value;
-        }
-      } else if (isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-      }
-    };
-
+    const dataKeys = util.objectKeys(ctx.data);
+    const extraKeys = dataKeys.filter((k) => !(k in shape));
+
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+      alwaysSet?: boolean;
+    }[] = [];
     for (const key of shapeKeys) {
       const keyValidator = shape[key];
-      const value = data[key];
-      handleParsed(
-        key,
-        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
-      );
+      const value = ctx.data[key];
+      pairs.push({
+        key: { status: "valid", value: key },
+        value: keyValidator._parse({
+          parent: ctx,
+          data: value,
+          path: [...ctx.path, key],
+        }),
+        alwaysSet: key in ctx.data,
+      });
     }
 
     if (this._def.catchall instanceof ZodNever) {
       const unknownKeys = this._def.unknownKeys;
 
       if (unknownKeys === "passthrough") {
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
         for (const key of extraKeys) {
-          resultObject[key] = data[key];
+          pairs.push({
+            key: { status: "valid", value: key },
+            value: { status: "valid", value: ctx.data[key] },
+          });
         }
       } else if (unknownKeys === "strict") {
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
         if (extraKeys.length > 0) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.unrecognized_keys,
-              keys: extraKeys,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.unrecognized_keys,
+            keys: extraKeys,
+          });
+          status.dirty();
         }
       } else if (unknownKeys === "strip") {
       } else {
@@ -1688,22 +1463,38 @@ export class ZodObject<
     } else {
       // run catchall validation
       const catchall = this._def.catchall;
-      const dataKeys = util.objectKeys(data);
-      const extraKeys = dataKeys.filter((k) => !(k in shape));
+
       for (const key of extraKeys) {
-        const value = data[key];
-        handleParsed(
-          key,
-          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
-        );
+        const value = ctx.data[key];
+        pairs.push({
+          key: { status: "valid", value: key },
+          value: catchall._parse(
+            { parent: ctx, path: [...ctx.path, key], data: value } //, ctx.child(key), value, getParsedType(value)
+          ),
+          alwaysSet: key in ctx.data,
+        });
       }
     }
+
     if (ctx.async) {
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(resultObject as Output)
-      );
+      return Promise.resolve()
+        .then(async () => {
+          const syncPairs: any[] = [];
+          for (const pair of pairs) {
+            const key = await pair.key;
+            syncPairs.push({
+              key,
+              value: await pair.value,
+              alwaysSet: pair.alwaysSet,
+            });
+          }
+          return syncPairs;
+        })
+        .then((syncPairs) => {
+          return ParseStatus.mergeObjectSync(status, syncPairs);
+        });
     } else {
-      return invalid ? INVALID : OK(resultObject as Output);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
     }
   }
 
@@ -1711,10 +1502,26 @@ export class ZodObject<
     return this._def.shape();
   }
 
-  strict(): ZodObject<T, "strict", Catchall> {
+  strict(message?: errorUtil.ErrMessage): ZodObject<T, "strict", Catchall> {
+    errorUtil.errToObj;
     return new ZodObject({
       ...this._def,
       unknownKeys: "strict",
+      ...(message !== undefined
+        ? {
+            errorMap: (issue, ctx) => {
+              const defaultError =
+                this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
+              if (issue.code === "unrecognized_keys")
+                return {
+                  message: errorUtil.errToObj(message).message ?? defaultError,
+                };
+              return {
+                message: defaultError,
+              };
+            },
+          }
+        : {}),
     }) as any;
   }
 
@@ -1762,7 +1569,6 @@ export class ZodObject<
       merging._def.shape()
     );
     const merged: any = new ZodObject({
-      // effects: [], // wipe all refinements
       unknownKeys: merging._def.unknownKeys,
       catchall: merging._def.catchall,
       shape: () => mergedShape,
@@ -1839,7 +1645,6 @@ export class ZodObject<
   partial(mask?: any) {
     const newShape: any = {};
     if (mask) {
-      // const newShape: any = {};
       util.objectKeys(this.shape).map((key) => {
         if (util.objectKeys(mask).indexOf(key) === -1) {
           newShape[key] = this.shape[key];
@@ -1942,78 +1747,81 @@ export interface ZodUnionDef<
   typeName: ZodFirstPartyTypeKind.ZodUnion;
 }
 
-// export type toOpts<T> = T extends ZodUnionOptions ? T : never;
-// export type ZodUnionType<
-//   A extends ZodTypeAny,
-//   B extends ZodTypeAny
-// > = A extends ZodUnion<infer AOpts>
-//   ? B extends ZodUnion<infer BOpts>
-//     ? ZodUnion<toOpts<[...AOpts, ...BOpts]>>
-//     : ZodUnion<toOpts<[...AOpts, B]>>
-//   : B extends ZodUnion<infer BOpts>
-//   ? ZodUnion<toOpts<[A, ...BOpts]>>
-//   : ZodUnion<toOpts<[A, B]>>;
-
 export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
   T[number]["_output"],
   ZodUnionDef<T>,
   T[number]["_input"]
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[number]["_output"]> {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
     const options = this._def.options;
-    const noMatch = (allIssues: ZodIssue[][]) => {
-      const unionErrors = allIssues.map((issues) => new ZodError(issues));
-      const nonTypeErrors = unionErrors.filter((err) => {
-        return err.issues[0].code !== "invalid_type";
-      });
-      if (nonTypeErrors.length === 1) {
-        // TODO encapsulate
-        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
-      } else {
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_union,
-            unionErrors,
-          },
-          { data }
-        );
+
+    function handleResults(
+      results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]
+    ) {
+      // return first issue-free validation if it exists
+      for (const result of results) {
+        if (result.result.status === "valid") {
+          return result.result;
+        }
+      }
+
+      for (const result of results) {
+        if (result.result.status === "dirty") {
+          // add issues from dirty option
+
+          ctx.issues.push(...result.ctx.issues);
+          return result.result;
+        }
       }
+
+      // return invalid
+      const unionErrors = results.map(
+        (result) => new ZodError(result.ctx.issues)
+      );
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union,
+        unionErrors,
+      });
       return INVALID;
-    };
+    }
 
     if (ctx.async) {
-      const contexts = options.map(
-        () => new ParseContext({ ...ctx.def, issues: [] })
-      );
       return Promise.all(
-        options.map((option, index) =>
-          option._parse(contexts[index], data, parsedType)
-        )
-      ).then((parsedOptions) => {
-        for (const parsedOption of parsedOptions) {
-          if (isOk(parsedOption)) {
-            return parsedOption;
-          }
-        }
-        return noMatch(contexts.map((ctx) => ctx.issues));
-      });
+        options.map(async (option) => {
+          const childCtx: ParseContext = {
+            ...ctx,
+            issues: [],
+            parent: null,
+          };
+          return {
+            result: await option._parseAsync({
+              data: ctx.data,
+              path: ctx.path,
+              parent: childCtx,
+            }),
+            ctx: childCtx,
+          };
+        })
+      ).then(handleResults);
     } else {
-      const allIssues: ZodIssue[][] = [];
-      for (const option of options) {
-        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-        const parsedOption = option._parseSync(optionCtx, data, parsedType);
-        if (isInvalid(parsedOption)) {
-          allIssues.push(optionCtx.issues);
-        } else {
-          return parsedOption;
-        }
-      }
-      return noMatch(allIssues);
+      const optionResults = options.map((option) => {
+        const childCtx: ParseContext = {
+          ...ctx,
+          issues: [],
+          parent: null,
+        };
+        return {
+          result: option._parseSync({
+            data: ctx.data,
+            path: ctx.path,
+            parent: childCtx,
+          }),
+          ctx: childCtx,
+        };
+      });
+
+      return handleResults(optionResults);
     }
   }
 
@@ -2106,42 +1914,57 @@ export class ZodIntersection<
   ZodIntersectionDef<T, U>,
   T["_input"] & U["_input"]
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T["_output"] & U["_output"]> {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
     const handleParsed = (
-      parsedLeft: SyncParseReturnType<T>,
-      parsedRight: SyncParseReturnType<U>
+      parsedLeft: SyncParseReturnType,
+      parsedRight: SyncParseReturnType
     ): SyncParseReturnType<T & U> => {
-      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
         return INVALID;
       }
 
       const merged = mergeValues(parsedLeft.value, parsedRight.value);
+
       if (!merged.valid) {
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_intersection_types,
-          },
-          { data }
-        );
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.invalid_intersection_types,
+        });
         return INVALID;
       }
-      return OK(merged.data);
+
+      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
+        status.dirty();
+      }
+
+      return { status: status.value, value: merged.data as any };
     };
 
     if (ctx.async) {
       return Promise.all([
-        this._def.left._parse(ctx, data, parsedType),
-        this._def.right._parse(ctx, data, parsedType),
+        this._def.left._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
       ]).then(([left, right]: any) => handleParsed(left, right));
     } else {
       return handleParsed(
-        this._def.left._parseSync(ctx, data, parsedType),
-        this._def.right._parseSync(ctx, data, parsedType)
+        this._def.left._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        })
       );
     }
   }
@@ -2210,98 +2033,58 @@ export class ZodTuple<
   ZodTupleDef<T, Rest>,
   InputTypeOfTupleWithRest<T, Rest>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
-    const rest = this._def.rest;
-
-    if (!rest && data.length > this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_big,
-          maximum: this._def.items.length,
-          inclusive: true,
-          type: "array",
-        },
-        { data }
-      );
-      return INVALID;
-    }
+    if (ctx.data.length < this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_small,
+        minimum: this._def.items.length,
+        inclusive: true,
+        type: "array",
+      });
 
-    if (data.length < this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_small,
-          minimum: this._def.items.length,
-          inclusive: true,
-          type: "array",
-        },
-        { data }
-      );
       return INVALID;
     }
 
-    const tasks: Promise<unknown>[] = [];
-    const items = this._def.items as ZodType<any, any, any>[];
-
-    const parseResult: any[] = new Array(data.length);
-    let invalid = false;
-
-    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
-      if (isOk(parsedItem)) {
-        parseResult[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
-
-    items.forEach((item, index) => {
-      handleParsed(
-        index,
-        item._parse(
-          ctx.stepInto(index),
-          data[index],
-          getParsedType(data[index])
-        )
-      );
-    });
+    const rest = this._def.rest;
 
-    if (rest) {
-      const restData: any[] = data.slice(items.length);
-      restData.forEach((dataItem, _index) => {
-        const index = _index + items.length;
-        handleParsed(
-          index,
-          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
-        );
+    if (!rest && ctx.data.length > this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_big,
+        maximum: this._def.items.length,
+        inclusive: true,
+        type: "array",
       });
+      status.dirty();
     }
 
+    const items = (ctx.data as any[])
+      .map((item, itemIndex) => {
+        const schema = this._def.items[itemIndex] || this._def.rest;
+        if (!schema) return (null as any) as SyncParseReturnType<any>;
+        return schema._parse({
+          data: item,
+          path: [...ctx.path, itemIndex],
+          parent: ctx,
+        });
+      })
+      .filter((x) => !!x); // filter nulls
+
     if (ctx.async) {
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return Promise.all(items).then((results) => {
+        return ParseStatus.mergeArray(status, results);
+      });
     } else {
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);
     }
   }
 
@@ -2360,59 +2143,44 @@ export class ZodRecord<
   get valueSchema() {
     return this._def.valueType;
   }
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Record<any, any>> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
-    const tasks: Promise<unknown>[] = [];
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+    }[] = [];
+
     const keyType = this._def.keyType;
     const valueType = this._def.valueType;
-    const parseResult: Record<string, ParseReturnType<any>> = {};
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedKey) && isOk(parsedValue)) {
-        parseResult[parsedKey.value] = parsedValue.value;
-      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else {
-        invalid = true;
-      }
-    };
 
-    for (const key in data) {
-      handleParsed(
-        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
-      );
+    for (const key in ctx.data) {
+      pairs.push({
+        key: keyType._parse({
+          data: key,
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+        value: valueType._parse({
+          data: ctx.data[key],
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+      });
     }
 
     if (ctx.async) {
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return ParseStatus.mergeObjectAsync(status, pairs);
     } else {
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
     }
   }
 
@@ -2472,69 +2240,69 @@ export class ZodMap<
   ZodMapDef<Key, Value>,
   Map<Key["_input"], Value["_input"]>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Map<any, any>> {
-    if (parsedType !== ZodParsedType.map) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.map,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.map) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.map,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
     const keyType = this._def.keyType;
     const valueType = this._def.valueType;
-    const dataMap: Map<unknown, unknown> = data;
-    const parseResult = new Map();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        parseResult.set(parsedKey.value, parsedValue.value);
-      }
-    };
 
-    [...dataMap.entries()].forEach(([key, value], index) => {
-      const entryCtx = ctx.stepInto(index);
-      const parsedKey = keyType._parse(
-        entryCtx.stepInto("key"),
-        key,
-        getParsedType(key)
-      );
-      const parsedValue = valueType._parse(
-        entryCtx.stepInto("value"),
-        value,
-        getParsedType(value)
-      );
-      handleParsed(parsedKey, parsedValue);
-    });
+    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(
+      ([key, value], index) => {
+        return {
+          key: keyType._parse({
+            data: key,
+            path: [...ctx.path, index, "key"],
+            parent: ctx,
+          }),
+          value: valueType._parse({
+            data: value,
+            path: [...ctx.path, index, "value"],
+            parent: ctx,
+          }),
+        };
+      }
+    );
 
     if (ctx.async) {
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      const finalMap = new Map();
+      return Promise.resolve().then(async () => {
+        for (const pair of pairs) {
+          const key = await pair.key;
+          const value = await pair.value;
+          if (key.status === "aborted" || value.status === "aborted") {
+            return INVALID;
+          }
+          if (key.status === "dirty" || value.status === "dirty") {
+            status.dirty();
+          }
+
+          finalMap.set(key.value, value.value);
+        }
+        return { status: status.value, value: finalMap };
+      });
     } else {
-      return invalid ? INVALID : OK(parseResult);
+      const finalMap = new Map();
+      for (const pair of pairs) {
+        const key = pair.key as SyncParseReturnType;
+        const value = pair.value as SyncParseReturnType;
+        if (key.status === "aborted" || value.status === "aborted") {
+          return INVALID;
+        }
+        if (key.status === "dirty" || value.status === "dirty") {
+          status.dirty();
+        }
+
+        finalMap.set(key.value, value.value);
+      }
+      return { status: status.value, value: finalMap };
     }
   }
   static create = <
@@ -2572,49 +2340,37 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
   ZodSetDef<Value>,
   Set<Value["_input"]>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Set<any>> {
-    if (parsedType !== ZodParsedType.set) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.set,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.set) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.set,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
-    const dataSet: Set<unknown> = data;
     const valueType = this._def.valueType;
-    const parsedSet = new Set();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-
-    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
-      if (isOk(parsedItem)) {
-        parsedSet.add(parsedItem.value);
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
+
+    function finalizeSet(elements: SyncParseReturnType<any>[]) {
+      const parsedSet = new Set();
+      for (const element of elements) {
+        if (element.status === "aborted") return INVALID;
+        if (element.status === "dirty") status.dirty();
+        parsedSet.add(element.value);
       }
-    };
+      return { status: status.value, value: parsedSet };
+    }
 
-    [...dataSet.values()].forEach((item, i) =>
-      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>
+      valueType._parse({ data: item, path: [...ctx.path, i], parent: ctx })
     );
 
     if (ctx.async) {
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
+      return Promise.all(elements).then((elements) => finalizeSet(elements));
     } else {
-      return invalid ? INVALID : OK(parsedSet);
+      return finalizeSet(elements as SyncParseReturnType[]);
     }
   }
 
@@ -2668,30 +2424,27 @@ export class ZodFunction<
   ZodFunctionDef<Args, Returns>,
   InnerTypeOfFunction<Args, Returns>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.function) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.function,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.function) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.function,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
     function makeArgsIssue(args: any, error: ZodError): ZodIssue {
       return makeIssue({
         data: args,
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
         issueData: {
           code: ZodIssueCode.invalid_arguments,
           argumentsError: error,
@@ -2702,8 +2455,13 @@ export class ZodFunction<
     function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
       return makeIssue({
         data: returns,
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
         issueData: {
           code: ZodIssueCode.invalid_return_type,
           returnTypeError: error,
@@ -2711,8 +2469,8 @@ export class ZodFunction<
       });
     }
 
-    const params = { errorMap: ctx.errorMap };
-    const fn = data;
+    const params = { errorMap: ctx.contextualErrorMap };
+    const fn = ctx.data;
 
     if (this._def.returns instanceof ZodPromise) {
       return OK(async (...args: any[]) => {
@@ -2724,7 +2482,8 @@ export class ZodFunction<
             throw error;
           });
         const result = await fn(...(parsedArgs as any));
-        const parsedReturns = await this._def.returns
+        const parsedReturns = await (this._def
+          .returns as ZodPromise<ZodTypeAny>)._def.type
           .parseAsync(result, params)
           .catch((e) => {
             error.addIssue(makeReturnsIssue(result, e));
@@ -2744,7 +2503,7 @@ export class ZodFunction<
           throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
         }
         return parsedReturns.data;
-      });
+      }) as any;
     }
   }
 
@@ -2829,13 +2588,10 @@ export class ZodLazy<T extends ZodTypeAny> extends ZodType<
     return this._def.getter();
   }
 
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<output<T>> {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
     const lazySchema = this._def.getter();
-    return lazySchema._parse(ctx, data, parsedType);
+    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
   }
 
   static create = <T extends ZodTypeAny>(
@@ -2863,24 +2619,17 @@ export interface ZodLiteralDef<T extends any = any> extends ZodTypeDef {
 }
 
 export class ZodLiteral<T extends any> extends ZodType<T, ZodLiteralDef<T>> {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T> {
-    if (data !== this._def.value) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: this._def.value as any,
-          received: data,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.data !== this._def.value) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: this._def.value as any,
+        received: ctx.data,
+      });
       return INVALID;
     }
-    return OK(data);
+    return { status: status.value, value: ctx.data };
   }
 
   get value() {
@@ -2940,23 +2689,16 @@ export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
   T[number],
   ZodEnumDef<T>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[number]> {
-    if (this._def.values.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: this._def.values,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (this._def.values.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: this._def.values,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
 
   get options() {
@@ -3009,25 +2751,19 @@ export class ZodNativeEnum<T extends EnumLike> extends ZodType<
   T[keyof T],
   ZodNativeEnumDef<T>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[keyof T]> {
+  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {
+    const { ctx } = this._processInputParams(input);
     const nativeEnumValues = util.getValidEnumValues(this._def.values);
-    if (nativeEnumValues.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: util.objectValues(nativeEnumValues),
-        },
-        { data }
-      );
+    if (nativeEnumValues.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: util.objectValues(nativeEnumValues),
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
+
   static create = <T extends EnumLike>(
     values: T,
     params?: RawCreateParams
@@ -3058,33 +2794,27 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
   ZodPromiseDef<T>,
   Promise<T["_input"]>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Promise<T["_output"]>> {
-    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.promise,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.promise,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
     const promisified =
-      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+      ctx.parsedType === ZodParsedType.promise
+        ? ctx.data
+        : Promise.resolve(ctx.data);
 
     return OK(
       promisified.then((data: any) => {
         return this._def.type.parseAsync(data, {
-          path: pathToArray(ctx.path),
-          errorMap: ctx.errorMap,
+          path: ctx.path,
+          errorMap: ctx.contextualErrorMap,
         });
       })
     );
@@ -3146,110 +2876,121 @@ export class ZodEffects<
     return this._def.schema;
   }
 
-  _parse(
-    ctx: ParseContext,
-    initialData: any,
-    initialParsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    const isSync = ctx.async === false;
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+
     const effect = this._def.effect || null;
-    const data = initialData;
-    const parsedType: ZodParsedType = initialParsedType;
 
     if (effect.type === "preprocess") {
-      const processed = effect.transform(initialData);
+      const processed = effect.transform(ctx.data);
 
       if (ctx.async) {
-        return Promise.resolve(processed).then((val) =>
-          this._def.schema._parseAsync(ctx, val, getParsedType(val))
-        );
+        return Promise.resolve(processed).then((processed) => {
+          return this._def.schema._parseAsync({
+            data: processed,
+            path: ctx.path,
+            parent: ctx,
+          });
+        });
       } else {
-        const result = this._def.schema._parseSync(
-          ctx,
-          processed,
-          getParsedType(processed)
-        );
-        if (result instanceof Promise)
-          throw new Error(
-            "Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead."
-          );
-        return result;
+        return this._def.schema._parseSync({
+          data: processed,
+          path: ctx.path,
+          parent: ctx,
+        });
       }
     }
 
     if (effect.type === "refinement") {
-      let invalid = false;
+      const checkCtx: RefinementCtx = {
+        addIssue: (arg: IssueData) => {
+          addIssueToContext(ctx, arg);
+          if (FATAL_CODES.includes(arg.code)) {
+            status.abort();
+          } else {
+            status.dirty();
+          }
+        },
+        get path() {
+          return ctx.path;
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
 
       const executeRefinement = (
-        acc: any,
-        effect: RefinementEffect<any>
+        acc: unknown
+        // effect: RefinementEffect<any>
       ): any => {
         const result = effect.refinement(acc, checkCtx);
+        if (ctx.async) {
+          return Promise.resolve(result);
+        }
         if (result instanceof Promise) {
-          if (isSync) {
-            throw new Error(
-              "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
-            );
-          }
-          return result.then(() => acc);
+          throw new Error(
+            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
+          );
         }
         return acc;
       };
 
-      const _addIssue = (arg: IssueData) => {
-        // don't abort early on refinement issues
-        invalid = true;
-        this.addIssue(ctx, arg, { data });
-      };
-      const checkCtx: RefinementCtx = {
-        addIssue: _addIssue,
-        get path() {
-          return pathToArray(ctx.path);
-        },
-      };
-
-      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+      if (ctx.async === false) {
+        const inner = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        if (inner.status === "aborted") return INVALID;
+        if (inner.status === "dirty") status.dirty();
 
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = executeRefinement(base.value, effect);
-        return invalid ? INVALID : OK(result);
+        // return value is ignored
+        executeRefinement(inner.value);
+        return { status: status.value, value: inner.value };
       } else {
         return this._def.schema
-          ._parseAsync(ctx, data, parsedType)
-          .then((result) => {
-            if (isInvalid(result)) return INVALID;
-            return executeRefinement(result.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
+          .then((inner) => {
+            if (inner.status === "aborted") return INVALID;
+            if (inner.status === "dirty") status.dirty();
+
+            return executeRefinement(inner.value).then(() => {
+              return { status: status.value, value: inner.value };
+            });
+          });
       }
     }
 
     if (effect.type === "transform") {
-      const invalid = false;
-      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
-        const transformed = effect.transform(acc);
-        if (transformed instanceof Promise && isSync) {
+      if (ctx.async === false) {
+        const base = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        // if (base.status === "aborted") return INVALID;
+        // if (base.status === "dirty") {
+        //   return { status: "dirty", value: base.value };
+        // }
+        if (!isValid(base)) return base;
+
+        const result = effect.transform(base.value);
+        if (result instanceof Promise) {
           throw new Error(
             `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
           );
         }
-        return transformed;
-      };
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = applyTransform(base.value, effect);
-        return invalid ? INVALID : OK(result);
+        return OK(result);
       } else {
         return this._def.schema
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
           .then((base) => {
-            if (isInvalid(base)) return INVALID;
-            return applyTransform(base.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+            if (!isValid(base)) return base;
+            // if (base.status === "aborted") return INVALID;
+            // if (base.status === "dirty") {
+            //   return { status: "dirty", value: base.value };
+            // }
+            return Promise.resolve(effect.transform(base.value)).then(OK);
+          });
       }
     }
 
@@ -3305,15 +3046,16 @@ export class ZodOptional<T extends ZodTypeAny> extends ZodType<
   ZodOptionalDef<T>,
   T["_input"] | undefined
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T["_output"] | undefined> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.undefined) {
       return OK(undefined);
     }
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
   }
 
   unwrap() {
@@ -3352,15 +3094,16 @@ export class ZodNullable<T extends ZodTypeAny> extends ZodType<
   ZodNullableDef<T>,
   T["_input"] | null
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T["_output"] | null> {
-    if (parsedType === ZodParsedType.null) {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.null) {
       return OK(null);
     }
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
   }
 
   unwrap() {
@@ -3398,15 +3141,17 @@ export class ZodDefault<T extends ZodTypeAny> extends ZodType<
   ZodDefaultDef<T>,
   T["_input"] | undefined
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<util.noUndefined<T["_output"]>> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
       data = this._def.defaultValue();
     }
-    return this._def.innerType._parse(ctx, data, getParsedType(data));
+    return this._def.innerType._parse({
+      data,
+      path: ctx.path,
+      parent: ctx,
+    });
   }
 
   removeDefault() {
@@ -3482,19 +3227,19 @@ export type ZodFirstPartySchemaTypes =
   | ZodUnknown
   | ZodNever
   | ZodVoid
-  | ZodArray<any>
-  | ZodObject<any>
+  | ZodArray<any, any>
+  | ZodObject<any, any, any, any, any>
   | ZodUnion<any>
   | ZodIntersection<any, any>
-  | ZodTuple
-  | ZodRecord
-  | ZodMap
-  | ZodSet
+  | ZodTuple<any, any>
+  | ZodRecord<any, any>
+  | ZodMap<any>
+  | ZodSet<any>
   | ZodFunction<any, any>
   | ZodLazy<any>
   | ZodLiteral<any>
   | ZodEnum<any>
-  | ZodEffects<any>
+  | ZodEffects<any, any, any>
   | ZodNativeEnum<any>
   | ZodOptional<any>
   | ZodNullable<any>
diff --git a/package.json b/package.json
index b7b86daff..000500c88 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.9.7",
+  "version": "3.10.3",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./lib/index.d.ts",
@@ -86,8 +86,8 @@
     "rollup-plugin-uglify": "^6.0.4",
     "ts-jest": "^26.4.4",
     "ts-node": "^9.1.0",
-    "tslib": "^2.1.0",
-    "typescript": "4.3"
+    "tslib": "^2.3.1",
+    "typescript": "^4.4.4"
   },
   "husky": {
     "hooks": {
diff --git a/src/ZodError.ts b/src/ZodError.ts
index 186ad7d04..bea079456 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -17,6 +17,15 @@ export const ZodIssueCode = util.arrayToEnum([
   "not_multiple_of",
 ]);
 
+export const FATAL_CODES = [
+  ZodIssueCode.invalid_type,
+  ZodIssueCode.invalid_date,
+  ZodIssueCode.invalid_intersection_types,
+  ZodIssueCode.invalid_return_type,
+  ZodIssueCode.invalid_arguments,
+  ZodIssueCode.invalid_enum_value,
+];
+
 export type ZodIssueCode = keyof typeof ZodIssueCode;
 
 export type ZodIssueBase = {
diff --git a/src/__tests__/default.test.ts b/src/__tests__/default.test.ts
index 8716e888f..c1c6d7389 100644
--- a/src/__tests__/default.test.ts
+++ b/src/__tests__/default.test.ts
@@ -101,3 +101,7 @@ test("chained defaults", () => {
   const result = stringWithDefault.parse(undefined);
   expect(result).toEqual("outer");
 });
+
+test("factory", () => {
+  z.ZodDefault.create(z.string()).parse(undefined);
+});
diff --git a/src/__tests__/error.test.ts b/src/__tests__/error.test.ts
index 7d33787f6..cf5a0ba1c 100644
--- a/src/__tests__/error.test.ts
+++ b/src/__tests__/error.test.ts
@@ -230,6 +230,25 @@ test("custom path", () => {
   }
 });
 
+test("custom path", () => {
+  const schema = z
+    .object({
+      password: z.string().min(6),
+      confirm: z.string().min(6),
+    })
+    .refine((val) => val.confirm === val.password);
+
+  const result = schema.safeParse({
+    password: "qwer",
+    confirm: "asdf",
+  });
+
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues.length).toEqual(3);
+  }
+});
+
 const schema = z.object({
   inner: z.object({
     name: z
@@ -248,7 +267,7 @@ test("no abort early on refinements", () => {
   const result1 = schema.safeParse(invalidItem);
   expect(result1.success).toEqual(false);
   if (!result1.success) {
-    expect(result1.error.issues.length).toEqual(1);
+    expect(result1.error.issues.length).toEqual(2);
   }
 });
 test("formatting", () => {
@@ -367,6 +386,16 @@ test("invalid and required and errorMap", () => {
   }).toThrow();
 });
 
+test("strict error message", () => {
+  const errorMsg = "Invalid object";
+  const obj = z.object({ x: z.string() }).strict(errorMsg);
+  const result = obj.safeParse({ x: "a", y: "b" });
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual(errorMsg);
+  }
+});
+
 // test("dont short circuit on continuable errors", () => {
 //   const user = z
 //     .object({
diff --git a/src/__tests__/function.test.ts b/src/__tests__/function.test.ts
index ab79e2f0b..aaf8fb68f 100644
--- a/src/__tests__/function.test.ts
+++ b/src/__tests__/function.test.ts
@@ -204,3 +204,10 @@ test("allow extra parameters", () => {
   ].filter(maxLength5);
   expect(filteredList.length).toEqual(2);
 });
+
+test("params and returnType getters", () => {
+  const func = z.function().args(z.string()).returns(z.string());
+
+  func.parameters().items[0].parse("asdf");
+  func.returnType().parse("asdf");
+});
diff --git a/src/__tests__/intersection.test.ts b/src/__tests__/intersection.test.ts
index 5a41908a1..de9255d80 100644
--- a/src/__tests__/intersection.test.ts
+++ b/src/__tests__/intersection.test.ts
@@ -43,7 +43,7 @@ test("deep intersection", () => {
   expect(cat.properties).toEqual({ is_animal: true, jumped: true });
 });
 
-test("deep intersection of arrays", () => {
+test("deep intersection of arrays", async () => {
   const Author = z.object({
     posts: z.array(
       z.object({
@@ -67,4 +67,54 @@ test("deep intersection of arrays", () => {
   ];
   const cat = Registry.parse({ posts });
   expect(cat.posts).toEqual(posts);
+  const asyncCat = await Registry.parseAsync({ posts });
+  expect(asyncCat.posts).toEqual(posts);
+});
+
+test("invalid intersection types", async () => {
+  const numberIntersection = z.intersection(
+    z.number(),
+    z.number().transform((x) => x + 1)
+  );
+
+  const syncResult = numberIntersection.safeParse(1234);
+  expect(syncResult.success).toEqual(false);
+  if (!syncResult.success) {
+    expect(syncResult.error.issues[0].code).toEqual(
+      z.ZodIssueCode.invalid_intersection_types
+    );
+  }
+
+  const asyncResult = await numberIntersection.spa(1234);
+  expect(asyncResult.success).toEqual(false);
+  if (!asyncResult.success) {
+    expect(asyncResult.error.issues[0].code).toEqual(
+      z.ZodIssueCode.invalid_intersection_types
+    );
+  }
+});
+
+test("invalid array merge", async () => {
+  const stringArrInt = z.intersection(
+    z.string().array(),
+    z
+      .string()
+      .array()
+      .transform((val) => [...val, "asdf"])
+  );
+  const syncResult = stringArrInt.safeParse(["asdf", "qwer"]);
+  expect(syncResult.success).toEqual(false);
+  if (!syncResult.success) {
+    expect(syncResult.error.issues[0].code).toEqual(
+      z.ZodIssueCode.invalid_intersection_types
+    );
+  }
+
+  const asyncResult = await stringArrInt.spa(["asdf", "qwer"]);
+  expect(asyncResult.success).toEqual(false);
+  if (!asyncResult.success) {
+    expect(asyncResult.error.issues[0].code).toEqual(
+      z.ZodIssueCode.invalid_intersection_types
+    );
+  }
 });
diff --git a/src/__tests__/map.test.ts b/src/__tests__/map.test.ts
index 04697c711..5cc1dd7b8 100644
--- a/src/__tests__/map.test.ts
+++ b/src/__tests__/map.test.ts
@@ -13,7 +13,7 @@ test("type inference", () => {
   f1;
 });
 
-test("doesn’t throw when a valid value is given", () => {
+test("valid parse", () => {
   const result = stringMap.safeParse(
     new Map([
       ["first", "foo"],
@@ -21,6 +21,28 @@ test("doesn’t throw when a valid value is given", () => {
     ])
   );
   expect(result.success).toEqual(true);
+  if (result.success) {
+    expect(result.data.has("first")).toEqual(true);
+    expect(result.data.has("second")).toEqual(true);
+    expect(result.data.get("first")).toEqual("foo");
+    expect(result.data.get("second")).toEqual("bar");
+  }
+});
+
+test("valid parse async", async () => {
+  const result = await stringMap.spa(
+    new Map([
+      ["first", "foo"],
+      ["second", "bar"],
+    ])
+  );
+  expect(result.success).toEqual(true);
+  if (result.success) {
+    expect(result.data.has("first")).toEqual(true);
+    expect(result.data.has("second")).toEqual(true);
+    expect(result.data.get("first")).toEqual("foo");
+    expect(result.data.get("second")).toEqual("bar");
+  }
 });
 
 test("throws when a Set is given", () => {
@@ -64,3 +86,26 @@ test("throws when the given map has multiple invalid entries", () => {
     expect(result.error.issues[1].path).toEqual([1, "value"]);
   }
 });
+
+test("dirty", async () => {
+  const map = z.map(
+    z.string().refine((val) => val === val.toUpperCase(), {
+      message: "Keys must be uppercase",
+    }),
+    z.string()
+  );
+  const result = await map.spa(
+    new Map([
+      ["first", "foo"],
+      ["second", "bar"],
+    ])
+  );
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues.length).toEqual(2);
+    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
+    expect(result.error.issues[0].message).toEqual("Keys must be uppercase");
+    expect(result.error.issues[1].code).toEqual(z.ZodIssueCode.custom);
+    expect(result.error.issues[1].message).toEqual("Keys must be uppercase");
+  }
+});
diff --git a/src/__tests__/number.test.ts b/src/__tests__/number.test.ts
index f592f5d4f..049900bd4 100644
--- a/src/__tests__/number.test.ts
+++ b/src/__tests__/number.test.ts
@@ -34,3 +34,14 @@ test("failing validations", () => {
 test("parse NaN", () => {
   expect(() => z.number().parse(NaN)).toThrow();
 });
+
+test("min max getters", () => {
+  expect(z.number().int().isInt).toEqual(true);
+  expect(z.number().isInt).toEqual(false);
+
+  expect(z.number().min(5).minValue).toEqual(5);
+  expect(z.number().min(5).min(10).minValue).toEqual(10);
+
+  expect(z.number().max(5).maxValue).toEqual(5);
+  expect(z.number().max(5).max(1).maxValue).toEqual(1);
+});
diff --git a/src/__tests__/object.test.ts b/src/__tests__/object.test.ts
index 8ca6e6f79..aa84e689a 100644
--- a/src/__tests__/object.test.ts
+++ b/src/__tests__/object.test.ts
@@ -234,3 +234,37 @@ test("inferred type for unknown/any keys", () => {
   > = true;
   _f1;
 });
+
+test("setKey", () => {
+  const base = z.object({ name: z.string() });
+  const withNewKey = base.setKey("age", z.number());
+
+  type withNewKey = z.infer<typeof withNewKey>;
+  const _t1: util.AssertEqual<withNewKey, { name: string; age: number }> = true;
+  _t1;
+  withNewKey.parse({ name: "asdf", age: 1234 });
+});
+
+test("strictcreate", async () => {
+  const strictObj = z.strictObject({
+    name: z.string(),
+  });
+
+  const syncResult = strictObj.safeParse({ name: "asdf", unexpected: 13 });
+  expect(syncResult.success).toEqual(false);
+
+  const asyncResult = await strictObj.spa({ name: "asdf", unexpected: 13 });
+  expect(asyncResult.success).toEqual(false);
+});
+
+test("object with refine", async () => {
+  const schema = z
+    .object({
+      a: z.string().default("foo"),
+      b: z.number(),
+    })
+    .refine(() => true);
+  expect(schema.parse({ b: 5 })).toEqual({ b: 5, a: "foo" });
+  const result = await schema.parseAsync({ b: 5 });
+  expect(result).toEqual({ b: 5, a: "foo" });
+});
diff --git a/src/__tests__/parseUtil.test.ts b/src/__tests__/parseUtil.test.ts
index 84db6f966..f8a2f0987 100644
--- a/src/__tests__/parseUtil.test.ts
+++ b/src/__tests__/parseUtil.test.ts
@@ -1,11 +1,28 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-import { INVALID, isInvalid } from "../helpers/parseUtil";
+import {
+  isAborted,
+  isDirty,
+  isValid,
+  SyncParseReturnType,
+} from "../helpers/parseUtil";
 
 test("parseUtil isInvalid should use structural typing", () => {
   // Test for issue #556: https://github.com/colinhacks/zod/issues/556
-  const newInstance: INVALID = Object.freeze({ valid: false });
-  expect(isInvalid(newInstance)).toBe(true);
-  expect(isInvalid(INVALID)).toBe(true);
+  const aborted: SyncParseReturnType = { status: "aborted" };
+  const dirty: SyncParseReturnType = { status: "dirty", value: "whatever" };
+  const valid: SyncParseReturnType = { status: "valid", value: "whatever" };
+
+  expect(isAborted(aborted)).toBe(true);
+  expect(isAborted(dirty)).toBe(false);
+  expect(isAborted(valid)).toBe(false);
+
+  expect(isDirty(aborted)).toBe(false);
+  expect(isDirty(dirty)).toBe(true);
+  expect(isDirty(valid)).toBe(false);
+
+  expect(isValid(aborted)).toBe(false);
+  expect(isValid(dirty)).toBe(false);
+  expect(isValid(valid)).toBe(true);
 });
diff --git a/src/__tests__/partials.test.ts b/src/__tests__/partials.test.ts
index 62ad5f0ad..5a57f4f36 100644
--- a/src/__tests__/partials.test.ts
+++ b/src/__tests__/partials.test.ts
@@ -145,3 +145,22 @@ test("required", () => {
   expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);
   expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);
 });
+
+test("with mask", async () => {
+  const object = z.object({
+    name: z.string(),
+    age: z.number().optional(),
+    field: z.string().optional().default("asdf"),
+  });
+
+  const masked = object
+    .partial({
+      name: true,
+      age: true,
+      field: true,
+    })
+    .strict();
+
+  masked.parse({});
+  await masked.parseAsync({});
+});
diff --git a/src/__tests__/primitive.test.ts b/src/__tests__/primitive.test.ts
index 465c0019c..68cc209da 100644
--- a/src/__tests__/primitive.test.ts
+++ b/src/__tests__/primitive.test.ts
@@ -411,3 +411,13 @@ test("primitive inference", () => {
     dateSchemaNullableTest,
   ];
 });
+
+test("get literal value", () => {
+  expect(literalStringSchema.value).toEqual("asdf");
+});
+
+test("optional convenience methd", () => {
+  z.ostring().parse(undefined);
+  z.onumber().parse(undefined);
+  z.oboolean().parse(undefined);
+});
diff --git a/src/__tests__/record.test.ts b/src/__tests__/record.test.ts
index d0490f5aa..9d964d73f 100644
--- a/src/__tests__/record.test.ts
+++ b/src/__tests__/record.test.ts
@@ -111,3 +111,11 @@ test("key schema", () => {
 // test("record element", () => {
 //   expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);
 // });
+
+test("key and value getters", () => {
+  const rec = z.record(z.string(), z.number());
+
+  rec.keySchema.parse("asdf");
+  rec.valueSchema.parse(1234);
+  rec.element.parse(1234);
+});
diff --git a/src/__tests__/recursive.test.ts b/src/__tests__/recursive.test.ts
index d8de21bb3..0e1f9e4dd 100644
--- a/src/__tests__/recursive.test.ts
+++ b/src/__tests__/recursive.test.ts
@@ -46,6 +46,9 @@ test("recursion with z.lazy", () => {
   Category.parse(testCategory);
 });
 
+test("schema getter", () => {
+  z.lazy(() => z.string()).schema.parse("asdf");
+});
 // interface A {
 //   val: number;
 //   b: B;
diff --git a/src/__tests__/refine.test.ts b/src/__tests__/refine.test.ts
index 466b1f9a3..512f4f85d 100644
--- a/src/__tests__/refine.test.ts
+++ b/src/__tests__/refine.test.ts
@@ -49,16 +49,16 @@ test("refinement 2", () => {
 });
 
 test("custom path", async () => {
-  try {
-    await z
-      .object({
-        password: z.string(),
-        confirm: z.string(),
-      })
-      .refine((data) => data.confirm === data.password, { path: ["confirm"] })
-      .parseAsync({ password: "asdf", confirm: "qewr" });
-  } catch (err) {
-    expect((err as z.ZodError).issues[0].path).toEqual(["confirm"]);
+  const result = await z
+    .object({
+      password: z.string(),
+      confirm: z.string(),
+    })
+    .refine((data) => data.confirm === data.password, { path: ["confirm"] })
+    .spa({ password: "asdf", confirm: "qewr" });
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].path).toEqual(["confirm"]);
   }
 });
 
@@ -81,8 +81,6 @@ test("use path in refinement context", async () => {
 
   const t1 = await noNested.spa("asdf");
   const t2 = await data.spa({ foo: "asdf" });
-  // console.log(t1);
-  // console.log(t2);
 
   expect(t1.success).toBe(true);
   expect(t2.success).toBe(false);
@@ -120,3 +118,39 @@ test("superRefine", () => {
 
   Strings.parse(["asfd", "qwer"]);
 });
+
+test("get inner type", () => {
+  z.string()
+    .refine(() => true)
+    .innerType()
+    .parse("asdf");
+});
+
+test("chained refinements", () => {
+  const objectSchema = z
+    .object({
+      length: z.number(),
+      size: z.number(),
+    })
+    .refine(({ length }) => length > 5, {
+      path: ["length"],
+      message: "length greater than 5",
+    })
+    .refine(({ size }) => size > 7, {
+      path: ["size"],
+      message: "size greater than 7",
+    });
+  const r1 = objectSchema.safeParse({
+    length: 4,
+    size: 9,
+  });
+  expect(r1.success).toEqual(false);
+  if (!r1.success) expect(r1.error.issues.length).toEqual(1);
+
+  const r2 = objectSchema.safeParse({
+    length: 4,
+    size: 3,
+  });
+  expect(r2.success).toEqual(false);
+  if (!r2.success) expect(r2.error.issues.length).toEqual(2);
+});
diff --git a/src/__tests__/set.test.ts b/src/__tests__/set.test.ts
index 18bad9435..51694d55d 100644
--- a/src/__tests__/set.test.ts
+++ b/src/__tests__/set.test.ts
@@ -13,9 +13,32 @@ test("type inference", () => {
   f1;
 });
 
-test("doesn’t throw when a valid value is given", () => {
+test("valid parse", () => {
   const result = stringSet.safeParse(new Set(["first", "second"]));
   expect(result.success).toEqual(true);
+  if (result.success) {
+    expect(result.data.has("first")).toEqual(true);
+    expect(result.data.has("second")).toEqual(true);
+    expect(result.data.has("third")).toEqual(false);
+  }
+});
+
+test("valid parse async", async () => {
+  const result = await stringSet.spa(new Set(["first", "second"]));
+  expect(result.success).toEqual(true);
+  if (result.success) {
+    expect(result.data.has("first")).toEqual(true);
+    expect(result.data.has("second")).toEqual(true);
+    expect(result.data.has("third")).toEqual(false);
+  }
+
+  const asyncResult = await stringSet.safeParse(new Set(["first", "second"]));
+  expect(asyncResult.success).toEqual(true);
+  if (asyncResult.success) {
+    expect(asyncResult.data.has("first")).toEqual(true);
+    expect(asyncResult.data.has("second")).toEqual(true);
+    expect(asyncResult.data.has("third")).toEqual(false);
+  }
 });
 
 test("doesn’t throw when an empty set is given", () => {
diff --git a/src/__tests__/string.test.ts b/src/__tests__/string.test.ts
index a8db59c6a..45a2443b9 100644
--- a/src/__tests__/string.test.ts
+++ b/src/__tests__/string.test.ts
@@ -56,9 +56,7 @@ test("url validations", () => {
     expect(() => url.parse("asdf")).toThrow();
     expect(() => url.parse("https:/")).toThrow();
     expect(() => url.parse("asdfj@lkjsdf.com")).toThrow();
-  } catch (err) {
-    // console.log(JSON.stringify(err, null, 2));
-  }
+  } catch (err) {}
 });
 
 test("url error overrides", () => {
@@ -141,8 +139,31 @@ test("regex lastIndex reset", () => {
 });
 
 test("checks getters", () => {
-  expect(z.string().uuid().isUUID).toEqual(true);
-  expect(z.string().uuid().isCUID).toEqual(false);
-  expect(z.string().cuid().isUUID).toEqual(false);
+  expect(z.string().email().isEmail).toEqual(true);
+  expect(z.string().email().isURL).toEqual(false);
+  expect(z.string().email().isCUID).toEqual(false);
+  expect(z.string().email().isUUID).toEqual(false);
+
+  expect(z.string().url().isEmail).toEqual(false);
+  expect(z.string().url().isURL).toEqual(true);
+  expect(z.string().url().isCUID).toEqual(false);
+  expect(z.string().url().isUUID).toEqual(false);
+
+  expect(z.string().cuid().isEmail).toEqual(false);
+  expect(z.string().cuid().isURL).toEqual(false);
   expect(z.string().cuid().isCUID).toEqual(true);
+  expect(z.string().cuid().isUUID).toEqual(false);
+
+  expect(z.string().uuid().isEmail).toEqual(false);
+  expect(z.string().uuid().isURL).toEqual(false);
+  expect(z.string().uuid().isCUID).toEqual(false);
+  expect(z.string().uuid().isUUID).toEqual(true);
+});
+
+test("min max getters", () => {
+  expect(z.string().min(5).minLength).toEqual(5);
+  expect(z.string().min(5).min(10).minLength).toEqual(10);
+
+  expect(z.string().max(5).maxLength).toEqual(5);
+  expect(z.string().max(5).max(1).maxLength).toEqual(1);
 });
diff --git a/src/__tests__/transformer.test.ts b/src/__tests__/transformer.test.ts
index a1eb606d1..55e34f1d1 100644
--- a/src/__tests__/transformer.test.ts
+++ b/src/__tests__/transformer.test.ts
@@ -129,3 +129,39 @@ test("async preprocess", async () => {
   const value = await schema.parseAsync("asdf");
   expect(value).toEqual(["asdf"]);
 });
+
+test("short circuit on dirty", () => {
+  const schema = z
+    .string()
+    .refine(() => false)
+    .transform((val) => val.toUpperCase());
+  const result = schema.safeParse("asdf");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
+  }
+
+  const result2 = schema.safeParse(1234);
+  expect(result2.success).toEqual(false);
+  if (!result2.success) {
+    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
+  }
+});
+
+test("async short circuit on dirty", async () => {
+  const schema = z
+    .string()
+    .refine(() => false)
+    .transform((val) => val.toUpperCase());
+  const result = await schema.spa("asdf");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
+  }
+
+  const result2 = await schema.spa(1234);
+  expect(result2.success).toEqual(false);
+  if (!result2.success) {
+    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
+  }
+});
diff --git a/src/__tests__/unions.test.ts b/src/__tests__/unions.test.ts
new file mode 100644
index 000000000..1327ca344
--- /dev/null
+++ b/src/__tests__/unions.test.ts
@@ -0,0 +1,56 @@
+import { expect, test } from "@jest/globals";
+
+import * as z from "../index";
+
+test("function parsing", () => {
+  const schema = z.union([
+    z.string().refine(() => false),
+    z.number().refine(() => false),
+  ]);
+  const result = schema.safeParse("asdf");
+  expect(result.success).toEqual(false);
+});
+
+test("union 2", () => {
+  const result = z
+    .union([z.number(), z.string().refine(() => false)])
+    .safeParse("a");
+  expect(result.success).toEqual(false);
+});
+
+test("return valid over invalid", () => {
+  const schema = z.union([
+    z.object({
+      email: z.string().email(),
+    }),
+    z.string(),
+  ]);
+  expect(schema.parse("asdf")).toEqual("asdf");
+  expect(schema.parse({ email: "asdlkjf@lkajsdf.com" })).toEqual({
+    email: "asdlkjf@lkajsdf.com",
+  });
+});
+
+test("return dirty result over aborted", () => {
+  const result = z
+    .union([z.number(), z.string().refine(() => false)])
+    .safeParse("a");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues).toEqual([
+      {
+        code: "custom",
+        message: "Invalid input",
+        path: [],
+      },
+    ]);
+  }
+});
+
+test("options getter", async () => {
+  const union = z.union([z.string(), z.number()]);
+  union.options[0].parse("asdf");
+  union.options[1].parse(1234);
+  await union.options[0].parseAsync("asdf");
+  await union.options[1].parseAsync(1234);
+});
diff --git a/src/helpers/parseUtil.ts b/src/helpers/parseUtil.ts
index 1d1034679..f35384f5e 100644
--- a/src/helpers/parseUtil.ts
+++ b/src/helpers/parseUtil.ts
@@ -32,59 +32,82 @@ export const ZodParsedType = util.arrayToEnum([
 
 export type ZodParsedType = keyof typeof ZodParsedType;
 
-export const getParsedType = (data: any): ZodParsedType => {
+function cacheAndReturn(
+  data: any,
+  parsedType: ZodParsedType,
+  cache?: Map<any, ZodParsedType>
+) {
+  if (cache) cache.set(data, parsedType);
+  return parsedType;
+}
+
+export const getParsedType = (
+  data: any,
+  cache?: Map<any, ZodParsedType>
+): ZodParsedType => {
+  if (cache && cache.has(data)) return cache.get(data)!;
   const t = typeof data;
+
   switch (t) {
     case "undefined":
-      return ZodParsedType.undefined;
+      return cacheAndReturn(data, ZodParsedType.undefined, cache);
+
     case "string":
-      return ZodParsedType.string;
+      return cacheAndReturn(data, ZodParsedType.string, cache);
+
     case "number":
-      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
+      return cacheAndReturn(
+        data,
+        isNaN(data) ? ZodParsedType.nan : ZodParsedType.number,
+        cache
+      );
+
     case "boolean":
-      return ZodParsedType.boolean;
+      return cacheAndReturn(data, ZodParsedType.boolean, cache);
+
     case "function":
-      return ZodParsedType.function;
+      return cacheAndReturn(data, ZodParsedType.function, cache);
+
     case "bigint":
-      return ZodParsedType.bigint;
+      return cacheAndReturn(data, ZodParsedType.bigint, cache);
+
     case "object":
-      if (Array.isArray(data)) return ZodParsedType.array;
-      if (data === null) return ZodParsedType.null;
+      if (Array.isArray(data)) {
+        return cacheAndReturn(data, ZodParsedType.array, cache);
+      }
+      if (data === null) {
+        return cacheAndReturn(data, ZodParsedType.null, cache);
+      }
       if (
         data.then &&
         typeof data.then === "function" &&
         data.catch &&
         typeof data.catch === "function"
       ) {
-        return ZodParsedType.promise;
+        return cacheAndReturn(data, ZodParsedType.promise, cache);
       }
       if (data instanceof Map) {
-        return ZodParsedType.map;
+        return cacheAndReturn(data, ZodParsedType.map, cache);
       }
       if (data instanceof Set) {
-        return ZodParsedType.set;
+        return cacheAndReturn(data, ZodParsedType.set, cache);
       }
       if (data instanceof Date) {
-        return ZodParsedType.date;
+        return cacheAndReturn(data, ZodParsedType.date, cache);
       }
-      return ZodParsedType.object;
+      return cacheAndReturn(data, ZodParsedType.object, cache);
+
     default:
-      return ZodParsedType.unknown;
+      return cacheAndReturn(data, ZodParsedType.unknown, cache);
   }
 };
 
-export const makeIssue = (
-  params: {
-    data: any;
-    path: (string | number)[];
-    errorMaps: (ZodErrorMap | undefined)[];
-    issueData: IssueData;
-  }
-  // data: any,
-  // path: (string | number)[],
-  // errorMap: ZodErrorMap,
-  // issueData: IssueData
-): ZodIssue => {
+export const makeIssue = (params: {
+  data: any;
+  path: (string | number)[];
+  errorMaps: ZodErrorMap[];
+  issueData: IssueData;
+}): ZodIssue => {
   const { data, path, errorMaps, issueData } = params;
   const fullPath = [...path, ...(issueData.path || [])];
   const fullIssue = {
@@ -109,124 +132,144 @@ export const makeIssue = (
 };
 
 export type ParseParams = {
-  // data: any;
   path: (string | number)[];
   errorMap: ZodErrorMap;
   async: boolean;
 };
 
-export type ParseParamsNoData = Omit<ParseParams, "data">;
-
 export type ParsePathComponent = string | number;
+export type ParsePath = ParsePathComponent[];
+export const EMPTY_PATH: ParsePath = [];
 
-export type ParsePath = null | {
-  readonly component: ParsePathComponent;
-  readonly parent: ParsePath;
-  readonly count: number;
-};
-
-export const EMPTY_PATH: ParsePath = null;
-
-export const pathToArray = (path: ParsePath): ParsePathComponent[] => {
-  if (path === null) return [];
-  const arr: ParsePathComponent[] = new Array(path.count);
-  while (path !== null) {
-    arr[path.count - 1] = path.component;
-    path = path.parent;
-  }
-  return arr;
-};
-
-export const pathFromArray = (arr: ParsePathComponent[]): ParsePath => {
-  let path: ParsePath = null;
-  for (let i = 0; i < arr.length; i++) {
-    path = { parent: path, component: arr[i], count: i + 1 };
-  }
-  return path;
-};
-
-export type ParseContextParameters = {
-  errorMap: ZodErrorMap;
-  async: boolean;
-};
-
-interface ParseContextDef {
+export interface ParseContext {
   readonly path: ParsePath;
   readonly issues: ZodIssue[];
-  readonly errorMap?: ZodErrorMap;
+  readonly schemaErrorMap?: ZodErrorMap;
+  readonly contextualErrorMap?: ZodErrorMap;
   readonly async: boolean;
+  readonly parent: ParseContext | null;
+  readonly typeCache: Map<any, ZodParsedType>;
+  readonly data: any;
+  readonly parsedType: ZodParsedType;
 }
 
-export class ParseContext {
-  // public readonly path: ParsePath;
-  // public readonly issues: ZodIssue[];
-  // public readonly errorMap: ZodErrorMap;
-  public readonly def: ParseContextDef;
+export type ParseInput = {
+  data: any;
+  path: (string | number)[];
+  parent: ParseContext;
+};
 
-  constructor(def: ParseContextDef) {
-    this.def = def;
-  }
-  get path() {
-    return this.def.path;
-  }
-  get issues() {
-    return this.def.issues;
+export function addIssueToContext(
+  ctx: ParseContext,
+  issueData: IssueData
+): void {
+  const issue = makeIssue({
+    issueData: issueData,
+    data: ctx.data,
+    path: ctx.path,
+    errorMaps: [
+      ctx.contextualErrorMap, // contextual error map is first priority
+      ctx.schemaErrorMap, // then schema-bound map if available
+      overrideErrorMap, // then global override map
+      defaultErrorMap, // then global default map
+    ].filter((x) => !!x) as ZodErrorMap[],
+  });
+  ctx.issues.push(issue);
+}
+
+export type ObjectPair = {
+  key: SyncParseReturnType<any>;
+  value: SyncParseReturnType<any>;
+};
+export class ParseStatus {
+  value: "aborted" | "dirty" | "valid" = "valid";
+  dirty() {
+    if (this.value === "valid") this.value = "dirty";
   }
-  get errorMap() {
-    return this.def.errorMap;
+  abort() {
+    if (this.value !== "aborted") this.value = "aborted";
   }
-  get async() {
-    return this.def.async;
+
+  static mergeArray(
+    status: ParseStatus,
+    results: SyncParseReturnType<any>[]
+  ): SyncParseReturnType {
+    const arrayValue: any[] = [];
+    for (const s of results) {
+      if (s.status === "aborted") return INVALID;
+      if (s.status === "dirty") status.dirty();
+      arrayValue.push(s.value);
+    }
+
+    return { status: status.value, value: arrayValue };
   }
 
-  stepInto(component: ParsePathComponent): ParseContext {
-    return new ParseContext({
-      ...this.def,
-      path:
-        this.path === null
-          ? { parent: null, count: 1, component }
-          : { parent: this.path, count: this.path.count + 1, component },
-    });
+  static async mergeObjectAsync(
+    status: ParseStatus,
+    pairs: { key: ParseReturnType<any>; value: ParseReturnType<any> }[]
+  ): Promise<SyncParseReturnType<any>> {
+    const syncPairs: ObjectPair[] = [];
+    for (const pair of pairs) {
+      syncPairs.push({
+        key: await pair.key,
+        value: await pair.value,
+      });
+    }
+    return ParseStatus.mergeObjectSync(status, syncPairs);
   }
 
-  _addIssue(
-    data: any,
-    issueData: IssueData,
-    params: { schemaErrorMap?: ZodErrorMap } = {}
-  ): void {
-    const issue = makeIssue({
-      data,
-      issueData,
-      path: pathToArray(this.path),
-      errorMaps: [
-        this.def.errorMap, // contextual error map is first priority
-        params.schemaErrorMap, // then schema-bound map if available
-        overrideErrorMap, // then global override map
-        defaultErrorMap, // then global default map
-      ],
-      // errorMaps: [this.errorMap],
-      // issueData,
-    });
-    this.issues.push(issue);
+  static mergeObjectSync(
+    status: ParseStatus,
+    pairs: {
+      key: SyncParseReturnType<any>;
+      value: SyncParseReturnType<any>;
+      alwaysSet?: boolean;
+    }[]
+  ): SyncParseReturnType {
+    const finalObject: any = {};
+    for (const pair of pairs) {
+      const { key, value } = pair;
+      if (key.status === "aborted") return INVALID;
+      if (value.status === "aborted") return INVALID;
+      if (key.status === "dirty") status.dirty();
+      if (value.status === "dirty") status.dirty();
+
+      if (typeof value.value !== "undefined" || pair.alwaysSet) {
+        finalObject[key.value] = value.value;
+      }
+    }
+
+    return { status: status.value, value: finalObject };
   }
 }
+export interface ParseResult {
+  status: "aborted" | "dirty" | "valid";
+  data: any;
+}
+
+export type INVALID = { status: "aborted" };
+export const INVALID: INVALID = Object.freeze({
+  status: "aborted",
+});
 
-export type INVALID = { valid: false };
-export const INVALID: INVALID = Object.freeze({ valid: false });
+export type DIRTY<T> = { status: "dirty"; value: T };
+export const DIRTY = <T>(value: T): DIRTY<T> => ({ status: "dirty", value });
 
-export type OK<T> = { valid: true; value: T };
-export const OK = <T>(value: T): OK<T> => ({ valid: true, value });
+export type OK<T> = { status: "valid"; value: T };
+export const OK = <T>(value: T): OK<T> => ({ status: "valid", value });
 
-export type SyncParseReturnType<T> = OK<T> | INVALID;
+export type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
 export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
 export type ParseReturnType<T> =
   | SyncParseReturnType<T>
   | AsyncParseReturnType<T>;
 
-export const isInvalid = (x: ParseReturnType<any>): x is INVALID =>
-  (x as any).valid === false;
-export const isOk = <T>(x: ParseReturnType<T>): x is OK<T> =>
-  (x as any).valid === true;
+export const isAborted = (x: ParseReturnType<any>): x is INVALID =>
+  (x as any).status === "aborted";
+export const isDirty = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
+  (x as any).status === "dirty";
+export const isValid = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
+  (x as any).status === "valid";
 export const isAsync = <T>(
   x: ParseReturnType<T>
 ): x is AsyncParseReturnType<T> => x instanceof Promise;
diff --git a/src/index.ts b/src/index.ts
index 85d41ec84..369ee11b2 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -1,3 +1,3 @@
-import * as z from "./external";
+import * as mod from "./external";
 export * from "./external";
-export { z };
+export { mod as z };
diff --git a/src/types.ts b/src/types.ts
index aa78eaa2b..078c64b70 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -1,25 +1,30 @@
+import { FATAL_CODES } from ".";
 import { errorUtil } from "./helpers/errorUtil";
 import {
+  addIssueToContext,
   AsyncParseReturnType,
   getParsedType,
   INVALID,
+  isAborted,
   isAsync,
-  isInvalid,
-  isOk,
+  isDirty,
+  isValid,
   makeIssue,
   OK,
   ParseContext,
-  ParseParamsNoData,
+  ParseInput,
+  ParseParams,
   ParseReturnType,
-  pathFromArray,
-  pathToArray,
+  ParseStatus,
   SyncParseReturnType,
   ZodParsedType,
 } from "./helpers/parseUtil";
 import { partialUtil } from "./helpers/partialUtil";
 import { util } from "./helpers/util";
 import {
+  defaultErrorMap,
   IssueData,
+  overrideErrorMap,
   StringValidation,
   ZodCustomIssue,
   ZodError,
@@ -52,43 +57,21 @@ export interface ZodTypeDef {
   errorMap?: ZodErrorMap;
 }
 
-// function customErrorMap(arg: string | ZodErrorMap | undefined) {
-//   if (typeof arg === "string") {
-//     const map: ZodErrorMap = (iss, ctx) => {
-//       if (iss.code === ZodIssueCode.invalid_type) {
-//         return { message: arg };
-//       }
-//       return { message: ctx.defaultError };
-//     };
-//   }
-// }
-
-const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
-  new ParseContext({
-    path: pathFromArray(params.path || []),
-    issues: [],
-    errorMap: params.errorMap,
-    async: params.async ?? false,
-  });
-
 const handleResult = <Input, Output>(
   ctx: ParseContext,
   result: SyncParseReturnType<Output>
 ):
   | { success: true; data: Output }
   | { success: false; error: ZodError<Input> } => {
-  if (isOk(result) && !ctx.issues.length) {
+  if (isValid(result)) {
     return { success: true, data: result.value };
   } else {
+    if (!ctx.issues.length) {
+      throw new Error("Validation failed but no issues detected.");
+    }
     const error = new ZodError(ctx.issues);
     return { success: false, error };
   }
-  // if (isOk(result)) {
-  //   return { success: true, data: result.value };
-  // } else {
-  //   const error = new ZodError(ctx.issues);
-  //   return { success: false, error };
-  // }
 };
 
 type RawCreateParams =
@@ -128,44 +111,39 @@ export abstract class ZodType<
   readonly _input!: Input;
   readonly _def!: Def;
 
-  abstract _parse(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<Output>;
+  abstract _parse(input: ParseInput): ParseReturnType<Output>;
 
-  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx._addIssue(params.data, issueData, {
-      schemaErrorMap: this._def.errorMap,
-    });
+  _processInputParams(
+    input: ParseInput
+  ): { status: ParseStatus; ctx: ParseContext } {
+    return {
+      status: new ParseStatus(),
+      ctx: {
+        ...input.parent,
+        data: input.data,
+        parsedType: getParsedType(input.data, input.parent.typeCache),
+        schemaErrorMap: this._def.errorMap,
+        path: input.path,
+        parent: input.parent,
+      },
+    };
   }
 
-  _parseSync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): SyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
+  _parseSync(input: ParseInput): SyncParseReturnType<Output> {
+    const result = this._parse(input);
     if (isAsync(result)) {
       throw new Error("Synchronous parse encountered promise.");
     }
     return result;
   }
 
-  _parseAsync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): AsyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
-    // if (isAsync(result)) {
-    //   return result;
-    // }
+  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {
+    const result = this._parse(input);
 
     return Promise.resolve(result);
   }
 
-  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
+  parse(data: unknown, params?: Partial<ParseParams>): Output {
     const result = this.safeParse(data, params);
     if (result.success) return result.data;
     throw result.error;
@@ -173,18 +151,29 @@ export abstract class ZodType<
 
   safeParse(
     data: unknown,
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
   ):
     | { success: true; data: Output }
     | { success: false; error: ZodError<Input> } {
-    const ctx = createRootContext({ ...params, async: false });
-    const result = this._parseSync(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: params?.async ?? false,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
+
     return handleResult(ctx, result);
   }
 
   async parseAsync(
     data: unknown,
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
   ): Promise<Output> {
     const result = await this.safeParseAsync(data, params);
     if (result.success) return result.data;
@@ -193,12 +182,23 @@ export abstract class ZodType<
 
   async safeParseAsync(
     data: unknown,
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
   ): Promise<
     { success: true; data: Output } | { success: false; error: ZodError }
   > {
-    const ctx = createRootContext({ ...params, async: true });
-    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: true,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+
+    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
     const result = await (isAsync(maybeAsyncResult)
       ? maybeAsyncResult
       : Promise.resolve(maybeAsyncResult));
@@ -326,12 +326,7 @@ export abstract class ZodType<
   default(def: () => util.noUndefined<Input>): ZodDefault<this>;
   default(def: any) {
     const defaultValueFunc = typeof def === "function" ? def : () => def;
-    // if (this instanceof ZodOptional) {
-    //   return new ZodOptional({
-    //     ...this._def,
-    //     defaultValue: defaultValueFunc,
-    //   }) as any;
-    // }
+
     return new ZodDefault({
       innerType: this,
       defaultValue: defaultValueFunc,
@@ -377,132 +372,98 @@ const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-
 const emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
 
 export class ZodString extends ZodType<string, ZodStringDef> {
-  _parse(
-    ctx: ParseContext,
-    data: string,
-    parsedType: ZodParsedType
-  ): ParseReturnType<string> {
-    if (parsedType !== ZodParsedType.string) {
-      this.addIssue(
+  _parse(input: ParseInput): ParseReturnType<string> {
+    const { status, ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.string) {
+      addIssueToContext(
         ctx,
         {
           code: ZodIssueCode.invalid_type,
           expected: ZodParsedType.string,
-          received: parsedType,
-        },
-        { data }
+          received: ctx.parsedType,
+        }
+        //
       );
       return INVALID;
     }
-    let invalid = false;
 
     for (const check of this._def.checks) {
       if (check.kind === "min") {
-        if (data.length < check.value) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: "string",
-              inclusive: true,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data.length < check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: "string",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "max") {
-        if (data.length > check.value) {
-          invalid = true;
-
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: "string",
-              inclusive: true,
-              message: check.message,
-              // ...errorUtil.errToObj(this._def.maxLength.message),
-            },
-            { data }
-          );
+        if (ctx.data.length > check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: "string",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "email") {
-        if (!emailRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: "email",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!emailRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: "email",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "uuid") {
-        if (!uuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: "uuid",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!uuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: "uuid",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "cuid") {
-        if (!cuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: "cuid",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!cuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: "cuid",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "url") {
         try {
-          new URL(data);
+          new URL(ctx.data);
         } catch {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: "url",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: "url",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "regex") {
-        // clear regex state
         check.regex.lastIndex = 0;
-        const testResult = check.regex.test(data);
+        const testResult = check.regex.test(ctx.data);
         if (!testResult) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: "regex",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: "regex",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
         }
       }
     }
 
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
   }
 
   protected _regex = (
@@ -632,98 +593,71 @@ export interface ZodNumberDef extends ZodTypeDef {
 }
 
 export class ZodNumber extends ZodType<number, ZodNumberDef> {
-  _parse(
-    ctx: ParseContext,
-    data: number,
-    parsedType: ZodParsedType
-  ): ParseReturnType<number> {
-    if (parsedType !== ZodParsedType.number) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.number,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<number> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.number) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.number,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
-    let invalid = false;
-
     for (const check of this._def.checks) {
       if (check.kind === "int") {
-        if (!util.isInteger(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.invalid_type,
-              expected: "integer",
-              received: "float",
-              message: check.message,
-            },
-            { data }
-          );
+        if (!util.isInteger(ctx.data)) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.invalid_type,
+            expected: "integer",
+            received: "float",
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "min") {
-        // const MIN = check.value;
         const tooSmall = check.inclusive
-          ? data < check.value
-          : data <= check.value;
+          ? ctx.data < check.value
+          : ctx.data <= check.value;
         if (tooSmall) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: "number",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: "number",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "max") {
         const tooBig = check.inclusive
-          ? data > check.value
-          : data >= check.value;
+          ? ctx.data > check.value
+          : ctx.data >= check.value;
         if (tooBig) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: "number",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: "number",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else if (check.kind === "multipleOf") {
-        if (data % check.value !== 0) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.not_multiple_of,
-              multipleOf: check.value,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data % check.value !== 0) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+          status.dirty();
         }
       } else {
         util.assertNever(check);
       }
     }
 
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
   }
 
   static create = (params?: RawCreateParams): ZodNumber => {
@@ -871,25 +805,17 @@ export interface ZodBigIntDef extends ZodTypeDef {
 }
 
 export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
-  _parse(
-    ctx: ParseContext,
-    data: bigint,
-    parsedType: ZodParsedType
-  ): ParseReturnType<bigint> {
-    if (parsedType !== ZodParsedType.bigint) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.bigint,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<bigint> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.bigint) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.bigint,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
 
   static create = (params?: RawCreateParams): ZodBigInt => {
@@ -912,25 +838,17 @@ export interface ZodBooleanDef extends ZodTypeDef {
 }
 
 export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
-  _parse(
-    ctx: ParseContext,
-    data: boolean,
-    parsedType: ZodParsedType
-  ): ParseReturnType<boolean> {
-    if (parsedType !== ZodParsedType.boolean) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.boolean,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<boolean> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.boolean) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.boolean,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
 
   static create = (params?: RawCreateParams): ZodBoolean => {
@@ -953,37 +871,27 @@ export interface ZodDateDef extends ZodTypeDef {
 }
 
 export class ZodDate extends ZodType<Date, ZodDateDef> {
-  _parse(
-    ctx: ParseContext,
-    data: Date,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Date> {
-    if (parsedType !== ZodParsedType.date) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.date,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.date) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.date,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    if (isNaN(data.getTime())) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_date,
-        },
-        { data }
-      );
-
+    if (isNaN(ctx.data.getTime())) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_date,
+      });
       return INVALID;
     }
 
-    return OK(new Date((data as Date).getTime()));
+    return {
+      status: status.value,
+      value: new Date((ctx.data as Date).getTime()),
+    };
   }
 
   static create = (params?: RawCreateParams): ZodDate => {
@@ -1006,25 +914,17 @@ export interface ZodUndefinedDef extends ZodTypeDef {
 }
 
 export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
-  _parse(
-    ctx: ParseContext,
-    data: undefined,
-    parsedType: ZodParsedType
-  ): ParseReturnType<undefined> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.undefined,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.undefined,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
   params?: RawCreateParams;
 
@@ -1048,25 +948,17 @@ export interface ZodNullDef extends ZodTypeDef {
 }
 
 export class ZodNull extends ZodType<null, ZodNullDef> {
-  _parse(
-    ctx: ParseContext,
-    data: null,
-    parsedType: ZodParsedType
-  ): ParseReturnType<null> {
-    if (parsedType !== ZodParsedType.null) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.null,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.null) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.null,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
   static create = (params?: RawCreateParams): ZodNull => {
     return new ZodNull({
@@ -1090,12 +982,9 @@ export interface ZodAnyDef extends ZodTypeDef {
 export class ZodAny extends ZodType<any, ZodAnyDef> {
   // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
   _any: true = true;
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
   }
   static create = (params?: RawCreateParams): ZodAny => {
     return new ZodAny({
@@ -1119,12 +1008,9 @@ export interface ZodUnknownDef extends ZodTypeDef {
 export class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
   // required
   _unknown: true = true;
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<unknown> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
   }
 
   static create = (params?: RawCreateParams): ZodUnknown => {
@@ -1147,20 +1033,13 @@ export interface ZodNeverDef extends ZodTypeDef {
 }
 
 export class ZodNever extends ZodType<never, ZodNeverDef> {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<never> {
-    this.addIssue(
-      ctx,
-      {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.never,
-        received: parsedType,
-      },
-      { data }
-    );
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    addIssueToContext(ctx, {
+      code: ZodIssueCode.invalid_type,
+      expected: ZodParsedType.never,
+      received: ctx.parsedType,
+    });
     return INVALID;
   }
   static create = (params?: RawCreateParams): ZodNever => {
@@ -1183,25 +1062,17 @@ export interface ZodVoidDef extends ZodTypeDef {
 }
 
 export class ZodVoid extends ZodType<void, ZodVoidDef> {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<void> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.void,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.void,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
 
   static create = (params?: RawCreateParams): ZodVoid => {
@@ -1245,93 +1116,69 @@ export class ZodArray<
     ? [T["_input"], ...T["_input"][]]
     : T["_input"][]
 > {
-  _parse(
-    ctx: ParseContext,
-    _data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
-    // return parseArray(ctx, data, parsedType, this._def) as any;
-    const def = this._def;
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
 
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data: _data }
-      );
+    const def = this._def;
 
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
-    const data: any[] = _data;
-
-    let invalid = false;
     if (def.minLength !== null) {
-      if (data.length < def.minLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_small,
-            minimum: def.minLength.value,
-            type: "array",
-            inclusive: true,
-            message: def.minLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length < def.minLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minLength.value,
+          type: "array",
+          inclusive: true,
+          message: def.minLength.message,
+        });
+        status.dirty();
       }
     }
 
     if (def.maxLength !== null) {
-      if (data.length > def.maxLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_big,
-            maximum: def.maxLength.value,
-            type: "array",
-            inclusive: true,
-            message: def.maxLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length > def.maxLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxLength.value,
+          type: "array",
+          inclusive: true,
+          message: def.maxLength.message,
+        });
+        status.dirty();
       }
     }
 
-    const tasks: Promise<any>[] = [];
-    const result: any = new Array(data.length);
-    const type = def.type;
-    const handleParsed = (
-      index: number,
-      parsedItem: ParseReturnType<T>
-    ): void => {
-      if (isOk(parsedItem)) {
-        result[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
+    if (ctx.async) {
+      return Promise.all(
+        (ctx.data as any[]).map((item, i) => {
+          return def.type._parseAsync({
+            parent: ctx,
+            path: [...ctx.path, i],
+            data: item,
+          });
+        })
+      ).then((result) => {
+        return ParseStatus.mergeArray(status, result);
+      });
+    }
 
-    data.forEach((item, index) => {
-      handleParsed(
-        index,
-        type._parse(ctx.stepInto(index), item, getParsedType(item))
-      );
+    const result = (ctx.data as any[]).map((item, i) => {
+      return def.type._parseSync({
+        parent: ctx,
+        path: [...ctx.path, i],
+        data: item,
+      });
     });
 
-    if (ctx.async) {
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
-    } else {
-      return invalid ? INVALID : OK(result);
-    }
+    return ParseStatus.mergeArray(status, result);
   }
 
   get element() {
@@ -1357,7 +1204,7 @@ export class ZodArray<
   }
 
   nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone"> {
-    return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:"atleastone" });
+    return this.min(1, message) as any;
   }
 
   static create = <T extends ZodTypeAny>(
@@ -1423,48 +1270,7 @@ export namespace objectUtil {
       ...second, // second overwrites first
     };
   };
-
-  export const intersectShapes = <U extends ZodRawShape, T extends ZodRawShape>(
-    first: U,
-    second: T
-  ): T & U => {
-    const firstKeys = util.objectKeys(first);
-    const secondKeys = util.objectKeys(second);
-    const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
-
-    const sharedShape: any = {};
-    for (const k of sharedKeys) {
-      sharedShape[k] = ZodIntersection.create(first[k], second[k]);
-    }
-    return {
-      ...(first as object),
-      ...(second as object),
-      ...sharedShape,
-    };
-  };
 }
-export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-  Second extends AnyZodObject
->(
-  second: Second
-): ZodObject<
-  First["_shape"] & Second["_shape"],
-  First["_unknownKeys"],
-  First["_catchall"]
-> => {
-  const mergedShape = objectUtil.mergeShapes(
-    first._def.shape(),
-    second._def.shape()
-  );
-  const merged: any = new ZodObject({
-    // effects: [...(first._def.effects || []), ...(second._def.effects || [])],
-    unknownKeys: first._def.unknownKeys,
-    catchall: first._def.catchall,
-    shape: () => mergedShape,
-    typeName: ZodFirstPartyTypeKind.ZodObject,
-  }) as any;
-  return merged;
-};
 
 export type extendShape<A, B> = {
   [k in Exclude<keyof A, keyof B>]: A[k];
@@ -1477,13 +1283,6 @@ const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
   augmentation: Augmentation
 ): ZodObject<
   extendShape<ReturnType<Def["shape"]>, Augmentation>,
-  // {
-  //   [k in Exclude<
-  //     keyof ReturnType<Def["shape"]>,
-  //     keyof Augmentation
-  //   >]: ReturnType<Def["shape"]>[k];
-  // } &
-  //   { [k in keyof Augmentation]: Augmentation[k] },
   Def["unknownKeys"],
   Def["catchall"]
 > => {
@@ -1605,81 +1404,57 @@ export class ZodObject<
     return (this._cached = { shape, keys });
   }
 
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
     const { shape, keys: shapeKeys } = this._getCached();
-
-    let invalid = false;
-    const tasks: Promise<any>[] = [];
-    const resultObject: Record<string, any> = {};
-
-    const handleParsed = (
-      key: string,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedValue)) {
-        const value = parsedValue.value;
-        if (typeof value !== "undefined" || key in data) {
-          // key was valid but result was undefined: add it to the result object
-          // only if key was in the input data object - if it wasn't, then it's
-          // an optional key that should not be added
-          resultObject[key] = value;
-        }
-      } else if (isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-      }
-    };
-
+    const dataKeys = util.objectKeys(ctx.data);
+    const extraKeys = dataKeys.filter((k) => !(k in shape));
+
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+      alwaysSet?: boolean;
+    }[] = [];
     for (const key of shapeKeys) {
       const keyValidator = shape[key];
-      const value = data[key];
-      handleParsed(
-        key,
-        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
-      );
+      const value = ctx.data[key];
+      pairs.push({
+        key: { status: "valid", value: key },
+        value: keyValidator._parse({
+          parent: ctx,
+          data: value,
+          path: [...ctx.path, key],
+        }),
+        alwaysSet: key in ctx.data,
+      });
     }
 
     if (this._def.catchall instanceof ZodNever) {
       const unknownKeys = this._def.unknownKeys;
 
       if (unknownKeys === "passthrough") {
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
         for (const key of extraKeys) {
-          resultObject[key] = data[key];
+          pairs.push({
+            key: { status: "valid", value: key },
+            value: { status: "valid", value: ctx.data[key] },
+          });
         }
       } else if (unknownKeys === "strict") {
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
         if (extraKeys.length > 0) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.unrecognized_keys,
-              keys: extraKeys,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.unrecognized_keys,
+            keys: extraKeys,
+          });
+          status.dirty();
         }
       } else if (unknownKeys === "strip") {
       } else {
@@ -1688,22 +1463,38 @@ export class ZodObject<
     } else {
       // run catchall validation
       const catchall = this._def.catchall;
-      const dataKeys = util.objectKeys(data);
-      const extraKeys = dataKeys.filter((k) => !(k in shape));
+
       for (const key of extraKeys) {
-        const value = data[key];
-        handleParsed(
-          key,
-          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
-        );
+        const value = ctx.data[key];
+        pairs.push({
+          key: { status: "valid", value: key },
+          value: catchall._parse(
+            { parent: ctx, path: [...ctx.path, key], data: value } //, ctx.child(key), value, getParsedType(value)
+          ),
+          alwaysSet: key in ctx.data,
+        });
       }
     }
+
     if (ctx.async) {
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(resultObject as Output)
-      );
+      return Promise.resolve()
+        .then(async () => {
+          const syncPairs: any[] = [];
+          for (const pair of pairs) {
+            const key = await pair.key;
+            syncPairs.push({
+              key,
+              value: await pair.value,
+              alwaysSet: pair.alwaysSet,
+            });
+          }
+          return syncPairs;
+        })
+        .then((syncPairs) => {
+          return ParseStatus.mergeObjectSync(status, syncPairs);
+        });
     } else {
-      return invalid ? INVALID : OK(resultObject as Output);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
     }
   }
 
@@ -1711,10 +1502,26 @@ export class ZodObject<
     return this._def.shape();
   }
 
-  strict(): ZodObject<T, "strict", Catchall> {
+  strict(message?: errorUtil.ErrMessage): ZodObject<T, "strict", Catchall> {
+    errorUtil.errToObj;
     return new ZodObject({
       ...this._def,
       unknownKeys: "strict",
+      ...(message !== undefined
+        ? {
+            errorMap: (issue, ctx) => {
+              const defaultError =
+                this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
+              if (issue.code === "unrecognized_keys")
+                return {
+                  message: errorUtil.errToObj(message).message ?? defaultError,
+                };
+              return {
+                message: defaultError,
+              };
+            },
+          }
+        : {}),
     }) as any;
   }
 
@@ -1762,7 +1569,6 @@ export class ZodObject<
       merging._def.shape()
     );
     const merged: any = new ZodObject({
-      // effects: [], // wipe all refinements
       unknownKeys: merging._def.unknownKeys,
       catchall: merging._def.catchall,
       shape: () => mergedShape,
@@ -1839,7 +1645,6 @@ export class ZodObject<
   partial(mask?: any) {
     const newShape: any = {};
     if (mask) {
-      // const newShape: any = {};
       util.objectKeys(this.shape).map((key) => {
         if (util.objectKeys(mask).indexOf(key) === -1) {
           newShape[key] = this.shape[key];
@@ -1942,78 +1747,81 @@ export interface ZodUnionDef<
   typeName: ZodFirstPartyTypeKind.ZodUnion;
 }
 
-// export type toOpts<T> = T extends ZodUnionOptions ? T : never;
-// export type ZodUnionType<
-//   A extends ZodTypeAny,
-//   B extends ZodTypeAny
-// > = A extends ZodUnion<infer AOpts>
-//   ? B extends ZodUnion<infer BOpts>
-//     ? ZodUnion<toOpts<[...AOpts, ...BOpts]>>
-//     : ZodUnion<toOpts<[...AOpts, B]>>
-//   : B extends ZodUnion<infer BOpts>
-//   ? ZodUnion<toOpts<[A, ...BOpts]>>
-//   : ZodUnion<toOpts<[A, B]>>;
-
 export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
   T[number]["_output"],
   ZodUnionDef<T>,
   T[number]["_input"]
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[number]["_output"]> {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
     const options = this._def.options;
-    const noMatch = (allIssues: ZodIssue[][]) => {
-      const unionErrors = allIssues.map((issues) => new ZodError(issues));
-      const nonTypeErrors = unionErrors.filter((err) => {
-        return err.issues[0].code !== "invalid_type";
-      });
-      if (nonTypeErrors.length === 1) {
-        // TODO encapsulate
-        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
-      } else {
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_union,
-            unionErrors,
-          },
-          { data }
-        );
+
+    function handleResults(
+      results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]
+    ) {
+      // return first issue-free validation if it exists
+      for (const result of results) {
+        if (result.result.status === "valid") {
+          return result.result;
+        }
+      }
+
+      for (const result of results) {
+        if (result.result.status === "dirty") {
+          // add issues from dirty option
+
+          ctx.issues.push(...result.ctx.issues);
+          return result.result;
+        }
       }
+
+      // return invalid
+      const unionErrors = results.map(
+        (result) => new ZodError(result.ctx.issues)
+      );
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union,
+        unionErrors,
+      });
       return INVALID;
-    };
+    }
 
     if (ctx.async) {
-      const contexts = options.map(
-        () => new ParseContext({ ...ctx.def, issues: [] })
-      );
       return Promise.all(
-        options.map((option, index) =>
-          option._parse(contexts[index], data, parsedType)
-        )
-      ).then((parsedOptions) => {
-        for (const parsedOption of parsedOptions) {
-          if (isOk(parsedOption)) {
-            return parsedOption;
-          }
-        }
-        return noMatch(contexts.map((ctx) => ctx.issues));
-      });
+        options.map(async (option) => {
+          const childCtx: ParseContext = {
+            ...ctx,
+            issues: [],
+            parent: null,
+          };
+          return {
+            result: await option._parseAsync({
+              data: ctx.data,
+              path: ctx.path,
+              parent: childCtx,
+            }),
+            ctx: childCtx,
+          };
+        })
+      ).then(handleResults);
     } else {
-      const allIssues: ZodIssue[][] = [];
-      for (const option of options) {
-        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-        const parsedOption = option._parseSync(optionCtx, data, parsedType);
-        if (isInvalid(parsedOption)) {
-          allIssues.push(optionCtx.issues);
-        } else {
-          return parsedOption;
-        }
-      }
-      return noMatch(allIssues);
+      const optionResults = options.map((option) => {
+        const childCtx: ParseContext = {
+          ...ctx,
+          issues: [],
+          parent: null,
+        };
+        return {
+          result: option._parseSync({
+            data: ctx.data,
+            path: ctx.path,
+            parent: childCtx,
+          }),
+          ctx: childCtx,
+        };
+      });
+
+      return handleResults(optionResults);
     }
   }
 
@@ -2106,42 +1914,57 @@ export class ZodIntersection<
   ZodIntersectionDef<T, U>,
   T["_input"] & U["_input"]
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T["_output"] & U["_output"]> {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
     const handleParsed = (
-      parsedLeft: SyncParseReturnType<T>,
-      parsedRight: SyncParseReturnType<U>
+      parsedLeft: SyncParseReturnType,
+      parsedRight: SyncParseReturnType
     ): SyncParseReturnType<T & U> => {
-      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
         return INVALID;
       }
 
       const merged = mergeValues(parsedLeft.value, parsedRight.value);
+
       if (!merged.valid) {
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_intersection_types,
-          },
-          { data }
-        );
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.invalid_intersection_types,
+        });
         return INVALID;
       }
-      return OK(merged.data);
+
+      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
+        status.dirty();
+      }
+
+      return { status: status.value, value: merged.data as any };
     };
 
     if (ctx.async) {
       return Promise.all([
-        this._def.left._parse(ctx, data, parsedType),
-        this._def.right._parse(ctx, data, parsedType),
+        this._def.left._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
       ]).then(([left, right]: any) => handleParsed(left, right));
     } else {
       return handleParsed(
-        this._def.left._parseSync(ctx, data, parsedType),
-        this._def.right._parseSync(ctx, data, parsedType)
+        this._def.left._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        })
       );
     }
   }
@@ -2210,98 +2033,58 @@ export class ZodTuple<
   ZodTupleDef<T, Rest>,
   InputTypeOfTupleWithRest<T, Rest>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
-    const rest = this._def.rest;
-
-    if (!rest && data.length > this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_big,
-          maximum: this._def.items.length,
-          inclusive: true,
-          type: "array",
-        },
-        { data }
-      );
-      return INVALID;
-    }
+    if (ctx.data.length < this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_small,
+        minimum: this._def.items.length,
+        inclusive: true,
+        type: "array",
+      });
 
-    if (data.length < this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_small,
-          minimum: this._def.items.length,
-          inclusive: true,
-          type: "array",
-        },
-        { data }
-      );
       return INVALID;
     }
 
-    const tasks: Promise<unknown>[] = [];
-    const items = this._def.items as ZodType<any, any, any>[];
-
-    const parseResult: any[] = new Array(data.length);
-    let invalid = false;
-
-    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
-      if (isOk(parsedItem)) {
-        parseResult[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
-
-    items.forEach((item, index) => {
-      handleParsed(
-        index,
-        item._parse(
-          ctx.stepInto(index),
-          data[index],
-          getParsedType(data[index])
-        )
-      );
-    });
+    const rest = this._def.rest;
 
-    if (rest) {
-      const restData: any[] = data.slice(items.length);
-      restData.forEach((dataItem, _index) => {
-        const index = _index + items.length;
-        handleParsed(
-          index,
-          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
-        );
+    if (!rest && ctx.data.length > this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_big,
+        maximum: this._def.items.length,
+        inclusive: true,
+        type: "array",
       });
+      status.dirty();
     }
 
+    const items = (ctx.data as any[])
+      .map((item, itemIndex) => {
+        const schema = this._def.items[itemIndex] || this._def.rest;
+        if (!schema) return (null as any) as SyncParseReturnType<any>;
+        return schema._parse({
+          data: item,
+          path: [...ctx.path, itemIndex],
+          parent: ctx,
+        });
+      })
+      .filter((x) => !!x); // filter nulls
+
     if (ctx.async) {
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return Promise.all(items).then((results) => {
+        return ParseStatus.mergeArray(status, results);
+      });
     } else {
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);
     }
   }
 
@@ -2360,59 +2143,44 @@ export class ZodRecord<
   get valueSchema() {
     return this._def.valueType;
   }
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Record<any, any>> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
-    const tasks: Promise<unknown>[] = [];
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+    }[] = [];
+
     const keyType = this._def.keyType;
     const valueType = this._def.valueType;
-    const parseResult: Record<string, ParseReturnType<any>> = {};
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedKey) && isOk(parsedValue)) {
-        parseResult[parsedKey.value] = parsedValue.value;
-      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else {
-        invalid = true;
-      }
-    };
 
-    for (const key in data) {
-      handleParsed(
-        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
-      );
+    for (const key in ctx.data) {
+      pairs.push({
+        key: keyType._parse({
+          data: key,
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+        value: valueType._parse({
+          data: ctx.data[key],
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+      });
     }
 
     if (ctx.async) {
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return ParseStatus.mergeObjectAsync(status, pairs);
     } else {
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
     }
   }
 
@@ -2472,69 +2240,69 @@ export class ZodMap<
   ZodMapDef<Key, Value>,
   Map<Key["_input"], Value["_input"]>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Map<any, any>> {
-    if (parsedType !== ZodParsedType.map) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.map,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.map) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.map,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
     const keyType = this._def.keyType;
     const valueType = this._def.valueType;
-    const dataMap: Map<unknown, unknown> = data;
-    const parseResult = new Map();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        parseResult.set(parsedKey.value, parsedValue.value);
-      }
-    };
 
-    [...dataMap.entries()].forEach(([key, value], index) => {
-      const entryCtx = ctx.stepInto(index);
-      const parsedKey = keyType._parse(
-        entryCtx.stepInto("key"),
-        key,
-        getParsedType(key)
-      );
-      const parsedValue = valueType._parse(
-        entryCtx.stepInto("value"),
-        value,
-        getParsedType(value)
-      );
-      handleParsed(parsedKey, parsedValue);
-    });
+    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(
+      ([key, value], index) => {
+        return {
+          key: keyType._parse({
+            data: key,
+            path: [...ctx.path, index, "key"],
+            parent: ctx,
+          }),
+          value: valueType._parse({
+            data: value,
+            path: [...ctx.path, index, "value"],
+            parent: ctx,
+          }),
+        };
+      }
+    );
 
     if (ctx.async) {
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      const finalMap = new Map();
+      return Promise.resolve().then(async () => {
+        for (const pair of pairs) {
+          const key = await pair.key;
+          const value = await pair.value;
+          if (key.status === "aborted" || value.status === "aborted") {
+            return INVALID;
+          }
+          if (key.status === "dirty" || value.status === "dirty") {
+            status.dirty();
+          }
+
+          finalMap.set(key.value, value.value);
+        }
+        return { status: status.value, value: finalMap };
+      });
     } else {
-      return invalid ? INVALID : OK(parseResult);
+      const finalMap = new Map();
+      for (const pair of pairs) {
+        const key = pair.key as SyncParseReturnType;
+        const value = pair.value as SyncParseReturnType;
+        if (key.status === "aborted" || value.status === "aborted") {
+          return INVALID;
+        }
+        if (key.status === "dirty" || value.status === "dirty") {
+          status.dirty();
+        }
+
+        finalMap.set(key.value, value.value);
+      }
+      return { status: status.value, value: finalMap };
     }
   }
   static create = <
@@ -2572,49 +2340,37 @@ export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
   ZodSetDef<Value>,
   Set<Value["_input"]>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Set<any>> {
-    if (parsedType !== ZodParsedType.set) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.set,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.set) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.set,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
-    const dataSet: Set<unknown> = data;
     const valueType = this._def.valueType;
-    const parsedSet = new Set();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-
-    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
-      if (isOk(parsedItem)) {
-        parsedSet.add(parsedItem.value);
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
+
+    function finalizeSet(elements: SyncParseReturnType<any>[]) {
+      const parsedSet = new Set();
+      for (const element of elements) {
+        if (element.status === "aborted") return INVALID;
+        if (element.status === "dirty") status.dirty();
+        parsedSet.add(element.value);
       }
-    };
+      return { status: status.value, value: parsedSet };
+    }
 
-    [...dataSet.values()].forEach((item, i) =>
-      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>
+      valueType._parse({ data: item, path: [...ctx.path, i], parent: ctx })
     );
 
     if (ctx.async) {
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
+      return Promise.all(elements).then((elements) => finalizeSet(elements));
     } else {
-      return invalid ? INVALID : OK(parsedSet);
+      return finalizeSet(elements as SyncParseReturnType[]);
     }
   }
 
@@ -2668,30 +2424,27 @@ export class ZodFunction<
   ZodFunctionDef<Args, Returns>,
   InnerTypeOfFunction<Args, Returns>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.function) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.function,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.function) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.function,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
     function makeArgsIssue(args: any, error: ZodError): ZodIssue {
       return makeIssue({
         data: args,
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
         issueData: {
           code: ZodIssueCode.invalid_arguments,
           argumentsError: error,
@@ -2702,8 +2455,13 @@ export class ZodFunction<
     function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
       return makeIssue({
         data: returns,
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
         issueData: {
           code: ZodIssueCode.invalid_return_type,
           returnTypeError: error,
@@ -2711,8 +2469,8 @@ export class ZodFunction<
       });
     }
 
-    const params = { errorMap: ctx.errorMap };
-    const fn = data;
+    const params = { errorMap: ctx.contextualErrorMap };
+    const fn = ctx.data;
 
     if (this._def.returns instanceof ZodPromise) {
       return OK(async (...args: any[]) => {
@@ -2724,7 +2482,8 @@ export class ZodFunction<
             throw error;
           });
         const result = await fn(...(parsedArgs as any));
-        const parsedReturns = await this._def.returns
+        const parsedReturns = await (this._def
+          .returns as ZodPromise<ZodTypeAny>)._def.type
           .parseAsync(result, params)
           .catch((e) => {
             error.addIssue(makeReturnsIssue(result, e));
@@ -2744,7 +2503,7 @@ export class ZodFunction<
           throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
         }
         return parsedReturns.data;
-      });
+      }) as any;
     }
   }
 
@@ -2829,13 +2588,10 @@ export class ZodLazy<T extends ZodTypeAny> extends ZodType<
     return this._def.getter();
   }
 
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<output<T>> {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
     const lazySchema = this._def.getter();
-    return lazySchema._parse(ctx, data, parsedType);
+    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
   }
 
   static create = <T extends ZodTypeAny>(
@@ -2863,24 +2619,17 @@ export interface ZodLiteralDef<T extends any = any> extends ZodTypeDef {
 }
 
 export class ZodLiteral<T extends any> extends ZodType<T, ZodLiteralDef<T>> {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T> {
-    if (data !== this._def.value) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: this._def.value as any,
-          received: data,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.data !== this._def.value) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: this._def.value as any,
+        received: ctx.data,
+      });
       return INVALID;
     }
-    return OK(data);
+    return { status: status.value, value: ctx.data };
   }
 
   get value() {
@@ -2940,23 +2689,16 @@ export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
   T[number],
   ZodEnumDef<T>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[number]> {
-    if (this._def.values.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: this._def.values,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (this._def.values.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: this._def.values,
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
 
   get options() {
@@ -3009,25 +2751,19 @@ export class ZodNativeEnum<T extends EnumLike> extends ZodType<
   T[keyof T],
   ZodNativeEnumDef<T>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[keyof T]> {
+  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {
+    const { ctx } = this._processInputParams(input);
     const nativeEnumValues = util.getValidEnumValues(this._def.values);
-    if (nativeEnumValues.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: util.objectValues(nativeEnumValues),
-        },
-        { data }
-      );
+    if (nativeEnumValues.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: util.objectValues(nativeEnumValues),
+      });
       return INVALID;
     }
-    return OK(data);
+    return OK(ctx.data);
   }
+
   static create = <T extends EnumLike>(
     values: T,
     params?: RawCreateParams
@@ -3058,33 +2794,27 @@ export class ZodPromise<T extends ZodTypeAny> extends ZodType<
   ZodPromiseDef<T>,
   Promise<T["_input"]>
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Promise<T["_output"]>> {
-    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.promise,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.promise,
+        received: ctx.parsedType,
+      });
       return INVALID;
     }
 
     const promisified =
-      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+      ctx.parsedType === ZodParsedType.promise
+        ? ctx.data
+        : Promise.resolve(ctx.data);
 
     return OK(
       promisified.then((data: any) => {
         return this._def.type.parseAsync(data, {
-          path: pathToArray(ctx.path),
-          errorMap: ctx.errorMap,
+          path: ctx.path,
+          errorMap: ctx.contextualErrorMap,
         });
       })
     );
@@ -3146,110 +2876,121 @@ export class ZodEffects<
     return this._def.schema;
   }
 
-  _parse(
-    ctx: ParseContext,
-    initialData: any,
-    initialParsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    const isSync = ctx.async === false;
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { status, ctx } = this._processInputParams(input);
+
     const effect = this._def.effect || null;
-    const data = initialData;
-    const parsedType: ZodParsedType = initialParsedType;
 
     if (effect.type === "preprocess") {
-      const processed = effect.transform(initialData);
+      const processed = effect.transform(ctx.data);
 
       if (ctx.async) {
-        return Promise.resolve(processed).then((val) =>
-          this._def.schema._parseAsync(ctx, val, getParsedType(val))
-        );
+        return Promise.resolve(processed).then((processed) => {
+          return this._def.schema._parseAsync({
+            data: processed,
+            path: ctx.path,
+            parent: ctx,
+          });
+        });
       } else {
-        const result = this._def.schema._parseSync(
-          ctx,
-          processed,
-          getParsedType(processed)
-        );
-        if (result instanceof Promise)
-          throw new Error(
-            "Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead."
-          );
-        return result;
+        return this._def.schema._parseSync({
+          data: processed,
+          path: ctx.path,
+          parent: ctx,
+        });
       }
     }
 
     if (effect.type === "refinement") {
-      let invalid = false;
+      const checkCtx: RefinementCtx = {
+        addIssue: (arg: IssueData) => {
+          addIssueToContext(ctx, arg);
+          if (FATAL_CODES.includes(arg.code)) {
+            status.abort();
+          } else {
+            status.dirty();
+          }
+        },
+        get path() {
+          return ctx.path;
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
 
       const executeRefinement = (
-        acc: any,
-        effect: RefinementEffect<any>
+        acc: unknown
+        // effect: RefinementEffect<any>
       ): any => {
         const result = effect.refinement(acc, checkCtx);
+        if (ctx.async) {
+          return Promise.resolve(result);
+        }
         if (result instanceof Promise) {
-          if (isSync) {
-            throw new Error(
-              "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
-            );
-          }
-          return result.then(() => acc);
+          throw new Error(
+            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
+          );
         }
         return acc;
       };
 
-      const _addIssue = (arg: IssueData) => {
-        // don't abort early on refinement issues
-        invalid = true;
-        this.addIssue(ctx, arg, { data });
-      };
-      const checkCtx: RefinementCtx = {
-        addIssue: _addIssue,
-        get path() {
-          return pathToArray(ctx.path);
-        },
-      };
-
-      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+      if (ctx.async === false) {
+        const inner = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        if (inner.status === "aborted") return INVALID;
+        if (inner.status === "dirty") status.dirty();
 
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = executeRefinement(base.value, effect);
-        return invalid ? INVALID : OK(result);
+        // return value is ignored
+        executeRefinement(inner.value);
+        return { status: status.value, value: inner.value };
       } else {
         return this._def.schema
-          ._parseAsync(ctx, data, parsedType)
-          .then((result) => {
-            if (isInvalid(result)) return INVALID;
-            return executeRefinement(result.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
+          .then((inner) => {
+            if (inner.status === "aborted") return INVALID;
+            if (inner.status === "dirty") status.dirty();
+
+            return executeRefinement(inner.value).then(() => {
+              return { status: status.value, value: inner.value };
+            });
+          });
       }
     }
 
     if (effect.type === "transform") {
-      const invalid = false;
-      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
-        const transformed = effect.transform(acc);
-        if (transformed instanceof Promise && isSync) {
+      if (ctx.async === false) {
+        const base = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        // if (base.status === "aborted") return INVALID;
+        // if (base.status === "dirty") {
+        //   return { status: "dirty", value: base.value };
+        // }
+        if (!isValid(base)) return base;
+
+        const result = effect.transform(base.value);
+        if (result instanceof Promise) {
           throw new Error(
             `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
           );
         }
-        return transformed;
-      };
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = applyTransform(base.value, effect);
-        return invalid ? INVALID : OK(result);
+        return OK(result);
       } else {
         return this._def.schema
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
           .then((base) => {
-            if (isInvalid(base)) return INVALID;
-            return applyTransform(base.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+            if (!isValid(base)) return base;
+            // if (base.status === "aborted") return INVALID;
+            // if (base.status === "dirty") {
+            //   return { status: "dirty", value: base.value };
+            // }
+            return Promise.resolve(effect.transform(base.value)).then(OK);
+          });
       }
     }
 
@@ -3305,15 +3046,16 @@ export class ZodOptional<T extends ZodTypeAny> extends ZodType<
   ZodOptionalDef<T>,
   T["_input"] | undefined
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T["_output"] | undefined> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.undefined) {
       return OK(undefined);
     }
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
   }
 
   unwrap() {
@@ -3352,15 +3094,16 @@ export class ZodNullable<T extends ZodTypeAny> extends ZodType<
   ZodNullableDef<T>,
   T["_input"] | null
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T["_output"] | null> {
-    if (parsedType === ZodParsedType.null) {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.null) {
       return OK(null);
     }
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
   }
 
   unwrap() {
@@ -3398,15 +3141,17 @@ export class ZodDefault<T extends ZodTypeAny> extends ZodType<
   ZodDefaultDef<T>,
   T["_input"] | undefined
 > {
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<util.noUndefined<T["_output"]>> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
+    const { ctx } = this._processInputParams(input);
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
       data = this._def.defaultValue();
     }
-    return this._def.innerType._parse(ctx, data, getParsedType(data));
+    return this._def.innerType._parse({
+      data,
+      path: ctx.path,
+      parent: ctx,
+    });
   }
 
   removeDefault() {
@@ -3482,19 +3227,19 @@ export type ZodFirstPartySchemaTypes =
   | ZodUnknown
   | ZodNever
   | ZodVoid
-  | ZodArray<any>
-  | ZodObject<any>
+  | ZodArray<any, any>
+  | ZodObject<any, any, any, any, any>
   | ZodUnion<any>
   | ZodIntersection<any, any>
-  | ZodTuple
-  | ZodRecord
-  | ZodMap
-  | ZodSet
+  | ZodTuple<any, any>
+  | ZodRecord<any, any>
+  | ZodMap<any>
+  | ZodSet<any>
   | ZodFunction<any, any>
   | ZodLazy<any>
   | ZodLiteral<any>
   | ZodEnum<any>
-  | ZodEffects<any>
+  | ZodEffects<any, any, any>
   | ZodNativeEnum<any>
   | ZodOptional<any>
   | ZodNullable<any>
diff --git a/yarn.lock b/yarn.lock
index 779abe251..498a71048 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -5327,10 +5327,10 @@ tslib@^1.8.1, tslib@^1.9.0:
   resolved "https://registry.yarnpkg.com/tslib/-/tslib-1.14.1.tgz#cf2d38bdc34a134bcaf1091c41f6619e2f672d00"
   integrity sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==
 
-tslib@^2.1.0:
-  version "2.1.0"
-  resolved "https://registry.yarnpkg.com/tslib/-/tslib-2.1.0.tgz#da60860f1c2ecaa5703ab7d39bc05b6bf988b97a"
-  integrity sha512-hcVC3wYEziELGGmEEXue7D75zbwIIVUMWAVbHItGPx0ziyXxrOMQx4rQEVEV45Ut/1IotuEvwqPopzIOkDMf0A==
+tslib@^2.3.1:
+  version "2.3.1"
+  resolved "https://registry.yarnpkg.com/tslib/-/tslib-2.3.1.tgz#e8a335add5ceae51aa261d32a490158ef042ef01"
+  integrity sha512-77EbyPPpMz+FRFRuAFlWMtmgUWGe9UOG2Z25NqCwiIjRhOf5iKGuzSe5P2w1laq+FkRy4p+PCuVkJSGkzTEKVw==
 
 tsutils@^3.17.1:
   version "3.17.1"
@@ -5392,10 +5392,10 @@ typedarray-to-buffer@^3.1.5:
   dependencies:
     is-typedarray "^1.0.0"
 
-typescript@4.3:
-  version "4.3.5"
-  resolved "https://registry.yarnpkg.com/typescript/-/typescript-4.3.5.tgz#4d1c37cc16e893973c45a06886b7113234f119f4"
-  integrity sha512-DqQgihaQ9cUrskJo9kIyW/+g0Vxsk8cDtZ52a3NGh0YNTfpUSArXSohyUGnvbPazEPLu398C0UxmKSOrPumUzA==
+typescript@^4.4.4:
+  version "4.4.4"
+  resolved "https://registry.yarnpkg.com/typescript/-/typescript-4.4.4.tgz#2cd01a1a1f160704d3101fd5a58ff0f9fcb8030c"
+  integrity sha512-DqGhF5IKoBl8WNf8C1gu8q0xZSInh9j1kJJMqT3a94w1JzVaBU4EXOSMrz9yDqMT0xt3selp83fuFMQ0uzv6qA==
 
 uglify-js@^3.1.4:
   version "3.12.1"
