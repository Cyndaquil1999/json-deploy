diff --git a/README.md b/README.md
index d913ed9b4..5649249ec 100644
--- a/README.md
+++ b/README.md
@@ -488,6 +488,7 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`nestjs-graphql-zod`](https://github.com/incetarik/nestjs-graphql-zod): Generates NestJS GraphQL model classes from Zod schemas. Provides GraphQL method decorators working with Zod schemas.
 - [`zod-openapi`](https://github.com/samchungy/zod-openapi): Create full OpenAPI v3.x documentation from Zod schemas.
 - [`fastify-zod-openapi`](https://github.com/samchungy/fastify-zod-openapi): Fastify type provider, validation, serialization and @fastify/swagger support for Zod schemas.
+- [`typeschema`](https://typeschema.com/): Universal adapter for schema validation.
 
 #### X to Zod
 
@@ -501,6 +502,7 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`prisma-zod-generator`](https://github.com/omar-dulaimi/prisma-zod-generator): Emit Zod schemas from your Prisma schema.
 - [`prisma-trpc-generator`](https://github.com/omar-dulaimi/prisma-trpc-generator): Emit fully implemented tRPC routers and their validation schemas using Zod.
 - [`zod-prisma-types`](https://github.com/chrishoermann/zod-prisma-types) Create Zod types from your Prisma models.
+- [`quicktype`](https://app.quicktype.io/): Convert JSON objects and JSON schemas into Zod schemas.
 
 #### Mocking
 
diff --git a/deno/lib/__tests__/function.test.ts b/deno/lib/__tests__/function.test.ts
index 45031fb09..675891e6d 100644
--- a/deno/lib/__tests__/function.test.ts
+++ b/deno/lib/__tests__/function.test.ts
@@ -32,27 +32,31 @@ test("function inference 1", () => {
 test("method parsing", () => {
   const methodObject = z.object({
     property: z.number(),
-    method: z.function().args(z.string()).returns(z.number())
+    method: z.function().args(z.string()).returns(z.number()),
   });
   const methodInstance = {
     property: 3,
-    method: function(s: string) { return s.length + this.property; }
+    method: function (s: string) {
+      return s.length + this.property;
+    },
   };
   const parsed = methodObject.parse(methodInstance);
-  expect(parsed.method('length=8')).toBe(11); // 8 length + 3 property
+  expect(parsed.method("length=8")).toBe(11); // 8 length + 3 property
 });
 
 test("async method parsing", async () => {
   const methodObject = z.object({
     property: z.number(),
-    method: z.function().args(z.string()).returns(z.promise(z.number()))
+    method: z.function().args(z.string()).returns(z.promise(z.number())),
   });
   const methodInstance = {
     property: 3,
-    method: async function(s: string) { return s.length + this.property; }
+    method: async function (s: string) {
+      return s.length + this.property;
+    },
   };
   const parsed = methodObject.parse(methodInstance);
-  expect(await parsed.method('length=8')).toBe(11); // 8 length + 3 property
+  expect(await parsed.method("length=8")).toBe(11); // 8 length + 3 property
 });
 
 test("args method", () => {
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 8743f4154..39325a9a9 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -371,7 +371,10 @@ export abstract class ZodType<
     refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput
   ): ZodEffects<this, RefinedOutput, Input>;
   superRefine(
-    refinement: (arg: Output, ctx: RefinementCtx) => void | Promise<void>
+    refinement: (arg: Output, ctx: RefinementCtx) => void
+  ): ZodEffects<this, Output, Input>;
+  superRefine(
+    refinement: (arg: Output, ctx: RefinementCtx) => Promise<void>
   ): ZodEffects<this, Output, Input>;
   superRefine(
     refinement: (arg: Output, ctx: RefinementCtx) => unknown | Promise<unknown>
diff --git a/package.json b/package.json
index 1cafe97ba..e51c4076e 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.22.1",
+  "version": "3.22.2",
   "author": "Colin McDonnell <colin@colinhacks.com>",
   "repository": {
     "type": "git",
diff --git a/playground.ts b/playground.ts
index 4e01473b6..2a67b4e95 100644
--- a/playground.ts
+++ b/playground.ts
@@ -1,3 +1,12 @@
 import { z } from "./src";
 
 z;
+
+const schema = z.object({
+  name: z.string(),
+  value: z.string(),
+});
+
+const schemaRefine = schema.superRefine(async (val, _ctx) => {
+  return val.value !== "INVALID";
+});
diff --git a/src/__tests__/function.test.ts b/src/__tests__/function.test.ts
index b6a572700..1c23cb9c5 100644
--- a/src/__tests__/function.test.ts
+++ b/src/__tests__/function.test.ts
@@ -31,27 +31,31 @@ test("function inference 1", () => {
 test("method parsing", () => {
   const methodObject = z.object({
     property: z.number(),
-    method: z.function().args(z.string()).returns(z.number())
+    method: z.function().args(z.string()).returns(z.number()),
   });
   const methodInstance = {
     property: 3,
-    method: function(s: string) { return s.length + this.property; }
+    method: function (s: string) {
+      return s.length + this.property;
+    },
   };
   const parsed = methodObject.parse(methodInstance);
-  expect(parsed.method('length=8')).toBe(11); // 8 length + 3 property
+  expect(parsed.method("length=8")).toBe(11); // 8 length + 3 property
 });
 
 test("async method parsing", async () => {
   const methodObject = z.object({
     property: z.number(),
-    method: z.function().args(z.string()).returns(z.promise(z.number()))
+    method: z.function().args(z.string()).returns(z.promise(z.number())),
   });
   const methodInstance = {
     property: 3,
-    method: async function(s: string) { return s.length + this.property; }
+    method: async function (s: string) {
+      return s.length + this.property;
+    },
   };
   const parsed = methodObject.parse(methodInstance);
-  expect(await parsed.method('length=8')).toBe(11); // 8 length + 3 property
+  expect(await parsed.method("length=8")).toBe(11); // 8 length + 3 property
 });
 
 test("args method", () => {
diff --git a/src/types.ts b/src/types.ts
index bdcf16662..51e188948 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -371,7 +371,10 @@ export abstract class ZodType<
     refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput
   ): ZodEffects<this, RefinedOutput, Input>;
   superRefine(
-    refinement: (arg: Output, ctx: RefinementCtx) => void | Promise<void>
+    refinement: (arg: Output, ctx: RefinementCtx) => void
+  ): ZodEffects<this, Output, Input>;
+  superRefine(
+    refinement: (arg: Output, ctx: RefinementCtx) => Promise<void>
   ): ZodEffects<this, Output, Input>;
   superRefine(
     refinement: (arg: Output, ctx: RefinementCtx) => unknown | Promise<unknown>
