diff --git a/deno/lib/__tests__/catch.test.ts b/deno/lib/__tests__/catch.test.ts
index 84c5bd4d9..935c39681 100644
--- a/deno/lib/__tests__/catch.test.ts
+++ b/deno/lib/__tests__/catch.test.ts
@@ -219,3 +219,13 @@ test("catch error", () => {
     catchError !== undefined && (catchError as z.ZodError).issues[0].message
   ).toMatch("string");
 });
+
+test("ctx.input", () => {
+  const schema = z.string().catch((ctx) => {
+    console.log(ctx.input);
+    console.log(ctx.error);
+    return String(ctx.input);
+  });
+
+  expect(schema.parse(123)).toEqual("123");
+});
diff --git a/deno/lib/__tests__/generics.test.ts b/deno/lib/__tests__/generics.test.ts
new file mode 100644
index 000000000..388e147e7
--- /dev/null
+++ b/deno/lib/__tests__/generics.test.ts
@@ -0,0 +1,25 @@
+// @ts-ignore TS6133
+import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
+const test = Deno.test;
+
+import { util } from "../helpers/util.ts";
+import * as z from "../index.ts";
+
+test("generics", () => {
+  async function stripOuter<TData extends z.ZodTypeAny>(
+    schema: TData,
+    data: unknown
+  ) {
+    return z
+      .object({
+        nested: schema, // as z.ZodTypeAny,
+      })
+      .transform((data) => {
+        return data.nested!;
+      })
+      .parse({ nested: data });
+  }
+
+  const result = stripOuter(z.object({ a: z.string() }), { a: "asdf" });
+  util.assertEqual<typeof result, Promise<{ a: string }>>(true);
+});
diff --git a/deno/lib/helpers/partialUtil.ts b/deno/lib/helpers/partialUtil.ts
index 4229a66d5..b9de239fd 100644
--- a/deno/lib/helpers/partialUtil.ts
+++ b/deno/lib/helpers/partialUtil.ts
@@ -3,6 +3,7 @@ import type {
   ZodNullable,
   ZodObject,
   ZodOptional,
+  ZodRawShape,
   ZodTuple,
   ZodTupleItems,
   ZodTypeAny,
@@ -34,33 +35,30 @@ export namespace partialUtil {
   //   ? "object" // T extends ZodOptional<any> // ? 'optional' // :
   //   : "rest"];
 
-  export type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<
-    infer Shape,
-    infer Params,
-    infer Catchall
-  >
-    ? ZodObject<
-        { [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>> },
-        Params,
-        Catchall
-      >
-    : T extends ZodArray<infer Type, infer Card>
-    ? ZodArray<DeepPartial<Type>, Card>
-    : T extends ZodOptional<infer Type>
-    ? ZodOptional<DeepPartial<Type>>
-    : T extends ZodNullable<infer Type>
-    ? ZodNullable<DeepPartial<Type>>
-    : T extends ZodTuple<infer Items>
-    ? {
-        [k in keyof Items]: Items[k] extends ZodTypeAny
-          ? DeepPartial<Items[k]>
-          : never;
-      } extends infer PI
-      ? PI extends ZodTupleItems
-        ? ZodTuple<PI>
+  export type DeepPartial<T extends ZodTypeAny> =
+    T extends ZodObject<ZodRawShape>
+      ? ZodObject<
+          { [k in keyof T["shape"]]: ZodOptional<DeepPartial<T["shape"][k]>> },
+          T["_def"]["unknownKeys"],
+          T["_def"]["catchall"]
+        >
+      : T extends ZodArray<infer Type, infer Card>
+      ? ZodArray<DeepPartial<Type>, Card>
+      : T extends ZodOptional<infer Type>
+      ? ZodOptional<DeepPartial<Type>>
+      : T extends ZodNullable<infer Type>
+      ? ZodNullable<DeepPartial<Type>>
+      : T extends ZodTuple<infer Items>
+      ? {
+          [k in keyof Items]: Items[k] extends ZodTypeAny
+            ? DeepPartial<Items[k]>
+            : never;
+        } extends infer PI
+        ? PI extends ZodTupleItems
+          ? ZodTuple<PI>
+          : never
         : never
-      : never
-    : T;
+      : T;
   //  {
   //     // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
   //     // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
diff --git a/deno/lib/helpers/util.ts b/deno/lib/helpers/util.ts
index 891906fae..21fe37338 100644
--- a/deno/lib/helpers/util.ts
+++ b/deno/lib/helpers/util.ts
@@ -5,6 +5,7 @@ export namespace util {
     ? true
     : false;
 
+  export type isAny<T> = 0 extends 1 & T ? true : false;
   export const assertEqual = <A, B>(val: AssertEqual<A, B>) => val;
   export function assertIs<T>(_arg: T): void {}
   export function assertNever(_x: never): never {
@@ -99,18 +100,22 @@ export namespace objectUtil {
     [k in Exclude<keyof U, keyof V>]: U[k];
   } & V;
 
-  type optionalKeys<T extends object> = {
-    [k in keyof T]: undefined extends T[k] ? k : never;
-  }[keyof T];
+  // type optionalKeys<T extends object> = {
+  //   [k in keyof T]: undefined extends T[k] ? k : never;
+  // }[keyof T];
 
   type requiredKeys<T extends object> = {
     [k in keyof T]: undefined extends T[k] ? never : k;
   }[keyof T];
 
-  export type addQuestionMarks<T extends object> = Partial<
-    Pick<T, optionalKeys<T>>
-  > &
-    Pick<T, requiredKeys<T>>;
+  // type alkjsdf = addQuestionMarks<{ a: any }>;
+
+  export type addQuestionMarks<
+    T extends object,
+    R extends keyof T = requiredKeys<T>
+    // O extends keyof T = optionalKeys<T>
+  > = Pick<T, R> & Partial<T>;
+  //  = { [k in O]?: T[k] } & { [k in R]: T[k] };
 
   export type identity<T> = T;
   export type flatten<T> = identity<{ [k in keyof T]: T[k] }>;
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 2343bd809..f61e449a3 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -464,7 +464,9 @@ export abstract class ZodType<
   }
 
   catch(def: Output): ZodCatch<this>;
-  catch(def: (ctx: { error: ZodError }) => Output): ZodCatch<this>;
+  catch(
+    def: (ctx: { error: ZodError; input: Input }) => Output
+  ): ZodCatch<this>;
   catch(def: any) {
     const catchValueFunc = typeof def === "function" ? def : () => def;
 
@@ -2131,44 +2133,42 @@ export type mergeTypes<A, B> = {
     : never;
 };
 
-export type baseObjectOutputType<Shape extends ZodRawShape> =
-  objectUtil.flatten<
-    objectUtil.addQuestionMarks<{
-      [k in keyof Shape]: Shape[k]["_output"];
-    }>
-  >;
-
 export type objectOutputType<
   Shape extends ZodRawShape,
   Catchall extends ZodTypeAny,
   UnknownKeys extends UnknownKeysParam = UnknownKeysParam
-> = (ZodTypeAny extends Catchall
-  ? baseObjectOutputType<Shape> & Passthrough<UnknownKeys>
-  : baseObjectOutputType<Shape> & {
-      [k: string]: Catchall["_output"];
-    }) &
-  Passthrough<UnknownKeys>;
-
-export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<
-  objectUtil.addQuestionMarks<{
-    [k in keyof Shape]: Shape[k]["_input"];
-  }>
->;
-
-export type Passthrough<UnknownKeys extends UnknownKeysParam> =
-  UnknownKeys extends "passthrough" ? { [k: string]: unknown } : unknown;
+> = objectUtil.flatten<
+  objectUtil.addQuestionMarks<baseObjectOutputType<Shape>>
+> &
+  CatchallOutput<Catchall> &
+  PassthroughType<UnknownKeys>;
+
+export type baseObjectOutputType<Shape extends ZodRawShape> = {
+  [k in keyof Shape]: Shape[k]["_output"];
+};
 
 export type objectInputType<
   Shape extends ZodRawShape,
   Catchall extends ZodTypeAny,
   UnknownKeys extends UnknownKeysParam = UnknownKeysParam
-> = ZodTypeAny extends Catchall
-  ? baseObjectInputType<Shape> & Passthrough<UnknownKeys>
-  : objectUtil.flatten<
-      baseObjectInputType<Shape> & {
-        [k: string]: Catchall["_input"];
-      } & Passthrough<UnknownKeys>
-    >;
+> = objectUtil.flatten<baseObjectInputType<Shape>> &
+  CatchallInput<Catchall> &
+  PassthroughType<UnknownKeys>;
+export type baseObjectInputType<Shape extends ZodRawShape> =
+  objectUtil.addQuestionMarks<{
+    [k in keyof Shape]: Shape[k]["_input"];
+  }>;
+
+export type CatchallOutput<T extends ZodTypeAny> = ZodTypeAny extends T
+  ? unknown
+  : { [k: string]: T["_output"] };
+
+export type CatchallInput<T extends ZodTypeAny> = ZodTypeAny extends T
+  ? unknown
+  : { [k: string]: T["_input"] };
+
+export type PassthroughType<T extends UnknownKeysParam> =
+  T extends "passthrough" ? { [k: string]: unknown } : unknown;
 
 export type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>
   ? deoptional<U>
@@ -4516,12 +4516,10 @@ export class ZodDefault<T extends ZodTypeAny> extends ZodType<
 //////////                      //////////
 //////////////////////////////////////////
 //////////////////////////////////////////
-export interface ZodCatchDef<
-  T extends ZodTypeAny = ZodTypeAny,
-  C extends T["_input"] = T["_input"]
-> extends ZodTypeDef {
+export interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
   innerType: T;
-  catchValue: (ctx: { error: ZodError }) => C;
+  catchValue: (ctx: { error: ZodError; input: unknown }) => T["_input"];
   typeName: ZodFirstPartyTypeKind.ZodCatch;
 }
 
@@ -4561,6 +4559,7 @@ export class ZodCatch<T extends ZodTypeAny> extends ZodType<
                   get error() {
                     return new ZodError(newCtx.common.issues);
                   },
+                  input: newCtx.data,
                 }),
         };
       });
@@ -4574,6 +4573,7 @@ export class ZodCatch<T extends ZodTypeAny> extends ZodType<
                 get error() {
                   return new ZodError(newCtx.common.issues);
                 },
+                input: newCtx.data,
               }),
       };
     }
diff --git a/package.json b/package.json
index ea41800c5..e57bdae93 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.21.1",
+  "version": "3.21.2",
   "author": "Colin McDonnell <colin@colinhacks.com>",
   "repository": {
     "type": "git",
diff --git a/playground.ts b/playground.ts
index 4e01473b6..d17b18eb4 100644
--- a/playground.ts
+++ b/playground.ts
@@ -1,3 +1,2 @@
 import { z } from "./src";
-
 z;
diff --git a/src/__tests__/catch.test.ts b/src/__tests__/catch.test.ts
index 5a02ce894..4586e4742 100644
--- a/src/__tests__/catch.test.ts
+++ b/src/__tests__/catch.test.ts
@@ -218,3 +218,13 @@ test("catch error", () => {
     catchError !== undefined && (catchError as z.ZodError).issues[0].message
   ).toMatch("string");
 });
+
+test("ctx.input", () => {
+  const schema = z.string().catch((ctx) => {
+    console.log(ctx.input);
+    console.log(ctx.error);
+    return String(ctx.input);
+  });
+
+  expect(schema.parse(123)).toEqual("123");
+});
diff --git a/src/__tests__/generics.test.ts b/src/__tests__/generics.test.ts
new file mode 100644
index 000000000..56460f26f
--- /dev/null
+++ b/src/__tests__/generics.test.ts
@@ -0,0 +1,24 @@
+// @ts-ignore TS6133
+import { expect, test } from "@jest/globals";
+
+import { util } from "../helpers/util";
+import * as z from "../index";
+
+test("generics", () => {
+  async function stripOuter<TData extends z.ZodTypeAny>(
+    schema: TData,
+    data: unknown
+  ) {
+    return z
+      .object({
+        nested: schema, // as z.ZodTypeAny,
+      })
+      .transform((data) => {
+        return data.nested!;
+      })
+      .parse({ nested: data });
+  }
+
+  const result = stripOuter(z.object({ a: z.string() }), { a: "asdf" });
+  util.assertEqual<typeof result, Promise<{ a: string }>>(true);
+});
diff --git a/src/helpers/partialUtil.ts b/src/helpers/partialUtil.ts
index c71feb774..ebfa5ec31 100644
--- a/src/helpers/partialUtil.ts
+++ b/src/helpers/partialUtil.ts
@@ -3,6 +3,7 @@ import type {
   ZodNullable,
   ZodObject,
   ZodOptional,
+  ZodRawShape,
   ZodTuple,
   ZodTupleItems,
   ZodTypeAny,
@@ -34,33 +35,30 @@ export namespace partialUtil {
   //   ? "object" // T extends ZodOptional<any> // ? 'optional' // :
   //   : "rest"];
 
-  export type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<
-    infer Shape,
-    infer Params,
-    infer Catchall
-  >
-    ? ZodObject<
-        { [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>> },
-        Params,
-        Catchall
-      >
-    : T extends ZodArray<infer Type, infer Card>
-    ? ZodArray<DeepPartial<Type>, Card>
-    : T extends ZodOptional<infer Type>
-    ? ZodOptional<DeepPartial<Type>>
-    : T extends ZodNullable<infer Type>
-    ? ZodNullable<DeepPartial<Type>>
-    : T extends ZodTuple<infer Items>
-    ? {
-        [k in keyof Items]: Items[k] extends ZodTypeAny
-          ? DeepPartial<Items[k]>
-          : never;
-      } extends infer PI
-      ? PI extends ZodTupleItems
-        ? ZodTuple<PI>
+  export type DeepPartial<T extends ZodTypeAny> =
+    T extends ZodObject<ZodRawShape>
+      ? ZodObject<
+          { [k in keyof T["shape"]]: ZodOptional<DeepPartial<T["shape"][k]>> },
+          T["_def"]["unknownKeys"],
+          T["_def"]["catchall"]
+        >
+      : T extends ZodArray<infer Type, infer Card>
+      ? ZodArray<DeepPartial<Type>, Card>
+      : T extends ZodOptional<infer Type>
+      ? ZodOptional<DeepPartial<Type>>
+      : T extends ZodNullable<infer Type>
+      ? ZodNullable<DeepPartial<Type>>
+      : T extends ZodTuple<infer Items>
+      ? {
+          [k in keyof Items]: Items[k] extends ZodTypeAny
+            ? DeepPartial<Items[k]>
+            : never;
+        } extends infer PI
+        ? PI extends ZodTupleItems
+          ? ZodTuple<PI>
+          : never
         : never
-      : never
-    : T;
+      : T;
   //  {
   //     // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
   //     // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
diff --git a/src/helpers/util.ts b/src/helpers/util.ts
index 891906fae..21fe37338 100644
--- a/src/helpers/util.ts
+++ b/src/helpers/util.ts
@@ -5,6 +5,7 @@ export namespace util {
     ? true
     : false;
 
+  export type isAny<T> = 0 extends 1 & T ? true : false;
   export const assertEqual = <A, B>(val: AssertEqual<A, B>) => val;
   export function assertIs<T>(_arg: T): void {}
   export function assertNever(_x: never): never {
@@ -99,18 +100,22 @@ export namespace objectUtil {
     [k in Exclude<keyof U, keyof V>]: U[k];
   } & V;
 
-  type optionalKeys<T extends object> = {
-    [k in keyof T]: undefined extends T[k] ? k : never;
-  }[keyof T];
+  // type optionalKeys<T extends object> = {
+  //   [k in keyof T]: undefined extends T[k] ? k : never;
+  // }[keyof T];
 
   type requiredKeys<T extends object> = {
     [k in keyof T]: undefined extends T[k] ? never : k;
   }[keyof T];
 
-  export type addQuestionMarks<T extends object> = Partial<
-    Pick<T, optionalKeys<T>>
-  > &
-    Pick<T, requiredKeys<T>>;
+  // type alkjsdf = addQuestionMarks<{ a: any }>;
+
+  export type addQuestionMarks<
+    T extends object,
+    R extends keyof T = requiredKeys<T>
+    // O extends keyof T = optionalKeys<T>
+  > = Pick<T, R> & Partial<T>;
+  //  = { [k in O]?: T[k] } & { [k in R]: T[k] };
 
   export type identity<T> = T;
   export type flatten<T> = identity<{ [k in keyof T]: T[k] }>;
diff --git a/src/types.ts b/src/types.ts
index f5106ca59..1336383ca 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -464,7 +464,9 @@ export abstract class ZodType<
   }
 
   catch(def: Output): ZodCatch<this>;
-  catch(def: (ctx: { error: ZodError }) => Output): ZodCatch<this>;
+  catch(
+    def: (ctx: { error: ZodError; input: Input }) => Output
+  ): ZodCatch<this>;
   catch(def: any) {
     const catchValueFunc = typeof def === "function" ? def : () => def;
 
@@ -2131,44 +2133,42 @@ export type mergeTypes<A, B> = {
     : never;
 };
 
-export type baseObjectOutputType<Shape extends ZodRawShape> =
-  objectUtil.flatten<
-    objectUtil.addQuestionMarks<{
-      [k in keyof Shape]: Shape[k]["_output"];
-    }>
-  >;
-
 export type objectOutputType<
   Shape extends ZodRawShape,
   Catchall extends ZodTypeAny,
   UnknownKeys extends UnknownKeysParam = UnknownKeysParam
-> = (ZodTypeAny extends Catchall
-  ? baseObjectOutputType<Shape> & Passthrough<UnknownKeys>
-  : baseObjectOutputType<Shape> & {
-      [k: string]: Catchall["_output"];
-    }) &
-  Passthrough<UnknownKeys>;
-
-export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<
-  objectUtil.addQuestionMarks<{
-    [k in keyof Shape]: Shape[k]["_input"];
-  }>
->;
-
-export type Passthrough<UnknownKeys extends UnknownKeysParam> =
-  UnknownKeys extends "passthrough" ? { [k: string]: unknown } : unknown;
+> = objectUtil.flatten<
+  objectUtil.addQuestionMarks<baseObjectOutputType<Shape>>
+> &
+  CatchallOutput<Catchall> &
+  PassthroughType<UnknownKeys>;
+
+export type baseObjectOutputType<Shape extends ZodRawShape> = {
+  [k in keyof Shape]: Shape[k]["_output"];
+};
 
 export type objectInputType<
   Shape extends ZodRawShape,
   Catchall extends ZodTypeAny,
   UnknownKeys extends UnknownKeysParam = UnknownKeysParam
-> = ZodTypeAny extends Catchall
-  ? baseObjectInputType<Shape> & Passthrough<UnknownKeys>
-  : objectUtil.flatten<
-      baseObjectInputType<Shape> & {
-        [k: string]: Catchall["_input"];
-      } & Passthrough<UnknownKeys>
-    >;
+> = objectUtil.flatten<baseObjectInputType<Shape>> &
+  CatchallInput<Catchall> &
+  PassthroughType<UnknownKeys>;
+export type baseObjectInputType<Shape extends ZodRawShape> =
+  objectUtil.addQuestionMarks<{
+    [k in keyof Shape]: Shape[k]["_input"];
+  }>;
+
+export type CatchallOutput<T extends ZodTypeAny> = ZodTypeAny extends T
+  ? unknown
+  : { [k: string]: T["_output"] };
+
+export type CatchallInput<T extends ZodTypeAny> = ZodTypeAny extends T
+  ? unknown
+  : { [k: string]: T["_input"] };
+
+export type PassthroughType<T extends UnknownKeysParam> =
+  T extends "passthrough" ? { [k: string]: unknown } : unknown;
 
 export type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>
   ? deoptional<U>
@@ -4516,12 +4516,10 @@ export class ZodDefault<T extends ZodTypeAny> extends ZodType<
 //////////                      //////////
 //////////////////////////////////////////
 //////////////////////////////////////////
-export interface ZodCatchDef<
-  T extends ZodTypeAny = ZodTypeAny,
-  C extends T["_input"] = T["_input"]
-> extends ZodTypeDef {
+export interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
   innerType: T;
-  catchValue: (ctx: { error: ZodError }) => C;
+  catchValue: (ctx: { error: ZodError; input: unknown }) => T["_input"];
   typeName: ZodFirstPartyTypeKind.ZodCatch;
 }
 
@@ -4561,6 +4559,7 @@ export class ZodCatch<T extends ZodTypeAny> extends ZodType<
                   get error() {
                     return new ZodError(newCtx.common.issues);
                   },
+                  input: newCtx.data,
                 }),
         };
       });
@@ -4574,6 +4573,7 @@ export class ZodCatch<T extends ZodTypeAny> extends ZodType<
                 get error() {
                   return new ZodError(newCtx.common.issues);
                 },
+                input: newCtx.data,
               }),
       };
     }
