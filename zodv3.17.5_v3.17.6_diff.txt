diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
index 0229838e9..61168fe08 100644
--- a/.github/workflows/release.yml
+++ b/.github/workflows/release.yml
@@ -111,7 +111,7 @@ jobs:
         with:
           tag_name: v${{ steps.publish.outputs.version }}
           release_name: v${{ steps.publish.outputs.version }}
-          commitish: ${{ github.ref }}
+          commitish: ref/heads/main
           body: ${{steps.github_release.outputs.changelog}}
           draft: false
           prerelease: false
diff --git a/.github/workflows/test.yml b/.github/workflows/test.yml
index d101c9a8e..0d5662abb 100644
--- a/.github/workflows/test.yml
+++ b/.github/workflows/test.yml
@@ -27,33 +27,33 @@ jobs:
       - run: yarn test
 
 
-  # test-deno:
-  #   runs-on: ubuntu-latest
-  #   strategy:
-  #     matrix:
-  #       deno: ["v1.x"]
-  #   name: Test with Deno ${{ matrix.deno }}
-  #   steps:
-  #     - uses: actions/checkout@v2
-  #     - uses: actions/setup-node@v1
-  #       with:
-  #         node-version: 16
-  #     - uses: denolib/setup-deno@v2
-  #       with:
-  #         deno-version: ${{ matrix.deno }}
-  #     - run: yarn install
-  #     - run: yarn build:deno
-  #     - run: deno --version
-  #     - run: deno test
-  #       working-directory: ./deno/lib
-  #     - run: deno run ./index.ts
-  #       working-directory: ./deno/lib
-  #     - run: deno run ./mod.ts
-  #       working-directory: ./deno/lib
-  #     - run: |
-  #         deno bundle ./mod.ts ./bundle.js
-  #         deno run ./bundle.js
-  #       working-directory: ./deno/lib
+  test-deno:
+    runs-on: ubuntu-latest
+    strategy:
+      matrix:
+        deno: ["v1.x"]
+    name: Test with Deno ${{ matrix.deno }}
+    steps:
+      - uses: actions/checkout@v2
+      - uses: actions/setup-node@v1
+        with:
+          node-version: 16
+      - uses: denolib/setup-deno@v2
+        with:
+          deno-version: ${{ matrix.deno }}
+      - run: yarn install
+      - run: yarn build:deno
+      - run: deno --version
+      - run: deno test
+        working-directory: ./deno/lib
+      - run: deno run ./index.ts
+        working-directory: ./deno/lib
+      - run: deno run ./mod.ts
+        working-directory: ./deno/lib
+      - run: |
+          deno bundle ./mod.ts ./bundle.js
+          deno run ./bundle.js
+        working-directory: ./deno/lib
 
   lint:
     runs-on: ubuntu-latest
diff --git a/README.md b/README.md
index c2c85885b..a5bf7286f 100644
--- a/README.md
+++ b/README.md
@@ -313,6 +313,7 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`prisma-zod-generator`](https://github.com/omar-dulaimi/prisma-zod-generator): Emit Zod schemas from your Prisma schema.
 - [`prisma-trpc-generator`](https://github.com/omar-dulaimi/prisma-trpc-generator): Emit fully implemented tRPC routers and their validation schemas using Zod.
 - [`nestjs-graphql-zod`](https://github.com/incetarik/nestjs-graphql-zod): Generates NestJS GraphQL model classes from Zod schemas dynamically and provides GraphQL method decorators working with Zod schemas.
+- [`zod-xlsx`](https://github.com/sidwebworks/zod-xlsx): A xlsx based resource validator using Zod schemas.
 - [`remix-domains`](https://github.com/SeasonedSoftware/remix-domains/): Improves end-to-end type safety in [Remix](https://remix.run/) by leveraging Zod to parse the framework's inputs such as FormData, URLSearchParams, etc.
 
 #### Form integrations
@@ -351,7 +352,7 @@ pnpm add zod          # pnpm
 
 ### Deno
 
-Unlike Node, Deno relies on direct URL imports instead of a package manager like npm. Zod is available on [deno.land/x](deno.land/x). The latest version can be imported like so:
+Unlike Node, Deno relies on direct URL imports instead of a package manager like NPM. Zod is available on [deno.land/x](https://deno.land/x). The latest version can be imported like so:
 
 ```ts
 import { z } from "https://deno.land/x/zod/mod.ts";
@@ -360,7 +361,7 @@ import { z } from "https://deno.land/x/zod/mod.ts";
 You can also specify a particular version:
 
 ```ts
-import { z } from from "https://deno.land/x/zod@v3.16.1/mod.ts"
+import { z } from "https://deno.land/x/zod@v3.16.1/mod.ts";
 ```
 
 > The rest of this README assumes you are using npm and importing directly from the `"zod"` package.
@@ -438,7 +439,7 @@ const tru = z.literal(true);
 tuna.value; // "tuna"
 ```
 
-> Currently there is no support for Date or bigint literals in Zod. If you have a use case for this feature, please file an issue.
+> Currently there is no support for Date literals in Zod. If you have a use case for this feature, please file an issue.
 
 ## Strings
 
diff --git a/deno/lib/README.md b/deno/lib/README.md
index c2c85885b..a5bf7286f 100644
--- a/deno/lib/README.md
+++ b/deno/lib/README.md
@@ -313,6 +313,7 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`prisma-zod-generator`](https://github.com/omar-dulaimi/prisma-zod-generator): Emit Zod schemas from your Prisma schema.
 - [`prisma-trpc-generator`](https://github.com/omar-dulaimi/prisma-trpc-generator): Emit fully implemented tRPC routers and their validation schemas using Zod.
 - [`nestjs-graphql-zod`](https://github.com/incetarik/nestjs-graphql-zod): Generates NestJS GraphQL model classes from Zod schemas dynamically and provides GraphQL method decorators working with Zod schemas.
+- [`zod-xlsx`](https://github.com/sidwebworks/zod-xlsx): A xlsx based resource validator using Zod schemas.
 - [`remix-domains`](https://github.com/SeasonedSoftware/remix-domains/): Improves end-to-end type safety in [Remix](https://remix.run/) by leveraging Zod to parse the framework's inputs such as FormData, URLSearchParams, etc.
 
 #### Form integrations
@@ -351,7 +352,7 @@ pnpm add zod          # pnpm
 
 ### Deno
 
-Unlike Node, Deno relies on direct URL imports instead of a package manager like npm. Zod is available on [deno.land/x](deno.land/x). The latest version can be imported like so:
+Unlike Node, Deno relies on direct URL imports instead of a package manager like NPM. Zod is available on [deno.land/x](https://deno.land/x). The latest version can be imported like so:
 
 ```ts
 import { z } from "https://deno.land/x/zod/mod.ts";
@@ -360,7 +361,7 @@ import { z } from "https://deno.land/x/zod/mod.ts";
 You can also specify a particular version:
 
 ```ts
-import { z } from from "https://deno.land/x/zod@v3.16.1/mod.ts"
+import { z } from "https://deno.land/x/zod@v3.16.1/mod.ts";
 ```
 
 > The rest of this README assumes you are using npm and importing directly from the `"zod"` package.
@@ -438,7 +439,7 @@ const tru = z.literal(true);
 tuna.value; // "tuna"
 ```
 
-> Currently there is no support for Date or bigint literals in Zod. If you have a use case for this feature, please file an issue.
+> Currently there is no support for Date literals in Zod. If you have a use case for this feature, please file an issue.
 
 ## Strings
 
diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index 75bb8629e..a30f2767f 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -1,4 +1,5 @@
 import type { TypeOf, ZodType } from "./index.ts";
+import { jsonStringifyReplacer } from "./helpers/parseUtil.ts";
 import { Primitive } from "./helpers/typeAliases.ts";
 import { util, ZodParsedType } from "./helpers/util.ts";
 
@@ -250,7 +251,7 @@ export class ZodError<T = any> extends Error {
     return this.message;
   }
   get message() {
-    return JSON.stringify(this.issues, null, 2);
+    return JSON.stringify(this.issues, jsonStringifyReplacer, 2);
   }
 
   get isEmpty(): boolean {
@@ -319,7 +320,8 @@ export const defaultErrorMap = (
       break;
     case ZodIssueCode.invalid_literal:
       message = `Invalid literal value, expected ${JSON.stringify(
-        issue.expected
+        issue.expected,
+        jsonStringifyReplacer
       )}`;
       break;
     case ZodIssueCode.unrecognized_keys:
@@ -411,8 +413,12 @@ export const defaultErrorMap = (
   return { message };
 };
 
-export let overrideErrorMap = defaultErrorMap;
+let overrideErrorMap = defaultErrorMap;
 
-export const setErrorMap = (map: ZodErrorMap) => {
+export function setErrorMap(map: ZodErrorMap) {
   overrideErrorMap = map;
-};
+}
+
+export function getErrorMap() {
+  return overrideErrorMap;
+}
diff --git a/deno/lib/__tests__/error.test.ts b/deno/lib/__tests__/error.test.ts
index 38140c12d..1c8568ddc 100644
--- a/deno/lib/__tests__/error.test.ts
+++ b/deno/lib/__tests__/error.test.ts
@@ -462,6 +462,18 @@ test("literal default error message", () => {
   }
 });
 
+test("literal bigint default error message", () => {
+  try {
+    z.literal(BigInt(12)).parse(BigInt(13));
+  } catch (err) {
+    const zerr: z.ZodError = err as any;
+    expect(zerr.issues.length).toEqual(1);
+    expect(zerr.issues[0].message).toEqual(
+      `Invalid literal value, expected "12"`
+    );
+  }
+});
+
 // test("dont short circuit on continuable errors", () => {
 //   const user = z
 //     .object({
diff --git a/deno/lib/__tests__/primitive.test.ts b/deno/lib/__tests__/primitive.test.ts
index 1d38ddad6..351eba8e7 100644
--- a/deno/lib/__tests__/primitive.test.ts
+++ b/deno/lib/__tests__/primitive.test.ts
@@ -8,6 +8,7 @@ import { Mocker } from "./Mocker.ts";
 const literalStringSchema = z.literal("asdf");
 const literalNumberSchema = z.literal(12);
 const literalBooleanSchema = z.literal(true);
+const literalBigIntSchema = z.literal(BigInt(42));
 const stringSchema = z.string();
 const numberSchema = z.number();
 const bigintSchema = z.bigint();
@@ -105,6 +106,30 @@ test("literal boolean object", () => {
   expect(f).toThrow();
 });
 
+test("literal bigint correct", () => {
+  expect(literalBigIntSchema.parse(BigInt(42))).toBe(BigInt(42));
+});
+
+test("literal bigint incorrect", () => {
+  const f = () => literalBigIntSchema.parse(BigInt(43));
+  expect(f).toThrow();
+});
+
+test("literal bigint number", () => {
+  const f = () => literalBigIntSchema.parse("asdf");
+  expect(f).toThrow();
+});
+
+test("literal bigint boolean", () => {
+  const f = () => literalBigIntSchema.parse(123);
+  expect(f).toThrow();
+});
+
+test("literal bigint object", () => {
+  const f = () => literalBigIntSchema.parse({});
+  expect(f).toThrow();
+});
+
 test("parse stringSchema string", () => {
   stringSchema.parse(val.string);
 });
@@ -326,6 +351,10 @@ test("primitive inference", () => {
     z.TypeOf<typeof literalBooleanSchema>,
     true
   > = true;
+  const literalBigIntSchemaTest: AssertEqual<
+    z.TypeOf<typeof literalBigIntSchema>,
+    bigint
+  > = true;
   const stringSchemaTest: AssertEqual<
     z.TypeOf<typeof stringSchema>,
     string
@@ -393,6 +422,7 @@ test("primitive inference", () => {
     literalStringSchemaTest,
     literalNumberSchemaTest,
     literalBooleanSchemaTest,
+    literalBigIntSchemaTest,
     stringSchemaTest,
     numberSchemaTest,
     bigintSchemaTest,
diff --git a/deno/lib/helpers/parseUtil.ts b/deno/lib/helpers/parseUtil.ts
index 4f81a3874..78c8531d7 100644
--- a/deno/lib/helpers/parseUtil.ts
+++ b/deno/lib/helpers/parseUtil.ts
@@ -1,5 +1,5 @@
 import type { IssueData, ZodErrorMap, ZodIssue } from "../ZodError.ts";
-import { defaultErrorMap, overrideErrorMap } from "../ZodError.ts";
+import { defaultErrorMap, getErrorMap } from "../ZodError.ts";
 import type { ZodParsedType } from "./util.ts";
 
 export const makeIssue = (params: {
@@ -71,7 +71,7 @@ export function addIssueToContext(
     errorMaps: [
       ctx.common.contextualErrorMap, // contextual error map is first priority
       ctx.schemaErrorMap, // then schema-bound map if available
-      overrideErrorMap, // then global override map
+      getErrorMap(), // then global override map
       defaultErrorMap, // then global default map
     ].filter((x) => !!x) as ZodErrorMap[],
   });
@@ -175,3 +175,10 @@ export const isAsync = <T>(
   x: ParseReturnType<T>
 ): x is AsyncParseReturnType<T> =>
   typeof Promise !== undefined && x instanceof Promise;
+
+export const jsonStringifyReplacer = (_: string, value: any): any => {
+  if (typeof value === "bigint") {
+    return value.toString();
+  }
+  return value;
+};
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index ac179c295..e51e2b25e 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -23,8 +23,8 @@ import { Primitive } from "./helpers/typeAliases.ts";
 import { getParsedType, util, ZodParsedType } from "./helpers/util.ts";
 import {
   defaultErrorMap,
+  getErrorMap,
   IssueData,
-  overrideErrorMap,
   StringValidation,
   ZodCustomIssue,
   ZodError,
@@ -2823,7 +2823,7 @@ export class ZodFunction<
         errorMaps: [
           ctx.common.contextualErrorMap,
           ctx.schemaErrorMap,
-          overrideErrorMap,
+          getErrorMap(),
           defaultErrorMap,
         ].filter((x) => !!x) as ZodErrorMap[],
         issueData: {
@@ -2840,7 +2840,7 @@ export class ZodFunction<
         errorMaps: [
           ctx.common.contextualErrorMap,
           ctx.schemaErrorMap,
-          overrideErrorMap,
+          getErrorMap(),
           defaultErrorMap,
         ].filter((x) => !!x) as ZodErrorMap[],
         issueData: {
diff --git a/package.json b/package.json
index 54b7fc19a..c99a790bd 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.17.5",
+  "version": "3.17.6",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./index.d.ts",
diff --git a/src/ZodError.ts b/src/ZodError.ts
index fe1422353..4b80d539f 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -1,4 +1,5 @@
 import type { TypeOf, ZodType } from ".";
+import { jsonStringifyReplacer } from "./helpers/parseUtil";
 import { Primitive } from "./helpers/typeAliases";
 import { util, ZodParsedType } from "./helpers/util";
 
@@ -250,7 +251,7 @@ export class ZodError<T = any> extends Error {
     return this.message;
   }
   get message() {
-    return JSON.stringify(this.issues, null, 2);
+    return JSON.stringify(this.issues, jsonStringifyReplacer, 2);
   }
 
   get isEmpty(): boolean {
@@ -319,7 +320,8 @@ export const defaultErrorMap = (
       break;
     case ZodIssueCode.invalid_literal:
       message = `Invalid literal value, expected ${JSON.stringify(
-        issue.expected
+        issue.expected,
+        jsonStringifyReplacer
       )}`;
       break;
     case ZodIssueCode.unrecognized_keys:
@@ -411,8 +413,12 @@ export const defaultErrorMap = (
   return { message };
 };
 
-export let overrideErrorMap = defaultErrorMap;
+let overrideErrorMap = defaultErrorMap;
 
-export const setErrorMap = (map: ZodErrorMap) => {
+export function setErrorMap(map: ZodErrorMap) {
   overrideErrorMap = map;
-};
+}
+
+export function getErrorMap() {
+  return overrideErrorMap;
+}
diff --git a/src/__tests__/error.test.ts b/src/__tests__/error.test.ts
index c4aa1deaa..47b6aea1a 100644
--- a/src/__tests__/error.test.ts
+++ b/src/__tests__/error.test.ts
@@ -461,6 +461,18 @@ test("literal default error message", () => {
   }
 });
 
+test("literal bigint default error message", () => {
+  try {
+    z.literal(BigInt(12)).parse(BigInt(13));
+  } catch (err) {
+    const zerr: z.ZodError = err as any;
+    expect(zerr.issues.length).toEqual(1);
+    expect(zerr.issues[0].message).toEqual(
+      `Invalid literal value, expected "12"`
+    );
+  }
+});
+
 // test("dont short circuit on continuable errors", () => {
 //   const user = z
 //     .object({
diff --git a/src/__tests__/primitive.test.ts b/src/__tests__/primitive.test.ts
index 68cc209da..acd950fa5 100644
--- a/src/__tests__/primitive.test.ts
+++ b/src/__tests__/primitive.test.ts
@@ -7,6 +7,7 @@ import { Mocker } from "./Mocker";
 const literalStringSchema = z.literal("asdf");
 const literalNumberSchema = z.literal(12);
 const literalBooleanSchema = z.literal(true);
+const literalBigIntSchema = z.literal(BigInt(42));
 const stringSchema = z.string();
 const numberSchema = z.number();
 const bigintSchema = z.bigint();
@@ -104,6 +105,30 @@ test("literal boolean object", () => {
   expect(f).toThrow();
 });
 
+test("literal bigint correct", () => {
+  expect(literalBigIntSchema.parse(BigInt(42))).toBe(BigInt(42));
+});
+
+test("literal bigint incorrect", () => {
+  const f = () => literalBigIntSchema.parse(BigInt(43));
+  expect(f).toThrow();
+});
+
+test("literal bigint number", () => {
+  const f = () => literalBigIntSchema.parse("asdf");
+  expect(f).toThrow();
+});
+
+test("literal bigint boolean", () => {
+  const f = () => literalBigIntSchema.parse(123);
+  expect(f).toThrow();
+});
+
+test("literal bigint object", () => {
+  const f = () => literalBigIntSchema.parse({});
+  expect(f).toThrow();
+});
+
 test("parse stringSchema string", () => {
   stringSchema.parse(val.string);
 });
@@ -325,6 +350,10 @@ test("primitive inference", () => {
     z.TypeOf<typeof literalBooleanSchema>,
     true
   > = true;
+  const literalBigIntSchemaTest: AssertEqual<
+    z.TypeOf<typeof literalBigIntSchema>,
+    bigint
+  > = true;
   const stringSchemaTest: AssertEqual<
     z.TypeOf<typeof stringSchema>,
     string
@@ -392,6 +421,7 @@ test("primitive inference", () => {
     literalStringSchemaTest,
     literalNumberSchemaTest,
     literalBooleanSchemaTest,
+    literalBigIntSchemaTest,
     stringSchemaTest,
     numberSchemaTest,
     bigintSchemaTest,
diff --git a/src/helpers/parseUtil.ts b/src/helpers/parseUtil.ts
index 2416d376d..7df8c0b02 100644
--- a/src/helpers/parseUtil.ts
+++ b/src/helpers/parseUtil.ts
@@ -1,5 +1,5 @@
 import type { IssueData, ZodErrorMap, ZodIssue } from "../ZodError";
-import { defaultErrorMap, overrideErrorMap } from "../ZodError";
+import { defaultErrorMap, getErrorMap } from "../ZodError";
 import type { ZodParsedType } from "./util";
 
 export const makeIssue = (params: {
@@ -71,7 +71,7 @@ export function addIssueToContext(
     errorMaps: [
       ctx.common.contextualErrorMap, // contextual error map is first priority
       ctx.schemaErrorMap, // then schema-bound map if available
-      overrideErrorMap, // then global override map
+      getErrorMap(), // then global override map
       defaultErrorMap, // then global default map
     ].filter((x) => !!x) as ZodErrorMap[],
   });
@@ -175,3 +175,10 @@ export const isAsync = <T>(
   x: ParseReturnType<T>
 ): x is AsyncParseReturnType<T> =>
   typeof Promise !== undefined && x instanceof Promise;
+
+export const jsonStringifyReplacer = (_: string, value: any): any => {
+  if (typeof value === "bigint") {
+    return value.toString();
+  }
+  return value;
+};
diff --git a/src/types.ts b/src/types.ts
index 5d78e224b..4f014884a 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -23,8 +23,8 @@ import { Primitive } from "./helpers/typeAliases";
 import { getParsedType, util, ZodParsedType } from "./helpers/util";
 import {
   defaultErrorMap,
+  getErrorMap,
   IssueData,
-  overrideErrorMap,
   StringValidation,
   ZodCustomIssue,
   ZodError,
@@ -2823,7 +2823,7 @@ export class ZodFunction<
         errorMaps: [
           ctx.common.contextualErrorMap,
           ctx.schemaErrorMap,
-          overrideErrorMap,
+          getErrorMap(),
           defaultErrorMap,
         ].filter((x) => !!x) as ZodErrorMap[],
         issueData: {
@@ -2840,7 +2840,7 @@ export class ZodFunction<
         errorMaps: [
           ctx.common.contextualErrorMap,
           ctx.schemaErrorMap,
-          overrideErrorMap,
+          getErrorMap(),
           defaultErrorMap,
         ].filter((x) => !!x) as ZodErrorMap[],
         issueData: {
