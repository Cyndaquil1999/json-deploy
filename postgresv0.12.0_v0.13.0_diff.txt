diff --git a/Dockerfile b/Dockerfile
index c8bdcc24..9f91b950 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,4 +1,4 @@
-FROM denoland/deno:alpine-1.11.0
+FROM denoland/deno:alpine-1.14.1
 WORKDIR /app
 
 # Install wait utility
@@ -18,8 +18,8 @@ ADD . .
 RUN deno cache mod.ts
 
 # Code health checks
-RUN deno lint
+RUN deno lint --config=deno.json
 RUN deno fmt --check
 
 # Run tests
-CMD /wait && deno test --unstable -A
+CMD /wait && deno test --unstable -A --jobs
diff --git a/README.md b/README.md
index 1ef8cee9..d3097753 100644
--- a/README.md
+++ b/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 [![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)](https://deno-postgres.com)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.12.0/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.13.0/mod.ts)
 [![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)](LICENSE)
 
 A lightweight PostgreSQL driver for Deno focused on user experience
@@ -126,20 +126,25 @@ Deno.test("INSERT works correctly", async () => {
 
 ### Setting up an advanced development environment
 
-More advanced features such as the Deno inspector, test filtering, database
-inspection and permission filtering can be achieved by setting up a local
-testing environment, as shown in the following steps:
+More advanced features such as the Deno inspector, test and permission
+filtering, database inspection and test code lens can be achieved by setting up
+a local testing environment, as shown in the following steps:
 
 1. Start the development databases using the Docker service with the command\
-   `docker-compose up postgres postgres_scram postgres_invalid_tls`\
+   `docker-compose up postgres_classic postgres_scram`\
    Though using the detach (`-d`) option is recommended, this will make the
    databases run in the background unless you use docker itself to stop them.
    You can find more info about this
    [here](https://docs.docker.com/compose/reference/up)
-2. Run the tests manually by using the command\
-   `DEVELOPMENT=true deno test --unstable -A`\
-   The `DEVELOPMENT` variable will tell the testing pipeline to use the local
-   testing settings specified in `tests/config.json`
+2. Set the `DENO_POSTGRES_DEVELOPMENT` environmental variable to true, either by
+   prepending it before the test command (on Linux) or setting it globally for
+   all environments
+
+   The `DENO_POSTGRES_DEVELOPMENT` variable will tell the testing pipeline to
+   use the local testing settings specified in `tests/config.json`, instead of
+   the CI settings
+3. Run the tests manually by using the command\
+   `deno test --unstable -A`
 
 ## Deno compatibility
 
@@ -148,12 +153,13 @@ Due to a not intended breaking change in Deno 1.9.0, two versions of
 the following is a compatibility table that ranges from Deno 1.8 to Deno 1.9 and
 above indicating possible compatibility problems
 
-| Deno version | Min driver version | Max driver version |
-| ------------ | ------------------ | ------------------ |
-| 1.8.x        | 0.5.0              | 0.10.0             |
-| 1.9.0        | 0.11.0             | 0.11.1             |
-| 1.9.1 and up | 0.11.2             | 0.11.3             |
-| 1.11.x       | 0.12.0             |                    |
+| Deno version  | Min driver version | Max driver version |
+| ------------- | ------------------ | ------------------ |
+| 1.8.x         | 0.5.0              | 0.10.0             |
+| 1.9.0         | 0.11.0             | 0.11.1             |
+| 1.9.1 and up  | 0.11.2             | 0.11.3             |
+| 1.11.0 and up | 0.12.0             | 0.13.0             |
+| 1.14.x        | 0.13.0             |                    |
 
 ## Contributing guidelines
 
@@ -163,9 +169,9 @@ When contributing to repository make sure to:
 2. All public interfaces must be typed and have a corresponding JS block
    explaining their usage
 3. All code must pass the format and lint checks enforced by `deno fmt` and
-   `deno lint --unstable` respectively. The build will not pass the tests if
-   these conditions are not met. Ignore rules will be accepted in the code base
-   when their respective justification is given in a comment
+   `deno lint --config=deno.json` respectively. The build will not pass the
+   tests if these conditions are not met. Ignore rules will be accepted in the
+   code base when their respective justification is given in a comment
 4. All features and fixes must have a corresponding test added in order to be
    accepted
 
diff --git a/client.ts b/client.ts
index 8bb53a74..9261401f 100644
--- a/client.ts
+++ b/client.ts
@@ -1,4 +1,3 @@
-// deno-lint-ignore-file camelcase
 import { Connection } from "./connection/connection.ts";
 import {
   ClientConfiguration,
@@ -31,6 +30,11 @@ export interface Session {
    * on connection. This id will undefined when there is no connection stablished
    */
   pid: number | undefined;
+  /**
+   * Indicates if the connection is being carried over TLS. It will be undefined when
+   * there is no connection stablished
+   */
+  tls: boolean | undefined;
 }
 
 export abstract class QueryClient {
@@ -42,8 +46,6 @@ export abstract class QueryClient {
     this.#connection = connection;
   }
 
-  // TODO
-  // Add comment about reconnection attempts
   get connected() {
     return this.#connection.connected;
   }
@@ -52,6 +54,7 @@ export abstract class QueryClient {
     return {
       current_transaction: this.#transaction,
       pid: this.#connection.pid,
+      tls: this.#connection.tls,
     };
   }
 
@@ -154,8 +157,8 @@ export abstract class QueryClient {
    * // transaction_2 now shares the same starting state that transaction_1 had
    * ```
    *
-   * https://www.postgresql.org/docs/13/tutorial-transactions.html
-   * https://www.postgresql.org/docs/13/sql-set-transaction.html
+   * https://www.postgresql.org/docs/14/tutorial-transactions.html
+   * https://www.postgresql.org/docs/14/sql-set-transaction.html
    */
   createTransaction(name: string, options?: TransactionOptions): Transaction {
     this.#assertOpenConnection();
@@ -362,8 +365,6 @@ export abstract class QueryClient {
   }
 }
 
-// TODO
-// Check for client connection and re-connection
 /**
  * Clients allow you to communicate with your PostgreSQL database and execute SQL
  * statements asynchronously
diff --git a/client/error.ts b/client/error.ts
new file mode 100644
index 00000000..5b11bd66
--- /dev/null
+++ b/client/error.ts
@@ -0,0 +1,39 @@
+import type { Notice } from "../connection/message.ts";
+
+export class ConnectionError extends Error {
+  constructor(message?: string) {
+    super(message);
+    this.name = "ConnectionError";
+  }
+}
+
+export class ConnectionParamsError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = "ConnectionParamsError";
+  }
+}
+
+export class PostgresError extends Error {
+  public fields: Notice;
+
+  constructor(fields: Notice) {
+    super(fields.message);
+    this.fields = fields;
+    this.name = "PostgresError";
+  }
+}
+
+// TODO
+// Use error cause once it's added to JavaScript
+export class TransactionError extends Error {
+  constructor(
+    transaction_name: string,
+    public cause: PostgresError,
+  ) {
+    super(
+      `The transaction "${transaction_name}" has been aborted due to \`${cause}\`. Check the "cause" property to get more details`,
+    );
+    this.name = "TransactionError";
+  }
+}
diff --git a/connection/auth.ts b/connection/auth.ts
new file mode 100644
index 00000000..52a681c9
--- /dev/null
+++ b/connection/auth.ts
@@ -0,0 +1,25 @@
+import { createHash } from "../deps.ts";
+
+const encoder = new TextEncoder();
+
+function md5(bytes: Uint8Array): string {
+  return createHash("md5").update(bytes).toString("hex");
+}
+
+// AuthenticationMD5Password
+// The actual PasswordMessage can be computed in SQL as:
+//  concat('md5', md5(concat(md5(concat(password, username)), random-salt))).
+// (Keep in mind the md5() function returns its result as a hex string.)
+export function hashMd5Password(
+  password: string,
+  username: string,
+  salt: Uint8Array,
+): string {
+  const innerHash = md5(encoder.encode(password + username));
+  const innerBytes = encoder.encode(innerHash);
+  const outerBuffer = new Uint8Array(innerBytes.length + salt.length);
+  outerBuffer.set(innerBytes);
+  outerBuffer.set(salt, innerBytes.length);
+  const outerHash = md5(outerBuffer);
+  return "md5" + outerHash;
+}
diff --git a/connection/connection.ts b/connection/connection.ts
index dd3b4002..456a97d4 100644
--- a/connection/connection.ts
+++ b/connection/connection.ts
@@ -1,5 +1,3 @@
-// deno-lint-ignore-file camelcase
-
 /*!
  * Substantial parts adapted from https://github.com/brianc/node-postgres
  * which is licensed as follows:
@@ -30,56 +28,55 @@
 
 import { bold, BufReader, BufWriter, yellow } from "../deps.ts";
 import { DeferredStack } from "../utils/deferred.ts";
-import { hashMd5Password, readUInt32BE } from "../utils/utils.ts";
-import { PacketWriter } from "./packet_writer.ts";
-import { Message, parseError, parseNotice } from "./warning.ts";
+import { readUInt32BE } from "../utils/utils.ts";
+import { PacketWriter } from "./packet.ts";
+import {
+  Message,
+  Notice,
+  parseBackendKeyMessage,
+  parseCommandCompleteMessage,
+  parseNoticeMessage,
+  parseRowDataMessage,
+  parseRowDescriptionMessage,
+} from "./message.ts";
 import {
   Query,
   QueryArrayResult,
   QueryObjectResult,
   QueryResult,
   ResultType,
-  RowDescription,
 } from "../query/query.ts";
-import { Column } from "../query/decode.ts";
-import type { ClientConfiguration } from "./connection_params.ts";
+import { ClientConfiguration } from "./connection_params.ts";
 import * as scram from "./scram.ts";
-import { ConnectionError } from "./warning.ts";
-
-enum TransactionStatus {
-  Idle = "I",
-  IdleInTransaction = "T",
-  InFailedTransaction = "E",
-}
-
-/**
- * This asserts the argument bind response is succesful
- */
-function assertArgumentsResponse(msg: Message) {
-  switch (msg.type) {
-    // bind completed
-    case "2":
-      // no-op
-      break;
-    // error response
-    case "E":
-      throw parseError(msg);
-    default:
-      throw new Error(`Unexpected frame: ${msg.type}`);
-  }
-}
+import {
+  ConnectionError,
+  ConnectionParamsError,
+  PostgresError,
+} from "../client/error.ts";
+import {
+  AUTHENTICATION_TYPE,
+  ERROR_MESSAGE,
+  INCOMING_AUTHENTICATION_MESSAGES,
+  INCOMING_QUERY_MESSAGES,
+  INCOMING_TLS_MESSAGES,
+} from "./message_code.ts";
+import { hashMd5Password } from "./auth.ts";
 
 function assertSuccessfulStartup(msg: Message) {
   switch (msg.type) {
-    case "E":
-      throw parseError(msg);
+    case ERROR_MESSAGE:
+      throw new PostgresError(parseNoticeMessage(msg));
   }
 }
 
 function assertSuccessfulAuthentication(auth_message: Message) {
-  if (auth_message.type === "E") {
-    throw parseError(auth_message);
-  } else if (auth_message.type !== "R") {
+  if (auth_message.type === ERROR_MESSAGE) {
+    throw new PostgresError(parseNoticeMessage(auth_message));
+  }
+
+  if (
+    auth_message.type !== INCOMING_AUTHENTICATION_MESSAGES.AUTHENTICATION
+  ) {
     throw new Error(`Unexpected auth response: ${auth_message.type}.`);
   }
 
@@ -89,22 +86,8 @@ function assertSuccessfulAuthentication(auth_message: Message) {
   }
 }
 
-/**
- * This asserts the query parse response is succesful
- */
-function assertQueryResponse(msg: Message) {
-  switch (msg.type) {
-    // parse completed
-    case "1":
-      // TODO: add to already parsed queries if
-      // query has name, so it's not parsed again
-      break;
-    // error response
-    case "E":
-      throw parseError(msg);
-    default:
-      throw new Error(`Unexpected frame: ${msg.type}`);
-  }
+function logNotice(notice: Notice) {
+  console.error(`${bold(yellow(notice.severity))}: ${notice.message}`);
 }
 
 const decoder = new TextDecoder();
@@ -113,19 +96,15 @@ const encoder = new TextEncoder();
 // TODO
 // - Refactor properties to not be lazily initialized
 //   or to handle their undefined value
-// - Expose connection PID as a method
-// - Cleanup properties on startup to guarantee safe reconnection
 export class Connection {
   #bufReader!: BufReader;
   #bufWriter!: BufWriter;
   #conn!: Deno.Conn;
   connected = false;
   #connection_params: ClientConfiguration;
+  #message_header = new Uint8Array(5);
   #onDisconnection: () => Promise<void>;
   #packetWriter = new PacketWriter();
-  // TODO
-  // Find out what parameters are for
-  #parameters: { [key: string]: string } = {};
   #pid?: number;
   #queryLock: DeferredStack<undefined> = new DeferredStack(
     1,
@@ -133,13 +112,8 @@ export class Connection {
   );
   // TODO
   // Find out what the secret key is for
-  // Clean on startup
   #secretKey?: number;
-  #tls = false;
-  // TODO
-  // Find out what the transaction status is used for
-  // Clean on startup
-  #transactionStatus?: TransactionStatus;
+  #tls?: boolean;
 
   get pid() {
     return this.#pid;
@@ -158,16 +132,18 @@ export class Connection {
     this.#onDisconnection = disconnection_callback;
   }
 
-  /** Read single message sent by backend */
+  /**
+   * Read single message sent by backend
+   */
   async #readMessage(): Promise<Message> {
-    // TODO: reuse buffer instead of allocating new ones each for each read
-    const header = new Uint8Array(5);
-    await this.#bufReader.readFull(header);
-    const msgType = decoder.decode(header.slice(0, 1));
+    // Clear buffer before reading the message type
+    this.#message_header.fill(0);
+    await this.#bufReader.readFull(this.#message_header);
+    const type = decoder.decode(this.#message_header.slice(0, 1));
     // TODO
     // Investigate if the ascii terminator is the best way to check for a broken
     // session
-    if (msgType === "\x00") {
+    if (type === "\x00") {
       // This error means that the database terminated the session without notifying
       // the library
       // TODO
@@ -176,11 +152,11 @@ export class Connection {
       // be handled in another place
       throw new ConnectionError("The session was terminated by the database");
     }
-    const msgLength = readUInt32BE(header, 1) - 4;
-    const msgBody = new Uint8Array(msgLength);
-    await this.#bufReader.readFull(msgBody);
+    const length = readUInt32BE(this.#message_header, 1) - 4;
+    const body = new Uint8Array(length);
+    await this.#bufReader.readFull(body);
 
-    return new Message(msgType, msgLength, msgBody);
+    return new Message(type, length, body);
   }
 
   async #serverAcceptsTLS(): Promise<boolean> {
@@ -198,9 +174,9 @@ export class Connection {
     await this.#conn.read(response);
 
     switch (String.fromCharCode(response[0])) {
-      case "S":
+      case INCOMING_TLS_MESSAGES.ACCEPTS_TLS:
         return true;
-      case "N":
+      case INCOMING_TLS_MESSAGES.NO_ACCEPTS_TLS:
         return false;
       default:
         throw new Error(
@@ -251,7 +227,7 @@ export class Connection {
 
   async #createTlsConnection(
     connection: Deno.Conn,
-    options: Deno.ConnectOptions,
+    options: { hostname: string; certFile?: string },
   ) {
     if ("startTls" in Deno) {
       // @ts-ignore This API should be available on unstable
@@ -268,70 +244,80 @@ export class Connection {
   #resetConnectionMetadata() {
     this.connected = false;
     this.#packetWriter = new PacketWriter();
-    this.#parameters = {};
     this.#pid = undefined;
     this.#queryLock = new DeferredStack(
       1,
       [undefined],
     );
     this.#secretKey = undefined;
-    this.#tls = false;
-    this.#transactionStatus = undefined;
+    this.#tls = undefined;
   }
 
-  async #startup() {
+  #closeConnection() {
     try {
       this.#conn.close();
     } catch (_e) {
-      // Swallow error
+      // Swallow if the connection had errored or been closed beforehand
+    } finally {
+      this.#resetConnectionMetadata();
     }
-    this.#resetConnectionMetadata();
+  }
+
+  async #startup() {
+    this.#closeConnection();
 
     const {
       hostname,
       port,
       tls: {
-        enforce: enforceTLS,
+        enabled: tls_enabled,
+        enforce: tls_enforced,
+        caFile,
       },
     } = this.#connection_params;
 
     // A BufWriter needs to be available in order to check if the server accepts TLS connections
     await this.#createNonTlsConnection({ hostname, port });
+    this.#tls = false;
 
-    const accepts_tls = await this.#serverAcceptsTLS()
-      .catch((e) => {
-        // Make sure to close the connection if the TLS validation throws
-        this.#conn.close();
-        throw e;
-      });
-
-    /**
-     * https://www.postgresql.org/docs/13/protocol-flow.html#id-1.10.5.7.11
-     * */
-    if (accepts_tls) {
-      try {
-        await this.#createTlsConnection(this.#conn, { hostname, port });
-        this.#tls = true;
-      } catch (e) {
-        if (!enforceTLS) {
-          console.error(
-            bold(yellow("TLS connection failed with message: ")) +
-              e.message +
-              "\n" +
-              bold("Defaulting to non-encrypted connection"),
-          );
-          await this.#createNonTlsConnection({ hostname, port });
-          this.#tls = false;
-        } else {
+    if (tls_enabled) {
+      // If TLS is disabled, we don't even try to connect.
+      const accepts_tls = await this.#serverAcceptsTLS()
+        .catch((e) => {
+          // Make sure to close the connection if the TLS validation throws
+          this.#closeConnection();
           throw e;
+        });
+
+      // https://www.postgresql.org/docs/14/protocol-flow.html#id-1.10.5.7.11
+      if (accepts_tls) {
+        try {
+          await this.#createTlsConnection(this.#conn, {
+            hostname,
+            certFile: caFile,
+          });
+          this.#tls = true;
+        } catch (e) {
+          if (!tls_enforced) {
+            console.error(
+              bold(yellow("TLS connection failed with message: ")) +
+                e.message +
+                "\n" +
+                bold("Defaulting to non-encrypted connection"),
+            );
+            await this.#createNonTlsConnection({ hostname, port });
+            this.#tls = false;
+          } else {
+            throw e;
+          }
         }
+      } else if (tls_enforced) {
+        // Make sure to close the connection before erroring
+        this.#closeConnection();
+        throw new Error(
+          "The server isn't accepting TLS connections. Change the client configuration so TLS configuration isn't required to connect",
+        );
       }
-    } else if (enforceTLS) {
-      // Make sure to close the connection before erroring
-      this.#conn.close();
-      throw new Error(
-        "The server isn't accepting TLS connections. Change the client configuration so TLS configuration isn't required to connect",
-      );
     }
 
     try {
@@ -339,10 +325,12 @@ export class Connection {
       try {
         startup_response = await this.#sendStartupMessage();
       } catch (e) {
-        if (e instanceof Deno.errors.InvalidData) {
-          if (enforceTLS) {
+        // Make sure to close the connection before erroring or reseting
+        this.#closeConnection();
+        if (e instanceof Deno.errors.InvalidData && tls_enabled) {
+          if (tls_enforced) {
             throw new Error(
-              "The certificate used to secure the TLS connection is invalid",
+              "The certificate used to secure the TLS connection is invalid.",
             );
           } else {
             console.error(
@@ -363,37 +351,32 @@ export class Connection {
       await this.#authenticate(startup_response);
 
       // Handle connection status
-      // (connected but not ready)
-      let msg;
-      connection_status:
-      while (true) {
-        msg = await this.#readMessage();
-        switch (msg.type) {
+      // Process connection initialization messages until connection returns ready
+      let message = await this.#readMessage();
+      while (message.type !== INCOMING_AUTHENTICATION_MESSAGES.READY) {
+        switch (message.type) {
           // Connection error (wrong database or user)
-          case "E":
-            await this.#processError(msg, false);
+          case ERROR_MESSAGE:
+            await this.#processErrorUnsafe(message, false);
             break;
-          // backend key data
-          case "K":
-            this.#processBackendKeyData(msg);
+          case INCOMING_AUTHENTICATION_MESSAGES.BACKEND_KEY: {
+            const { pid, secret_key } = parseBackendKeyMessage(message);
+            this.#pid = pid;
+            this.#secretKey = secret_key;
             break;
-          // parameter status
-          case "S":
-            this.#processParameterStatus(msg);
-            break;
-          // ready for query
-          case "Z": {
-            this.#processReadyForQuery(msg);
-            break connection_status;
           }
+          case INCOMING_AUTHENTICATION_MESSAGES.PARAMETER_STATUS:
+            break;
           default:
-            throw new Error(`Unknown response for startup: ${msg.type}`);
+            throw new Error(`Unknown response for startup: ${message.type}`);
         }
+
+        message = await this.#readMessage();
       }
 
       this.connected = true;
     } catch (e) {
-      this.#conn.close();
+      this.#closeConnection();
       throw e;
     }
   }
@@ -404,8 +387,8 @@ export class Connection {
    * @param is_reconnection This indicates whether the startup should behave as if there was
    * a connection previously established, or if it should attempt to create a connection first
    *
-   * https://www.postgresql.org/docs/13/protocol-flow.html#id-1.10.5.7.3
-   * */
+   * https://www.postgresql.org/docs/14/protocol-flow.html#id-1.10.5.7.3
+   */
   async startup(is_reconnection: boolean) {
     if (is_reconnection && this.#connection_params.connection.attempts === 0) {
       throw new Error(
@@ -450,47 +433,50 @@ export class Connection {
     }
   }
 
-  // TODO
-  // Why is this handling the startup message response?
   /**
-   * Will attempt to #authenticate with the database using the provided
+   * Will attempt to authenticate with the database using the provided
    * password credentials
    */
-  async #authenticate(msg: Message) {
-    const code = msg.reader.readInt32();
-    switch (code) {
-      // pass
-      case 0:
+  async #authenticate(authentication_request: Message) {
+    const authentication_type = authentication_request.reader.readInt32();
+
+    let authentication_result: Message;
+    switch (authentication_type) {
+      case AUTHENTICATION_TYPE.NO_AUTHENTICATION:
+        authentication_result = authentication_request;
         break;
-      // cleartext password
-      case 3:
-        await assertSuccessfulAuthentication(
-          await this.#authenticateWithClearPassword(),
-        );
+      case AUTHENTICATION_TYPE.CLEAR_TEXT:
+        authentication_result = await this.#authenticateWithClearPassword();
         break;
-      // md5 password
-      case 5: {
-        const salt = msg.reader.readBytes(4);
-        await assertSuccessfulAuthentication(
-          await this.#authenticateWithMd5(salt),
-        );
+      case AUTHENTICATION_TYPE.MD5: {
+        const salt = authentication_request.reader.readBytes(4);
+        authentication_result = await this.#authenticateWithMd5(salt);
         break;
       }
-      case 7: {
+      case AUTHENTICATION_TYPE.SCM:
         throw new Error(
-          "Database server expected gss authentication, which is not supported at the moment",
+          "Database server expected SCM authentication, which is not supported at the moment",
         );
-      }
-      // scram-sha-256 password
-      case 10: {
-        await assertSuccessfulAuthentication(
-          await this.#authenticateWithScramSha256(),
+      case AUTHENTICATION_TYPE.GSS_STARTUP:
+        throw new Error(
+          "Database server expected GSS authentication, which is not supported at the moment",
+        );
+      case AUTHENTICATION_TYPE.GSS_CONTINUE:
+        throw new Error(
+          "Database server expected GSS authentication, which is not supported at the moment",
+        );
+      case AUTHENTICATION_TYPE.SSPI:
+        throw new Error(
+          "Database server expected SSPI authentication, which is not supported at the moment",
         );
+      case AUTHENTICATION_TYPE.SASL_STARTUP:
+        authentication_result = await this.#authenticateWithSasl();
         break;
-      }
       default:
-        throw new Error(`Unknown auth message code ${code}`);
+        throw new Error(`Unknown auth message code ${authentication_type}`);
     }
+
+    await assertSuccessfulAuthentication(authentication_result);
   }
 
   async #authenticateWithClearPassword(): Promise<Message> {
@@ -508,7 +494,9 @@ export class Connection {
     this.#packetWriter.clear();
 
     if (!this.#connection_params.password) {
-      throw new Error("Auth Error: attempting MD5 auth with password unset");
+      throw new ConnectionParamsError(
+        "Attempting MD5 authentication with unset password",
+      );
     }
 
     const password = hashMd5Password(
@@ -524,10 +512,13 @@ export class Connection {
     return this.#readMessage();
   }
 
-  async #authenticateWithScramSha256(): Promise<Message> {
+  /**
+   * https://www.postgresql.org/docs/14/sasl-authentication.html
+   */
+  async #authenticateWithSasl(): Promise<Message> {
     if (!this.#connection_params.password) {
-      throw new Error(
-        "Auth Error: attempting SCRAM-SHA-256 auth with password unset",
+      throw new ConnectionParamsError(
+        "Attempting SASL auth with unset password",
       );
     }
 
@@ -546,90 +537,66 @@ export class Connection {
     this.#bufWriter.write(this.#packetWriter.flush(0x70));
     this.#bufWriter.flush();
 
-    // AuthenticationSASLContinue
-    const saslContinue = await this.#readMessage();
-    switch (saslContinue.type) {
-      case "R": {
-        if (saslContinue.reader.readInt32() != 11) {
-          throw new Error("AuthenticationSASLContinue is expected");
+    const maybe_sasl_continue = await this.#readMessage();
+    switch (maybe_sasl_continue.type) {
+      case INCOMING_AUTHENTICATION_MESSAGES.AUTHENTICATION: {
+        const authentication_type = maybe_sasl_continue.reader.readInt32();
+        if (authentication_type !== AUTHENTICATION_TYPE.SASL_CONTINUE) {
+          throw new Error(
+            `Unexpected authentication type in SASL negotiation: ${authentication_type}`,
+          );
         }
         break;
       }
-      case "E": {
-        throw parseError(saslContinue);
-      }
-      default: {
-        throw new Error("unexpected message");
-      }
+      case ERROR_MESSAGE:
+        throw new PostgresError(parseNoticeMessage(maybe_sasl_continue));
+      default:
+        throw new Error(
+          `Unexpected message in SASL negotiation: ${maybe_sasl_continue.type}`,
+        );
     }
-    const serverFirstMessage = utf8.decode(saslContinue.reader.readAllBytes());
-    await client.receiveChallenge(serverFirstMessage);
+    const sasl_continue = utf8.decode(
+      maybe_sasl_continue.reader.readAllBytes(),
+    );
+    await client.receiveChallenge(sasl_continue);
 
     this.#packetWriter.clear();
-    // SASLResponse
     this.#packetWriter.addString(await client.composeResponse());
     this.#bufWriter.write(this.#packetWriter.flush(0x70));
     this.#bufWriter.flush();
 
-    // AuthenticationSASLFinal
-    const saslFinal = await this.#readMessage();
-    switch (saslFinal.type) {
-      case "R": {
-        if (saslFinal.reader.readInt32() !== 12) {
-          throw new Error("AuthenticationSASLFinal is expected");
+    const maybe_sasl_final = await this.#readMessage();
+    switch (maybe_sasl_final.type) {
+      case INCOMING_AUTHENTICATION_MESSAGES.AUTHENTICATION: {
+        const authentication_type = maybe_sasl_final.reader.readInt32();
+        if (authentication_type !== AUTHENTICATION_TYPE.SASL_FINAL) {
+          throw new Error(
+            `Unexpected authentication type in SASL finalization: ${authentication_type}`,
+          );
         }
         break;
       }
-      case "E": {
-        throw parseError(saslFinal);
-      }
-      default: {
-        throw new Error("unexpected message");
-      }
+      case ERROR_MESSAGE:
+        throw new PostgresError(parseNoticeMessage(maybe_sasl_final));
+      default:
+        throw new Error(
+          `Unexpected message in SASL finalization: ${maybe_sasl_continue.type}`,
+        );
     }
-    const serverFinalMessage = utf8.decode(saslFinal.reader.readAllBytes());
-    await client.receiveResponse(serverFinalMessage);
+    const sasl_final = utf8.decode(
+      maybe_sasl_final.reader.readAllBytes(),
+    );
+    await client.receiveResponse(sasl_final);
 
-    // AuthenticationOK
+    // Return authentication result
     return this.#readMessage();
   }
 
-  #processBackendKeyData(msg: Message) {
-    this.#pid = msg.reader.readInt32();
-    this.#secretKey = msg.reader.readInt32();
-  }
-
-  #processParameterStatus(msg: Message) {
-    // TODO: should we save all parameters?
-    const key = msg.reader.readCString();
-    const value = msg.reader.readCString();
-    this.#parameters[key] = value;
-  }
-
-  #processReadyForQuery(msg: Message) {
-    const txStatus = msg.reader.readByte();
-    this.#transactionStatus = String.fromCharCode(
-      txStatus,
-    ) as TransactionStatus;
-  }
-
-  async #readReadyForQuery() {
-    const msg = await this.#readMessage();
-
-    if (msg.type !== "Z") {
-      throw new Error(
-        `Unexpected message type: ${msg.type}, expected "Z" (ReadyForQuery)`,
-      );
-    }
-
-    this.#processReadyForQuery(msg);
-  }
-
   async #simpleQuery(
-    _query: Query<ResultType.ARRAY>,
+    query: Query<ResultType.ARRAY>,
   ): Promise<QueryArrayResult>;
   async #simpleQuery(
-    _query: Query<ResultType.OBJECT>,
+    query: Query<ResultType.OBJECT>,
   ): Promise<QueryObjectResult>;
   async #simpleQuery(
     query: Query<ResultType>,
@@ -648,75 +615,56 @@ export class Connection {
       result = new QueryObjectResult(query);
     }
 
-    let msg: Message;
-
-    msg = await this.#readMessage();
-
-    // Query startup message, executed only once
-    switch (msg.type) {
-      // row description
-      case "T":
-        result.loadColumnDescriptions(this.#parseRowDescription(msg));
-        break;
-      // no data
-      case "n":
-        break;
-      // error response
-      case "E":
-        await this.#processError(msg);
-        break;
-      // notice response
-      case "N":
-        result.warnings.push(await this.#processNotice(msg));
-        break;
-      // command complete
-      // TODO: this is duplicated in next loop
-      case "C": {
-        const commandTag = this.#getCommandTag(msg);
-        result.handleCommandComplete(commandTag);
-        result.done();
-        break;
-      }
-      default:
-        throw new Error(`Unexpected frame: ${msg.type}`);
-    }
-
-    // Handle each row returned by the query
-    while (true) {
-      msg = await this.#readMessage();
-      switch (msg.type) {
-        // data row
-        case "D": {
-          // this is actually packet read
-          result.insertRow(this.#parseRowData(msg));
+    let error: Error | undefined;
+    let current_message = await this.#readMessage();
+
+    // Process messages until ready signal is sent
+    // Delay error handling until after the ready signal is sent
+    while (current_message.type !== INCOMING_QUERY_MESSAGES.READY) {
+      switch (current_message.type) {
+        case ERROR_MESSAGE:
+          error = new PostgresError(parseNoticeMessage(current_message));
+          break;
+        case INCOMING_QUERY_MESSAGES.COMMAND_COMPLETE: {
+          result.handleCommandComplete(
+            parseCommandCompleteMessage(current_message),
+          );
           break;
         }
-        // command complete
-        case "C": {
-          const commandTag = this.#getCommandTag(msg);
-          result.handleCommandComplete(commandTag);
-          result.done();
+        case INCOMING_QUERY_MESSAGES.DATA_ROW: {
+          result.insertRow(parseRowDataMessage(current_message));
           break;
         }
-        // ready for query
-        case "Z":
-          this.#processReadyForQuery(msg);
-          return result;
-        // error response
-        case "E":
-          await this.#processError(msg);
+        case INCOMING_QUERY_MESSAGES.EMPTY_QUERY:
           break;
-        // notice response
-        case "N":
-          result.warnings.push(await this.#processNotice(msg));
+        case INCOMING_QUERY_MESSAGES.NOTICE_WARNING: {
+          const notice = parseNoticeMessage(current_message);
+          logNotice(notice);
+          result.warnings.push(notice);
           break;
-        case "T":
-          result.loadColumnDescriptions(this.#parseRowDescription(msg));
+        }
+        case INCOMING_QUERY_MESSAGES.PARAMETER_STATUS:
           break;
+        case INCOMING_QUERY_MESSAGES.READY:
+          break;
+        case INCOMING_QUERY_MESSAGES.ROW_DESCRIPTION: {
+          result.loadColumnDescriptions(
+            parseRowDescriptionMessage(current_message),
+          );
+          break;
+        }
         default:
-          throw new Error(`Unexpected frame: ${msg.type}`);
+          throw new Error(
+            `Unexpected simple query message: ${current_message.type}`,
+          );
       }
+
+      current_message = await this.#readMessage();
     }
+
+    if (error) throw error;
+
+    return result;
   }
 
   async #appendQueryToMessage<T extends ResultType>(query: Query<T>) {
@@ -777,7 +725,7 @@ export class Connection {
    * This function appends the query type (in this case prepared statement)
    * to the message
    */
-  async #appendQueryTypeToMessage() {
+  async #appendDescribeToMessage() {
     this.#packetWriter.clear();
 
     const buffer = this.#packetWriter.addCString("P").flush(0x44);
@@ -801,102 +749,99 @@ export class Connection {
     await this.#bufWriter.write(buffer);
   }
 
-  async #processError(msg: Message, recoverable = true) {
-    const error = parseError(msg);
+  // TODO
+  // Rename process function to a more meaningful name and move out of class
+  async #processErrorUnsafe(
+    msg: Message,
+    recoverable = true,
+  ) {
+    const error = new PostgresError(parseNoticeMessage(msg));
     if (recoverable) {
-      await this.#readReadyForQuery();
+      let maybe_ready_message = await this.#readMessage();
+      while (maybe_ready_message.type !== INCOMING_QUERY_MESSAGES.READY) {
+        maybe_ready_message = await this.#readMessage();
+      }
     }
     throw error;
   }
 
-  #processNotice(msg: Message) {
-    const warning = parseNotice(msg);
-    console.error(`${bold(yellow(warning.severity))}: ${warning.message}`);
-    return warning;
-  }
-
-  // TODO: I believe error handling here is not correct, shouldn't 'sync' message be
-  //  sent after error response is received in prepared statements?
   /**
-   * https://www.postgresql.org/docs/13/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
+   * https://www.postgresql.org/docs/14/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
    */
   async #preparedQuery<T extends ResultType>(
     query: Query<T>,
   ): Promise<QueryResult> {
+    // The parse messages declares the statement, query arguments and the cursor used in the transaction
+    // The database will respond with a parse response
     await this.#appendQueryToMessage(query);
     await this.#appendArgumentsToMessage(query);
-    await this.#appendQueryTypeToMessage();
+    // The describe message will specify the query type and the cursor in which the current query will be running
+    // The database will respond with a bind response
+    await this.#appendDescribeToMessage();
+    // The execute response contains the portal in which the query will be run and how many rows should it return
     await this.#appendExecuteToMessage();
     await this.#appendSyncToMessage();
     // send all messages to backend
     await this.#bufWriter.flush();
 
-    await assertQueryResponse(await this.#readMessage());
-    await assertArgumentsResponse(await this.#readMessage());
-
     let result;
     if (query.result_type === ResultType.ARRAY) {
       result = new QueryArrayResult(query);
     } else {
       result = new QueryObjectResult(query);
     }
-    let msg: Message;
-    msg = await this.#readMessage();
-
-    switch (msg.type) {
-      // row description
-      case "T": {
-        const rowDescription = this.#parseRowDescription(msg);
-        result.loadColumnDescriptions(rowDescription);
-        break;
-      }
-      // no data
-      case "n":
-        break;
-      // notice response
-      case "N":
-        result.warnings.push(await this.#processNotice(msg));
-        break;
-      // error
-      case "E":
-        await this.#processError(msg);
-        break;
-      default:
-        throw new Error(`Unexpected frame: ${msg.type}`);
-    }
 
-    outerLoop:
-    while (true) {
-      msg = await this.#readMessage();
-      switch (msg.type) {
-        // data row
-        case "D": {
-          // this is actually packet read
-          const rawDataRow = this.#parseRowData(msg);
-          result.insertRow(rawDataRow);
+    let error: Error | undefined;
+    let current_message = await this.#readMessage();
+
+    while (current_message.type !== INCOMING_QUERY_MESSAGES.READY) {
+      switch (current_message.type) {
+        case ERROR_MESSAGE: {
+          error = new PostgresError(parseNoticeMessage(current_message));
+          break;
+        }
+        case INCOMING_QUERY_MESSAGES.BIND_COMPLETE:
+          break;
+        case INCOMING_QUERY_MESSAGES.COMMAND_COMPLETE: {
+          result.handleCommandComplete(
+            parseCommandCompleteMessage(current_message),
+          );
           break;
         }
-        // command complete
-        case "C": {
-          const commandTag = this.#getCommandTag(msg);
-          result.handleCommandComplete(commandTag);
-          result.done();
-          break outerLoop;
+        case INCOMING_QUERY_MESSAGES.DATA_ROW: {
+          result.insertRow(parseRowDataMessage(current_message));
+          break;
+        }
+        case INCOMING_QUERY_MESSAGES.NO_DATA:
+          break;
+        case INCOMING_QUERY_MESSAGES.NOTICE_WARNING: {
+          const notice = parseNoticeMessage(current_message);
+          logNotice(notice);
+          result.warnings.push(notice);
+          break;
         }
-        // notice response
-        case "N":
-          result.warnings.push(await this.#processNotice(msg));
+        case INCOMING_QUERY_MESSAGES.PARAMETER_STATUS:
+          break;
+        case INCOMING_QUERY_MESSAGES.PARSE_COMPLETE:
+          // TODO: add to already parsed queries if
+          // query has name, so it's not parsed again
           break;
-        // error response
-        case "E":
-          await this.#processError(msg);
+        case INCOMING_QUERY_MESSAGES.ROW_DESCRIPTION: {
+          result.loadColumnDescriptions(
+            parseRowDescriptionMessage(current_message),
+          );
           break;
+        }
         default:
-          throw new Error(`Unexpected frame: ${msg.type}`);
+          throw new Error(
+            `Unexpected prepared query message: ${current_message.type}`,
+          );
       }
+
+      current_message = await this.#readMessage();
     }
 
-    await this.#readReadyForQuery();
+    if (error) throw error;
 
     return result;
   }
@@ -933,65 +878,16 @@ export class Connection {
     }
   }
 
-  #parseRowDescription(msg: Message): RowDescription {
-    const columnCount = msg.reader.readInt16();
-    const columns = [];
-
-    for (let i = 0; i < columnCount; i++) {
-      // TODO: if one of columns has 'format' == 'binary',
-      //  all of them will be in same format?
-      const column = new Column(
-        msg.reader.readCString(), // name
-        msg.reader.readInt32(), // tableOid
-        msg.reader.readInt16(), // index
-        msg.reader.readInt32(), // dataTypeOid
-        msg.reader.readInt16(), // column
-        msg.reader.readInt32(), // typeModifier
-        msg.reader.readInt16(), // format
-      );
-      columns.push(column);
-    }
-
-    return new RowDescription(columnCount, columns);
-  }
-
-  //TODO
-  //Research corner cases where #parseRowData can return null values
-  // deno-lint-ignore no-explicit-any
-  #parseRowData(msg: Message): any[] {
-    const fieldCount = msg.reader.readInt16();
-    const row = [];
-
-    for (let i = 0; i < fieldCount; i++) {
-      const colLength = msg.reader.readInt32();
-
-      if (colLength == -1) {
-        row.push(null);
-        continue;
-      }
-
-      // reading raw bytes here, they will be properly parsed later
-      row.push(msg.reader.readBytes(colLength));
-    }
-
-    return row;
-  }
-
-  #getCommandTag(msg: Message) {
-    return msg.reader.readString(msg.byteCount);
-  }
-
   async end(): Promise<void> {
     if (this.connected) {
       const terminationMessage = new Uint8Array([0x58, 0x00, 0x00, 0x00, 0x04]);
       await this.#bufWriter.write(terminationMessage);
       try {
         await this.#bufWriter.flush();
-        this.#conn.close();
+        this.#closeConnection();
       } catch (_e) {
-        // This steps can fail if the underlying connection has been closed ungracefully
+        // This steps can fail if the underlying connection had been closed ungracefully
       } finally {
-        this.#resetConnectionMetadata();
         this.#onDisconnection();
       }
     }
diff --git a/connection/connection_params.ts b/connection/connection_params.ts
index 2e78919e..ca0d59fd 100644
--- a/connection/connection_params.ts
+++ b/connection/connection_params.ts
@@ -1,5 +1,5 @@
-// deno-lint-ignore-file camelcase
 import { parseDsn } from "../utils/utils.ts";
+import { ConnectionParamsError } from "../client/error.ts";
 
 /**
  * The connection string must match the following URI structure
@@ -29,13 +29,6 @@ function getPgEnv(): ClientOptions {
   };
 }
 
-export class ConnectionParamsError extends Error {
-  constructor(message: string) {
-    super(message);
-    this.name = "ConnectionParamsError";
-  }
-}
-
 export interface ConnectionOptions {
   /**
    * By default, any client will only attempt to stablish
@@ -48,14 +41,25 @@ export interface ConnectionOptions {
   attempts: number;
 }
 
+// TODO
+// Refactor enabled and enforce into one single option for 1.0
 export interface TLSOptions {
+  /**
+   * If TLS support is enabled or not. If the server requires TLS,
+   * the connection will fail.
+   */
+  enabled: boolean;
   /**
    * This will force the connection to run over TLS
    * If the server doesn't support TLS, the connection will fail
    *
    * default: `false`
-   * */
+   */
   enforce: boolean;
+  /**
+   * A custom CA file to use for the TLS connection to the server.
+   */
+  caFile?: string;
 }
 
 export interface ClientOptions {
@@ -131,26 +135,30 @@ function parseOptionsFromDsn(connString: string): ClientOptions {
     );
   }
 
-  let enforceTls = false;
+  let tls: TLSOptions = { enabled: true, enforce: false };
   if (dsn.params.sslmode) {
     const sslmode = dsn.params.sslmode;
     delete dsn.params.sslmode;
 
-    if (sslmode !== "require" && sslmode !== "prefer") {
+    if (!["disable", "require", "prefer"].includes(sslmode)) {
       throw new ConnectionParamsError(
-        `Supplied DSN has invalid sslmode '${sslmode}'. Only 'require' or 'prefer' are supported`,
+        `Supplied DSN has invalid sslmode '${sslmode}'. Only 'disable', 'require', and 'prefer' are supported`,
       );
     }
 
     if (sslmode === "require") {
-      enforceTls = true;
+      tls = { enabled: true, enforce: true };
+    }
+
+    if (sslmode === "disable") {
+      tls = { enabled: false, enforce: false };
     }
   }
 
   return {
     ...dsn,
-    tls: { enforce: enforceTls },
     applicationName: dsn.params.application_name,
+    tls,
   };
 }
 
@@ -162,6 +170,7 @@ const DEFAULT_OPTIONS: Omit<ClientConfiguration, "database" | "user"> = {
   hostname: "127.0.0.1",
   port: 5432,
   tls: {
+    enabled: true,
     enforce: false,
   },
 };
@@ -199,6 +208,15 @@ export function createParams(
     );
   }
 
+  const tls_enabled = !!(params?.tls?.enabled ?? DEFAULT_OPTIONS.tls.enabled);
+  const tls_enforced = !!(params?.tls?.enforce ?? DEFAULT_OPTIONS.tls.enforce);
+
+  if (!tls_enabled && tls_enforced) {
+    throw new ConnectionParamsError(
+      "Can't enforce TLS when client has TLS encryption is disabled",
+    );
+  }
+
   // TODO
   // Perhaps username should be taken from the PC user as a default?
   const connection_options = {
@@ -213,7 +231,9 @@ export function createParams(
     password: params.password ?? pgEnv.password,
     port,
     tls: {
-      enforce: !!params?.tls?.enforce ?? DEFAULT_OPTIONS.tls.enforce,
+      enabled: tls_enabled,
+      enforce: tls_enforced,
+      caFile: params?.tls?.caFile,
     },
     user: params.user ?? pgEnv.user,
   };
diff --git a/connection/message.ts b/connection/message.ts
new file mode 100644
index 00000000..edf40866
--- /dev/null
+++ b/connection/message.ts
@@ -0,0 +1,176 @@
+import { Column } from "../query/decode.ts";
+import { PacketReader } from "./packet.ts";
+import { RowDescription } from "../query/query.ts";
+
+export class Message {
+  public reader: PacketReader;
+
+  constructor(
+    public type: string,
+    public byteCount: number,
+    public body: Uint8Array,
+  ) {
+    this.reader = new PacketReader(body);
+  }
+}
+
+export interface Notice {
+  severity: string;
+  code: string;
+  message: string;
+  detail?: string;
+  hint?: string;
+  position?: string;
+  internalPosition?: string;
+  internalQuery?: string;
+  where?: string;
+  schema?: string;
+  table?: string;
+  column?: string;
+  dataType?: string;
+  constraint?: string;
+  file?: string;
+  line?: string;
+  routine?: string;
+}
+
+export function parseBackendKeyMessage(
+  message: Message,
+): { pid: number; secret_key: number } {
+  return {
+    pid: message.reader.readInt32(),
+    secret_key: message.reader.readInt32(),
+  };
+}
+
+/**
+ * This function returns the command result tag from the command message
+ */
+export function parseCommandCompleteMessage(message: Message): string {
+  return message.reader.readString(message.byteCount);
+}
+
+/**
+ * https://www.postgresql.org/docs/14/protocol-error-fields.html
+ */
+export function parseNoticeMessage(message: Message): Notice {
+  // deno-lint-ignore no-explicit-any
+  const error_fields: any = {};
+
+  let byte: number;
+  let field_code: string;
+  let field_value: string;
+
+  while ((byte = message.reader.readByte())) {
+    field_code = String.fromCharCode(byte);
+    field_value = message.reader.readCString();
+
+    switch (field_code) {
+      case "S":
+        error_fields.severity = field_value;
+        break;
+      case "C":
+        error_fields.code = field_value;
+        break;
+      case "M":
+        error_fields.message = field_value;
+        break;
+      case "D":
+        error_fields.detail = field_value;
+        break;
+      case "H":
+        error_fields.hint = field_value;
+        break;
+      case "P":
+        error_fields.position = field_value;
+        break;
+      case "p":
+        error_fields.internalPosition = field_value;
+        break;
+      case "q":
+        error_fields.internalQuery = field_value;
+        break;
+      case "W":
+        error_fields.where = field_value;
+        break;
+      case "s":
+        error_fields.schema = field_value;
+        break;
+      case "t":
+        error_fields.table = field_value;
+        break;
+      case "c":
+        error_fields.column = field_value;
+        break;
+      case "d":
+        error_fields.dataTypeName = field_value;
+        break;
+      case "n":
+        error_fields.constraint = field_value;
+        break;
+      case "F":
+        error_fields.file = field_value;
+        break;
+      case "L":
+        error_fields.line = field_value;
+        break;
+      case "R":
+        error_fields.routine = field_value;
+        break;
+      default:
+        // from Postgres docs
+        // > Since more field types might be added in future,
+        // > frontends should silently ignore fields of unrecognized type.
+        break;
+    }
+  }
+
+  return error_fields;
+}
+
+/**
+ * Parses a row data message into an array of bytes ready to be processed as column values
+ */
+// TODO
+// Research corner cases where parseRowData can return null values
+// deno-lint-ignore no-explicit-any
+export function parseRowDataMessage(message: Message): any[] {
+  const field_count = message.reader.readInt16();
+  const row = [];
+
+  for (let i = 0; i < field_count; i++) {
+    const col_length = message.reader.readInt32();
+
+    if (col_length == -1) {
+      row.push(null);
+      continue;
+    }
+
+    // reading raw bytes here, they will be properly parsed later
+    row.push(message.reader.readBytes(col_length));
+  }
+
+  return row;
+}
+
+export function parseRowDescriptionMessage(message: Message): RowDescription {
+  const column_count = message.reader.readInt16();
+  const columns = [];
+
+  for (let i = 0; i < column_count; i++) {
+    // TODO: if one of columns has 'format' == 'binary',
+    // all of them will be in same format?
+    const column = new Column(
+      message.reader.readCString(), // name
+      message.reader.readInt32(), // tableOid
+      message.reader.readInt16(), // index
+      message.reader.readInt32(), // dataTypeOid
+      message.reader.readInt16(), // column
+      message.reader.readInt32(), // typeModifier
+      message.reader.readInt16(), // format
+    );
+    columns.push(column);
+  }
+
+  return new RowDescription(column_count, columns);
+}
diff --git a/connection/message_code.ts b/connection/message_code.ts
new file mode 100644
index 00000000..966a02ae
--- /dev/null
+++ b/connection/message_code.ts
@@ -0,0 +1,45 @@
+// https://www.postgresql.org/docs/14/protocol-message-formats.html
+
+export const ERROR_MESSAGE = "E";
+
+export const AUTHENTICATION_TYPE = {
+  CLEAR_TEXT: 3,
+  GSS_CONTINUE: 8,
+  GSS_STARTUP: 7,
+  MD5: 5,
+  NO_AUTHENTICATION: 0,
+  SASL_CONTINUE: 11,
+  SASL_FINAL: 12,
+  SASL_STARTUP: 10,
+  SCM: 6,
+  SSPI: 9,
+} as const;
+
+export const INCOMING_QUERY_BIND_MESSAGES = {} as const;
+
+export const INCOMING_QUERY_PARSE_MESSAGES = {} as const;
+
+export const INCOMING_AUTHENTICATION_MESSAGES = {
+  AUTHENTICATION: "R",
+  BACKEND_KEY: "K",
+  PARAMETER_STATUS: "S",
+  READY: "Z",
+} as const;
+
+export const INCOMING_TLS_MESSAGES = {
+  ACCEPTS_TLS: "S",
+  NO_ACCEPTS_TLS: "N",
+} as const;
+
+export const INCOMING_QUERY_MESSAGES = {
+  BIND_COMPLETE: "2",
+  PARSE_COMPLETE: "1",
+  COMMAND_COMPLETE: "C",
+  DATA_ROW: "D",
+  EMPTY_QUERY: "I",
+  NO_DATA: "n",
+  NOTICE_WARNING: "N",
+  PARAMETER_STATUS: "S",
+  READY: "Z",
+  ROW_DESCRIPTION: "T",
+} as const;
diff --git a/connection/packet_writer.ts b/connection/packet.ts
similarity index 77%
rename from connection/packet_writer.ts
rename to connection/packet.ts
index 9f0a90f6..36abae18 100644
--- a/connection/packet_writer.ts
+++ b/connection/packet.ts
@@ -26,6 +26,62 @@
  */
 
 import { copy } from "../deps.ts";
+import { readInt16BE, readInt32BE } from "../utils/utils.ts";
+
+export class PacketReader {
+  #buffer: Uint8Array;
+  #decoder = new TextDecoder();
+  #offset = 0;
+
+  constructor(buffer: Uint8Array) {
+    this.#buffer = buffer;
+  }
+
+  readInt16(): number {
+    const value = readInt16BE(this.#buffer, this.#offset);
+    this.#offset += 2;
+    return value;
+  }
+
+  readInt32(): number {
+    const value = readInt32BE(this.#buffer, this.#offset);
+    this.#offset += 4;
+    return value;
+  }
+
+  readByte(): number {
+    return this.readBytes(1)[0];
+  }
+
+  readBytes(length: number): Uint8Array {
+    const start = this.#offset;
+    const end = start + length;
+    const slice = this.#buffer.slice(start, end);
+    this.#offset = end;
+    return slice;
+  }
+
+  readAllBytes(): Uint8Array {
+    const slice = this.#buffer.slice(this.#offset);
+    this.#offset = this.#buffer.length;
+    return slice;
+  }
+
+  readString(length: number): string {
+    const bytes = this.readBytes(length);
+    return this.#decoder.decode(bytes);
+  }
+
+  readCString(): string {
+    const start = this.#offset;
+    // find next null byte
+    const end = this.#buffer.indexOf(0, start);
+    const slice = this.#buffer.slice(start, end);
+    // add +1 for null byte
+    this.#offset = end + 1;
+    return this.#decoder.decode(slice);
+  }
+}
 
 export class PacketWriter {
   #buffer: Uint8Array;
diff --git a/connection/packet_reader.ts b/connection/packet_reader.ts
deleted file mode 100644
index b69c16cd..00000000
--- a/connection/packet_reader.ts
+++ /dev/null
@@ -1,56 +0,0 @@
-import { readInt16BE, readInt32BE } from "../utils/utils.ts";
-
-export class PacketReader {
-  #buffer: Uint8Array;
-  #decoder = new TextDecoder();
-  #offset = 0;
-
-  constructor(buffer: Uint8Array) {
-    this.#buffer = buffer;
-  }
-
-  readInt16(): number {
-    const value = readInt16BE(this.#buffer, this.#offset);
-    this.#offset += 2;
-    return value;
-  }
-
-  readInt32(): number {
-    const value = readInt32BE(this.#buffer, this.#offset);
-    this.#offset += 4;
-    return value;
-  }
-
-  readByte(): number {
-    return this.readBytes(1)[0];
-  }
-
-  readBytes(length: number): Uint8Array {
-    const start = this.#offset;
-    const end = start + length;
-    const slice = this.#buffer.slice(start, end);
-    this.#offset = end;
-    return slice;
-  }
-
-  readAllBytes(): Uint8Array {
-    const slice = this.#buffer.slice(this.#offset);
-    this.#offset = this.#buffer.length;
-    return slice;
-  }
-
-  readString(length: number): string {
-    const bytes = this.readBytes(length);
-    return this.#decoder.decode(bytes);
-  }
-
-  readCString(): string {
-    const start = this.#offset;
-    // find next null byte
-    const end = this.#buffer.indexOf(0, start);
-    const slice = this.#buffer.slice(start, end);
-    // add +1 for null byte
-    this.#offset = end + 1;
-    return this.#decoder.decode(slice);
-  }
-}
diff --git a/connection/scram.ts b/connection/scram.ts
index 036e3856..dbafbb78 100644
--- a/connection/scram.ts
+++ b/connection/scram.ts
@@ -6,13 +6,6 @@ function assert(cond: unknown): asserts cond {
   }
 }
 
-/** Error thrown on SCRAM authentication failure. */
-export class AuthError extends Error {
-  constructor(public reason: Reason, message?: string) {
-    super(message ?? reason);
-  }
-}
-
 /** Reason of authentication failure. */
 export enum Reason {
   BadMessage = "server sent an ill-formed message",
@@ -89,23 +82,23 @@ export class Client {
 
       const nonce = attrs.r;
       if (!attrs.r || !attrs.r.startsWith(this.#clientNonce)) {
-        throw new AuthError(Reason.BadServerNonce);
+        throw new Error(Reason.BadServerNonce);
       }
       this.#serverNonce = nonce;
 
       let salt: Uint8Array | undefined;
       if (!attrs.s) {
-        throw new AuthError(Reason.BadSalt);
+        throw new Error(Reason.BadSalt);
       }
       try {
         salt = base64.decode(attrs.s);
       } catch {
-        throw new AuthError(Reason.BadSalt);
+        throw new Error(Reason.BadSalt);
       }
 
       const iterCount = parseInt(attrs.i) | 0;
       if (iterCount <= 0) {
-        throw new AuthError(Reason.BadIterationCount);
+        throw new Error(Reason.BadIterationCount);
       }
 
       this.#keys = await deriveKeys(this.#password, salt, iterCount);
@@ -155,14 +148,14 @@ export class Client {
       const attrs = parseAttributes(response);
 
       if (attrs.e) {
-        throw new AuthError(Reason.Rejected, attrs.e);
+        throw new Error(attrs.e ?? Reason.Rejected);
       }
 
       const verifier = base64.encode(
         await computeSignature(this.#authMessage, this.#keys.server),
       );
       if (attrs.v !== verifier) {
-        throw new AuthError(Reason.BadVerifier);
+        throw new Error(Reason.BadVerifier);
       }
 
       this.#state = State.ServerResponse;
@@ -185,7 +178,7 @@ function parseAttributes(str: string): Record<string, string> {
   for (const entry of str.split(",")) {
     const pos = entry.indexOf("=");
     if (pos < 1) {
-      throw new AuthError(Reason.BadMessage);
+      throw new Error(Reason.BadMessage);
     }
 
     const key = entry.substr(0, pos);
diff --git a/connection/warning.ts b/connection/warning.ts
deleted file mode 100644
index 44be6b7b..00000000
--- a/connection/warning.ts
+++ /dev/null
@@ -1,146 +0,0 @@
-// deno-lint-ignore-file camelcase
-import { PacketReader } from "./packet_reader.ts";
-
-export class Message {
-  public reader: PacketReader;
-
-  constructor(
-    public type: string,
-    public byteCount: number,
-    public body: Uint8Array,
-  ) {
-    this.reader = new PacketReader(body);
-  }
-}
-
-export interface WarningFields {
-  severity: string;
-  code: string;
-  message: string;
-  detail?: string;
-  hint?: string;
-  position?: string;
-  internalPosition?: string;
-  internalQuery?: string;
-  where?: string;
-  schema?: string;
-  table?: string;
-  column?: string;
-  dataType?: string;
-  constraint?: string;
-  file?: string;
-  line?: string;
-  routine?: string;
-}
-
-export class ConnectionError extends Error {}
-
-export class PostgresError extends Error {
-  public fields: WarningFields;
-
-  constructor(fields: WarningFields) {
-    super(fields.message);
-    this.fields = fields;
-    this.name = "PostgresError";
-  }
-}
-
-// TODO
-// Use error cause once it's added to JavaScript
-export class TransactionError extends Error {
-  constructor(
-    transaction_name: string,
-    public cause: PostgresError,
-  ) {
-    super(
-      `The transaction "${transaction_name}" has been aborted due to \`${cause}\`. Check the "cause" property to get more details`,
-    );
-  }
-}
-
-export function parseError(msg: Message): PostgresError {
-  return new PostgresError(parseWarning(msg));
-}
-
-export function parseNotice(msg: Message): WarningFields {
-  return parseWarning(msg);
-}
-
-/**
- * https://www.postgresql.org/docs/current/protocol-error-fields.html
- * */
-function parseWarning(msg: Message): WarningFields {
-  // https://www.postgresql.org/docs/current/protocol-error-fields.html
-  // deno-lint-ignore no-explicit-any
-  const errorFields: any = {};
-
-  let byte: number;
-  let char: string;
-  let errorMsg: string;
-
-  while ((byte = msg.reader.readByte())) {
-    char = String.fromCharCode(byte);
-    errorMsg = msg.reader.readCString();
-
-    switch (char) {
-      case "S":
-        errorFields.severity = errorMsg;
-        break;
-      case "C":
-        errorFields.code = errorMsg;
-        break;
-      case "M":
-        errorFields.message = errorMsg;
-        break;
-      case "D":
-        errorFields.detail = errorMsg;
-        break;
-      case "H":
-        errorFields.hint = errorMsg;
-        break;
-      case "P":
-        errorFields.position = errorMsg;
-        break;
-      case "p":
-        errorFields.internalPosition = errorMsg;
-        break;
-      case "q":
-        errorFields.internalQuery = errorMsg;
-        break;
-      case "W":
-        errorFields.where = errorMsg;
-        break;
-      case "s":
-        errorFields.schema = errorMsg;
-        break;
-      case "t":
-        errorFields.table = errorMsg;
-        break;
-      case "c":
-        errorFields.column = errorMsg;
-        break;
-      case "d":
-        errorFields.dataTypeName = errorMsg;
-        break;
-      case "n":
-        errorFields.constraint = errorMsg;
-        break;
-      case "F":
-        errorFields.file = errorMsg;
-        break;
-      case "L":
-        errorFields.line = errorMsg;
-        break;
-      case "R":
-        errorFields.routine = errorMsg;
-        break;
-      default:
-        // from Postgres docs
-        // > Since more field types might be added in future,
-        // > frontends should silently ignore fields of unrecognized type.
-        break;
-    }
-  }
-
-  return errorFields;
-}
diff --git a/deno.json b/deno.json
new file mode 100644
index 00000000..6580b1a6
--- /dev/null
+++ b/deno.json
@@ -0,0 +1,9 @@
+{
+  "lint": {
+    "rules": {
+      "exclude": [
+        "camelcase"
+      ]
+    }
+  }
+}
diff --git a/deps.ts b/deps.ts
index 55a5b78d..233bb1a0 100644
--- a/deps.ts
+++ b/deps.ts
@@ -1,8 +1,11 @@
-export { BufReader, BufWriter } from "https://deno.land/std@0.98.0/io/bufio.ts";
-export { copy } from "https://deno.land/std@0.98.0/bytes/mod.ts";
-export { createHash } from "https://deno.land/std@0.98.0/hash/mod.ts";
-export { HmacSha256 } from "https://deno.land/std@0.98.0/hash/sha256.ts";
-export * as base64 from "https://deno.land/std@0.98.0/encoding/base64.ts";
-export { deferred, delay } from "https://deno.land/std@0.98.0/async/mod.ts";
-export type { Deferred } from "https://deno.land/std@0.98.0/async/mod.ts";
-export { bold, yellow } from "https://deno.land/std@0.98.0/fmt/colors.ts";
+export {
+  BufReader,
+  BufWriter,
+} from "https://deno.land/std@0.108.0/io/bufio.ts";
+export { copy } from "https://deno.land/std@0.108.0/bytes/mod.ts";
+export { createHash } from "https://deno.land/std@0.108.0/hash/mod.ts";
+export { HmacSha256 } from "https://deno.land/std@0.108.0/hash/sha256.ts";
+export * as base64 from "https://deno.land/std@0.108.0/encoding/base64.ts";
+export { deferred, delay } from "https://deno.land/std@0.108.0/async/mod.ts";
+export type { Deferred } from "https://deno.land/std@0.108.0/async/mod.ts";
+export { bold, yellow } from "https://deno.land/std@0.108.0/fmt/colors.ts";
diff --git a/docker-compose.yml b/docker-compose.yml
index c3e25829..754ceb19 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -1,20 +1,20 @@
 version: '3.8'
 
 services:
-  postgres:
-    image: postgres
+  postgres_classic:
+    image: postgres:14
     hostname: postgres
     environment:
       - POSTGRES_DB=postgres
       - POSTGRES_PASSWORD=postgres
       - POSTGRES_USER=postgres
     volumes:
-      - ./docker/postgres/data/:/var/lib/postgresql/host/
-      - ./docker/postgres/init/:/docker-entrypoint-initdb.d/
+      - ./docker/postgres_classic/data/:/var/lib/postgresql/host/
+      - ./docker/postgres_classic/init/:/docker-entrypoint-initdb.d/
     ports:
       - "6001:5432"
   postgres_scram:
-    image: postgres
+    image: postgres:14
     hostname: postgres_scram
     environment:
       - POSTGRES_DB=postgres
@@ -27,26 +27,13 @@ services:
       - ./docker/postgres_scram/init/:/docker-entrypoint-initdb.d/
     ports:
       - "6002:5432"
-  postgres_invalid_tls:
-    image: postgres
-    hostname: postgres_invalid_tls
-    environment:
-      - POSTGRES_DB=postgres
-      - POSTGRES_PASSWORD=postgres
-      - POSTGRES_USER=postgres
-    volumes:
-      - ./docker/postgres_invalid_tls/data/:/var/lib/postgresql/host/
-      - ./docker/postgres_invalid_tls/init/:/docker-entrypoint-initdb.d/
-    ports:
-      - "6003:5432"
   tests:
     build: .
     depends_on:
-      - postgres
+      - postgres_classic
       - postgres_scram
-      - postgres_invalid_tls
     environment:
-      - WAIT_HOSTS=postgres:5432,postgres_scram:5432,postgres_invalid_tls:5432
+      - WAIT_HOSTS=postgres_classic:5432,postgres_scram:5432
       # Wait thirty seconds after database goes online
       # For database metadata initialization
       - WAIT_AFTER_HOSTS=15
diff --git a/docker/certs/.gitignore b/docker/certs/.gitignore
new file mode 100644
index 00000000..ee207f31
--- /dev/null
+++ b/docker/certs/.gitignore
@@ -0,0 +1,5 @@
+*
+
+!.gitignore
+!ca.crt
+!domains.txt
\ No newline at end of file
diff --git a/docker/certs/ca.crt b/docker/certs/ca.crt
new file mode 100644
index 00000000..e96104dd
--- /dev/null
+++ b/docker/certs/ca.crt
@@ -0,0 +1,20 @@
+-----BEGIN CERTIFICATE-----
+MIIDMTCCAhmgAwIBAgIUfkdvRA7spdYY2eBzMIaUpwdZLVswDQYJKoZIhvcNAQEL
+BQAwJzELMAkGA1UEBhMCVVMxGDAWBgNVBAMMD0V4YW1wbGUtUm9vdC1DQTAgFw0y
+MTA5MjkwNTE1NTBaGA8yMTIwMDkwNTA1MTU1MFowJzELMAkGA1UEBhMCVVMxGDAW
+BgNVBAMMD0V4YW1wbGUtUm9vdC1DQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
+AQoCggEBAOJWA8iyktDM3rcFOOmomxjS2/1MUThm6Cg1IlOJoPZmWp7NSssJoYhe
+OynOmV0RwlyYz0kOoHbW13eiIl28sJioLqP7zwvMMNwTFwdW760umg4RHwojgilT
+ataDKH4onbKWJWsRC7nD0E8KhViiyEdBZUayjwnOVnJCT0xLroYIU0TpzVgSiqq/
+qi827NHs82HaU6iVDs7cVvCrW6Lsc3RowmgFjvPo3WqBzo3HLhqTUL/YI4MnuLxs
+yLdoTYc+v/7p2O23IwLIzMzHCaS77jNP9e0deavi9l4skaI9Ly762Eem5d0qtzE5
+1/+IdhIfVkDtq5jzZtjbi7Wx410xfRMCAwEAAaNTMFEwHQYDVR0OBBYEFLuBbJIl
+zyQv4IaataQYMkNqlejoMB8GA1UdIwQYMBaAFLuBbJIlzyQv4IaataQYMkNqlejo
+MA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAJwPeK+ncvPhcjJt
+++oO83dPd+0IK1Tk02rcECia7Kuyp5jlIcUZ65JrMBq1xtcYR/ukGacZrK98qUaj
+rgjzSGqSiZZ/JNI+s7er2qZRscacOuOBlEXYaFbKPMp4E21BE0F3OAvd2h0PjFMz
+ambclnQtKc3Y0glm8Qj5+f1D6PgxhQ+RamV3OFIFbLg8mhp2gBjEW30AScwN+bkk
+uyCBnCopGbk0Zup0UuSkApDnueaff9j05igbFfVkJbp1ZeLNfpN/qDgnZqbn7Her
+/ugFfzsyevAhldxKEql2DdQQhpWsXHZSEsv0m56cgvl/sfsSeBzf2zkVUMgw632P
+7djdJtc=
+-----END CERTIFICATE-----
diff --git a/docker/certs/domains.txt b/docker/certs/domains.txt
new file mode 100644
index 00000000..43e1aafa
--- /dev/null
+++ b/docker/certs/domains.txt
@@ -0,0 +1,8 @@
+authorityKeyIdentifier=keyid,issuer
+basicConstraints=CA:FALSE
+keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
+subjectAltName = @alt_names
+[alt_names]
+DNS.1 = localhost
+DNS.2 = postgres_classic
+DNS.3 = postgres_scram
diff --git a/docker/generate_tls_keys.sh b/docker/generate_tls_keys.sh
new file mode 100755
index 00000000..b3c6af8f
--- /dev/null
+++ b/docker/generate_tls_keys.sh
@@ -0,0 +1,18 @@
+# Set CWD relative to script location
+cd "$(dirname "$0")"
+
+# Generate CA certificate and key
+openssl req -x509 -nodes -new -sha256 -days 36135 -newkey rsa:2048 -keyout ./certs/ca.key -out ./certs/ca.pem -subj "/C=US/CN=Example-Root-CA"
+openssl x509 -outform pem -in ./certs/ca.pem -out ./certs/ca.crt
+
+# Generate leaf certificate
+openssl req -new -nodes -newkey rsa:2048 -keyout ./certs/server.key -out ./certs/server.csr -subj "/C=US/ST=YourState/L=YourCity/O=Example-Certificates/CN=localhost"
+openssl x509 -req -sha256 -days 36135 -in ./certs/server.csr -CA ./certs/ca.pem -CAkey ./certs/ca.key -CAcreateserial -extfile ./certs/domains.txt -out ./certs/server.crt
+
+chmod 777 certs/server.crt
+cp -f certs/server.crt postgres_classic/data/
+cp -f certs/server.crt postgres_scram/data/
+
+chmod 777 certs/server.key
+cp -f certs/server.key postgres_classic/data/
+cp -f certs/server.key postgres_scram/data/
diff --git a/docker/postgres/data/pg_hba.conf b/docker/postgres/data/pg_hba.conf
deleted file mode 100755
index 4e4c3e53..00000000
--- a/docker/postgres/data/pg_hba.conf
+++ /dev/null
@@ -1,3 +0,0 @@
-hostnossl  all         postgres              0.0.0.0/0  md5
-hostnossl  postgres    clear                 0.0.0.0/0  password
-hostnossl  postgres    md5                   0.0.0.0/0  md5
diff --git a/docker/postgres/data/postgresql.conf b/docker/postgres/data/postgresql.conf
deleted file mode 100755
index 2a20969c..00000000
--- a/docker/postgres/data/postgresql.conf
+++ /dev/null
@@ -1 +0,0 @@
-ssl = off
diff --git a/docker/postgres/init/initialize_test_server.sh b/docker/postgres/init/initialize_test_server.sh
deleted file mode 100644
index ac0e7636..00000000
--- a/docker/postgres/init/initialize_test_server.sh
+++ /dev/null
@@ -1,2 +0,0 @@
-cat /var/lib/postgresql/host/postgresql.conf >> /var/lib/postgresql/data/postgresql.conf
-cp /var/lib/postgresql/host/pg_hba.conf /var/lib/postgresql/data
diff --git a/docker/postgres_classic/data/pg_hba.conf b/docker/postgres_classic/data/pg_hba.conf
new file mode 100755
index 00000000..dbf38889
--- /dev/null
+++ b/docker/postgres_classic/data/pg_hba.conf
@@ -0,0 +1,8 @@
+hostssl     postgres    clear                 0.0.0.0/0  password
+hostnossl   postgres    clear                 0.0.0.0/0  password
+hostssl     all         postgres              0.0.0.0/0  md5
+hostnossl   all         postgres              0.0.0.0/0  md5
+hostssl     postgres    md5                   0.0.0.0/0  md5
+hostnossl   postgres    md5                   0.0.0.0/0  md5
+hostssl     postgres    tls_only              0.0.0.0/0  md5
+
diff --git a/docker/postgres_invalid_tls/data/postgresql.conf b/docker/postgres_classic/data/postgresql.conf
similarity index 100%
rename from docker/postgres_invalid_tls/data/postgresql.conf
rename to docker/postgres_classic/data/postgresql.conf
diff --git a/docker/postgres_classic/data/server.crt b/docker/postgres_classic/data/server.crt
new file mode 100755
index 00000000..ea2fb4d9
--- /dev/null
+++ b/docker/postgres_classic/data/server.crt
@@ -0,0 +1,22 @@
+-----BEGIN CERTIFICATE-----
+MIIDkTCCAnmgAwIBAgIUCeSCBCVxR0+kf5GcadXrLln0WdYwDQYJKoZIhvcNAQEL
+BQAwJzELMAkGA1UEBhMCVVMxGDAWBgNVBAMMD0V4YW1wbGUtUm9vdC1DQTAgFw0y
+MTA5MjkwNTE1NTBaGA8yMTIwMDkwNTA1MTU1MFowZzELMAkGA1UEBhMCVVMxEjAQ
+BgNVBAgMCVlvdXJTdGF0ZTERMA8GA1UEBwwIWW91ckNpdHkxHTAbBgNVBAoMFEV4
+YW1wbGUtQ2VydGlmaWNhdGVzMRIwEAYDVQQDDAlsb2NhbGhvc3QwggEiMA0GCSqG
+SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDMbJZmDVvPlwipJPBa8sIvl5eA+r2xFj0t
+GN90Nol0VhUxcH6wyo85ILxa+eMIywmYbs3JCdigYz3Y/1cEQ0Uc/Qaqqt28pDFH
+yx/mG6DudDp7kF+Yc6KQ3ZJiMjj++mpT8oJqGEn32VT0yXEWjs+6goafx76Zre/4
+K8mVIL+ve4CnWp15jNo7YMpvw0hCvM4Ev3MHYKn4XSR1nJlozizRb9k6UZJlcR3v
+8NS/AvXqzcJ8d+iCvl9X9YIZaHq8YKgf3Hd0qPqZwA1f/rDzTS583/xuZ04ngd5m
+gg88S5cd0JZ12mZnPYpWkJJWC/bs+14blaIjtdJURhegOTx2AIVjAgMBAAGjczBx
+MB8GA1UdIwQYMBaAFLuBbJIlzyQv4IaataQYMkNqlejoMAkGA1UdEwQCMAAwCwYD
+VR0PBAQDAgTwMDYGA1UdEQQvMC2CCWxvY2FsaG9zdIIQcG9zdGdyZXNfY2xhc3Np
+Y4IOcG9zdGdyZXNfc2NyYW0wDQYJKoZIhvcNAQELBQADggEBAEHjZQGpUW2r5VDy
+3l/BSjKk30I4GQdr58lSfWdh6ULGpOQ3yp1WgJWiH4eKSgozwFeOCqz8oWEKkIS0
+EZFnb0hXaZW2KcXRAco2oyRlQLmSs0XxPJiZNwVAOz1cvF8m/Rk0kbwzCczTPNgp
+N0/xMBxAnE3x7ExwA332gCJ1PQ6KMStMbjhRNb+FhrAdSe/ljzWtHrVEJ8WFsORD
+BjI6oVw1KdZTuzshVMxArW02DutdlssHMQNexYmM9k2fnHQc1zePtVJNJmWiG0/o
+lcHLdsy74AEkFw29X7jpq6Ivsz2HvU8cR14oYRxEY+bhXjqcdl67CKXR/i/sDYcq
+8kzqWZk=
+-----END CERTIFICATE-----
diff --git a/docker/postgres_classic/data/server.key b/docker/postgres_classic/data/server.key
new file mode 100755
index 00000000..f324210e
--- /dev/null
+++ b/docker/postgres_classic/data/server.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDMbJZmDVvPlwip
+JPBa8sIvl5eA+r2xFj0tGN90Nol0VhUxcH6wyo85ILxa+eMIywmYbs3JCdigYz3Y
+/1cEQ0Uc/Qaqqt28pDFHyx/mG6DudDp7kF+Yc6KQ3ZJiMjj++mpT8oJqGEn32VT0
+yXEWjs+6goafx76Zre/4K8mVIL+ve4CnWp15jNo7YMpvw0hCvM4Ev3MHYKn4XSR1
+nJlozizRb9k6UZJlcR3v8NS/AvXqzcJ8d+iCvl9X9YIZaHq8YKgf3Hd0qPqZwA1f
+/rDzTS583/xuZ04ngd5mgg88S5cd0JZ12mZnPYpWkJJWC/bs+14blaIjtdJURheg
+OTx2AIVjAgMBAAECggEANBWutE3PCLNYt4/71ZBovauIJIq+bjJWX/koZfnHR+bu
++2vIO89AcrPOifeFSyZASaBhuklR8nuWtIVKbIGfSGWHn1BtsrS7AanVdNGxTVA7
+3mPIl5VO5E4wD+jv8LdpA/6UD+gkYIv1Q3FX6QF2F/VNy8Qe4hUZQUgW0nJHpLQE
+KXSkOY9r4GMRWzRwpGr3YmR7ZQspBPHuSKzg71Tg0cWUB56uWHphPy1AKuWznVj4
+RavKMUB311Y+TFYCW0cPPA0dByb9i11SeYbbcBEZCTC8UQ5yCsB2EGpZeeO7pukp
+fI1XOxlrVSfiFhGkmtZJQnnsy8anlfJiVa6+CupUwQKBgQDy2Zi53CrIZpaeu3kt
+Msgd3FIQ3UjWHei/Icr35wBjmGKTkuyNikZEZx10v6lD1RK6HTL/5GABIgY617Kp
+KdicZb40/mdy2WqfjyVyMZkiRMQR6qFXp4+Pao5nt/Vr2ICbrT+VtsWnFxtmTa/w
+Wf5JSbImv3r6qc+LfE0Px5wAEwKBgQDXflReOv42BAakDMDk3mlUq9kiXQPF/goC
+XuacI04qv/XJqujtz5i3mRmKXt2Y5R8uiXWp9Z+ho+N6m3RIVq/9soIzzR9FDiQ3
+5fw3UnuU2KFGMshGwWcmdz0ffrzNjoWKaRQuHFvymdTpV7+bT1Vy4VrcmISA0iQA
+AyidP3svcQKBgQCvsrxrY53UZVx9tRcjm0TrTbZWGzMSLotwlQtatdczN1HCgR8B
+/FOAM7Y8/FmDCQpGes+mEV1gFHS7Z8kL2ImuBXJKtvCzSBd7Hz6xUq7++w98Auv+
+Fe2ojig/Y/l8sCPD/eEt+REhJXeeWYB7/TAbZ+UrYYehCPBuc1zxmLIF3wKBgQDA
+1O4ASH/0rBOZN0RhSVkuCH1MD7nxsYsZZfysmbc38ACsjsDTFWKOYHUHai6Xw+fs
+R9s/1GkdRr+nlnYuyUvBFL0IR7SEocvtLWNNygSGRHfEjmrDTgvU0vyiM1IWC0Qa
+gD8rp/rrk5Z/nCL8grhvDZO2NNDVSbYnQKxWUlkUMQKBgQCA2rOXvS+8IzY0tS4Y
+0hsuKZvriEGWIasSx3pIsIv5YQtBs/+cSldOWZ0e4cFZplforXZELI4bxpIP3FoV
+1Ve6Xp1XEDhLwYWYHauxfToT5/NEQA8rR0D50L5GrGj11mmxmK/jB4PHnredPSHt
+p5epz21mLgNZhemziafCZZ7nTw==
+-----END PRIVATE KEY-----
diff --git a/docker/postgres_classic/init/initialize_test_server.sh b/docker/postgres_classic/init/initialize_test_server.sh
new file mode 100644
index 00000000..934ad771
--- /dev/null
+++ b/docker/postgres_classic/init/initialize_test_server.sh
@@ -0,0 +1,6 @@
+cat /var/lib/postgresql/host/postgresql.conf >> /var/lib/postgresql/data/postgresql.conf
+cp /var/lib/postgresql/host/pg_hba.conf /var/lib/postgresql/data
+cp /var/lib/postgresql/host/server.crt /var/lib/postgresql/data
+cp /var/lib/postgresql/host/server.key /var/lib/postgresql/data
+chmod 600 /var/lib/postgresql/data/server.crt
+chmod 600 /var/lib/postgresql/data/server.key
diff --git a/docker/postgres/init/initialize_test_server.sql b/docker/postgres_classic/init/initialize_test_server.sql
similarity index 100%
rename from docker/postgres/init/initialize_test_server.sql
rename to docker/postgres_classic/init/initialize_test_server.sql
diff --git a/docker/postgres_invalid_tls/data/pg_hba.conf b/docker/postgres_invalid_tls/data/pg_hba.conf
deleted file mode 100755
index 02c4591a..00000000
--- a/docker/postgres_invalid_tls/data/pg_hba.conf
+++ /dev/null
@@ -1 +0,0 @@
-hostssl    postgres    postgres   0.0.0.0/0  md5
diff --git a/docker/postgres_invalid_tls/init/initialize_test_server.sh b/docker/postgres_invalid_tls/init/initialize_test_server.sh
deleted file mode 100644
index 403b4cd3..00000000
--- a/docker/postgres_invalid_tls/init/initialize_test_server.sh
+++ /dev/null
@@ -1,8 +0,0 @@
-cat /var/lib/postgresql/host/postgresql.conf >> /var/lib/postgresql/data/postgresql.conf
-cp /var/lib/postgresql/host/pg_hba.conf /var/lib/postgresql/data
-openssl genrsa -out /var/lib/postgresql/data/server.key 2048
-openssl req -new -key /var/lib/postgresql/data/server.key -out /var/lib/postgresql/data/server.csr -subj "/C=CO/ST=Cundinamarca/L=Bogota/O=deno-postgres.com/CN=deno-postgres.com"
-openssl rsa -in /var/lib/postgresql/data/server.key -out /var/lib/postgresql/data/server.key
-openssl x509 -req -days 365 -in /var/lib/postgresql/data/server.csr -signkey /var/lib/postgresql/data/server.key -out /var/lib/postgresql/data/server.crt -sha256
-chmod 600 /var/lib/postgresql/data/server.crt
-chmod 600 /var/lib/postgresql/data/server.key
diff --git a/docker/postgres_invalid_tls/init/initialize_test_server.sql b/docker/postgres_invalid_tls/init/initialize_test_server.sql
deleted file mode 100644
index e69de29b..00000000
diff --git a/docker/postgres_scram/data/pg_hba.conf b/docker/postgres_scram/data/pg_hba.conf
index b97cce44..9e696ec6 100644
--- a/docker/postgres_scram/data/pg_hba.conf
+++ b/docker/postgres_scram/data/pg_hba.conf
@@ -1,2 +1,2 @@
-hostnossl  all         postgres    0.0.0.0/0  scram-sha-256
+hostssl    postgres    scram       0.0.0.0/0  scram-sha-256
 hostnossl  postgres    scram       0.0.0.0/0  scram-sha-256
diff --git a/docker/postgres_scram/data/postgresql.conf b/docker/postgres_scram/data/postgresql.conf
index 91f4196c..a7bb5d98 100644
--- a/docker/postgres_scram/data/postgresql.conf
+++ b/docker/postgres_scram/data/postgresql.conf
@@ -1,3 +1,3 @@
-ssl = off
-# ssl_cert_file = 'server.crt'
-# ssl_key_file = 'server.key'
\ No newline at end of file
+ssl = on
+ssl_cert_file = 'server.crt'
+ssl_key_file = 'server.key'
\ No newline at end of file
diff --git a/docker/postgres_scram/data/server.crt b/docker/postgres_scram/data/server.crt
new file mode 100755
index 00000000..ea2fb4d9
--- /dev/null
+++ b/docker/postgres_scram/data/server.crt
@@ -0,0 +1,22 @@
+-----BEGIN CERTIFICATE-----
+MIIDkTCCAnmgAwIBAgIUCeSCBCVxR0+kf5GcadXrLln0WdYwDQYJKoZIhvcNAQEL
+BQAwJzELMAkGA1UEBhMCVVMxGDAWBgNVBAMMD0V4YW1wbGUtUm9vdC1DQTAgFw0y
+MTA5MjkwNTE1NTBaGA8yMTIwMDkwNTA1MTU1MFowZzELMAkGA1UEBhMCVVMxEjAQ
+BgNVBAgMCVlvdXJTdGF0ZTERMA8GA1UEBwwIWW91ckNpdHkxHTAbBgNVBAoMFEV4
+YW1wbGUtQ2VydGlmaWNhdGVzMRIwEAYDVQQDDAlsb2NhbGhvc3QwggEiMA0GCSqG
+SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDMbJZmDVvPlwipJPBa8sIvl5eA+r2xFj0t
+GN90Nol0VhUxcH6wyo85ILxa+eMIywmYbs3JCdigYz3Y/1cEQ0Uc/Qaqqt28pDFH
+yx/mG6DudDp7kF+Yc6KQ3ZJiMjj++mpT8oJqGEn32VT0yXEWjs+6goafx76Zre/4
+K8mVIL+ve4CnWp15jNo7YMpvw0hCvM4Ev3MHYKn4XSR1nJlozizRb9k6UZJlcR3v
+8NS/AvXqzcJ8d+iCvl9X9YIZaHq8YKgf3Hd0qPqZwA1f/rDzTS583/xuZ04ngd5m
+gg88S5cd0JZ12mZnPYpWkJJWC/bs+14blaIjtdJURhegOTx2AIVjAgMBAAGjczBx
+MB8GA1UdIwQYMBaAFLuBbJIlzyQv4IaataQYMkNqlejoMAkGA1UdEwQCMAAwCwYD
+VR0PBAQDAgTwMDYGA1UdEQQvMC2CCWxvY2FsaG9zdIIQcG9zdGdyZXNfY2xhc3Np
+Y4IOcG9zdGdyZXNfc2NyYW0wDQYJKoZIhvcNAQELBQADggEBAEHjZQGpUW2r5VDy
+3l/BSjKk30I4GQdr58lSfWdh6ULGpOQ3yp1WgJWiH4eKSgozwFeOCqz8oWEKkIS0
+EZFnb0hXaZW2KcXRAco2oyRlQLmSs0XxPJiZNwVAOz1cvF8m/Rk0kbwzCczTPNgp
+N0/xMBxAnE3x7ExwA332gCJ1PQ6KMStMbjhRNb+FhrAdSe/ljzWtHrVEJ8WFsORD
+BjI6oVw1KdZTuzshVMxArW02DutdlssHMQNexYmM9k2fnHQc1zePtVJNJmWiG0/o
+lcHLdsy74AEkFw29X7jpq6Ivsz2HvU8cR14oYRxEY+bhXjqcdl67CKXR/i/sDYcq
+8kzqWZk=
+-----END CERTIFICATE-----
diff --git a/docker/postgres_scram/data/server.key b/docker/postgres_scram/data/server.key
new file mode 100755
index 00000000..f324210e
--- /dev/null
+++ b/docker/postgres_scram/data/server.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDMbJZmDVvPlwip
+JPBa8sIvl5eA+r2xFj0tGN90Nol0VhUxcH6wyo85ILxa+eMIywmYbs3JCdigYz3Y
+/1cEQ0Uc/Qaqqt28pDFHyx/mG6DudDp7kF+Yc6KQ3ZJiMjj++mpT8oJqGEn32VT0
+yXEWjs+6goafx76Zre/4K8mVIL+ve4CnWp15jNo7YMpvw0hCvM4Ev3MHYKn4XSR1
+nJlozizRb9k6UZJlcR3v8NS/AvXqzcJ8d+iCvl9X9YIZaHq8YKgf3Hd0qPqZwA1f
+/rDzTS583/xuZ04ngd5mgg88S5cd0JZ12mZnPYpWkJJWC/bs+14blaIjtdJURheg
+OTx2AIVjAgMBAAECggEANBWutE3PCLNYt4/71ZBovauIJIq+bjJWX/koZfnHR+bu
++2vIO89AcrPOifeFSyZASaBhuklR8nuWtIVKbIGfSGWHn1BtsrS7AanVdNGxTVA7
+3mPIl5VO5E4wD+jv8LdpA/6UD+gkYIv1Q3FX6QF2F/VNy8Qe4hUZQUgW0nJHpLQE
+KXSkOY9r4GMRWzRwpGr3YmR7ZQspBPHuSKzg71Tg0cWUB56uWHphPy1AKuWznVj4
+RavKMUB311Y+TFYCW0cPPA0dByb9i11SeYbbcBEZCTC8UQ5yCsB2EGpZeeO7pukp
+fI1XOxlrVSfiFhGkmtZJQnnsy8anlfJiVa6+CupUwQKBgQDy2Zi53CrIZpaeu3kt
+Msgd3FIQ3UjWHei/Icr35wBjmGKTkuyNikZEZx10v6lD1RK6HTL/5GABIgY617Kp
+KdicZb40/mdy2WqfjyVyMZkiRMQR6qFXp4+Pao5nt/Vr2ICbrT+VtsWnFxtmTa/w
+Wf5JSbImv3r6qc+LfE0Px5wAEwKBgQDXflReOv42BAakDMDk3mlUq9kiXQPF/goC
+XuacI04qv/XJqujtz5i3mRmKXt2Y5R8uiXWp9Z+ho+N6m3RIVq/9soIzzR9FDiQ3
+5fw3UnuU2KFGMshGwWcmdz0ffrzNjoWKaRQuHFvymdTpV7+bT1Vy4VrcmISA0iQA
+AyidP3svcQKBgQCvsrxrY53UZVx9tRcjm0TrTbZWGzMSLotwlQtatdczN1HCgR8B
+/FOAM7Y8/FmDCQpGes+mEV1gFHS7Z8kL2ImuBXJKtvCzSBd7Hz6xUq7++w98Auv+
+Fe2ojig/Y/l8sCPD/eEt+REhJXeeWYB7/TAbZ+UrYYehCPBuc1zxmLIF3wKBgQDA
+1O4ASH/0rBOZN0RhSVkuCH1MD7nxsYsZZfysmbc38ACsjsDTFWKOYHUHai6Xw+fs
+R9s/1GkdRr+nlnYuyUvBFL0IR7SEocvtLWNNygSGRHfEjmrDTgvU0vyiM1IWC0Qa
+gD8rp/rrk5Z/nCL8grhvDZO2NNDVSbYnQKxWUlkUMQKBgQCA2rOXvS+8IzY0tS4Y
+0hsuKZvriEGWIasSx3pIsIv5YQtBs/+cSldOWZ0e4cFZplforXZELI4bxpIP3FoV
+1Ve6Xp1XEDhLwYWYHauxfToT5/NEQA8rR0D50L5GrGj11mmxmK/jB4PHnredPSHt
+p5epz21mLgNZhemziafCZZ7nTw==
+-----END PRIVATE KEY-----
diff --git a/docker/postgres_scram/init/initialize_test_server.sh b/docker/postgres_scram/init/initialize_test_server.sh
index 2bba73f0..68c4a180 100644
--- a/docker/postgres_scram/init/initialize_test_server.sh
+++ b/docker/postgres_scram/init/initialize_test_server.sh
@@ -1,4 +1,6 @@
 cat /var/lib/postgresql/host/postgresql.conf >> /var/lib/postgresql/data/postgresql.conf
 cp /var/lib/postgresql/host/pg_hba.conf /var/lib/postgresql/data
-# chmod 600 /var/lib/postgresql/data/server.crt
-# chmod 600 /var/lib/postgresql/data/server.key
\ No newline at end of file
+cp /var/lib/postgresql/host/server.crt /var/lib/postgresql/data
+cp /var/lib/postgresql/host/server.key /var/lib/postgresql/data
+chmod 600 /var/lib/postgresql/data/server.crt
+chmod 600 /var/lib/postgresql/data/server.key
\ No newline at end of file
diff --git a/docs/README.md b/docs/README.md
index af5a155b..d6d7e84e 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 ![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.12.0/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.13.0/mod.ts)
 ![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)
 
 `deno-postgres` is a lightweight PostgreSQL driver for Deno focused on user
@@ -60,13 +60,57 @@ config = {
 
 // Alternatively you can use a connection string
 config =
-  "postgres://user:password@localhost:5432/test?application_name=my_custom_app";
+  "postgres://user:password@localhost:5432/test?application_name=my_custom_app&sslmode=required";
 
 const client = new Client(config);
 await client.connect();
 await client.end();
 ```
 
+### Connection string
+
+A valid connection string must reflect most of the options that will otherwise
+be available in a client configuration, with the following structure:
+
+```
+driver://user:password@host:port/database_name
+```
+
+#### Password encoding
+
+One thing that must be taken into consideration is that passwords contained
+inside the URL must be properly encoded in order to be passed down to the
+database. You can achieve that by using the JavaScript API `encodeURIComponent`
+and passing your password as an argument.
+
+**Invalid**:
+
+- `postgres://me:Mtx%3@localhost:5432/my_database`
+- `postgres://me:pssword!=with_symbols@localhost:5432/my_database`
+
+**Valid**:
+
+- `postgres://me:Mtx%253@localhost:5432/my_database`
+- `postgres://me:p%C3%A1ssword!%3Dwith_symbols@localhost:5432/my_database`
+
+When possible and if the password is not encoded correctly, the driver will try
+and pass the raw password to the database, however it's highly recommended that
+all passwords are always encoded.
+
+#### URL parameters
+
+Additional to the basic structure, connection strings may contain a variety of
+search parameters such as the following:
+
+- application_name: The equivalent of applicationName in client configuration
+- sslmode: Allows you to specify the tls configuration for your client, the
+  allowed values are the following:
+  - disable: Skip TLS connection altogether
+  - prefer: Attempt to stablish a TLS connection, default to unencrypted if the
+    negotiation fails
+  - require: Attempt to stablish a TLS connection, abort the connection if the
+    negotiation fails
+
 #### Database reconnection
 
 It's a very common occurrence to get broken connections due to connectivity
@@ -126,18 +170,23 @@ your total first-connection-attempts will ammount to four.
 Using a database that supports TLS is quite simple. After providing your
 connection parameters, the client will check if the database accepts encrypted
 connections and will attempt to connect with the parameters provided. If the
-connection is succesful, the following transactions will be carried over TLS.
+connection is successful, the following transactions will be carried over TLS.
 
 However, if the connection fails for whatever reason the user can choose to
 terminate the connection or to attempt to connect using a non-encrypted one.
-This behavior can be defined using the connection parameter `tls.enforce` (not
-available if using a connection string).
+This behavior can be defined using the connection parameter `tls.enforce` or the
+"required" option when using a connection string.
+
+If set, the driver will fail inmediately if no TLS connection can be
+established, otherwise the driver will attempt to connect without encryption
+after TLS connection has failed, but will display a warning containing the
+reason why the TLS connection failed. **This is the default configuration**.
 
-If set to true, the driver will fail inmediately if no TLS connection can be
-established. If set to false the driver will attempt to connect without
-encryption after TLS connection has failed, but will display a warning
-containing the reason why the TLS connection failed. **This is the default
-configuration**.
+If you wish to skip TLS connections altogether, you can do so by passing false
+as a parameter in the `tls.enabled` option or the "disable" option when using a
+connection string. Although discouraged, this option is pretty useful when
+dealing with development databases or versions of Postgres that didn't support
+TLS encrypted connections.
 
 Sadly, stablishing a TLS connection in the way Postgres requires it isn't
 possible without the `Deno.startTls` API, which is currently marked as unstable.
@@ -148,16 +197,16 @@ don't have an estimated time of when that might happen.
 
 There is a miriad of factors you have to take into account when using a
 certificate to encrypt your connection that, if not taken care of, can render
-your certificate invalid. Deno is specially strict when stablishing a TLS
-connection, rendering self-signed certificates unusable at the time.
+your certificate invalid.
 
-Work is being done in order to address the needs of those users who need to use
-said certificates, however as a personal piece of advice I recommend you to not
-use TLS at all if you are going to use a non-secure certificate, specially on a
-publicly reachable server.
+When using a self signed certificate, make sure to specify the path to the CA
+certificate in the `tls.caFile` option when creating the Postgres `Client`, or
+using the `--cert` option when starting Deno. The latter approach only works for
+Deno 1.12.2 or later.
 
 TLS can be disabled from your server by editing your `postgresql.conf` file and
-setting the `ssl` option to `off`.
+setting the `ssl` option to `off`, or in the driver side by using the "disabled"
+option in the client configuration.
 
 #### Env parameters
 
@@ -168,7 +217,7 @@ for Deno to be run with `--allow-env` permissions
 
 The env variables that the client will recognize are taken from `libpq` to keep
 consistency with other PostgreSQL clients out there (see
-https://www.postgresql.org/docs/current/libpq-envars.html)
+https://www.postgresql.org/docs/14/libpq-envars.html)
 
 ```ts
 // PGUSER=user PGPASSWORD=admin PGDATABASE=test deno run --allow-net --allow-env --unstable database.js
@@ -240,7 +289,7 @@ const dbPool = new Pool({
 
 const client = await dbPool.connect(); // 19 connections are still available
 await client.queryArray`UPDATE X SET Y = 'Z'`;
-await client.release(); // This connection is now available for use again
+client.release(); // This connection is now available for use again
 ```
 
 The number of pools is up to you, but a pool of 20 is good for small
@@ -310,8 +359,9 @@ single function call
 ```ts
 async function runQuery(query: string) {
   const client = await pool.connect();
+  let result;
   try {
-    const result = await client.queryObject(query);
+    result = await client.queryObject(query);
   } finally {
     client.release();
   }
diff --git a/mod.ts b/mod.ts
index d921f6e3..9bc1eb03 100644
--- a/mod.ts
+++ b/mod.ts
@@ -1,5 +1,9 @@
 export { Client } from "./client.ts";
-export { ConnectionError, PostgresError } from "./connection/warning.ts";
+export {
+  ConnectionError,
+  PostgresError,
+  TransactionError,
+} from "./client/error.ts";
 export { Pool } from "./pool.ts";
 
 // TODO
diff --git a/pool.ts b/pool.ts
index 58659a4d..76075ced 100644
--- a/pool.ts
+++ b/pool.ts
@@ -1,4 +1,3 @@
-// deno-lint-ignore-file camelcase
 import { PoolClient } from "./client.ts";
 import {
   ClientConfiguration,
@@ -25,7 +24,7 @@ import { DeferredAccessStack } from "./utils/deferred.ts";
  *
  * const client = await pool.connect();
  * await client.queryArray`SELECT 1`;
- * await client.release();
+ * client.release();
  * ```
  *
  * You can also opt to not initialize all your connections at once by passing the `lazy`
@@ -98,8 +97,6 @@ export class Pool {
     this.#size = size;
 
     // This must ALWAYS be called the last
-    // TODO
-    // Refactor into its own initialization function
     this.#ready = this.#initialize();
   }
 
@@ -117,7 +114,7 @@ export class Pool {
    * ```ts
    * const client = pool.connect();
    * await client.queryArray`UPDATE MY_TABLE SET X = 1`;
-   * await client.release();
+   * client.release();
    * ```
    */
   async connect(): Promise<PoolClient> {
diff --git a/query/array_parser.ts b/query/array_parser.ts
index 66f484fa..1db591d0 100644
--- a/query/array_parser.ts
+++ b/query/array_parser.ts
@@ -1,21 +1,17 @@
 // Based of https://github.com/bendrucker/postgres-array
 // Copyright (c) Ben Drucker <bvdrucker@gmail.com> (bendrucker.me). MIT License.
 
+type AllowedSeparators = "," | ";";
 /** Incorrectly parsed data types default to null */
 type ArrayResult<T> = Array<T | null | ArrayResult<T>>;
 type Transformer<T> = (value: string) => T;
 
-function defaultValue(value: string): string {
-  return value;
-}
-
-export function parseArray(source: string): ArrayResult<string>;
 export function parseArray<T>(
   source: string,
   transform: Transformer<T>,
-): ArrayResult<T>;
-export function parseArray(source: string, transform = defaultValue) {
-  return new ArrayParser(source, transform).parse();
+  separator: AllowedSeparators = ",",
+) {
+  return new ArrayParser(source, transform, separator).parse();
 }
 
 class ArrayParser<T> {
@@ -27,6 +23,7 @@ class ArrayParser<T> {
   constructor(
     public source: string,
     public transform: Transformer<T>,
+    public separator: AllowedSeparators,
   ) {}
 
   isEof(): boolean {
@@ -73,23 +70,7 @@ class ArrayParser<T> {
     }
   }
 
-  /**
-   * Arrays can contain items separated by semicolon (such as boxes)
-   * and commas
-   *
-   * This checks if there is an instance of a semicolon on the top level
-   * of the array. If it were to be found, the separator will be
-   * a semicolon, otherwise it will default to a comma
-   */
-  getSeparator() {
-    if (/;(?![^(]*\))/.test(this.source.substr(1, this.source.length - 1))) {
-      return ";";
-    }
-    return ",";
-  }
-
   parse(nested = false): ArrayResult<T> {
-    const separator = this.getSeparator();
     let character, parser, quote;
     this.consumeDimensions();
     while (!this.isEof()) {
@@ -100,6 +81,7 @@ class ArrayParser<T> {
           parser = new ArrayParser(
             this.source.substr(this.position - 1),
             this.transform,
+            this.separator,
           );
           this.entries.push(parser.parse(true));
           this.position += parser.position - 2;
@@ -113,7 +95,7 @@ class ArrayParser<T> {
       } else if (character.value === '"' && !character.escaped) {
         if (quote) this.newEntry(true);
         quote = !quote;
-      } else if (character.value === separator && !quote) {
+      } else if (character.value === this.separator && !quote) {
         this.newEntry();
       } else {
         this.record(character.value);
diff --git a/query/decoders.ts b/query/decoders.ts
index e5373345..b9906bba 100644
--- a/query/decoders.ts
+++ b/query/decoders.ts
@@ -49,7 +49,7 @@ export function decodeBox(value: string): Box {
 }
 
 export function decodeBoxArray(value: string) {
-  return parseArray(value, decodeBox);
+  return parseArray(value, decodeBox, ";");
 }
 
 export function decodeBytea(byteaStr: string): Uint8Array {
@@ -293,7 +293,7 @@ export function decodePolygonArray(value: string) {
 
 export function decodeStringArray(value: string) {
   if (!value) return null;
-  return parseArray(value);
+  return parseArray(value, (value) => value);
 }
 
 /**
diff --git a/query/oid.ts b/query/oid.ts
index 7d56460f..1c754427 100644
--- a/query/oid.ts
+++ b/query/oid.ts
@@ -1,9 +1,6 @@
-// deno-lint-ignore-file camelcase
 export const Oid = {
   bool: 16,
   bytea: 17,
-  // TODO
-  // Find out how to test char types
   char: 18,
   name: 19,
   int8: 20,
@@ -52,8 +49,6 @@ export const Oid = {
   inet: 869,
   bool_array: 1000,
   byte_array: 1001,
-  // TODO
-  // Find out how to test char types
   char_array: 1002,
   name_array: 1003,
   int2_array: 1005,
diff --git a/query/query.ts b/query/query.ts
index 360d9611..a7097d9b 100644
--- a/query/query.ts
+++ b/query/query.ts
@@ -1,7 +1,6 @@
-// deno-lint-ignore-file camelcase
 import { encode, EncodedArg } from "./encode.ts";
 import { Column, decode } from "./decode.ts";
-import { WarningFields } from "../connection/warning.ts";
+import { Notice } from "../connection/message.ts";
 
 const commandTagRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;
 
@@ -69,7 +68,7 @@ export interface QueryObjectConfig extends QueryConfig {
 // Limit the type of parameters that can be passed
 // to a query
 /**
- * https://www.postgresql.org/docs/current/sql-prepare.html
+ * https://www.postgresql.org/docs/14/sql-prepare.html
  *
  * This arguments will be appended to the prepared statement passed
  * as query
@@ -83,18 +82,15 @@ export interface QueryObjectConfig extends QueryConfig {
  *  20, // $2
  * );
  * ```
- * */
+ */
 // deno-lint-ignore no-explicit-any
 export type QueryArguments = any[];
 
 export class QueryResult {
-  // TODO
-  // This should be private for real
-  public _done = false;
   public command!: CommandType;
   public rowCount?: number;
   public rowDescription?: RowDescription;
-  public warnings: WarningFields[] = [];
+  public warnings: Notice[] = [];
 
   constructor(public query: Query<ResultType>) {}
 
@@ -123,10 +119,6 @@ export class QueryResult {
   insertRow(_row: Uint8Array[]): void {
     throw new Error("No implementation for insertRow is defined");
   }
-
-  done() {
-    this._done = true;
-  }
 }
 
 export class QueryArrayResult<T extends Array<unknown> = Array<unknown>>
@@ -134,15 +126,6 @@ export class QueryArrayResult<T extends Array<unknown> = Array<unknown>>
   public rows: T[] = [];
 
   insertRow(row_data: Uint8Array[]) {
-    // TODO
-    // Investigate multiple query status report
-    // INSERT INTO X VALUES (1); SELECT PG_TERMINATE_BACKEND(PID) triggers an error here
-    // if (this._done) {
-    //   throw new Error(
-    //     "Tried to add a new row to the result after the result is done reading",
-    //   );
-    // }
-
     if (!this.rowDescription) {
       throw new Error(
         "The row descriptions required to parse the result data weren't initialized",
@@ -169,18 +152,9 @@ export class QueryObjectResult<
   public rows: T[] = [];
 
   insertRow(row_data: Uint8Array[]) {
-    // TODO
-    // Investigate multiple query status report
-    // INSERT INTO X VALUES (1); SELECT PG_TERMINATE_BACKEND(PID) triggers an error here
-    // if (this._done) {
-    //   throw new Error(
-    //     "Tried to add a new row to the result after the result is done reading",
-    //   );
-    // }
-
     if (!this.rowDescription) {
       throw new Error(
-        "The row descriptions required to parse the result data weren't initialized",
+        "The row description required to parse the result data wasn't initialized",
       );
     }
 
diff --git a/query/transaction.ts b/query/transaction.ts
index 95244a85..9a3017ab 100644
--- a/query/transaction.ts
+++ b/query/transaction.ts
@@ -1,4 +1,3 @@
-// deno-lint-ignore-file camelcase
 import type { QueryClient } from "../client.ts";
 import {
   Query,
@@ -12,7 +11,7 @@ import {
   templateStringToQuery,
 } from "./query.ts";
 import { isTemplateString } from "../utils/utils.ts";
-import { PostgresError, TransactionError } from "../connection/warning.ts";
+import { PostgresError, TransactionError } from "../client/error.ts";
 
 export class Savepoint {
   /**
@@ -82,7 +81,7 @@ export class Savepoint {
    * await savepoint.release(); // This will undo the last update and return the savepoint to the first instance
    * await transaction.rollback(); // Will rollback before the table was deleted
    * ```
-   * */
+   */
   async update() {
     await this.#update_callback(this.name);
     ++this.#instance_count;
@@ -153,7 +152,7 @@ export class Transaction {
    * // Important operations
    * await transaction.commit(); // Session is unlocked, external operations can now take place
    * ```
-   * https://www.postgresql.org/docs/13/sql-begin.html
+   * https://www.postgresql.org/docs/14/sql-begin.html
    */
   async begin() {
     if (this.#client.session.current_transaction !== null) {
@@ -236,7 +235,7 @@ export class Transaction {
    * await transaction.commit(); // The transaction finishes for good
    * ```
    *
-   * https://www.postgresql.org/docs/13/sql-commit.html
+   * https://www.postgresql.org/docs/14/sql-commit.html
    */
   async commit(options?: { chain?: boolean }) {
     this.#assertTransactionOpen();
@@ -285,7 +284,7 @@ export class Transaction {
    * const transaction_2 = client_2.createTransaction("new_transaction", { isolation_level: "repeatable_read", snapshot });
    * // transaction_2 now shares the same starting state that transaction_1 had
    * ```
-   * https://www.postgresql.org/docs/13/functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION
+   * https://www.postgresql.org/docs/14/functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION
    */
   async getSnapshot(): Promise<string> {
     this.#assertTransactionOpen();
@@ -353,14 +352,10 @@ export class Transaction {
     try {
       return await this.#executeQuery(query) as QueryArrayResult<T>;
     } catch (e) {
-      // deno-lint-ignore no-unreachable
       if (e instanceof PostgresError) {
-        // deno-lint-ignore no-unreachable
         await this.commit();
-        // deno-lint-ignore no-unreachable
         throw new TransactionError(this.name, e);
       } else {
-        // deno-lint-ignore no-unreachable
         throw e;
       }
     }
@@ -447,14 +442,10 @@ export class Transaction {
     try {
       return await this.#executeQuery(query) as QueryObjectResult<T>;
     } catch (e) {
-      // deno-lint-ignore no-unreachable
       if (e instanceof PostgresError) {
-        // deno-lint-ignore no-unreachable
         await this.commit();
-        // deno-lint-ignore no-unreachable
         throw new TransactionError(this.name, e);
       } else {
-        // deno-lint-ignore no-unreachable
         throw e;
       }
     }
@@ -503,7 +494,7 @@ export class Transaction {
    * ```ts
    * await transaction.rollback({ chain: true, savepoint: my_savepoint }); // Error, can't both return to savepoint and reset transaction
    * ```
-   * https://www.postgresql.org/docs/13/sql-rollback.html
+   * https://www.postgresql.org/docs/14/sql-rollback.html
    */
   async rollback(savepoint?: string | Savepoint): Promise<void>;
   async rollback(options?: { savepoint?: string | Savepoint }): Promise<void>;
@@ -622,7 +613,7 @@ export class Transaction {
    * const savepoint_b = await transaction.save("a"); // They will be the same savepoint, but the savepoint will be updated to this position
    * await transaction.rollback(savepoint_a); // Rolls back to savepoint_b
    * ```
-   * https://www.postgresql.org/docs/13/sql-savepoint.html
+   * https://www.postgresql.org/docs/14/sql-savepoint.html
    */
   async savepoint(name: string): Promise<Savepoint> {
     this.#assertTransactionOpen();
diff --git a/query/types.ts b/query/types.ts
index 7d20bde8..9234cec4 100644
--- a/query/types.ts
+++ b/query/types.ts
@@ -1,5 +1,5 @@
 /**
- * https://www.postgresql.org/docs/13/datatype-geometric.html#id-1.5.7.16.8
+ * https://www.postgresql.org/docs/14/datatype-geometric.html#id-1.5.7.16.8
  */
 export interface Box {
   a: Point;
@@ -7,7 +7,7 @@ export interface Box {
 }
 
 /**
- * https://www.postgresql.org/docs/13/datatype-geometric.html#DATATYPE-CIRCLE
+ * https://www.postgresql.org/docs/14/datatype-geometric.html#DATATYPE-CIRCLE
  */
 export interface Circle {
   point: Point;
@@ -19,8 +19,8 @@ export interface Circle {
  *
  * Example: 1.89, 2, 2.1
  *
- * https://www.postgresql.org/docs/13/datatype-numeric.html#DATATYPE-FLOAT
- * */
+ * https://www.postgresql.org/docs/14/datatype-numeric.html#DATATYPE-FLOAT
+ */
 export type Float4 = "string";
 
 /**
@@ -28,12 +28,12 @@ export type Float4 = "string";
  *
  * Example: 1.89, 2, 2.1
  *
- * https://www.postgresql.org/docs/13/datatype-numeric.html#DATATYPE-FLOAT
- * */
+ * https://www.postgresql.org/docs/14/datatype-numeric.html#DATATYPE-FLOAT
+ */
 export type Float8 = "string";
 
 /**
- * https://www.postgresql.org/docs/13/datatype-geometric.html#DATATYPE-LINE
+ * https://www.postgresql.org/docs/14/datatype-geometric.html#DATATYPE-LINE
  */
 export interface Line {
   a: Float8;
@@ -42,7 +42,7 @@ export interface Line {
 }
 
 /**
- * https://www.postgresql.org/docs/13/datatype-geometric.html#DATATYPE-LSEG
+ * https://www.postgresql.org/docs/14/datatype-geometric.html#DATATYPE-LSEG
  */
 export interface LineSegment {
   a: Point;
@@ -50,12 +50,12 @@ export interface LineSegment {
 }
 
 /**
- * https://www.postgresql.org/docs/13/datatype-geometric.html#id-1.5.7.16.9
+ * https://www.postgresql.org/docs/14/datatype-geometric.html#id-1.5.7.16.9
  */
 export type Path = Point[];
 
 /**
- * https://www.postgresql.org/docs/13/datatype-geometric.html#id-1.5.7.16.5
+ * https://www.postgresql.org/docs/14/datatype-geometric.html#id-1.5.7.16.5
  */
 export interface Point {
   x: Float8;
@@ -63,12 +63,12 @@ export interface Point {
 }
 
 /**
- * https://www.postgresql.org/docs/13/datatype-geometric.html#DATATYPE-POLYGON
+ * https://www.postgresql.org/docs/14/datatype-geometric.html#DATATYPE-POLYGON
  */
 export type Polygon = Point[];
 
 /**
- * https://www.postgresql.org/docs/13/datatype-oid.html
+ * https://www.postgresql.org/docs/14/datatype-oid.html
  */
 export type TID = [BigInt, BigInt];
 
@@ -76,6 +76,6 @@ export type TID = [BigInt, BigInt];
  * Additional to containing normal dates, they can contain 'Infinity'
  * values, so handle them with care
  *
- * https://www.postgresql.org/docs/13/datatype-datetime.html
+ * https://www.postgresql.org/docs/14/datatype-datetime.html
  */
 export type Timestamp = Date | number;
diff --git a/tests/scram_test.ts b/tests/auth_test.ts
similarity index 51%
rename from tests/scram_test.ts
rename to tests/auth_test.ts
index 39a7396e..0c1131df 100644
--- a/tests/scram_test.ts
+++ b/tests/auth_test.ts
@@ -3,11 +3,11 @@ import {
   assertNotEquals,
   assertThrowsAsync,
 } from "./test_deps.ts";
-import * as scram from "../connection/scram.ts";
+import { Client as ScramClient, Reason } from "../connection/scram.ts";
 
-Deno.test("scram.Client reproduces RFC 7677 example", async () => {
+Deno.test("Scram client reproduces RFC 7677 example", async () => {
   // Example seen in https://tools.ietf.org/html/rfc7677
-  const client = new scram.Client("user", "pencil", "rOprNGfwEbeRWgbNEkqO");
+  const client = new ScramClient("user", "pencil", "rOprNGfwEbeRWgbNEkqO");
 
   assertEquals(
     client.composeChallenge(),
@@ -27,32 +27,40 @@ Deno.test("scram.Client reproduces RFC 7677 example", async () => {
   );
 });
 
-Deno.test("scram.Client catches bad server nonce", async () => {
+Deno.test("Scram client catches bad server nonce", async () => {
   const testCases = [
     "s=c2FsdA==,i=4096", // no server nonce
     "r=,s=c2FsdA==,i=4096", // empty
     "r=nonce2,s=c2FsdA==,i=4096", // not prefixed with client nonce
   ];
   for (const testCase of testCases) {
-    const client = new scram.Client("user", "password", "nonce1");
+    const client = new ScramClient("user", "password", "nonce1");
     client.composeChallenge();
-    await assertThrowsAsync(() => client.receiveChallenge(testCase));
+    await assertThrowsAsync(
+      () => client.receiveChallenge(testCase),
+      Error,
+      Reason.BadServerNonce,
+    );
   }
 });
 
-Deno.test("scram.Client catches bad salt", async () => {
+Deno.test("Scram client catches bad salt", async () => {
   const testCases = [
     "r=nonce12,i=4096", // no salt
     "r=nonce12,s=*,i=4096", // ill-formed base-64 string
   ];
   for (const testCase of testCases) {
-    const client = new scram.Client("user", "password", "nonce1");
+    const client = new ScramClient("user", "password", "nonce1");
     client.composeChallenge();
-    await assertThrowsAsync(() => client.receiveChallenge(testCase));
+    await assertThrowsAsync(
+      () => client.receiveChallenge(testCase),
+      Error,
+      Reason.BadSalt,
+    );
   }
 });
 
-Deno.test("scram.Client catches bad iteration count", async () => {
+Deno.test("Scram client catches bad iteration count", async () => {
   const testCases = [
     "r=nonce12,s=c2FsdA==", // no iteration count
     "r=nonce12,s=c2FsdA==,i=", // empty
@@ -61,30 +69,44 @@ Deno.test("scram.Client catches bad iteration count", async () => {
     "r=nonce12,s=c2FsdA==,i=-1", // non-positive integer
   ];
   for (const testCase of testCases) {
-    const client = new scram.Client("user", "password", "nonce1");
+    const client = new ScramClient("user", "password", "nonce1");
     client.composeChallenge();
-    await assertThrowsAsync(() => client.receiveChallenge(testCase));
+    await assertThrowsAsync(
+      () => client.receiveChallenge(testCase),
+      Error,
+      Reason.BadIterationCount,
+    );
   }
 });
 
-Deno.test("scram.Client catches bad verifier", async () => {
-  const client = new scram.Client("user", "password", "nonce1");
+Deno.test("Scram client catches bad verifier", async () => {
+  const client = new ScramClient("user", "password", "nonce1");
   client.composeChallenge();
   await client.receiveChallenge("r=nonce12,s=c2FsdA==,i=4096");
   await client.composeResponse();
-  await assertThrowsAsync(() => client.receiveResponse("v=xxxx"));
+  await assertThrowsAsync(
+    () => client.receiveResponse("v=xxxx"),
+    Error,
+    Reason.BadVerifier,
+  );
 });
 
-Deno.test("scram.Client catches server rejection", async () => {
-  const client = new scram.Client("user", "password", "nonce1");
+Deno.test("Scram client catches server rejection", async () => {
+  const client = new ScramClient("user", "password", "nonce1");
   client.composeChallenge();
   await client.receiveChallenge("r=nonce12,s=c2FsdA==,i=4096");
   await client.composeResponse();
-  await assertThrowsAsync(() => client.receiveResponse("e=auth error"));
+
+  const message = "auth error";
+  await assertThrowsAsync(
+    () => client.receiveResponse(`e=${message}`),
+    Error,
+    message,
+  );
 });
 
-Deno.test("scram.Client generates unique challenge", () => {
-  const challenge1 = new scram.Client("user", "password").composeChallenge();
-  const challenge2 = new scram.Client("user", "password").composeChallenge();
+Deno.test("Scram client generates unique challenge", () => {
+  const challenge1 = new ScramClient("user", "password").composeChallenge();
+  const challenge2 = new ScramClient("user", "password").composeChallenge();
   assertNotEquals(challenge1, challenge2);
 });
diff --git a/tests/config.json b/tests/config.json
index a4d7b7ad..d86768b4 100644
--- a/tests/config.json
+++ b/tests/config.json
@@ -1,15 +1,16 @@
 {
   "ci": {
-    "postgres": {
+    "postgres_classic": {
       "applicationName": "deno_postgres",
       "database": "postgres",
-      "hostname": "postgres",
+      "hostname": "postgres_classic",
       "password": "postgres",
       "port": 5432,
       "users": {
         "clear": "clear",
         "main": "postgres",
-        "md5": "md5"
+        "md5": "md5",
+        "tls_only": "tls_only"
       }
     },
     "postgres_scram": {
@@ -21,23 +22,10 @@
       "users": {
         "scram": "scram"
       }
-    },
-    "postgres_invalid_tls": {
-      "applicationName": "deno_postgres",
-      "database": "postgres",
-      "hostname": "postgres_invalid_tls",
-      "password": "postgres",
-      "port": 5432,
-      "tls": {
-        "enforce": true
-      },
-      "users": {
-        "main": "postgres"
-      }
     }
   },
   "local": {
-    "postgres": {
+    "postgres_classic": {
       "applicationName": "deno_postgres",
       "database": "postgres",
       "hostname": "localhost",
@@ -46,7 +34,8 @@
       "users": {
         "clear": "clear",
         "main": "postgres",
-        "md5": "md5"
+        "md5": "md5",
+        "tls_only": "tls_only"
       }
     },
     "postgres_scram": {
@@ -58,19 +47,6 @@
       "users": {
         "scram": "scram"
       }
-    },
-    "postgres_invalid_tls": {
-      "applicationName": "deno_postgres",
-      "database": "postgres",
-      "hostname": "localhost",
-      "password": "postgres",
-      "port": 6003,
-      "tls": {
-        "enforce": true
-      },
-      "users": {
-        "main": "postgres"
-      }
     }
   }
 }
diff --git a/tests/config.ts b/tests/config.ts
index be472af2..efef8ed1 100644
--- a/tests/config.ts
+++ b/tests/config.ts
@@ -1,42 +1,29 @@
-// deno-lint-ignore-file camelcase
 import { ClientOptions } from "../connection/connection_params.ts";
+import { fromFileUrl } from "./test_deps.ts";
 
-interface EnvironmentConfig {
-  postgres: {
-    applicationName: string;
-    database: string;
-    hostname: string;
-    password: string;
-    port: string | number;
-    users: {
-      clear: string;
-      main: string;
-      md5: string;
-    };
-  };
-  postgres_scram: {
-    applicationName: string;
-    database: string;
-    hostname: string;
-    password: string;
-    port: string | number;
-    users: {
-      scram: string;
-    };
+type ConfigFileConnection = Pick<
+  ClientOptions,
+  "applicationName" | "database" | "hostname" | "password" | "port"
+>;
+
+type Classic = ConfigFileConnection & {
+  users: {
+    clear: string;
+    main: string;
+    md5: string;
+    tls_only: string;
   };
-  postgres_invalid_tls: {
-    applicationName: string;
-    database: string;
-    hostname: string;
-    password: string;
-    port: string | number;
-    tls: {
-      enforce: boolean;
-    };
-    users: {
-      main: string;
-    };
+};
+
+type Scram = ConfigFileConnection & {
+  users: {
+    scram: string;
   };
+};
+
+interface EnvironmentConfig {
+  postgres_classic: Classic;
+  postgres_scram: Scram;
 }
 
 const config_file: {
@@ -46,64 +33,79 @@ const config_file: {
   await Deno.readTextFile(new URL("./config.json", import.meta.url)),
 );
 
-const config = Deno.env.get("DEVELOPMENT") === "true"
+const config = Deno.env.get("DENO_POSTGRES_DEVELOPMENT") === "true"
   ? config_file.local
   : config_file.ci;
 
-export const getClearConfiguration = (): ClientOptions => {
+const enabled_tls = {
+  caFile: fromFileUrl(new URL("../docker/certs/ca.crt", import.meta.url)),
+  enabled: true,
+  enforce: true,
+};
+
+const disabled_tls = {
+  enabled: false,
+};
+
+export const getClearConfiguration = (
+  tls: boolean,
+): ClientOptions => {
   return {
-    applicationName: config.postgres.applicationName,
-    database: config.postgres.database,
-    hostname: config.postgres.hostname,
-    password: config.postgres.password,
-    port: config.postgres.port,
-    user: config.postgres.users.clear,
+    applicationName: config.postgres_classic.applicationName,
+    database: config.postgres_classic.database,
+    hostname: config.postgres_classic.hostname,
+    password: config.postgres_classic.password,
+    port: config.postgres_classic.port,
+    tls: tls ? enabled_tls : disabled_tls,
+    user: config.postgres_classic.users.clear,
   };
 };
 
+/** MD5 authenticated user with privileged access to the database */
 export const getMainConfiguration = (): ClientOptions => {
   return {
-    applicationName: config.postgres.applicationName,
-    database: config.postgres.database,
-    hostname: config.postgres.hostname,
-    password: config.postgres.password,
-    port: config.postgres.port,
-    user: config.postgres.users.main,
+    applicationName: config.postgres_classic.applicationName,
+    database: config.postgres_classic.database,
+    hostname: config.postgres_classic.hostname,
+    password: config.postgres_classic.password,
+    port: config.postgres_classic.port,
+    tls: enabled_tls,
+    user: config.postgres_classic.users.main,
   };
 };
 
-export const getMd5Configuration = (): ClientOptions => {
+export const getMd5Configuration = (tls: boolean): ClientOptions => {
   return {
-    applicationName: config.postgres.applicationName,
-    database: config.postgres.database,
-    hostname: config.postgres.hostname,
-    password: config.postgres.password,
-    port: config.postgres.port,
-    user: config.postgres.users.md5,
+    applicationName: config.postgres_classic.applicationName,
+    database: config.postgres_classic.database,
+    hostname: config.postgres_classic.hostname,
+    password: config.postgres_classic.password,
+    port: config.postgres_classic.port,
+    tls: tls ? enabled_tls : disabled_tls,
+    user: config.postgres_classic.users.md5,
   };
 };
 
-export const getScramSha256Configuration = (): ClientOptions => {
+export const getScramConfiguration = (tls: boolean): ClientOptions => {
   return {
     applicationName: config.postgres_scram.applicationName,
     database: config.postgres_scram.database,
     hostname: config.postgres_scram.hostname,
     password: config.postgres_scram.password,
     port: config.postgres_scram.port,
+    tls: tls ? enabled_tls : disabled_tls,
     user: config.postgres_scram.users.scram,
   };
 };
 
-export const getInvalidTlsConfiguration = (): ClientOptions => {
+export const getTlsOnlyConfiguration = (): ClientOptions => {
   return {
-    applicationName: config.postgres_invalid_tls.applicationName,
-    database: config.postgres_invalid_tls.database,
-    hostname: config.postgres_invalid_tls.hostname,
-    password: config.postgres_invalid_tls.password,
-    port: config.postgres_invalid_tls.port,
-    tls: {
-      enforce: config.postgres_invalid_tls.tls.enforce,
-    },
-    user: config.postgres_invalid_tls.users.main,
+    applicationName: config.postgres_classic.applicationName,
+    database: config.postgres_classic.database,
+    hostname: config.postgres_classic.hostname,
+    password: config.postgres_classic.password,
+    port: config.postgres_classic.port,
+    tls: enabled_tls,
+    user: config.postgres_classic.users.tls_only,
   };
 };
diff --git a/tests/connection_params_test.ts b/tests/connection_params_test.ts
index dd97c45f..a2aa9c96 100644
--- a/tests/connection_params_test.ts
+++ b/tests/connection_params_test.ts
@@ -1,9 +1,6 @@
-// deno-lint-ignore-file camelcase
 import { assertEquals, assertThrows } from "./test_deps.ts";
-import {
-  ConnectionParamsError,
-  createParams,
-} from "../connection/connection_params.ts";
+import { createParams } from "../connection/connection_params.ts";
+import { ConnectionParamsError } from "../client/error.ts";
 import { has_env_access } from "./constants.ts";
 
 /**
@@ -56,7 +53,7 @@ function withNotAllowedEnv(fn: () => void) {
   };
 }
 
-Deno.test("dsnStyleParameters", function () {
+Deno.test("Parses connection string", function () {
   const p = createParams(
     "postgres://some_user@some_host:10101/deno_postgres",
   );
@@ -67,7 +64,7 @@ Deno.test("dsnStyleParameters", function () {
   assertEquals(p.port, 10101);
 });
 
-Deno.test("dsnStyleParametersWithPostgresqlDriver", function () {
+Deno.test('Parses connection string with "postgresql" as driver', function () {
   const p = createParams(
     "postgresql://some_user@some_host:10101/deno_postgres",
   );
@@ -78,7 +75,7 @@ Deno.test("dsnStyleParametersWithPostgresqlDriver", function () {
   assertEquals(p.port, 10101);
 });
 
-Deno.test("dsnStyleParametersWithoutExplicitPort", function () {
+Deno.test("Parses connection string without port", function () {
   const p = createParams(
     "postgres://some_user@some_host/deno_postgres",
   );
@@ -89,7 +86,7 @@ Deno.test("dsnStyleParametersWithoutExplicitPort", function () {
   assertEquals(p.port, 5432);
 });
 
-Deno.test("dsnStyleParametersWithApplicationName", function () {
+Deno.test("Parses connection string with application name", function () {
   const p = createParams(
     "postgres://some_user@some_host:10101/deno_postgres?application_name=test_app",
   );
@@ -101,15 +98,16 @@ Deno.test("dsnStyleParametersWithApplicationName", function () {
   assertEquals(p.port, 10101);
 });
 
-Deno.test("dsnStyleParametersWithSSLModeRequire", function () {
+Deno.test("Parses connection string with sslmode required", function () {
   const p = createParams(
     "postgres://some_user@some_host:10101/deno_postgres?sslmode=require",
   );
 
+  assertEquals(p.tls.enabled, true);
   assertEquals(p.tls.enforce, true);
 });
 
-Deno.test("dsnStyleParametersWithInvalidDriver", function () {
+Deno.test("Throws on connection string with invalid driver", function () {
   assertThrows(
     () =>
       createParams(
@@ -120,7 +118,7 @@ Deno.test("dsnStyleParametersWithInvalidDriver", function () {
   );
 });
 
-Deno.test("dsnStyleParametersWithInvalidPort", function () {
+Deno.test("Throws on connection string with invalid port", function () {
   assertThrows(
     () =>
       createParams(
@@ -131,18 +129,18 @@ Deno.test("dsnStyleParametersWithInvalidPort", function () {
   );
 });
 
-Deno.test("dsnStyleParametersWithInvalidSSLMode", function () {
+Deno.test("Throws on connection string with invalid ssl mode", function () {
   assertThrows(
     () =>
       createParams(
-        "postgres://some_user@some_host:10101/deno_postgres?sslmode=disable",
+        "postgres://some_user@some_host:10101/deno_postgres?sslmode=verify-full",
       ),
     undefined,
-    "Supplied DSN has invalid sslmode 'disable'. Only 'require' or 'prefer' are supported",
+    "Supplied DSN has invalid sslmode 'verify-full'. Only 'disable', 'require', and 'prefer' are supported",
   );
 });
 
-Deno.test("objectStyleParameters", function () {
+Deno.test("Parses connection options", function () {
   const p = createParams({
     user: "some_user",
     hostname: "some_host",
@@ -156,8 +154,22 @@ Deno.test("objectStyleParameters", function () {
   assertEquals(p.port, 10101);
 });
 
+Deno.test("Throws on invalid tls options", function () {
+  assertThrows(
+    () =>
+      createParams({
+        tls: {
+          enabled: false,
+          enforce: true,
+        },
+      }),
+    ConnectionParamsError,
+    "Can't enforce TLS when client has TLS encryption is disabled",
+  );
+});
+
 Deno.test({
-  name: "envParameters",
+  name: "Parses env connection options",
   ignore: !has_env_access,
   fn() {
     withEnv({
@@ -176,7 +188,7 @@ Deno.test({
 });
 
 Deno.test({
-  name: "envParametersWithInvalidPort",
+  name: "Throws on env connection options with invalid port",
   ignore: !has_env_access,
   fn() {
     const port = "abc";
@@ -196,7 +208,7 @@ Deno.test({
 });
 
 Deno.test(
-  "envParametersWhenNotAllowed",
+  "Parses mixed connection options and env connection options",
   withNotAllowedEnv(function () {
     const p = createParams({
       database: "deno_postgres",
@@ -210,7 +222,7 @@ Deno.test(
   }),
 );
 
-Deno.test("defaultParameters", function () {
+Deno.test("Uses default connection options", function () {
   const database = "deno_postgres";
   const user = "deno_postgres";
 
@@ -232,7 +244,7 @@ Deno.test("defaultParameters", function () {
   );
 });
 
-Deno.test("requiredParameters", function () {
+Deno.test("Throws when required options are not passed", function () {
   if (has_env_access) {
     if (!(Deno.env.get("PGUSER") && Deno.env.get("PGDATABASE"))) {
       assertThrows(
diff --git a/tests/connection_test.ts b/tests/connection_test.ts
index a86697fe..9561f2b8 100644
--- a/tests/connection_test.ts
+++ b/tests/connection_test.ts
@@ -1,50 +1,146 @@
-// deno-lint-ignore-file camelcase
 import { assertEquals, assertThrowsAsync, deferred } from "./test_deps.ts";
 import {
   getClearConfiguration,
-  getInvalidTlsConfiguration,
   getMainConfiguration,
   getMd5Configuration,
-  getScramSha256Configuration,
+  getScramConfiguration,
+  getTlsOnlyConfiguration,
 } from "./config.ts";
-import { Client, PostgresError } from "../mod.ts";
-import { ConnectionError } from "../connection/warning.ts";
+import { Client, ConnectionError, PostgresError } from "../mod.ts";
 
 function getRandomString() {
   return Math.random().toString(36).substring(7);
 }
 
-Deno.test("Clear password authentication (no tls)", async () => {
-  const client = new Client(getClearConfiguration());
+Deno.test("Clear password authentication (unencrypted)", async () => {
+  const client = new Client(getClearConfiguration(false));
   await client.connect();
-  await client.end();
+
+  try {
+    assertEquals(client.session.tls, false);
+  } finally {
+    await client.end();
+  }
+});
+
+Deno.test("Clear password authentication (tls)", async () => {
+  const client = new Client(getClearConfiguration(true));
+  await client.connect();
+
+  try {
+    assertEquals(client.session.tls, true);
+  } finally {
+    await client.end();
+  }
+});
+
+Deno.test("MD5 authentication (unencrypted)", async () => {
+  const client = new Client(getMd5Configuration(false));
+  await client.connect();
+
+  try {
+    assertEquals(client.session.tls, false);
+  } finally {
+    await client.end();
+  }
+});
+
+Deno.test("MD5 authentication (tls)", async () => {
+  const client = new Client(getMd5Configuration(true));
+  await client.connect();
+
+  try {
+    assertEquals(client.session.tls, true);
+  } finally {
+    await client.end();
+  }
 });
 
-Deno.test("MD5 authentication (no tls)", async () => {
-  const client = new Client(getMd5Configuration());
+Deno.test("SCRAM-SHA-256 authentication (unencrypted)", async () => {
+  const client = new Client(getScramConfiguration(false));
   await client.connect();
-  await client.end();
+
+  try {
+    assertEquals(client.session.tls, false);
+  } finally {
+    await client.end();
+  }
 });
 
-Deno.test("SCRAM-SHA-256 authentication (no tls)", async () => {
-  const client = new Client(getScramSha256Configuration());
+Deno.test("SCRAM-SHA-256 authentication (tls)", async () => {
+  const client = new Client(getScramConfiguration(true));
   await client.connect();
-  await client.end();
+
+  try {
+    assertEquals(client.session.tls, true);
+  } finally {
+    await client.end();
+  }
 });
+Deno.test("Skips TLS connection when TLS disabled", async () => {
+  const client = new Client({
+    ...getTlsOnlyConfiguration(),
+    tls: { enabled: false },
+  });
 
-Deno.test("Handles invalid TLS certificates correctly", async () => {
-  const client = new Client(getInvalidTlsConfiguration());
+  // Connection will fail due to TLS only user
+  try {
+    await assertThrowsAsync(
+      () => client.connect(),
+      PostgresError,
+      "no pg_hba.conf",
+    );
+  } finally {
+    try {
+      assertEquals(client.session.tls, undefined);
+    } finally {
+      await client.end();
+    }
+  }
+});
 
-  await assertThrowsAsync(
-    async (): Promise<void> => {
-      await client.connect();
+Deno.test("Aborts TLS connection when certificate is untrusted", async () => {
+  // Force TLS but don't provide CA
+  const client = new Client({
+    ...getTlsOnlyConfiguration(),
+    tls: {
+      enabled: true,
+      enforce: true,
     },
-    Error,
-    "The certificate used to secure the TLS connection is invalid",
-  )
-    .finally(async () => {
+  });
+
+  try {
+    await assertThrowsAsync(
+      async (): Promise<void> => {
+        await client.connect();
+      },
+      Error,
+      "The certificate used to secure the TLS connection is invalid",
+    );
+  } finally {
+    try {
+      assertEquals(client.session.tls, undefined);
+    } finally {
       await client.end();
-    });
+    }
+  }
+});
+
+Deno.test("Defaults to unencrypted when certificate is invalid and TLS is not enforced", async () => {
+  // Remove CA, request tls and disable enforce
+  const client = new Client({
+    ...getMainConfiguration(),
+    tls: { enabled: true, enforce: false },
+  });
+
+  await client.connect();
+
+  // Connection will fail due to TLS only user
+  try {
+    assertEquals(client.session.tls, false);
+  } finally {
+    await client.end();
+  }
 });
 
 Deno.test("Handles bad authentication correctly", async function () {
@@ -52,16 +148,17 @@ Deno.test("Handles bad authentication correctly", async function () {
   badConnectionData.password += getRandomString();
   const client = new Client(badConnectionData);
 
-  await assertThrowsAsync(
-    async (): Promise<void> => {
-      await client.connect();
-    },
-    PostgresError,
-    "password authentication failed for user",
-  )
-    .finally(async () => {
-      await client.end();
-    });
+  try {
+    await assertThrowsAsync(
+      async (): Promise<void> => {
+        await client.connect();
+      },
+      PostgresError,
+      "password authentication failed for user",
+    );
+  } finally {
+    await client.end();
+  }
 });
 
 // This test requires current user database connection permissions
@@ -71,32 +168,54 @@ Deno.test("Startup error when database does not exist", async function () {
   badConnectionData.database += getRandomString();
   const client = new Client(badConnectionData);
 
-  await assertThrowsAsync(
-    async (): Promise<void> => {
-      await client.connect();
-    },
-    PostgresError,
-    "does not exist",
-  )
-    .finally(async () => {
-      await client.end();
-    });
+  try {
+    await assertThrowsAsync(
+      async (): Promise<void> => {
+        await client.connect();
+      },
+      PostgresError,
+      "does not exist",
+    );
+  } finally {
+    await client.end();
+  }
 });
 
 Deno.test("Exposes session PID", async () => {
-  const client = new Client(getClearConfiguration());
+  const client = new Client(getMainConfiguration());
   await client.connect();
-  const { rows } = await client.queryObject<{ pid: string }>(
-    "SELECT PG_BACKEND_PID() AS PID",
-  );
-  assertEquals(client.session.pid, rows[0].pid);
 
-  await client.end();
-  assertEquals(
-    client.session.pid,
-    undefined,
-    "PID is not cleared after disconnection",
-  );
+  try {
+    const { rows } = await client.queryObject<{ pid: string }>(
+      "SELECT PG_BACKEND_PID() AS PID",
+    );
+    assertEquals(client.session.pid, rows[0].pid);
+  } finally {
+    await client.end();
+
+    assertEquals(
+      client.session.pid,
+      undefined,
+      "PID was not cleared after disconnection",
+    );
+  }
+});
+
+Deno.test("Exposes session encryption", async () => {
+  const client = new Client(getMainConfiguration());
+  await client.connect();
+
+  try {
+    assertEquals(client.session.tls, true);
+  } finally {
+    await client.end();
+
+    assertEquals(
+      client.session.tls,
+      undefined,
+      "TLS was not cleared after disconnection",
+    );
+  }
 });
 
 Deno.test("Closes connection on bad TLS availability verification", async function () {
@@ -261,46 +380,48 @@ Deno.test("Attempts reconnection on disconnection", async function () {
   });
   await client.connect();
 
-  const test_table = "TEST_DENO_RECONNECTION_1";
-  const test_value = 1;
-
-  await client.queryArray(`DROP TABLE IF EXISTS ${test_table}`);
-  await client.queryArray(`CREATE TABLE ${test_table} (X INT)`);
-
-  await assertThrowsAsync(
-    () =>
-      client.queryArray(
-        `INSERT INTO ${test_table} VALUES (${test_value}); COMMIT; SELECT PG_TERMINATE_BACKEND(${client.session.pid})`,
-      ),
-    ConnectionError,
-    "The session was terminated by the database",
-  );
-  assertEquals(client.connected, false);
-
-  const { rows: result_1 } = await client.queryObject<{ pid: string }>({
-    text: "SELECT PG_BACKEND_PID() AS PID",
-    fields: ["pid"],
-  });
-  assertEquals(
-    client.session.pid,
-    result_1[0].pid,
-    "The PID is not reseted after reconnection",
-  );
-
-  const { rows: result_2 } = await client.queryObject<{ x: number }>({
-    text: `SELECT X FROM ${test_table}`,
-    fields: ["x"],
-  });
-  assertEquals(
-    result_2.length,
-    1,
-  );
-  assertEquals(
-    result_2[0].x,
-    test_value,
-  );
-
-  await client.end();
+  try {
+    const test_table = "TEST_DENO_RECONNECTION_1";
+    const test_value = 1;
+
+    await client.queryArray(`DROP TABLE IF EXISTS ${test_table}`);
+    await client.queryArray(`CREATE TABLE ${test_table} (X INT)`);
+
+    await assertThrowsAsync(
+      () =>
+        client.queryArray(
+          `INSERT INTO ${test_table} VALUES (${test_value}); COMMIT; SELECT PG_TERMINATE_BACKEND(${client.session.pid})`,
+        ),
+      ConnectionError,
+      "The session was terminated by the database",
+    );
+    assertEquals(client.connected, false);
+
+    const { rows: result_1 } = await client.queryObject<{ pid: string }>({
+      text: "SELECT PG_BACKEND_PID() AS PID",
+      fields: ["pid"],
+    });
+    assertEquals(
+      client.session.pid,
+      result_1[0].pid,
+      "The PID is not reseted after reconnection",
+    );
+
+    const { rows: result_2 } = await client.queryObject<{ x: number }>({
+      text: `SELECT X FROM ${test_table}`,
+      fields: ["x"],
+    });
+    assertEquals(
+      result_2.length,
+      1,
+    );
+    assertEquals(
+      result_2[0].x,
+      test_value,
+    );
+  } finally {
+    await client.end();
+  }
 });
 
 Deno.test("Doesn't attempt reconnection when attempts are set to zero", async function () {
@@ -309,14 +430,20 @@ Deno.test("Doesn't attempt reconnection when attempts are set to zero", async fu
     connection: { attempts: 0 },
   });
   await client.connect();
-  await assertThrowsAsync(() =>
-    client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`
-  );
-  assertEquals(client.connected, false);
 
-  await assertThrowsAsync(
-    () => client.queryArray`SELECT 1`,
-    Error,
-    "The client has been disconnected from the database",
-  );
+  try {
+    await assertThrowsAsync(() =>
+      client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`
+    );
+    assertEquals(client.connected, false);
+
+    await assertThrowsAsync(
+      () => client.queryArray`SELECT 1`,
+      Error,
+      "The client has been disconnected from the database",
+    );
+  } finally {
+    // End the connection in case the previous assertions failed
+    await client.end();
+  }
 });
diff --git a/tests/constants.ts b/tests/constants.ts
index 2fdd16b1..1348c46f 100644
--- a/tests/constants.ts
+++ b/tests/constants.ts
@@ -1,18 +1,3 @@
-// deno-lint-ignore-file camelcase
-export const DEFAULT_SETUP = [
-  "DROP TABLE IF EXISTS ids;",
-  "CREATE TABLE ids(id integer);",
-  "INSERT INTO ids(id) VALUES(1);",
-  "INSERT INTO ids(id) VALUES(2);",
-  "DROP TABLE IF EXISTS timestamps;",
-  "CREATE TABLE timestamps(dt timestamptz);",
-  `INSERT INTO timestamps(dt) VALUES('2019-02-10T10:30:40.005+04:30');`,
-  "DROP TABLE IF EXISTS bytes;",
-  "CREATE TABLE bytes(b bytea);",
-  "INSERT INTO bytes VALUES(E'foo\\\\000\\\\200\\\\\\\\\\\\377')",
-  "CREATE OR REPLACE FUNCTION CREATE_NOTICE () RETURNS INT AS $$ BEGIN RAISE NOTICE 'NOTICED'; RETURN (SELECT 1); END; $$ LANGUAGE PLPGSQL;",
-];
-
 let has_env_access = true;
 try {
   Deno.env.toObject();
diff --git a/tests/data_types_test.ts b/tests/data_types_test.ts
index 268544c8..e51a1750 100644
--- a/tests/data_types_test.ts
+++ b/tests/data_types_test.ts
@@ -1,8 +1,6 @@
-// deno-lint-ignore-file camelcase
 import { assertEquals, base64, formatDate, parseDate } from "./test_deps.ts";
-import { Client } from "../mod.ts";
 import { getMainConfiguration } from "./config.ts";
-import { getTestClient } from "./helpers.ts";
+import { generateSimpleClientTest } from "./helpers.ts";
 import {
   Box,
   Circle,
@@ -17,14 +15,8 @@ import {
   Timestamp,
 } from "../query/types.ts";
 
-const SETUP = [
-  "DROP TABLE IF EXISTS data_types;",
-  `CREATE TABLE data_types(
-     inet_t inet,
-     macaddr_t macaddr,
-     cidr_t cidr
-  );`,
-];
+// TODO
+// Find out how to test char types
 
 /**
  * This will generate a random number with a precision of 2
@@ -40,455 +32,6 @@ function generateRandomPoint(max_value = 100): Point {
   };
 }
 
-const CLIENT = new Client(getMainConfiguration());
-const testClient = getTestClient(CLIENT, SETUP);
-
-testClient(async function inet() {
-  const url = "127.0.0.1";
-  await CLIENT.queryArray(
-    "INSERT INTO data_types (inet_t) VALUES($1)",
-    url,
-  );
-  const selectRes = await CLIENT.queryArray(
-    "SELECT inet_t FROM data_types WHERE inet_t=$1",
-    url,
-  );
-  assertEquals(selectRes.rows[0][0], url);
-});
-
-testClient(async function inetArray() {
-  const selectRes = await CLIENT.queryArray(
-    "SELECT '{ 127.0.0.1, 192.168.178.0/24 }'::inet[]",
-  );
-  assertEquals(selectRes.rows[0], [["127.0.0.1", "192.168.178.0/24"]]);
-});
-
-testClient(async function inetNestedArray() {
-  const selectRes = await CLIENT.queryArray(
-    "SELECT '{{127.0.0.1},{192.168.178.0/24}}'::inet[]",
-  );
-  assertEquals(selectRes.rows[0], [[["127.0.0.1"], ["192.168.178.0/24"]]]);
-});
-
-testClient(async function macaddr() {
-  const address = "08:00:2b:01:02:03";
-
-  await CLIENT.queryArray(
-    "INSERT INTO data_types (macaddr_t) VALUES($1)",
-    address,
-  );
-  const selectRes = await CLIENT.queryArray(
-    "SELECT macaddr_t FROM data_types WHERE macaddr_t=$1",
-    address,
-  );
-  assertEquals(selectRes.rows[0][0], address);
-});
-
-testClient(async function macaddrArray() {
-  const selectRes = await CLIENT.queryArray(
-    "SELECT '{ 08:00:2b:01:02:03, 09:00:2b:01:02:04 }'::macaddr[]",
-  );
-  assertEquals(selectRes.rows[0], [["08:00:2b:01:02:03", "09:00:2b:01:02:04"]]);
-});
-
-testClient(async function macaddrNestedArray() {
-  const selectRes = await CLIENT.queryArray(
-    "SELECT '{{08:00:2b:01:02:03},{09:00:2b:01:02:04}}'::macaddr[]",
-  );
-  assertEquals(
-    selectRes.rows[0],
-    [[["08:00:2b:01:02:03"], ["09:00:2b:01:02:04"]]],
-  );
-});
-
-testClient(async function cidr() {
-  const host = "192.168.100.128/25";
-  await CLIENT.queryArray(
-    "INSERT INTO data_types (cidr_t) VALUES($1)",
-    host,
-  );
-  const selectRes = await CLIENT.queryArray(
-    "SELECT cidr_t FROM data_types WHERE cidr_t=$1",
-    host,
-  );
-  assertEquals(selectRes.rows[0][0], host);
-});
-
-testClient(async function cidrArray() {
-  const selectRes = await CLIENT.queryArray(
-    "SELECT '{ 10.1.0.0/16, 11.11.11.0/24 }'::cidr[]",
-  );
-  assertEquals(selectRes.rows[0], [["10.1.0.0/16", "11.11.11.0/24"]]);
-});
-
-testClient(async function cidrNestedArray() {
-  const selectRes = await CLIENT.queryArray(
-    "SELECT '{{10.1.0.0/16},{11.11.11.0/24}}'::cidr[]",
-  );
-  assertEquals(selectRes.rows[0], [[["10.1.0.0/16"], ["11.11.11.0/24"]]]);
-});
-
-testClient(async function name() {
-  const result = await CLIENT.queryArray(`SELECT 'some'::name`);
-  assertEquals(result.rows[0][0], "some");
-});
-
-testClient(async function nameArray() {
-  const result = await CLIENT.queryArray(`SELECT ARRAY['some'::name, 'none']`);
-  assertEquals(result.rows[0][0], ["some", "none"]);
-});
-
-testClient(async function oid() {
-  const result = await CLIENT.queryArray(`SELECT 1::oid`);
-  assertEquals(result.rows[0][0], "1");
-});
-
-testClient(async function oidArray() {
-  const result = await CLIENT.queryArray(`SELECT ARRAY[1::oid, 452, 1023]`);
-  assertEquals(result.rows[0][0], ["1", "452", "1023"]);
-});
-
-testClient(async function regproc() {
-  const result = await CLIENT.queryArray(`SELECT 'now'::regproc`);
-  assertEquals(result.rows[0][0], "now");
-});
-
-testClient(async function regprocArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT ARRAY['now'::regproc, 'timeofday']`,
-  );
-  assertEquals(result.rows[0][0], ["now", "timeofday"]);
-});
-
-testClient(async function regprocedure() {
-  const result = await CLIENT.queryArray(`SELECT 'sum(integer)'::regprocedure`);
-  assertEquals(result.rows[0][0], "sum(integer)");
-});
-
-testClient(async function regprocedureArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT ARRAY['sum(integer)'::regprocedure, 'max(integer)']`,
-  );
-  assertEquals(result.rows[0][0], ["sum(integer)", "max(integer)"]);
-});
-
-testClient(async function regoper() {
-  const result = await CLIENT.queryArray(`SELECT '!'::regoper`);
-  assertEquals(result.rows[0][0], "!");
-});
-
-testClient(async function regoperArray() {
-  const result = await CLIENT.queryArray(`SELECT ARRAY['!'::regoper]`);
-  assertEquals(result.rows[0][0], ["!"]);
-});
-
-testClient(async function regoperator() {
-  const result = await CLIENT.queryArray(
-    `SELECT '!(bigint,NONE)'::regoperator`,
-  );
-  assertEquals(result.rows[0][0], "!(bigint,NONE)");
-});
-
-testClient(async function regoperatorArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT ARRAY['!(bigint,NONE)'::regoperator, '*(integer,integer)']`,
-  );
-  assertEquals(result.rows[0][0], ["!(bigint,NONE)", "*(integer,integer)"]);
-});
-
-testClient(async function regclass() {
-  const result = await CLIENT.queryArray(`SELECT 'data_types'::regclass`);
-  assertEquals(result.rows, [["data_types"]]);
-});
-
-testClient(async function regclassArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT ARRAY['data_types'::regclass, 'pg_type']`,
-  );
-  assertEquals(result.rows[0][0], ["data_types", "pg_type"]);
-});
-
-testClient(async function regtype() {
-  const result = await CLIENT.queryArray(`SELECT 'integer'::regtype`);
-  assertEquals(result.rows[0][0], "integer");
-});
-
-testClient(async function regtypeArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT ARRAY['integer'::regtype, 'bigint']`,
-  );
-  assertEquals(result.rows[0][0], ["integer", "bigint"]);
-});
-
-testClient(async function regrole() {
-  const user = getMainConfiguration().user;
-
-  const result = await CLIENT.queryArray(
-    `SELECT ($1)::regrole`,
-    user,
-  );
-
-  assertEquals(result.rows[0][0], user);
-});
-
-testClient(async function regroleArray() {
-  const user = getMainConfiguration().user;
-
-  const result = await CLIENT.queryArray(
-    `SELECT ARRAY[($1)::regrole]`,
-    user,
-  );
-
-  assertEquals(result.rows[0][0], [user]);
-});
-
-testClient(async function regnamespace() {
-  const result = await CLIENT.queryArray(`SELECT 'public'::regnamespace;`);
-  assertEquals(result.rows[0][0], "public");
-});
-
-testClient(async function regnamespaceArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT ARRAY['public'::regnamespace, 'pg_catalog'];`,
-  );
-  assertEquals(result.rows[0][0], ["public", "pg_catalog"]);
-});
-
-testClient(async function regconfig() {
-  const result = await CLIENT.queryArray(`SElECT 'english'::regconfig`);
-  assertEquals(result.rows, [["english"]]);
-});
-
-testClient(async function regconfigArray() {
-  const result = await CLIENT.queryArray(
-    `SElECT ARRAY['english'::regconfig, 'spanish']`,
-  );
-  assertEquals(result.rows[0][0], ["english", "spanish"]);
-});
-
-testClient(async function regdictionary() {
-  const result = await CLIENT.queryArray("SELECT 'simple'::regdictionary");
-  assertEquals(result.rows[0][0], "simple");
-});
-
-testClient(async function regdictionaryArray() {
-  const result = await CLIENT.queryArray(
-    "SELECT ARRAY['simple'::regdictionary]",
-  );
-  assertEquals(result.rows[0][0], ["simple"]);
-});
-
-testClient(async function bigint() {
-  const result = await CLIENT.queryArray("SELECT 9223372036854775807");
-  assertEquals(result.rows[0][0], 9223372036854775807n);
-});
-
-testClient(async function bigintArray() {
-  const result = await CLIENT.queryArray(
-    "SELECT ARRAY[9223372036854775807, 789141]",
-  );
-  assertEquals(result.rows[0][0], [9223372036854775807n, 789141n]);
-});
-
-testClient(async function numeric() {
-  const number = "1234567890.1234567890";
-  const result = await CLIENT.queryArray(`SELECT $1::numeric`, number);
-  assertEquals(result.rows[0][0], number);
-});
-
-testClient(async function numericArray() {
-  const numeric = ["1234567890.1234567890", "6107693.123123124"];
-  const result = await CLIENT.queryArray(
-    `SELECT ARRAY[$1::numeric, $2]`,
-    numeric[0],
-    numeric[1],
-  );
-  assertEquals(result.rows[0][0], numeric);
-});
-
-testClient(async function integerArray() {
-  const result = await CLIENT.queryArray("SELECT '{1,100}'::int[]");
-  assertEquals(result.rows[0], [[1, 100]]);
-});
-
-testClient(async function integerNestedArray() {
-  const result = await CLIENT.queryArray("SELECT '{{1},{100}}'::int[]");
-  assertEquals(result.rows[0], [[[1], [100]]]);
-});
-
-testClient(async function char() {
-  await CLIENT.queryArray(
-    `CREATE TEMP TABLE CHAR_TEST (X CHARACTER(2));`,
-  );
-  await CLIENT.queryArray(
-    `INSERT INTO CHAR_TEST (X) VALUES ('A');`,
-  );
-  const result = await CLIENT.queryArray(
-    `SELECT X FROM CHAR_TEST`,
-  );
-  assertEquals(result.rows[0][0], "A ");
-});
-
-testClient(async function charArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT '{"x","Y"}'::char[]`,
-  );
-  assertEquals(result.rows[0][0], ["x", "Y"]);
-});
-
-testClient(async function text() {
-  const result = await CLIENT.queryArray(
-    `SELECT 'ABCD'::text`,
-  );
-  assertEquals(result.rows[0][0], "ABCD");
-});
-
-testClient(async function textArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT '{"(ZYX)-123-456","(ABC)-987-654"}'::text[]`,
-  );
-  assertEquals(result.rows[0], [["(ZYX)-123-456", "(ABC)-987-654"]]);
-});
-
-testClient(async function textNestedArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT '{{"(ZYX)-123-456"},{"(ABC)-987-654"}}'::text[]`,
-  );
-  assertEquals(result.rows[0], [[["(ZYX)-123-456"], ["(ABC)-987-654"]]]);
-});
-
-testClient(async function varchar() {
-  const result = await CLIENT.queryArray(
-    `SELECT 'ABC'::varchar`,
-  );
-  assertEquals(result.rows[0][0], "ABC");
-});
-
-testClient(async function varcharArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT '{"(ZYX)-(PQR)-456","(ABC)-987-(?=+)"}'::varchar[]`,
-  );
-  assertEquals(result.rows[0], [["(ZYX)-(PQR)-456", "(ABC)-987-(?=+)"]]);
-});
-
-testClient(async function varcharNestedArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT '{{"(ZYX)-(PQR)-456"},{"(ABC)-987-(?=+)"}}'::varchar[]`,
-  );
-  assertEquals(result.rows[0], [[["(ZYX)-(PQR)-456"], ["(ABC)-987-(?=+)"]]]);
-});
-
-testClient(async function uuid() {
-  const uuid_text = "c4792ecb-c00a-43a2-bd74-5b0ed551c599";
-  const result = await CLIENT.queryArray(`SELECT $1::uuid`, uuid_text);
-  assertEquals(result.rows[0][0], uuid_text);
-});
-
-testClient(async function uuidArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT '{"c4792ecb-c00a-43a2-bd74-5b0ed551c599",
-      "c9dd159e-d3d7-4bdf-b0ea-e51831c28e9b"}'::uuid[]`,
-  );
-  assertEquals(
-    result.rows[0],
-    [[
-      "c4792ecb-c00a-43a2-bd74-5b0ed551c599",
-      "c9dd159e-d3d7-4bdf-b0ea-e51831c28e9b",
-    ]],
-  );
-});
-
-testClient(async function uuidNestedArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT '{{"c4792ecb-c00a-43a2-bd74-5b0ed551c599"},
-      {"c9dd159e-d3d7-4bdf-b0ea-e51831c28e9b"}}'::uuid[]`,
-  );
-  assertEquals(
-    result.rows[0],
-    [[
-      ["c4792ecb-c00a-43a2-bd74-5b0ed551c599"],
-      ["c9dd159e-d3d7-4bdf-b0ea-e51831c28e9b"],
-    ]],
-  );
-});
-
-testClient(async function voidType() {
-  const result = await CLIENT.queryArray("select pg_sleep(0.01)"); // `pg_sleep()` returns void.
-  assertEquals(result.rows, [[""]]);
-});
-
-testClient(async function bpcharType() {
-  const result = await CLIENT.queryArray(
-    "SELECT cast('U7DV6WQ26D7X2IILX5L4LTYMZUKJ5F3CEDDQV3ZSLQVYNRPX2WUA' as char(52));",
-  );
-  assertEquals(
-    result.rows,
-    [["U7DV6WQ26D7X2IILX5L4LTYMZUKJ5F3CEDDQV3ZSLQVYNRPX2WUA"]],
-  );
-});
-
-testClient(async function bpcharArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT '{"AB1234","4321BA"}'::bpchar[]`,
-  );
-  assertEquals(result.rows[0], [["AB1234", "4321BA"]]);
-});
-
-testClient(async function bpcharNestedArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT '{{"AB1234"},{"4321BA"}}'::bpchar[]`,
-  );
-  assertEquals(result.rows[0], [[["AB1234"], ["4321BA"]]]);
-});
-
-testClient(async function jsonArray() {
-  const json_array = await CLIENT.queryArray(
-    `SELECT ARRAY_AGG(A) FROM  (
-      SELECT JSON_BUILD_OBJECT( 'X', '1' ) AS A
-      UNION ALL
-      SELECT JSON_BUILD_OBJECT( 'Y', '2' ) AS A
-    )	A`,
-  );
-
-  assertEquals(json_array.rows[0][0], [{ X: "1" }, { Y: "2" }]);
-
-  const jsonArrayNested = await CLIENT.queryArray(
-    `SELECT ARRAY[ARRAY[ARRAY_AGG(A), ARRAY_AGG(A)], ARRAY[ARRAY_AGG(A), ARRAY_AGG(A)]] FROM  (
-      SELECT JSON_BUILD_OBJECT( 'X', '1' ) AS A
-      UNION ALL
-      SELECT JSON_BUILD_OBJECT( 'Y', '2' ) AS A
-    )	A`,
-  );
-
-  assertEquals(
-    jsonArrayNested.rows[0][0],
-    [
-      [
-        [{ X: "1" }, { Y: "2" }],
-        [{ X: "1" }, { Y: "2" }],
-      ],
-      [
-        [{ X: "1" }, { Y: "2" }],
-        [{ X: "1" }, { Y: "2" }],
-      ],
-    ],
-  );
-});
-
-testClient(async function bool() {
-  const result = await CLIENT.queryArray(
-    `SELECT bool('y')`,
-  );
-  assertEquals(result.rows[0][0], true);
-});
-
-testClient(async function boolArray() {
-  const result = await CLIENT.queryArray(
-    `SELECT array[bool('y'), bool('n'), bool('1'), bool('0')]`,
-  );
-  assertEquals(result.rows[0][0], [true, false, true, false]);
-});
-
 const CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
 function randomBase64(): string {
   return base64.encode(
@@ -499,397 +42,1176 @@ function randomBase64(): string {
   );
 }
 
-testClient(async function bytea() {
-  const base64_string = randomBase64();
-
-  const result = await CLIENT.queryArray(
-    `SELECT decode('${base64_string}','base64')`,
-  );
-
-  assertEquals(result.rows[0][0], base64.decode(base64_string));
-});
-
-testClient(async function byteaArray() {
-  const strings = Array.from(
-    { length: Math.ceil(Math.random() * 10) },
-    randomBase64,
-  );
-
-  const result = await CLIENT.queryArray(
-    `SELECT array[ ${
-      strings.map((x) => `decode('${x}', 'base64')`).join(", ")
-    } ]`,
-  );
-
-  assertEquals(
-    result.rows[0][0],
-    strings.map(base64.decode),
-  );
-});
-
-testClient(async function point() {
-  const selectRes = await CLIENT.queryArray<[Point]>(
-    "SELECT point(1, 2.5)",
-  );
-  assertEquals(selectRes.rows, [[{ x: "1", y: "2.5" }]]);
-});
-
-testClient(async function pointArray() {
-  const result1 = await CLIENT.queryArray(
-    `SELECT '{"(1, 2)","(3.5, 4.1)"}'::point[]`,
-  );
-  assertEquals(result1.rows, [
-    [[{ x: "1", y: "2" }, { x: "3.5", y: "4.1" }]],
-  ]);
-
-  const result2 = await CLIENT.queryArray(
-    `SELECT array[ array[ point(1,2), point(3.5, 4.1) ], array[ point(25, 50), point(-10, -17.5) ] ]`,
-  );
-  assertEquals(result2.rows[0], [
-    [
-      [{ x: "1", y: "2" }, { x: "3.5", y: "4.1" }],
-      [{ x: "25", y: "50" }, { x: "-10", y: "-17.5" }],
-    ],
-  ]);
-});
-
-testClient(async function time() {
-  const result = await CLIENT.queryArray("SELECT '01:01:01'::TIME");
-
-  assertEquals(result.rows[0][0], "01:01:01");
-});
-
-testClient(async function timeArray() {
-  const result = await CLIENT.queryArray("SELECT ARRAY['01:01:01'::TIME]");
-
-  assertEquals(result.rows[0][0], ["01:01:01"]);
-});
-
-testClient(async function timestamp() {
-  const date = "1999-01-08 04:05:06";
-  const result = await CLIENT.queryArray<[Timestamp]>(
-    `SELECT $1::TIMESTAMP, 'INFINITY'::TIMESTAMP`,
-    date,
-  );
-
-  assertEquals(result.rows[0], [new Date(date), Infinity]);
-});
-
-testClient(async function timestampArray() {
-  const timestamps = [
-    "2011-10-05T14:48:00.00",
-    new Date().toISOString().slice(0, -1),
-  ];
-
-  const result = await CLIENT.queryArray<[[Timestamp, Timestamp]]>(
-    `SELECT ARRAY[$1::TIMESTAMP, $2]`,
-    ...timestamps,
-  );
-
-  assertEquals(result.rows[0][0], timestamps.map((x) => new Date(x)));
-});
-
-testClient(async function timestamptz() {
-  const timestamp = "1999-01-08 04:05:06+02";
-  const result = await CLIENT.queryArray<[Timestamp]>(
-    `SELECT $1::TIMESTAMPTZ, 'INFINITY'::TIMESTAMPTZ`,
-    timestamp,
-  );
-
-  assertEquals(result.rows[0], [new Date(timestamp), Infinity]);
-});
-
 const timezone = new Date().toTimeString().slice(12, 17);
 
-testClient(async function timestamptzArray() {
-  const timestamps = [
-    "2012/04/10 10:10:30 +0000",
-    new Date().toISOString(),
-  ];
-
-  const result = await CLIENT.queryArray<[[Timestamp, Timestamp]]>(
-    `SELECT ARRAY[$1::TIMESTAMPTZ, $2]`,
-    ...timestamps,
-  );
-
-  assertEquals(result.rows[0][0], [
-    new Date(timestamps[0]),
-    new Date(timestamps[1]),
-  ]);
-});
-
-testClient(async function timetz() {
-  const result = await CLIENT.queryArray<[string]>(
-    `SELECT '01:01:01${timezone}'::TIMETZ`,
-  );
-
-  assertEquals(result.rows[0][0].slice(0, 8), "01:01:01");
-});
-
-testClient(async function timetzArray() {
-  const result = await CLIENT.queryArray<[string]>(
-    `SELECT ARRAY['01:01:01${timezone}'::TIMETZ]`,
-  );
-
-  assertEquals(typeof result.rows[0][0][0], "string");
-
-  assertEquals(result.rows[0][0][0].slice(0, 8), "01:01:01");
-});
-
-testClient(async function xid() {
-  const result = await CLIENT.queryArray("SELECT '1'::xid");
-
-  assertEquals(result.rows[0][0], 1);
-});
-
-testClient(async function xidArray() {
-  const result = await CLIENT.queryArray(
-    "SELECT ARRAY['12'::xid, '4789'::xid]",
-  );
-
-  assertEquals(result.rows[0][0], [12, 4789]);
-});
-
-testClient(async function float4() {
-  const result = await CLIENT.queryArray<[Float4, Float4]>(
-    "SELECT '1'::FLOAT4, '17.89'::FLOAT4",
-  );
-
-  assertEquals(result.rows[0], ["1", "17.89"]);
-});
-
-testClient(async function float4Array() {
-  const result = await CLIENT.queryArray<[[Float4, Float4]]>(
-    "SELECT ARRAY['12.25'::FLOAT4, '4789']",
-  );
-
-  assertEquals(result.rows[0][0], ["12.25", "4789"]);
-});
-
-testClient(async function float8() {
-  const result = await CLIENT.queryArray<[Float8, Float8]>(
-    "SELECT '1'::FLOAT8, '17.89'::FLOAT8",
-  );
-
-  assertEquals(result.rows[0], ["1", "17.89"]);
-});
-
-testClient(async function float8Array() {
-  const result = await CLIENT.queryArray<[[Float8, Float8]]>(
-    "SELECT ARRAY['12.25'::FLOAT8, '4789']",
-  );
-
-  assertEquals(result.rows[0][0], ["12.25", "4789"]);
-});
-
-testClient(async function tid() {
-  const result = await CLIENT.queryArray<[TID, TID]>(
-    "SELECT '(1, 19)'::TID, '(23, 17)'::TID",
-  );
-
-  assertEquals(result.rows[0], [[1n, 19n], [23n, 17n]]);
-});
-
-testClient(async function tidArray() {
-  const result = await CLIENT.queryArray<[[TID, TID]]>(
-    "SELECT ARRAY['(4681, 1869)'::TID, '(0, 17476)']",
-  );
-
-  assertEquals(result.rows[0][0], [[4681n, 1869n], [0n, 17476n]]);
-});
-
-testClient(async function date() {
-  const date_text = "2020-01-01";
-
-  const result = await CLIENT.queryArray<[Timestamp, Timestamp]>(
-    "SELECT $1::DATE, 'Infinity'::Date",
-    date_text,
-  );
-
-  assertEquals(result.rows[0], [parseDate(date_text, "yyyy-MM-dd"), Infinity]);
-});
-
-testClient(async function dateArray() {
-  const dates = ["2020-01-01", formatDate(new Date(), "yyyy-MM-dd")];
-
-  const result = await CLIENT.queryArray<[Timestamp, Timestamp]>(
-    "SELECT ARRAY[$1::DATE, $2]",
-    ...dates,
-  );
-
-  assertEquals(
-    result.rows[0][0],
-    dates.map((date) => parseDate(date, "yyyy-MM-dd")),
-  );
-});
-
-testClient(async function line() {
-  const result = await CLIENT.queryArray<[Line]>(
-    "SELECT '[(1, 2), (3, 4)]'::LINE",
-  );
-
-  assertEquals(result.rows[0][0], { a: "1", b: "-1", c: "1" });
-});
-
-testClient(async function lineArray() {
-  const result = await CLIENT.queryArray<[[Line, Line]]>(
-    "SELECT ARRAY['[(1, 2), (3, 4)]'::LINE, '41, 1, -9, 25.5']",
-  );
-
-  assertEquals(result.rows[0][0], [
-    { a: "1", b: "-1", c: "1" },
-    {
-      a: "-0.49",
-      b: "-1",
-      c: "21.09",
-    },
-  ]);
-});
-
-testClient(async function lineSegment() {
-  const result = await CLIENT.queryArray<[LineSegment]>(
-    "SELECT '[(1, 2), (3, 4)]'::LSEG",
-  );
-
-  assertEquals(result.rows[0][0], {
-    a: { x: "1", y: "2" },
-    b: { x: "3", y: "4" },
-  });
-});
-
-testClient(async function lineSegmentArray() {
-  const result = await CLIENT.queryArray<[[LineSegment, LineSegment]]>(
-    "SELECT ARRAY['[(1, 2), (3, 4)]'::LSEG, '41, 1, -9, 25.5']",
-  );
-
-  assertEquals(result.rows[0][0], [
-    {
+const testClient = generateSimpleClientTest(getMainConfiguration());
+
+Deno.test(
+  "inet",
+  testClient(async (client) => {
+    const url = "127.0.0.1";
+    const selectRes = await client.queryArray(
+      "SELECT $1::INET",
+      url,
+    );
+    assertEquals(selectRes.rows[0], [url]);
+  }),
+);
+
+Deno.test(
+  "inet array",
+  testClient(async (client) => {
+    const { rows: result_1 } = await client.queryArray(
+      "SELECT '{ 127.0.0.1, 192.168.178.0/24 }'::inet[]",
+    );
+    assertEquals(result_1[0], [["127.0.0.1", "192.168.178.0/24"]]);
+
+    const { rows: result_2 } = await client.queryArray(
+      "SELECT '{{127.0.0.1},{192.168.178.0/24}}'::inet[]",
+    );
+    assertEquals(result_2[0], [[["127.0.0.1"], ["192.168.178.0/24"]]]);
+  }),
+);
+
+Deno.test(
+  "macaddr",
+  testClient(async (client) => {
+    const address = "08:00:2b:01:02:03";
+
+    const { rows } = await client.queryArray(
+      "SELECT $1::MACADDR",
+      address,
+    );
+    assertEquals(rows[0], [address]);
+  }),
+);
+
+Deno.test(
+  "macaddr array",
+  testClient(async (client) => {
+    const { rows: result_1 } = await client.queryArray(
+      "SELECT '{ 08:00:2b:01:02:03, 09:00:2b:01:02:04 }'::macaddr[]",
+    );
+    assertEquals(result_1[0], [[
+      "08:00:2b:01:02:03",
+      "09:00:2b:01:02:04",
+    ]]);
+
+    const { rows: result_2 } = await client.queryArray(
+      "SELECT '{{08:00:2b:01:02:03},{09:00:2b:01:02:04}}'::macaddr[]",
+    );
+    assertEquals(
+      result_2[0],
+      [[["08:00:2b:01:02:03"], ["09:00:2b:01:02:04"]]],
+    );
+  }),
+);
+
+Deno.test(
+  "cidr",
+  testClient(async (client) => {
+    const host = "192.168.100.128/25";
+
+    const { rows } = await client.queryArray(
+      "SELECT $1::CIDR",
+      host,
+    );
+    assertEquals(rows[0], [host]);
+  }),
+);
+
+Deno.test(
+  "cidr array",
+  testClient(async (client) => {
+    const { rows: result_1 } = await client.queryArray(
+      "SELECT '{ 10.1.0.0/16, 11.11.11.0/24 }'::cidr[]",
+    );
+    assertEquals(result_1[0], [["10.1.0.0/16", "11.11.11.0/24"]]);
+
+    const { rows: result_2 } = await client.queryArray(
+      "SELECT '{{10.1.0.0/16},{11.11.11.0/24}}'::cidr[]",
+    );
+    assertEquals(result_2[0], [[["10.1.0.0/16"], ["11.11.11.0/24"]]]);
+  }),
+);
+
+Deno.test(
+  "name",
+  testClient(async (client) => {
+    const name = "some";
+    const result = await client.queryArray(`SELECT $1::name`, name);
+    assertEquals(result.rows[0], [name]);
+  }),
+);
+
+Deno.test(
+  "name array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT ARRAY['some'::name, 'none']`,
+    );
+    assertEquals(result.rows[0], [["some", "none"]]);
+  }),
+);
+
+Deno.test(
+  "oid",
+  testClient(async (client) => {
+    const result = await client.queryArray(`SELECT 1::oid`);
+    assertEquals(result.rows[0][0], "1");
+  }),
+);
+
+Deno.test(
+  "oid array",
+  testClient(async (client) => {
+    const result = await client.queryArray(`SELECT ARRAY[1::oid, 452, 1023]`);
+    assertEquals(result.rows[0][0], ["1", "452", "1023"]);
+  }),
+);
+
+Deno.test(
+  "regproc",
+  testClient(async (client) => {
+    const result = await client.queryArray(`SELECT 'now'::regproc`);
+    assertEquals(result.rows[0][0], "now");
+  }),
+);
+
+Deno.test(
+  "regproc array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT ARRAY['now'::regproc, 'timeofday']`,
+    );
+    assertEquals(result.rows[0][0], ["now", "timeofday"]);
+  }),
+);
+
+Deno.test(
+  "regprocedure",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT 'sum(integer)'::regprocedure`,
+    );
+    assertEquals(result.rows[0][0], "sum(integer)");
+  }),
+);
+
+Deno.test(
+  "regprocedure array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT ARRAY['sum(integer)'::regprocedure, 'max(integer)']`,
+    );
+    assertEquals(result.rows[0][0], ["sum(integer)", "max(integer)"]);
+  }),
+);
+
+Deno.test(
+  "regoper",
+  testClient(async (client) => {
+    const operator = "!!";
+
+    const { rows } = await client.queryObject({
+      args: [operator],
+      fields: ["result"],
+      text: "SELECT $1::regoper",
+    });
+
+    assertEquals(rows[0], { result: operator });
+  }),
+);
+
+Deno.test(
+  "regoper array",
+  testClient(async (client) => {
+    const operator_1 = "!!";
+    const operator_2 = "|/";
+
+    const { rows } = await client.queryObject({
+      args: [operator_1, operator_2],
+      fields: ["result"],
+      text: "SELECT ARRAY[$1::regoper, $2]",
+    });
+
+    assertEquals(rows[0], { result: [operator_1, operator_2] });
+  }),
+);
+
+Deno.test(
+  "regoperator",
+  testClient(async (client) => {
+    const regoperator = "-(NONE,integer)";
+
+    const { rows } = await client.queryObject({
+      args: [regoperator],
+      fields: ["result"],
+      text: "SELECT $1::regoperator",
+    });
+
+    assertEquals(rows[0], { result: regoperator });
+  }),
+);
+
+Deno.test(
+  "regoperator array",
+  testClient(async (client) => {
+    const regoperator_1 = "-(NONE,integer)";
+    const regoperator_2 = "*(integer,integer)";
+
+    const { rows } = await client.queryObject({
+      args: [regoperator_1, regoperator_2],
+      fields: ["result"],
+      text: "SELECT ARRAY[$1::regoperator, $2]",
+    });
+
+    assertEquals(rows[0], { result: [regoperator_1, regoperator_2] });
+  }),
+);
+
+Deno.test(
+  "regclass",
+  testClient(async (client) => {
+    const object_name = "TEST_REGCLASS";
+
+    await client.queryArray(`CREATE TEMP TABLE ${object_name} (X INT)`);
+
+    const result = await client.queryObject<{ table_name: string }>({
+      args: [object_name],
+      fields: ["table_name"],
+      text: "SELECT $1::REGCLASS",
+    });
+
+    assertEquals(result.rows.length, 1);
+    // Objects in postgres are case insensitive unless indicated otherwise
+    assertEquals(
+      result.rows[0].table_name.toLowerCase(),
+      object_name.toLowerCase(),
+    );
+  }),
+);
+
+Deno.test(
+  "regclass array",
+  testClient(async (client) => {
+    const object_1 = "TEST_REGCLASS_1";
+    const object_2 = "TEST_REGCLASS_2";
+
+    await client.queryArray(`CREATE TEMP TABLE ${object_1} (X INT)`);
+    await client.queryArray(`CREATE TEMP TABLE ${object_2} (X INT)`);
+
+    const { rows: result } = await client.queryObject<
+      { tables: [string, string] }
+    >({
+      args: [object_1, object_2],
+      fields: ["tables"],
+      text: "SELECT ARRAY[$1::REGCLASS, $2]",
+    });
+
+    assertEquals(result.length, 1);
+    assertEquals(result[0].tables.length, 2);
+    // Objects in postgres are case insensitive unless indicated otherwise
+    assertEquals(
+      result[0].tables.map((x) => x.toLowerCase()),
+      [object_1, object_2].map((x) => x.toLowerCase()),
+    );
+  }),
+);
+
+Deno.test(
+  "regtype",
+  testClient(async (client) => {
+    const result = await client.queryArray(`SELECT 'integer'::regtype`);
+    assertEquals(result.rows[0][0], "integer");
+  }),
+);
+
+Deno.test(
+  "regtype array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT ARRAY['integer'::regtype, 'bigint']`,
+    );
+    assertEquals(result.rows[0][0], ["integer", "bigint"]);
+  }),
+);
+
+// TODO
+// Refactor test to look for users directly in the database instead
+// of relying on config
+Deno.test(
+  "regrole",
+  testClient(async (client) => {
+    const user = getMainConfiguration().user;
+
+    const result = await client.queryArray(
+      `SELECT ($1)::regrole`,
+      user,
+    );
+
+    assertEquals(result.rows[0][0], user);
+  }),
+);
+
+Deno.test(
+  "regrole array",
+  testClient(async (client) => {
+    const user = getMainConfiguration().user;
+
+    const result = await client.queryArray(
+      `SELECT ARRAY[($1)::regrole]`,
+      user,
+    );
+
+    assertEquals(result.rows[0][0], [user]);
+  }),
+);
+
+Deno.test(
+  "regnamespace",
+  testClient(async (client) => {
+    const result = await client.queryArray(`SELECT 'public'::regnamespace;`);
+    assertEquals(result.rows[0][0], "public");
+  }),
+);
+
+Deno.test(
+  "regnamespace array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT ARRAY['public'::regnamespace, 'pg_catalog'];`,
+    );
+    assertEquals(result.rows[0][0], ["public", "pg_catalog"]);
+  }),
+);
+
+Deno.test(
+  "regconfig",
+  testClient(async (client) => {
+    const result = await client.queryArray(`SElECT 'english'::regconfig`);
+    assertEquals(result.rows, [["english"]]);
+  }),
+);
+
+Deno.test(
+  "regconfig array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SElECT ARRAY['english'::regconfig, 'spanish']`,
+    );
+    assertEquals(result.rows[0][0], ["english", "spanish"]);
+  }),
+);
+
+Deno.test(
+  "regdictionary",
+  testClient(async (client) => {
+    const result = await client.queryArray("SELECT 'simple'::regdictionary");
+    assertEquals(result.rows[0][0], "simple");
+  }),
+);
+
+Deno.test(
+  "regdictionary array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      "SELECT ARRAY['simple'::regdictionary]",
+    );
+    assertEquals(result.rows[0][0], ["simple"]);
+  }),
+);
+
+Deno.test(
+  "bigint",
+  testClient(async (client) => {
+    const result = await client.queryArray("SELECT 9223372036854775807");
+    assertEquals(result.rows[0][0], 9223372036854775807n);
+  }),
+);
+
+Deno.test(
+  "bigint array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      "SELECT ARRAY[9223372036854775807, 789141]",
+    );
+    assertEquals(result.rows[0][0], [9223372036854775807n, 789141n]);
+  }),
+);
+
+Deno.test(
+  "numeric",
+  testClient(async (client) => {
+    const number = "1234567890.1234567890";
+    const result = await client.queryArray(`SELECT $1::numeric`, number);
+    assertEquals(result.rows[0][0], number);
+  }),
+);
+
+Deno.test(
+  "numeric array",
+  testClient(async (client) => {
+    const numeric = ["1234567890.1234567890", "6107693.123123124"];
+    const result = await client.queryArray(
+      `SELECT ARRAY[$1::numeric, $2]`,
+      numeric[0],
+      numeric[1],
+    );
+    assertEquals(result.rows[0][0], numeric);
+  }),
+);
+
+Deno.test(
+  "integer",
+  testClient(async (client) => {
+    const int = 17;
+
+    const { rows: result } = await client.queryObject({
+      args: [int],
+      fields: ["result"],
+      text: "SELECT $1::INTEGER",
+    });
+
+    assertEquals(result[0], { result: int });
+  }),
+);
+
+Deno.test(
+  "integer array",
+  testClient(async (client) => {
+    const { rows: result_1 } = await client.queryArray(
+      "SELECT '{1,100}'::int[]",
+    );
+    assertEquals(result_1[0], [[1, 100]]);
+
+    const { rows: result_2 } = await client.queryArray(
+      "SELECT '{{1},{100}}'::int[]",
+    );
+    assertEquals(result_2[0], [[[1], [100]]]);
+  }),
+);
+
+Deno.test(
+  "char",
+  testClient(async (client) => {
+    await client.queryArray(
+      `CREATE TEMP TABLE CHAR_TEST (X CHARACTER(2));`,
+    );
+    await client.queryArray(
+      `INSERT INTO CHAR_TEST (X) VALUES ('A');`,
+    );
+    const result = await client.queryArray(
+      `SELECT X FROM CHAR_TEST`,
+    );
+    assertEquals(result.rows[0][0], "A ");
+  }),
+);
+
+Deno.test(
+  "char array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT '{"x","Y"}'::char[]`,
+    );
+    assertEquals(result.rows[0][0], ["x", "Y"]);
+  }),
+);
+
+Deno.test(
+  "text",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT 'ABCD'::text`,
+    );
+    assertEquals(result.rows[0], ["ABCD"]);
+  }),
+);
+
+Deno.test(
+  "text array",
+  testClient(async (client) => {
+    const { rows: result_1 } = await client.queryArray(
+      `SELECT '{"(ZYX)-123-456","(ABC)-987-654"}'::text[]`,
+    );
+    assertEquals(result_1[0], [["(ZYX)-123-456", "(ABC)-987-654"]]);
+
+    const { rows: result_2 } = await client.queryArray(
+      `SELECT '{{"(ZYX)-123-456"},{"(ABC)-987-654"}}'::text[]`,
+    );
+    assertEquals(result_2[0], [[["(ZYX)-123-456"], ["(ABC)-987-654"]]]);
+  }),
+);
+
+Deno.test(
+  "varchar",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT 'ABC'::varchar`,
+    );
+    assertEquals(result.rows[0][0], "ABC");
+  }),
+);
+
+Deno.test(
+  "varchar array",
+  testClient(async (client) => {
+    const { rows: result_1 } = await client.queryArray(
+      `SELECT '{"(ZYX)-(PQR)-456","(ABC)-987-(?=+)"}'::varchar[]`,
+    );
+    assertEquals(result_1[0], [["(ZYX)-(PQR)-456", "(ABC)-987-(?=+)"]]);
+
+    const { rows: result_2 } = await client.queryArray(
+      `SELECT '{{"(ZYX)-(PQR)-456"},{"(ABC)-987-(?=+)"}}'::varchar[]`,
+    );
+    assertEquals(result_2[0], [[["(ZYX)-(PQR)-456"], ["(ABC)-987-(?=+)"]]]);
+  }),
+);
+
+Deno.test(
+  "uuid",
+  testClient(async (client) => {
+    const uuid_text = "c4792ecb-c00a-43a2-bd74-5b0ed551c599";
+    const result = await client.queryArray(`SELECT $1::uuid`, uuid_text);
+    assertEquals(result.rows[0][0], uuid_text);
+  }),
+);
+
+Deno.test(
+  "uuid array",
+  testClient(async (client) => {
+    const { rows: result_1 } = await client.queryArray(
+      `SELECT '{"c4792ecb-c00a-43a2-bd74-5b0ed551c599",
+          "c9dd159e-d3d7-4bdf-b0ea-e51831c28e9b"}'::uuid[]`,
+    );
+    assertEquals(
+      result_1[0],
+      [[
+        "c4792ecb-c00a-43a2-bd74-5b0ed551c599",
+        "c9dd159e-d3d7-4bdf-b0ea-e51831c28e9b",
+      ]],
+    );
+
+    const { rows: result_2 } = await client.queryArray(
+      `SELECT '{{"c4792ecb-c00a-43a2-bd74-5b0ed551c599"},
+          {"c9dd159e-d3d7-4bdf-b0ea-e51831c28e9b"}}'::uuid[]`,
+    );
+    assertEquals(
+      result_2[0],
+      [[
+        ["c4792ecb-c00a-43a2-bd74-5b0ed551c599"],
+        ["c9dd159e-d3d7-4bdf-b0ea-e51831c28e9b"],
+      ]],
+    );
+  }),
+);
+
+Deno.test(
+  "void",
+  testClient(async (client) => {
+    const result = await client.queryArray`SELECT PG_SLEEP(0.01)`; // `pg_sleep()` returns void.
+    assertEquals(result.rows, [[""]]);
+  }),
+);
+
+Deno.test(
+  "bpchar",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      "SELECT cast('U7DV6WQ26D7X2IILX5L4LTYMZUKJ5F3CEDDQV3ZSLQVYNRPX2WUA' as char(52));",
+    );
+    assertEquals(
+      result.rows,
+      [["U7DV6WQ26D7X2IILX5L4LTYMZUKJ5F3CEDDQV3ZSLQVYNRPX2WUA"]],
+    );
+  }),
+);
+
+Deno.test(
+  "bpchar array",
+  testClient(async (client) => {
+    const { rows: result_1 } = await client.queryArray(
+      `SELECT '{"AB1234","4321BA"}'::bpchar[]`,
+    );
+    assertEquals(result_1[0], [["AB1234", "4321BA"]]);
+
+    const { rows: result_2 } = await client.queryArray(
+      `SELECT '{{"AB1234"},{"4321BA"}}'::bpchar[]`,
+    );
+    assertEquals(result_2[0], [[["AB1234"], ["4321BA"]]]);
+  }),
+);
+
+Deno.test(
+  "bool",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT bool('y')`,
+    );
+    assertEquals(result.rows[0][0], true);
+  }),
+);
+
+Deno.test(
+  "bool array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      `SELECT array[bool('y'), bool('n'), bool('1'), bool('0')]`,
+    );
+    assertEquals(result.rows[0][0], [true, false, true, false]);
+  }),
+);
+
+Deno.test(
+  "bytea",
+  testClient(async (client) => {
+    const base64_string = randomBase64();
+
+    const result = await client.queryArray(
+      `SELECT decode('${base64_string}','base64')`,
+    );
+
+    assertEquals(result.rows[0][0], base64.decode(base64_string));
+  }),
+);
+
+Deno.test(
+  "bytea array",
+  testClient(async (client) => {
+    const strings = Array.from(
+      { length: Math.ceil(Math.random() * 10) },
+      randomBase64,
+    );
+
+    const result = await client.queryArray(
+      `SELECT array[ ${
+        strings.map((x) => `decode('${x}', 'base64')`).join(", ")
+      } ]`,
+    );
+
+    assertEquals(
+      result.rows[0][0],
+      strings.map(base64.decode),
+    );
+  }),
+);
+
+Deno.test(
+  "point",
+  testClient(async (client) => {
+    const selectRes = await client.queryArray<[Point]>(
+      "SELECT point(1, 2.5)",
+    );
+    assertEquals(selectRes.rows, [[{ x: "1", y: "2.5" }]]);
+  }),
+);
+
+Deno.test(
+  "point array",
+  testClient(async (client) => {
+    const result1 = await client.queryArray(
+      `SELECT '{"(1, 2)","(3.5, 4.1)"}'::point[]`,
+    );
+    assertEquals(result1.rows, [
+      [[{ x: "1", y: "2" }, { x: "3.5", y: "4.1" }]],
+    ]);
+
+    const result2 = await client.queryArray(
+      `SELECT array[ array[ point(1,2), point(3.5, 4.1) ], array[ point(25, 50), point(-10, -17.5) ] ]`,
+    );
+    assertEquals(result2.rows[0], [
+      [
+        [{ x: "1", y: "2" }, { x: "3.5", y: "4.1" }],
+        [{ x: "25", y: "50" }, { x: "-10", y: "-17.5" }],
+      ],
+    ]);
+  }),
+);
+
+Deno.test(
+  "time",
+  testClient(async (client) => {
+    const result = await client.queryArray("SELECT '01:01:01'::TIME");
+
+    assertEquals(result.rows[0][0], "01:01:01");
+  }),
+);
+
+Deno.test(
+  "time array",
+  testClient(async (client) => {
+    const result = await client.queryArray("SELECT ARRAY['01:01:01'::TIME]");
+
+    assertEquals(result.rows[0][0], ["01:01:01"]);
+  }),
+);
+
+Deno.test(
+  "timestamp",
+  testClient(async (client) => {
+    const date = "1999-01-08 04:05:06";
+    const result = await client.queryArray<[Timestamp]>(
+      `SELECT $1::TIMESTAMP, 'INFINITY'::TIMESTAMP`,
+      date,
+    );
+
+    assertEquals(result.rows[0], [new Date(date), Infinity]);
+  }),
+);
+
+Deno.test(
+  "timestamp array",
+  testClient(async (client) => {
+    const timestamps = [
+      "2011-10-05T14:48:00.00",
+      new Date().toISOString().slice(0, -1),
+    ];
+
+    const result = await client.queryArray<[[Timestamp, Timestamp]]>(
+      `SELECT ARRAY[$1::TIMESTAMP, $2]`,
+      ...timestamps,
+    );
+
+    assertEquals(result.rows[0][0], timestamps.map((x) => new Date(x)));
+  }),
+);
+
+Deno.test(
+  "timestamptz",
+  testClient(async (client) => {
+    const timestamp = "1999-01-08 04:05:06+02";
+    const result = await client.queryArray<[Timestamp]>(
+      `SELECT $1::TIMESTAMPTZ, 'INFINITY'::TIMESTAMPTZ`,
+      timestamp,
+    );
+
+    assertEquals(result.rows[0], [new Date(timestamp), Infinity]);
+  }),
+);
+
+Deno.test(
+  "timestamptz array",
+  testClient(async (client) => {
+    const timestamps = [
+      "2012/04/10 10:10:30 +0000",
+      new Date().toISOString(),
+    ];
+
+    const result = await client.queryArray<[[Timestamp, Timestamp]]>(
+      `SELECT ARRAY[$1::TIMESTAMPTZ, $2]`,
+      ...timestamps,
+    );
+
+    assertEquals(result.rows[0][0], [
+      new Date(timestamps[0]),
+      new Date(timestamps[1]),
+    ]);
+  }),
+);
+
+Deno.test(
+  "timetz",
+  testClient(async (client) => {
+    const result = await client.queryArray<[string]>(
+      `SELECT '01:01:01${timezone}'::TIMETZ`,
+    );
+
+    assertEquals(result.rows[0][0].slice(0, 8), "01:01:01");
+  }),
+);
+
+Deno.test(
+  "timetz array",
+  testClient(async (client) => {
+    const result = await client.queryArray<[string]>(
+      `SELECT ARRAY['01:01:01${timezone}'::TIMETZ]`,
+    );
+
+    assertEquals(typeof result.rows[0][0][0], "string");
+
+    assertEquals(result.rows[0][0][0].slice(0, 8), "01:01:01");
+  }),
+);
+
+Deno.test(
+  "xid",
+  testClient(async (client) => {
+    const result = await client.queryArray("SELECT '1'::xid");
+
+    assertEquals(result.rows[0][0], 1);
+  }),
+);
+
+Deno.test(
+  "xid array",
+  testClient(async (client) => {
+    const result = await client.queryArray(
+      "SELECT ARRAY['12'::xid, '4789'::xid]",
+    );
+
+    assertEquals(result.rows[0][0], [12, 4789]);
+  }),
+);
+
+Deno.test(
+  "float4",
+  testClient(async (client) => {
+    const result = await client.queryArray<[Float4, Float4]>(
+      "SELECT '1'::FLOAT4, '17.89'::FLOAT4",
+    );
+
+    assertEquals(result.rows[0], ["1", "17.89"]);
+  }),
+);
+
+Deno.test(
+  "float4 array",
+  testClient(async (client) => {
+    const result = await client.queryArray<[[Float4, Float4]]>(
+      "SELECT ARRAY['12.25'::FLOAT4, '4789']",
+    );
+
+    assertEquals(result.rows[0][0], ["12.25", "4789"]);
+  }),
+);
+
+Deno.test(
+  "float8",
+  testClient(async (client) => {
+    const result = await client.queryArray<[Float8, Float8]>(
+      "SELECT '1'::FLOAT8, '17.89'::FLOAT8",
+    );
+
+    assertEquals(result.rows[0], ["1", "17.89"]);
+  }),
+);
+
+Deno.test(
+  "float8 array",
+  testClient(async (client) => {
+    const result = await client.queryArray<[[Float8, Float8]]>(
+      "SELECT ARRAY['12.25'::FLOAT8, '4789']",
+    );
+
+    assertEquals(result.rows[0][0], ["12.25", "4789"]);
+  }),
+);
+
+Deno.test(
+  "tid",
+  testClient(async (client) => {
+    const result = await client.queryArray<[TID, TID]>(
+      "SELECT '(1, 19)'::TID, '(23, 17)'::TID",
+    );
+
+    assertEquals(result.rows[0], [[1n, 19n], [23n, 17n]]);
+  }),
+);
+
+Deno.test(
+  "tid array",
+  testClient(async (client) => {
+    const result = await client.queryArray<[[TID, TID]]>(
+      "SELECT ARRAY['(4681, 1869)'::TID, '(0, 17476)']",
+    );
+
+    assertEquals(result.rows[0][0], [[4681n, 1869n], [0n, 17476n]]);
+  }),
+);
+
+Deno.test(
+  "date",
+  testClient(async (client) => {
+    const date_text = "2020-01-01";
+
+    const result = await client.queryArray<[Timestamp, Timestamp]>(
+      "SELECT $1::DATE, 'Infinity'::Date",
+      date_text,
+    );
+
+    assertEquals(result.rows[0], [
+      parseDate(date_text, "yyyy-MM-dd"),
+      Infinity,
+    ]);
+  }),
+);
+
+Deno.test(
+  "date array",
+  testClient(async (client) => {
+    const dates = ["2020-01-01", formatDate(new Date(), "yyyy-MM-dd")];
+
+    const result = await client.queryArray<[Timestamp, Timestamp]>(
+      "SELECT ARRAY[$1::DATE, $2]",
+      ...dates,
+    );
+
+    assertEquals(
+      result.rows[0][0],
+      dates.map((date) => parseDate(date, "yyyy-MM-dd")),
+    );
+  }),
+);
+
+Deno.test(
+  "line",
+  testClient(async (client) => {
+    const result = await client.queryArray<[Line]>(
+      "SELECT '[(1, 2), (3, 4)]'::LINE",
+    );
+
+    assertEquals(result.rows[0][0], { a: "1", b: "-1", c: "1" });
+  }),
+);
+
+Deno.test(
+  "line array",
+  testClient(async (client) => {
+    const result = await client.queryArray<[[Line, Line]]>(
+      "SELECT ARRAY['[(1, 2), (3, 4)]'::LINE, '41, 1, -9, 25.5']",
+    );
+
+    assertEquals(result.rows[0][0], [
+      { a: "1", b: "-1", c: "1" },
+      {
+        a: "-0.49",
+        b: "-1",
+        c: "21.09",
+      },
+    ]);
+  }),
+);
+
+Deno.test(
+  "line segment",
+  testClient(async (client) => {
+    const result = await client.queryArray<[LineSegment]>(
+      "SELECT '[(1, 2), (3, 4)]'::LSEG",
+    );
+
+    assertEquals(result.rows[0][0], {
       a: { x: "1", y: "2" },
       b: { x: "3", y: "4" },
-    },
-    {
-      a: { x: "41", y: "1" },
-      b: { x: "-9", y: "25.5" },
-    },
-  ]);
-});
-
-testClient(async function box() {
-  const result = await CLIENT.queryArray<[Box]>(
-    "SELECT '((1, 2), (3, 4))'::BOX",
-  );
-
-  assertEquals(result.rows[0][0], {
-    a: { x: "3", y: "4" },
-    b: { x: "1", y: "2" },
-  });
-});
-
-testClient(async function boxArray() {
-  const result = await CLIENT.queryArray<[[Box, Box]]>(
-    "SELECT ARRAY['(1, 2), (3, 4)'::BOX, '41, 1, -9, 25.5']",
-  );
-
-  assertEquals(result.rows[0][0], [
-    {
+    });
+  }),
+);
+
+Deno.test(
+  "line segment array",
+  testClient(async (client) => {
+    const result = await client.queryArray<[[LineSegment, LineSegment]]>(
+      "SELECT ARRAY['[(1, 2), (3, 4)]'::LSEG, '41, 1, -9, 25.5']",
+    );
+
+    assertEquals(result.rows[0][0], [
+      {
+        a: { x: "1", y: "2" },
+        b: { x: "3", y: "4" },
+      },
+      {
+        a: { x: "41", y: "1" },
+        b: { x: "-9", y: "25.5" },
+      },
+    ]);
+  }),
+);
+
+Deno.test(
+  "box",
+  testClient(async (client) => {
+    const result = await client.queryArray<[Box]>(
+      "SELECT '((1, 2), (3, 4))'::BOX",
+    );
+
+    assertEquals(result.rows[0][0], {
       a: { x: "3", y: "4" },
       b: { x: "1", y: "2" },
-    },
-    {
-      a: { x: "41", y: "25.5" },
-      b: { x: "-9", y: "1" },
-    },
-  ]);
-});
-
-testClient(async function path() {
-  const points = Array.from(
-    { length: Math.floor((Math.random() + 1) * 10) },
-    generateRandomPoint,
-  );
-
-  const selectRes = await CLIENT.queryArray<[Path]>(
-    `SELECT '(${points.map(({ x, y }) => `(${x},${y})`).join(",")})'::PATH`,
-  );
-
-  assertEquals(selectRes.rows[0][0], points);
-});
-
-testClient(async function pathArray() {
-  const points = Array.from(
-    { length: Math.floor((Math.random() + 1) * 10) },
-    generateRandomPoint,
-  );
-
-  const selectRes = await CLIENT.queryArray<[[Path]]>(
-    `SELECT ARRAY['(${
-      points.map(({ x, y }) => `(${x},${y})`).join(",")
-    })'::PATH]`,
-  );
-
-  assertEquals(selectRes.rows[0][0][0], points);
-});
-
-testClient(async function polygon() {
-  const points = Array.from(
-    { length: Math.floor((Math.random() + 1) * 10) },
-    generateRandomPoint,
-  );
-
-  const selectRes = await CLIENT.queryArray<[Polygon]>(
-    `SELECT '(${points.map(({ x, y }) => `(${x},${y})`).join(",")})'::POLYGON`,
-  );
-
-  assertEquals(selectRes.rows[0][0], points);
-});
-
-testClient(async function polygonArray() {
-  const points = Array.from(
-    { length: Math.floor((Math.random() + 1) * 10) },
-    generateRandomPoint,
-  );
-
-  const selectRes = await CLIENT.queryArray<[[Polygon]]>(
-    `SELECT ARRAY['(${
-      points.map(({ x, y }) => `(${x},${y})`).join(",")
-    })'::POLYGON]`,
-  );
-
-  assertEquals(selectRes.rows[0][0][0], points);
-});
-
-testClient(async function circle() {
-  const point = generateRandomPoint();
-  const radius = String(generateRandomNumber(100));
-
-  const { rows } = await CLIENT.queryArray<[Circle]>(
-    `SELECT '<(${point.x},${point.y}), ${radius}>'::CIRCLE`,
-  );
-
-  assertEquals(rows[0][0], { point, radius });
-});
-
-testClient(async function circleArray() {
-  const point = generateRandomPoint();
-  const radius = String(generateRandomNumber(100));
-
-  const { rows } = await CLIENT.queryArray<[[Circle]]>(
-    `SELECT ARRAY['<(${point.x},${point.y}), ${radius}>'::CIRCLE]`,
-  );
-
-  assertEquals(rows[0][0][0], { point, radius });
-});
-
-testClient(async function unhandledType() {
-  const { rows: exists } = await CLIENT.queryArray(
-    "SELECT EXISTS (SELECT TRUE FROM PG_TYPE WHERE UPPER(TYPNAME) = 'DIRECTION')",
-  );
-  if (exists[0][0]) {
-    await CLIENT.queryArray("DROP TYPE DIRECTION;");
-  }
-  await CLIENT.queryArray("CREATE TYPE DIRECTION AS ENUM ( 'LEFT', 'RIGHT' )");
-  const { rows: result } = await CLIENT.queryArray("SELECT 'LEFT'::DIRECTION;");
-  await CLIENT.queryArray("DROP TYPE DIRECTION;");
-
-  assertEquals(result[0][0], "LEFT");
-});
+    });
+  }),
+);
+
+Deno.test(
+  "box array",
+  testClient(async (client) => {
+    const result = await client.queryArray<[[Box, Box]]>(
+      "SELECT ARRAY['(1, 2), (3, 4)'::BOX, '41, 1, -9, 25.5']",
+    );
+
+    assertEquals(result.rows[0][0], [
+      {
+        a: { x: "3", y: "4" },
+        b: { x: "1", y: "2" },
+      },
+      {
+        a: { x: "41", y: "25.5" },
+        b: { x: "-9", y: "1" },
+      },
+    ]);
+  }),
+);
+
+Deno.test(
+  "path",
+  testClient(async (client) => {
+    const points = Array.from(
+      { length: Math.floor((Math.random() + 1) * 10) },
+      generateRandomPoint,
+    );
+
+    const selectRes = await client.queryArray<[Path]>(
+      `SELECT '(${points.map(({ x, y }) => `(${x},${y})`).join(",")})'::PATH`,
+    );
+
+    assertEquals(selectRes.rows[0][0], points);
+  }),
+);
+
+Deno.test(
+  "path array",
+  testClient(async (client) => {
+    const points = Array.from(
+      { length: Math.floor((Math.random() + 1) * 10) },
+      generateRandomPoint,
+    );
+
+    const selectRes = await client.queryArray<[[Path]]>(
+      `SELECT ARRAY['(${
+        points.map(({ x, y }) => `(${x},${y})`).join(",")
+      })'::PATH]`,
+    );
+
+    assertEquals(selectRes.rows[0][0][0], points);
+  }),
+);
+
+Deno.test(
+  "polygon",
+  testClient(async (client) => {
+    const points = Array.from(
+      { length: Math.floor((Math.random() + 1) * 10) },
+      generateRandomPoint,
+    );
+
+    const selectRes = await client.queryArray<[Polygon]>(
+      `SELECT '(${
+        points.map(({ x, y }) => `(${x},${y})`).join(",")
+      })'::POLYGON`,
+    );
+
+    assertEquals(selectRes.rows[0][0], points);
+  }),
+);
+
+Deno.test(
+  "polygon array",
+  testClient(async (client) => {
+    const points = Array.from(
+      { length: Math.floor((Math.random() + 1) * 10) },
+      generateRandomPoint,
+    );
+
+    const selectRes = await client.queryArray<[[Polygon]]>(
+      `SELECT ARRAY['(${
+        points.map(({ x, y }) => `(${x},${y})`).join(",")
+      })'::POLYGON]`,
+    );
+
+    assertEquals(selectRes.rows[0][0][0], points);
+  }),
+);
+
+Deno.test(
+  "circle",
+  testClient(async (client) => {
+    const point = generateRandomPoint();
+    const radius = String(generateRandomNumber(100));
+
+    const { rows } = await client.queryArray<[Circle]>(
+      `SELECT '<(${point.x},${point.y}), ${radius}>'::CIRCLE`,
+    );
+
+    assertEquals(rows[0][0], { point, radius });
+  }),
+);
+
+Deno.test(
+  "circle array",
+  testClient(async (client) => {
+    const point = generateRandomPoint();
+    const radius = String(generateRandomNumber(100));
+
+    const { rows } = await client.queryArray<[[Circle]]>(
+      `SELECT ARRAY['<(${point.x},${point.y}), ${radius}>'::CIRCLE]`,
+    );
+
+    assertEquals(rows[0][0][0], { point, radius });
+  }),
+);
+
+Deno.test(
+  "unhandled type",
+  testClient(async (client) => {
+    const { rows: exists } = await client.queryArray(
+      "SELECT EXISTS (SELECT TRUE FROM PG_TYPE WHERE UPPER(TYPNAME) = 'DIRECTION')",
+    );
+    if (exists[0][0]) {
+      await client.queryArray("DROP TYPE DIRECTION;");
+    }
+    await client.queryArray(
+      "CREATE TYPE DIRECTION AS ENUM ( 'LEFT', 'RIGHT' )",
+    );
+    const { rows: result } = await client.queryArray(
+      "SELECT 'LEFT'::DIRECTION;",
+    );
+    await client.queryArray("DROP TYPE DIRECTION;");
+
+    assertEquals(result[0][0], "LEFT");
+  }),
+);
+
+Deno.test(
+  "json",
+  testClient(async (client) => {
+    const result = await client.queryArray
+      `SELECT JSON_BUILD_OBJECT( 'X', '1' )`;
+
+    assertEquals(result.rows[0], [{ X: "1" }]);
+  }),
+);
+
+Deno.test(
+  "json array",
+  testClient(async (client) => {
+    const json_array = await client.queryArray(
+      `SELECT ARRAY_AGG(A) FROM  (
+          SELECT JSON_BUILD_OBJECT( 'X', '1' ) AS A
+          UNION ALL
+          SELECT JSON_BUILD_OBJECT( 'Y', '2' ) AS A
+        )	A`,
+    );
+
+    assertEquals(json_array.rows[0][0], [{ X: "1" }, { Y: "2" }]);
+
+    const jsonArrayNested = await client.queryArray(
+      `SELECT ARRAY[ARRAY[ARRAY_AGG(A), ARRAY_AGG(A)], ARRAY[ARRAY_AGG(A), ARRAY_AGG(A)]] FROM  (
+          SELECT JSON_BUILD_OBJECT( 'X', '1' ) AS A
+          UNION ALL
+          SELECT JSON_BUILD_OBJECT( 'Y', '2' ) AS A
+        )	A`,
+    );
+
+    assertEquals(
+      jsonArrayNested.rows[0][0],
+      [
+        [
+          [{ X: "1" }, { Y: "2" }],
+          [{ X: "1" }, { Y: "2" }],
+        ],
+        [
+          [{ X: "1" }, { Y: "2" }],
+          [{ X: "1" }, { Y: "2" }],
+        ],
+      ],
+    );
+  }),
+);
diff --git a/tests/encode_test.ts b/tests/encode_test.ts
index 1f48d64c..125bbf80 100644
--- a/tests/encode_test.ts
+++ b/tests/encode_test.ts
@@ -1,4 +1,3 @@
-const { test } = Deno;
 import { assertEquals } from "./test_deps.ts";
 import { encode } from "../query/encode.ts";
 
@@ -16,7 +15,7 @@ function overrideTimezoneOffset(offset: number) {
   };
 }
 
-test("encodeDatetime", function () {
+Deno.test("encodeDatetime", function () {
   // GMT
   overrideTimezoneOffset(0);
 
@@ -36,33 +35,33 @@ test("encodeDatetime", function () {
   resetTimezoneOffset();
 });
 
-test("encodeUndefined", function () {
+Deno.test("encodeUndefined", function () {
   assertEquals(encode(undefined), null);
 });
 
-test("encodeNull", function () {
+Deno.test("encodeNull", function () {
   assertEquals(encode(null), null);
 });
 
-test("encodeBoolean", function () {
+Deno.test("encodeBoolean", function () {
   assertEquals(encode(true), "true");
   assertEquals(encode(false), "false");
 });
 
-test("encodeNumber", function () {
+Deno.test("encodeNumber", function () {
   assertEquals(encode(1), "1");
   assertEquals(encode(1.2345), "1.2345");
 });
 
-test("encodeString", function () {
+Deno.test("encodeString", function () {
   assertEquals(encode("deno-postgres"), "deno-postgres");
 });
 
-test("encodeObject", function () {
+Deno.test("encodeObject", function () {
   assertEquals(encode({ x: 1 }), '{"x":1}');
 });
 
-test("encodeUint8Array", function () {
+Deno.test("encodeUint8Array", function () {
   const buf1 = new Uint8Array([1, 2, 3]);
   const buf2 = new Uint8Array([2, 10, 500]);
   const buf3 = new Uint8Array([11]);
@@ -72,20 +71,20 @@ test("encodeUint8Array", function () {
   assertEquals("\\x0b", encode(buf3));
 });
 
-test("encodeArray", function () {
+Deno.test("encodeArray", function () {
   const array = [null, "postgres", 1, ["foo", "bar"]];
   const encodedArray = encode(array);
 
   assertEquals(encodedArray, '{NULL,"postgres","1",{"foo","bar"}}');
 });
 
-test("encodeObjectArray", function () {
+Deno.test("encodeObjectArray", function () {
   const array = [{ x: 1 }, { y: 2 }];
   const encodedArray = encode(array);
   assertEquals(encodedArray, '{"{\\"x\\":1}","{\\"y\\":2}"}');
 });
 
-test("encodeDateArray", function () {
+Deno.test("encodeDateArray", function () {
   overrideTimezoneOffset(0);
 
   const array = [new Date(2019, 1, 10, 20, 30, 40, 5)];
diff --git a/tests/helpers.ts b/tests/helpers.ts
index 785e1847..e26a7f27 100644
--- a/tests/helpers.ts
+++ b/tests/helpers.ts
@@ -1,25 +1,44 @@
-import type { Client } from "../client.ts";
+import { Client } from "../client.ts";
+import { Pool } from "../pool.ts";
+import type { ClientOptions } from "../connection/connection_params.ts";
 
-export function getTestClient(
-  client: Client,
-  defSetupQueries?: Array<string>,
+export function generateSimpleClientTest(
+  client_options: ClientOptions,
 ) {
-  return function testClient(
-    t: Deno.TestDefinition["fn"],
-    setupQueries?: Array<string>,
-  ) {
-    const fn = async () => {
+  return function testSimpleClient(
+    test_function: (client: Client) => Promise<void>,
+  ): () => Promise<void> {
+    return async () => {
+      const client = new Client(client_options);
       try {
         await client.connect();
-        for (const q of setupQueries || defSetupQueries || []) {
-          await client.queryArray(q);
-        }
-        await t();
+        await test_function(client);
       } finally {
         await client.end();
       }
     };
-    const name = t.name;
-    Deno.test({ fn, name });
+  };
+}
+
+export function generatePoolClientTest(client_options: ClientOptions) {
+  return function generatePoolClientTest1(
+    test_function: (pool: Pool, size: number, lazy: boolean) => Promise<void>,
+    size = 10,
+    lazy = false,
+  ) {
+    return async () => {
+      const pool = new Pool(client_options, size, lazy);
+      // If the connection is not lazy, create a client to await
+      // for initialization
+      if (!lazy) {
+        const client = await pool.connect();
+        client.release();
+      }
+      try {
+        await test_function(pool, size, lazy);
+      } finally {
+        await pool.end();
+      }
+    };
   };
 }
diff --git a/tests/pool_test.ts b/tests/pool_test.ts
index 98032740..25215664 100644
--- a/tests/pool_test.ts
+++ b/tests/pool_test.ts
@@ -1,137 +1,127 @@
-// deno-lint-ignore-file camelcase
 import { assertEquals, delay } from "./test_deps.ts";
-import { Pool } from "../pool.ts";
 import { getMainConfiguration } from "./config.ts";
+import { generatePoolClientTest } from "./helpers.ts";
 
-function testPool(
-  name: string,
-  t: (pool: Pool, size: number, lazy: boolean) => void | Promise<void>,
-  size = 10,
-  lazy = false,
-) {
-  const fn = async () => {
-    const POOL = new Pool(getMainConfiguration(), size, lazy);
-    // If the connection is not lazy, create a client to await
-    // for initialization
-    if (!lazy) {
-      const client = await POOL.connect();
-      await client.release();
-    }
-    try {
-      await t(POOL, size, lazy);
-    } finally {
-      await POOL.end();
-    }
-  };
-  Deno.test({ fn, name });
-}
+const testPool = generatePoolClientTest(getMainConfiguration());
 
-testPool(
+Deno.test(
   "Pool handles simultaneous connections correcly",
-  async function (POOL) {
-    assertEquals(POOL.available, 10);
-    const client = await POOL.connect();
-    const p = client.queryArray("SELECT pg_sleep(0.1) is null, -1 AS id");
-    await delay(1);
-    assertEquals(POOL.available, 9);
-    assertEquals(POOL.size, 10);
-    await p;
-    await client.release();
-    assertEquals(POOL.available, 10);
-
-    const qsThunks = [...Array(25)].map(async (_, i) => {
+  testPool(
+    async (POOL) => {
+      assertEquals(POOL.available, 10);
       const client = await POOL.connect();
-      const query = await client.queryArray(
-        "SELECT pg_sleep(0.1) is null, $1::text as id",
-        i,
-      );
-      await client.release();
-      return query;
-    });
-    const qsPromises = Promise.all(qsThunks);
-    await delay(1);
-    assertEquals(POOL.available, 0);
-    const qs = await qsPromises;
-    assertEquals(POOL.available, 10);
-    assertEquals(POOL.size, 10);
+      const p = client.queryArray("SELECT pg_sleep(0.1) is null, -1 AS id");
+      await delay(1);
+      assertEquals(POOL.available, 9);
+      assertEquals(POOL.size, 10);
+      await p;
+      client.release();
+      assertEquals(POOL.available, 10);
 
-    const result = qs.map((r) => r.rows[0][1]);
-    const expected = [...Array(25)].map((_, i) => i.toString());
-    assertEquals(result, expected);
-  },
+      const qsThunks = [...Array(25)].map(async (_, i) => {
+        const client = await POOL.connect();
+        const query = await client.queryArray(
+          "SELECT pg_sleep(0.1) is null, $1::text as id",
+          i,
+        );
+        client.release();
+        return query;
+      });
+      const qsPromises = Promise.all(qsThunks);
+      await delay(1);
+      assertEquals(POOL.available, 0);
+      const qs = await qsPromises;
+      assertEquals(POOL.available, 10);
+      assertEquals(POOL.size, 10);
+
+      const result = qs.map((r) => r.rows[0][1]);
+      const expected = [...Array(25)].map((_, i) => i.toString());
+      assertEquals(result, expected);
+    },
+  ),
 );
 
-testPool(
+Deno.test(
   "Pool initializes lazy connections on demand",
-  async function (POOL, size) {
-    const client_1 = await POOL.connect();
-    await client_1.queryArray("SELECT 1");
-    await client_1.release();
-    assertEquals(await POOL.initialized(), 1);
+  testPool(
+    async (POOL, size) => {
+      const client_1 = await POOL.connect();
+      await client_1.queryArray("SELECT 1");
+      await client_1.release();
+      assertEquals(await POOL.initialized(), 1);
 
-    const client_2 = await POOL.connect();
-    const p = client_2.queryArray("SELECT pg_sleep(0.1) is null, -1 AS id");
-    await delay(1);
-    assertEquals(POOL.size, size);
-    assertEquals(POOL.available, size - 1);
-    assertEquals(await POOL.initialized(), 0);
-    await p;
-    await client_2.release();
-    assertEquals(await POOL.initialized(), 1);
+      const client_2 = await POOL.connect();
+      const p = client_2.queryArray("SELECT pg_sleep(0.1) is null, -1 AS id");
+      await delay(1);
+      assertEquals(POOL.size, size);
+      assertEquals(POOL.available, size - 1);
+      assertEquals(await POOL.initialized(), 0);
+      await p;
+      await client_2.release();
+      assertEquals(await POOL.initialized(), 1);
 
-    // Test stack repletion as well
-    const requested_clients = size + 5;
-    const qsThunks = Array.from({ length: requested_clients }, async (_, i) => {
-      const client = await POOL.connect();
-      const query = await client.queryArray(
-        "SELECT pg_sleep(0.1) is null, $1::text as id",
-        i,
+      // Test stack repletion as well
+      const requested_clients = size + 5;
+      const qsThunks = Array.from(
+        { length: requested_clients },
+        async (_, i) => {
+          const client = await POOL.connect();
+          const query = await client.queryArray(
+            "SELECT pg_sleep(0.1) is null, $1::text as id",
+            i,
+          );
+          client.release();
+          return query;
+        },
       );
-      await client.release();
-      return query;
-    });
-    const qsPromises = Promise.all(qsThunks);
-    await delay(1);
-    assertEquals(POOL.available, 0);
-    assertEquals(await POOL.initialized(), 0);
-    const qs = await qsPromises;
-    assertEquals(POOL.available, size);
-    assertEquals(await POOL.initialized(), size);
+      const qsPromises = Promise.all(qsThunks);
+      await delay(1);
+      assertEquals(POOL.available, 0);
+      assertEquals(await POOL.initialized(), 0);
+      const qs = await qsPromises;
+      assertEquals(POOL.available, size);
+      assertEquals(await POOL.initialized(), size);
 
-    const result = qs.map((r) => r.rows[0][1]);
-    const expected = Array.from(
-      { length: requested_clients },
-      (_, i) => i.toString(),
-    );
-    assertEquals(result, expected);
-  },
-  10,
-  true,
+      const result = qs.map((r) => r.rows[0][1]);
+      const expected = Array.from(
+        { length: requested_clients },
+        (_, i) => i.toString(),
+      );
+      assertEquals(result, expected);
+    },
+    10,
+    true,
+  ),
 );
 
-testPool("Pool can be reinitialized after termination", async function (POOL) {
-  await POOL.end();
-  assertEquals(POOL.available, 0);
-
-  const client = await POOL.connect();
-  await client.queryArray`SELECT 1`;
-  await client.release();
-  assertEquals(POOL.available, 10);
-});
-
-testPool(
-  "Lazy pool can be reinitialized after termination",
-  async function (POOL, size) {
+Deno.test(
+  "Pool can be reinitialized after termination",
+  testPool(async (POOL) => {
     await POOL.end();
     assertEquals(POOL.available, 0);
-    assertEquals(await POOL.initialized(), 0);
 
     const client = await POOL.connect();
     await client.queryArray`SELECT 1`;
-    await client.release();
-    assertEquals(await POOL.initialized(), 1);
-    assertEquals(POOL.available, size);
-  },
-  10,
-  true,
+    client.release();
+    assertEquals(POOL.available, 10);
+  }),
+);
+
+Deno.test(
+  "Lazy pool can be reinitialized after termination",
+  testPool(
+    async (POOL, size) => {
+      await POOL.end();
+      assertEquals(POOL.available, 0);
+      assertEquals(await POOL.initialized(), 0);
+
+      const client = await POOL.connect();
+      await client.queryArray`SELECT 1`;
+      client.release();
+      assertEquals(await POOL.initialized(), 1);
+      assertEquals(POOL.available, size);
+    },
+    10,
+    true,
+  ),
 );
diff --git a/tests/query_client_test.ts b/tests/query_client_test.ts
index 981ab461..d33a7a02 100644
--- a/tests/query_client_test.ts
+++ b/tests/query_client_test.ts
@@ -1,6 +1,10 @@
-// deno-lint-ignore-file camelcase
-import { Client, ConnectionError, Pool } from "../mod.ts";
-import { assert, assertEquals, assertThrowsAsync } from "./test_deps.ts";
+import { Client, ConnectionError, Pool, PostgresError } from "../mod.ts";
+import {
+  assert,
+  assertEquals,
+  assertObjectMatch,
+  assertThrowsAsync,
+} from "./test_deps.ts";
 import { getMainConfiguration } from "./config.ts";
 import { PoolClient, QueryClient } from "../client.ts";
 
@@ -35,7 +39,7 @@ function testClient(
       });
     } finally {
       for (const client of clients) {
-        await client.release();
+        client.release();
       }
       await pool.end();
     }
@@ -72,6 +76,195 @@ testClient("Prepared statements", async function (generateClient) {
   assertEquals(result.rows, [{ id: 1 }]);
 });
 
+testClient(
+  "Simple query handles recovery after error state",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    await client.queryArray`CREATE TEMP TABLE PREPARED_STATEMENT_ERROR (X INT)`;
+
+    await assertThrowsAsync(() =>
+      client.queryArray(
+        "INSERT INTO PREPARED_STATEMENT_ERROR VALUES ($1)",
+        "TEXT",
+      )
+    );
+
+    const { rows } = await client.queryObject<{ result: number }>({
+      fields: ["result"],
+      text: "SELECT 1",
+    });
+
+    assertEquals(rows[0], { result: 1 });
+  },
+);
+
+testClient(
+  "Simple query can handle multiple query failures at once",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    await assertThrowsAsync(
+      () =>
+        client.queryArray(
+          "SELECT 1; SELECT '2'::INT; SELECT 'A'::INT",
+        ),
+      PostgresError,
+      "invalid input syntax for type integer",
+    );
+
+    const { rows } = await client.queryObject<{ result: number }>({
+      fields: ["result"],
+      text: "SELECT 1",
+    });
+
+    assertEquals(rows[0], { result: 1 });
+  },
+);
+
+testClient(
+  "Simple query can return multiple queries",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    const { rows: result } = await client.queryObject<{ result: number }>({
+      text: "SELECT 1; SELECT '2'::INT",
+      fields: ["result"],
+    });
+
+    assertEquals(result, [{ result: 1 }, { result: 2 }]);
+  },
+);
+
+testClient(
+  "Simple query handles empty query",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    const { rows: result } = await client.queryArray("");
+    assertEquals(result, []);
+  },
+);
+
+testClient(
+  "Prepared query handles recovery after error state",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    await client.queryArray`CREATE TEMP TABLE PREPARED_STATEMENT_ERROR (X INT)`;
+
+    await assertThrowsAsync(() =>
+      client.queryArray(
+        "INSERT INTO PREPARED_STATEMENT_ERROR VALUES ($1)",
+        "TEXT",
+      ), PostgresError);
+
+    const result = "handled";
+
+    const { rows } = await client.queryObject({
+      args: [result],
+      fields: ["result"],
+      text: "SELECT $1",
+    });
+
+    assertEquals(rows[0], { result });
+  },
+);
+
+testClient(
+  "Handles array with semicolon separator",
+  async (generateClient) => {
+    const client = await generateClient();
+    const item_1 = "Test;Azer";
+    const item_2 = "123;456";
+
+    const { rows: result_1 } = await client.queryArray(
+      `SELECT ARRAY[$1, $2]`,
+      item_1,
+      item_2,
+    );
+    assertEquals(result_1[0], [[item_1, item_2]]);
+  },
+);
+
+testClient(
+  "Handles parameter status messages on simple query",
+  async (generateClient) => {
+    const client = await generateClient();
+
+    const { rows: result_1 } = await client.queryArray
+      `SET TIME ZONE 'HongKong'`;
+
+    assertEquals(result_1, []);
+
+    const { rows: result_2 } = await client.queryObject({
+      fields: ["result"],
+      text: "SET TIME ZONE 'HongKong'; SELECT 1",
+    });
+
+    assertEquals(result_2, [{ result: 1 }]);
+  },
+);
+
+testClient(
+  "Handles parameter status messages on prepared query",
+  async (generateClient) => {
+    const client = await generateClient();
+
+    const result = 10;
+
+    await client.queryArray
+      `CREATE OR REPLACE FUNCTION PG_TEMP.CHANGE_TIMEZONE(RES INTEGER) RETURNS INT AS $$
+			BEGIN
+			SET TIME ZONE 'HongKong';
+			END;
+			$$ LANGUAGE PLPGSQL;`;
+
+    await assertThrowsAsync(
+      () =>
+        client.queryArray("SELECT * FROM PG_TEMP.CHANGE_TIMEZONE($1)", result),
+      PostgresError,
+      "control reached end of function without RETURN",
+    );
+
+    await client.queryArray
+      `CREATE OR REPLACE FUNCTION PG_TEMP.CHANGE_TIMEZONE(RES INTEGER) RETURNS INT AS $$
+			BEGIN
+			SET TIME ZONE 'HongKong';
+			RETURN RES;
+			END;
+			$$ LANGUAGE PLPGSQL;`;
+
+    const { rows: result_1 } = await client.queryObject({
+      args: [result],
+      fields: ["result"],
+      text: "SELECT * FROM PG_TEMP.CHANGE_TIMEZONE($1)",
+    });
+
+    assertEquals(result_1, [{ result }]);
+  },
+);
+
+testClient(
+  "Handles parameter status after error",
+  async (generateClient) => {
+    const client = await generateClient();
+
+    await client.queryArray
+      `CREATE OR REPLACE FUNCTION PG_TEMP.CHANGE_TIMEZONE() RETURNS INT AS $$
+			BEGIN
+			SET TIME ZONE 'HongKong';
+			END;
+			$$ LANGUAGE PLPGSQL;`;
+
+    await assertThrowsAsync(
+      () => client.queryArray`SELECT * FROM PG_TEMP.CHANGE_TIMEZONE()`,
+      PostgresError,
+      "control reached end of function without RETURN",
+    );
+  },
+);
+
 testClient("Terminated connections", async function (generateClient) {
   const client = await generateClient();
   await client.end();
@@ -93,9 +286,7 @@ testClient("Default reconnection", async (generateClient) => {
   await assertThrowsAsync(
     () => client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`,
     ConnectionError,
-    "The session was terminated by the database",
   );
-  assertEquals(client.connected, false);
 
   const { rows: result } = await client.queryObject<{ res: number }>({
     text: `SELECT 1`,
@@ -105,6 +296,7 @@ testClient("Default reconnection", async (generateClient) => {
     result[0].res,
     1,
   );
+
   assertEquals(client.connected, true);
 });
 
@@ -137,6 +329,47 @@ testClient("Handling of query notices", async function (generateClient) {
   assert(warnings[0].message.includes("already exists"));
 });
 
+testClient(
+  "Handling of messages between data fetching",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    await client.queryArray
+      `CREATE OR REPLACE FUNCTION PG_TEMP.MESSAGE_BETWEEN_DATA(MESSAGE VARCHAR) RETURNS VARCHAR AS $$
+			BEGIN
+			RAISE NOTICE '%', MESSAGE;
+			RETURN MESSAGE;
+			END;
+			$$ LANGUAGE PLPGSQL;`;
+
+    const message_1 = "MESSAGE_1";
+    const message_2 = "MESSAGE_2";
+    const message_3 = "MESSAGE_3";
+
+    const { rows: result, warnings } = await client.queryObject({
+      args: [message_1, message_2, message_3],
+      fields: ["result"],
+      text: `SELECT * FROM PG_TEMP.MESSAGE_BETWEEN_DATA($1)
+			UNION ALL
+			SELECT * FROM PG_TEMP.MESSAGE_BETWEEN_DATA($2)
+			UNION ALL
+			SELECT * FROM PG_TEMP.MESSAGE_BETWEEN_DATA($3)`,
+    });
+
+    assertEquals(result.length, 3);
+    assertEquals(warnings.length, 3);
+
+    assertEquals(result[0], { result: message_1 });
+    assertObjectMatch(warnings[0], { message: message_1 });
+
+    assertEquals(result[1], { result: message_2 });
+    assertObjectMatch(warnings[1], { message: message_2 });
+
+    assertEquals(result[2], { result: message_3 });
+    assertObjectMatch(warnings[2], { message: message_3 });
+  },
+);
+
 testClient("nativeType", async function (generateClient) {
   const client = await generateClient();
 
@@ -374,6 +607,23 @@ testClient(
   },
 );
 
+testClient(
+  "Object query throws when multiple query results don't have the same number of rows",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    await assertThrowsAsync(
+      () =>
+        client.queryObject<{ result: number }>({
+          text: "SELECT 1; SELECT '2'::INT, '3'",
+          fields: ["result"],
+        }),
+      RangeError,
+      "The fields provided for the query don't match the ones returned as a result",
+    );
+  },
+);
+
 testClient(
   "Query object with template string",
   async function (generateClient) {
diff --git a/tests/test_deps.ts b/tests/test_deps.ts
index 4a4643b1..1d29db67 100644
--- a/tests/test_deps.ts
+++ b/tests/test_deps.ts
@@ -3,10 +3,12 @@ export {
   assert,
   assertEquals,
   assertNotEquals,
+  assertObjectMatch,
   assertThrows,
   assertThrowsAsync,
-} from "https://deno.land/std@0.98.0/testing/asserts.ts";
+} from "https://deno.land/std@0.108.0/testing/asserts.ts";
 export {
   format as formatDate,
   parse as parseDate,
-} from "https://deno.land/std@0.98.0/datetime/mod.ts";
+} from "https://deno.land/std@0.108.0/datetime/mod.ts";
+export { fromFileUrl } from "https://deno.land/std@0.108.0/path/mod.ts";
diff --git a/tests/utils_test.ts b/tests/utils_test.ts
index af6bcaf0..067cdcee 100644
--- a/tests/utils_test.ts
+++ b/tests/utils_test.ts
@@ -1,4 +1,3 @@
-// deno-lint-ignore-file camelcase
 import { assertEquals } from "./test_deps.ts";
 import { DsnResult, parseDsn } from "../utils/utils.ts";
 import { DeferredAccessStack } from "../utils/deferred.ts";
@@ -23,9 +22,18 @@ class LazilyInitializedObject {
   }
 }
 
-Deno.test("parseDsn", function () {
+Deno.test("Parses connection string into config", function () {
   let c: DsnResult;
 
+  c = parseDsn("postgres://deno.land/test_database");
+
+  assertEquals(c.driver, "postgres");
+  assertEquals(c.user, "");
+  assertEquals(c.password, "");
+  assertEquals(c.hostname, "deno.land");
+  assertEquals(c.port, "");
+  assertEquals(c.database, "test_database");
+
   c = parseDsn(
     "postgres://fizz:buzz@deno.land:8000/test_database?application_name=myapp",
   );
@@ -37,15 +45,53 @@ Deno.test("parseDsn", function () {
   assertEquals(c.port, "8000");
   assertEquals(c.database, "test_database");
   assertEquals(c.params.application_name, "myapp");
+});
 
-  c = parseDsn("postgres://deno.land/test_database");
+Deno.test("Parses connection string params into param object", function () {
+  const params = {
+    param_1: "asd",
+    param_2: "xyz",
+    param_3: "3541",
+  };
 
-  assertEquals(c.driver, "postgres");
-  assertEquals(c.user, "");
-  assertEquals(c.password, "");
-  assertEquals(c.hostname, "deno.land");
-  assertEquals(c.port, "");
-  assertEquals(c.database, "test_database");
+  const base_url = new URL("postgres://fizz:buzz@deno.land:8000/test_database");
+  for (const [key, value] of Object.entries(params)) {
+    base_url.searchParams.set(key, value);
+  }
+
+  const parsed_dsn = parseDsn(base_url.toString());
+
+  assertEquals(parsed_dsn.params, params);
+});
+
+Deno.test("Decodes connection string password correctly", function () {
+  let parsed_dsn: DsnResult;
+  let password: string;
+
+  password = "Mtx=";
+  parsed_dsn = parseDsn(
+    `postgres://root:${encodeURIComponent(password)}@localhost:9999/txdb`,
+  );
+  assertEquals(parsed_dsn.password, password);
+
+  password = "pssword!=?with_symbols";
+  parsed_dsn = parseDsn(
+    `postgres://root:${encodeURIComponent(password)}@localhost:9999/txdb`,
+  );
+  assertEquals(parsed_dsn.password, password);
+});
+
+Deno.test("Defaults to connection string password literal if decoding fails", function () {
+  let parsed_dsn: DsnResult;
+  let password: string;
+
+  password = "Mtx%3";
+  parsed_dsn = parseDsn(`postgres://root:${password}@localhost:9999/txdb`);
+  assertEquals(parsed_dsn.password, password);
+
+  password = "%E0%A4%A";
+  parsed_dsn = parseDsn(`postgres://root:${password}@localhost:9999/txdb`);
+  assertEquals(parsed_dsn.password, password);
 });
 
 Deno.test("DeferredAccessStack", async () => {
diff --git a/utils/utils.ts b/utils/utils.ts
index a157df6d..1fd7f90e 100644
--- a/utils/utils.ts
+++ b/utils/utils.ts
@@ -1,4 +1,4 @@
-import { createHash } from "../deps.ts";
+import { bold, yellow } from "../deps.ts";
 
 export function readInt16BE(buffer: Uint8Array, offset: number): number {
   offset = offset >>> 0;
@@ -33,31 +33,6 @@ export function readUInt32BE(buffer: Uint8Array, offset: number): number {
   );
 }
 
-const encoder = new TextEncoder();
-
-function md5(bytes: Uint8Array): string {
-  return createHash("md5").update(bytes).toString("hex");
-}
-
-// https://www.postgresql.org/docs/current/protocol-flow.html
-// AuthenticationMD5Password
-// The actual PasswordMessage can be computed in SQL as:
-//  concat('md5', md5(concat(md5(concat(password, username)), random-salt))).
-// (Keep in mind the md5() function returns its result as a hex string.)
-export function hashMd5Password(
-  password: string,
-  username: string,
-  salt: Uint8Array,
-): string {
-  const innerHash = md5(encoder.encode(password + username));
-  const innerBytes = encoder.encode(innerHash);
-  const outerBuffer = new Uint8Array(innerBytes.length + salt.length);
-  outerBuffer.set(innerBytes);
-  outerBuffer.set(salt, innerBytes.length);
-  const outerHash = md5(outerBuffer);
-  return "md5" + outerHash;
-}
-
 export interface DsnResult {
   driver: string;
   user: string;
@@ -76,10 +51,23 @@ export function parseDsn(dsn: string): DsnResult {
   const [protocol, strippedUrl] = dsn.match(/(?:(?!:\/\/).)+/g) ?? ["", ""];
   const url = new URL(`http:${strippedUrl}`);
 
+  let password = url.password;
+  // Special characters in the password may be url-encoded by URL(), such as =
+  try {
+    password = decodeURIComponent(password);
+  } catch (_e) {
+    console.error(
+      bold(
+        yellow("Failed to decode URL password") +
+          "\nDefaulting to raw password",
+      ),
+    );
+  }
+
   return {
+    password,
     driver: protocol,
     user: url.username,
-    password: url.password,
     hostname: url.hostname,
     port: url.port,
     // remove leading slash from path
