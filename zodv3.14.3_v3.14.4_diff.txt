diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index 213695a0e..03222cc87 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -4,6 +4,7 @@ import { util } from "./helpers/util.ts";
 
 export const ZodIssueCode = util.arrayToEnum([
   "invalid_type",
+  "invalid_literal",
   "custom",
   "invalid_union",
   "invalid_union_discriminator",
@@ -23,7 +24,6 @@ export type ZodIssueCode = keyof typeof ZodIssueCode;
 
 export type ZodIssueBase = {
   path: (string | number)[];
-  // code: ZodIssueCode;
   message?: string;
 };
 
@@ -33,6 +33,11 @@ export interface ZodInvalidTypeIssue extends ZodIssueBase {
   received: ZodParsedType;
 }
 
+export interface ZodInvalidLiteralIssue extends ZodIssueBase {
+  code: typeof ZodIssueCode.invalid_literal;
+  expected: unknown;
+}
+
 export interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.unrecognized_keys;
   keys: string[];
@@ -106,6 +111,7 @@ export type DenormalizedError = { [k: string]: DenormalizedError | string[] };
 
 export type ZodIssueOptionalMessage =
   | ZodInvalidTypeIssue
+  | ZodInvalidLiteralIssue
   | ZodUnrecognizedKeysIssue
   | ZodInvalidUnionIssue
   | ZodInvalidUnionDiscriminatorIssue
@@ -286,6 +292,11 @@ export const defaultErrorMap = (
         message = `Expected ${issue.expected}, received ${issue.received}`;
       }
       break;
+    case ZodIssueCode.invalid_literal:
+      message = `Invalid literal value, expected ${JSON.stringify(
+        issue.expected
+      )}`;
+      break;
     case ZodIssueCode.unrecognized_keys:
       message = `Unrecognized key(s) in object: ${issue.keys
         .map((k) => `'${k}'`)
diff --git a/deno/lib/__tests__/error.test.ts b/deno/lib/__tests__/error.test.ts
index 6de517752..6d79a6845 100644
--- a/deno/lib/__tests__/error.test.ts
+++ b/deno/lib/__tests__/error.test.ts
@@ -419,7 +419,9 @@ test("literal default error message", () => {
   } catch (err) {
     const zerr: z.ZodError = err as any;
     expect(zerr.issues.length).toEqual(1);
-    expect(zerr.issues[0].message).toEqual("Expected string, received string");
+    expect(zerr.issues[0].message).toEqual(
+      `Invalid literal value, expected "Tuna"`
+    );
   }
 });
 
diff --git a/deno/lib/helpers/parseUtil.ts b/deno/lib/helpers/parseUtil.ts
index 81790a58a..60d9aadcf 100644
--- a/deno/lib/helpers/parseUtil.ts
+++ b/deno/lib/helpers/parseUtil.ts
@@ -129,7 +129,6 @@ export interface ParseContext {
     readonly issues: ZodIssue[];
     readonly contextualErrorMap?: ZodErrorMap;
     readonly async: boolean;
-    readonly typeCache: Map<any, ZodParsedType> | undefined;
   };
   readonly path: ParsePath;
   readonly schemaErrorMap?: ZodErrorMap;
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 3b38e9a9b..3d8026c68 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -236,7 +236,6 @@ export abstract class ZodType<
       common: {
         issues: [],
         async: params?.async ?? false,
-        typeCache: typeof Map !== "undefined" ? new Map() : undefined,
         contextualErrorMap: params?.errorMap,
       },
       path: params?.path || [],
@@ -268,7 +267,6 @@ export abstract class ZodType<
         issues: [],
         contextualErrorMap: params?.errorMap,
         async: true,
-        typeCache: typeof Map !== "undefined" ? new Map() : undefined,
       },
       path: params?.path || [],
       schemaErrorMap: this._def.errorMap,
@@ -1558,8 +1556,12 @@ export class ZodObject<
     const { status, ctx } = this._processInputParams(input);
 
     const { shape, keys: shapeKeys } = this._getCached();
-    const dataKeys = util.objectKeys(ctx.data);
-    const extraKeys = dataKeys.filter((k) => !shapeKeys.includes(k));
+    const extraKeys: string[] = [];
+    for (const key in ctx.data) {
+      if (!shapeKeys.includes(key)) {
+        extraKeys.push(key);
+      }
+    }
 
     const pairs: {
       key: ParseReturnType<any>;
@@ -2987,9 +2989,8 @@ export class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>> {
     if (input.data !== this._def.value) {
       const ctx = this._getOrReturnCtx(input);
       addIssueToContext(ctx, {
-        code: ZodIssueCode.invalid_type,
-        expected: getParsedType(this._def.value),
-        received: ctx.parsedType,
+        code: ZodIssueCode.invalid_literal,
+        expected: this._def.value,
       });
       return INVALID;
     }
diff --git a/package.json b/package.json
index fb392f4f1..6723732de 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.14.3",
+  "version": "3.14.4",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./lib/index.d.ts",
diff --git a/src/ZodError.ts b/src/ZodError.ts
index 97580e8a9..d7217bdc7 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -4,6 +4,7 @@ import { util } from "./helpers/util";
 
 export const ZodIssueCode = util.arrayToEnum([
   "invalid_type",
+  "invalid_literal",
   "custom",
   "invalid_union",
   "invalid_union_discriminator",
@@ -23,7 +24,6 @@ export type ZodIssueCode = keyof typeof ZodIssueCode;
 
 export type ZodIssueBase = {
   path: (string | number)[];
-  // code: ZodIssueCode;
   message?: string;
 };
 
@@ -33,6 +33,11 @@ export interface ZodInvalidTypeIssue extends ZodIssueBase {
   received: ZodParsedType;
 }
 
+export interface ZodInvalidLiteralIssue extends ZodIssueBase {
+  code: typeof ZodIssueCode.invalid_literal;
+  expected: unknown;
+}
+
 export interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.unrecognized_keys;
   keys: string[];
@@ -106,6 +111,7 @@ export type DenormalizedError = { [k: string]: DenormalizedError | string[] };
 
 export type ZodIssueOptionalMessage =
   | ZodInvalidTypeIssue
+  | ZodInvalidLiteralIssue
   | ZodUnrecognizedKeysIssue
   | ZodInvalidUnionIssue
   | ZodInvalidUnionDiscriminatorIssue
@@ -286,6 +292,11 @@ export const defaultErrorMap = (
         message = `Expected ${issue.expected}, received ${issue.received}`;
       }
       break;
+    case ZodIssueCode.invalid_literal:
+      message = `Invalid literal value, expected ${JSON.stringify(
+        issue.expected
+      )}`;
+      break;
     case ZodIssueCode.unrecognized_keys:
       message = `Unrecognized key(s) in object: ${issue.keys
         .map((k) => `'${k}'`)
diff --git a/src/__tests__/error.test.ts b/src/__tests__/error.test.ts
index b74ad671f..c1ed18a10 100644
--- a/src/__tests__/error.test.ts
+++ b/src/__tests__/error.test.ts
@@ -418,7 +418,9 @@ test("literal default error message", () => {
   } catch (err) {
     const zerr: z.ZodError = err as any;
     expect(zerr.issues.length).toEqual(1);
-    expect(zerr.issues[0].message).toEqual("Expected string, received string");
+    expect(zerr.issues[0].message).toEqual(
+      `Invalid literal value, expected "Tuna"`
+    );
   }
 });
 
diff --git a/src/helpers/parseUtil.ts b/src/helpers/parseUtil.ts
index c8b0d35c1..f7926d3d6 100644
--- a/src/helpers/parseUtil.ts
+++ b/src/helpers/parseUtil.ts
@@ -129,7 +129,6 @@ export interface ParseContext {
     readonly issues: ZodIssue[];
     readonly contextualErrorMap?: ZodErrorMap;
     readonly async: boolean;
-    readonly typeCache: Map<any, ZodParsedType> | undefined;
   };
   readonly path: ParsePath;
   readonly schemaErrorMap?: ZodErrorMap;
diff --git a/src/types.ts b/src/types.ts
index 635d1a525..358b744c3 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -236,7 +236,6 @@ export abstract class ZodType<
       common: {
         issues: [],
         async: params?.async ?? false,
-        typeCache: typeof Map !== "undefined" ? new Map() : undefined,
         contextualErrorMap: params?.errorMap,
       },
       path: params?.path || [],
@@ -268,7 +267,6 @@ export abstract class ZodType<
         issues: [],
         contextualErrorMap: params?.errorMap,
         async: true,
-        typeCache: typeof Map !== "undefined" ? new Map() : undefined,
       },
       path: params?.path || [],
       schemaErrorMap: this._def.errorMap,
@@ -1558,8 +1556,12 @@ export class ZodObject<
     const { status, ctx } = this._processInputParams(input);
 
     const { shape, keys: shapeKeys } = this._getCached();
-    const dataKeys = util.objectKeys(ctx.data);
-    const extraKeys = dataKeys.filter((k) => !shapeKeys.includes(k));
+    const extraKeys: string[] = [];
+    for (const key in ctx.data) {
+      if (!shapeKeys.includes(key)) {
+        extraKeys.push(key);
+      }
+    }
 
     const pairs: {
       key: ParseReturnType<any>;
@@ -2987,9 +2989,8 @@ export class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>> {
     if (input.data !== this._def.value) {
       const ctx = this._getOrReturnCtx(input);
       addIssueToContext(ctx, {
-        code: ZodIssueCode.invalid_type,
-        expected: getParsedType(this._def.value),
-        received: ctx.parsedType,
+        code: ZodIssueCode.invalid_literal,
+        expected: this._def.value,
       });
       return INVALID;
     }
