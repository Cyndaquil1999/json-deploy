diff --git a/.gitignore b/.gitignore
index 2e9402426..e38b9a309 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,3 +6,4 @@ coverage
 .idea
 *.log
 src/playground.ts
+deno/lib/playground.ts
diff --git a/README.md b/README.md
index 7e85f01b0..9c12188ef 100644
--- a/README.md
+++ b/README.md
@@ -226,12 +226,18 @@ npm install zod
 There are a growing number of tools that are built atop or support Zod natively! If you've built a tool or library on top of Zod, tell me about it [on Twitter](https://twitter.com/colinhacks) or [start a Discussion](https://github.com/colinhacks/zod/discussions). I'll add it below and tweet it out.
 
 - [`tRPC`](https://github.com/trpc/trpc): Build end-to-end typesafe APIs without GraphQL
-- [`react-hook-form`](https://github.com/react-hook-form/resolvers): Build type-safe forms easily with React Hook Form and the Zod resolver.
 - [`ts-to-zod`](https://github.com/fabien0102/ts-to-zod): Convert TypeScript definitions into Zod schemas.
 - [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.
 - [`zod-fast-check`](https://github.com/DavidTimms/zod-fast-check): Generate `fast-check` arbitraries from Zod schemas.
 - [`zod-endpoints`](https://github.com/flock-community/zod-endpoints): Contract-first strictly typed endpoints with Zod. OpenAPI compatible.
 - [`express-zod-api`](https://github.com/RobinTail/express-zod-api): Build Express-based APIs with I/O schema validation and custom middlewares
+- [`zod-to-json-schema`](https://github.com/StefanTerdell/zod-to-json-schema): Convert your Zod schemas into [JSON Schemas](https://json-schema.org/).
+- [`json-to-zod`](https://github.com/rsinohara/json-to-zod): Convert JSON objects into Zod schemas. Use it live [here](https://rsinohara.github.io/json-to-zod-react/).
+
+### Form integrations
+
+- [`react-hook-form`](https://github.com/react-hook-form/resolvers#zod): A first-party Zod resolver for React Hook Form
+- [`formik`](https://github.com/robertLichtnow/zod-formik-adapter): A community-maintained Formik adapter for Zod
 
 # Basic usage
 
@@ -1568,11 +1574,11 @@ You can separately extract the input and output types like so:
 const stringToNumber = z.string().transform((val) => val.length);
 
 // ⚠️ Important: z.infer returns the OUTPUT type!
-type input = z.input<stringToNumber>; // string
-type output = z.output<stringToNumber>; // number
+type input = z.input<typeof stringToNumber>; // string
+type output = z.output<typeof stringToNumber>; // number
 
 // equivalent to z.output!
-type inferred = z.infer<stringToNumber>; // number
+type inferred = z.infer<typeof stringToNumber>; // number
 ```
 
 # Errors
diff --git a/deno/lib/benchmarks/index.ts b/deno/lib/benchmarks/index.ts
index edc568f75..ae1fa8154 100644
--- a/deno/lib/benchmarks/index.ts
+++ b/deno/lib/benchmarks/index.ts
@@ -1,6 +1,11 @@
 import objectBenchmarks from "./object.ts";
 import stringBenchmarks from "./string.ts";
+import unionBenchmarks from "./union.ts";
 
-for (const suite of [...stringBenchmarks.suites, ...objectBenchmarks.suites]) {
+for (const suite of [
+  ...stringBenchmarks.suites,
+  ...objectBenchmarks.suites,
+  ...unionBenchmarks.suites,
+]) {
   suite.run();
 }
diff --git a/deno/lib/benchmarks/union.ts b/deno/lib/benchmarks/union.ts
new file mode 100644
index 000000000..62f2df92a
--- /dev/null
+++ b/deno/lib/benchmarks/union.ts
@@ -0,0 +1,80 @@
+import Benchmark from "benchmark";
+
+import { z } from "../index.ts";
+
+const doubleSuite = new Benchmark.Suite("z.union: double");
+const manySuite = new Benchmark.Suite("z.union: many");
+
+const aSchema = z.object({
+  type: z.literal("a"),
+});
+const objA = {
+  type: "a",
+};
+
+const bSchema = z.object({
+  type: z.literal("b"),
+});
+const objB = {
+  type: "b",
+};
+
+const cSchema = z.object({
+  type: z.literal("c"),
+});
+const objC = {
+  type: "c",
+};
+
+const dSchema = z.object({
+  type: z.literal("d"),
+});
+
+const double = z.union([aSchema, bSchema]);
+const many = z.union([aSchema, bSchema, cSchema, dSchema]);
+
+doubleSuite
+  .add("valid: a", () => {
+    double.parse(objA);
+  })
+  .add("valid: b", () => {
+    double.parse(objB);
+  })
+  .add("invalid: null", () => {
+    try {
+      double.parse(null);
+    } catch (err) {}
+  })
+  .add("invalid: wrong shape", () => {
+    try {
+      double.parse(objC);
+    } catch (err) {}
+  })
+  .on("cycle", (e: Benchmark.Event) => {
+    console.log(`${(doubleSuite as any).name}: ${e.target}`);
+  });
+
+manySuite
+  .add("valid: a", () => {
+    many.parse(objA);
+  })
+  .add("valid: c", () => {
+    many.parse(objC);
+  })
+  .add("invalid: null", () => {
+    try {
+      many.parse(null);
+    } catch (err) {}
+  })
+  .add("invalid: wrong shape", () => {
+    try {
+      many.parse({ type: "unknown" });
+    } catch (err) {}
+  })
+  .on("cycle", (e: Benchmark.Event) => {
+    console.log(`${(manySuite as any).name}: ${e.target}`);
+  });
+
+export default {
+  suites: [doubleSuite, manySuite],
+};
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index bd7a1a231..302b9c3f6 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -1515,7 +1515,7 @@ export class ZodObject<
 
   /**
    * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
-   * If you want to pass through unknown properies, use `.passthrough()` instead.
+   * If you want to pass through unknown properties, use `.passthrough()` instead.
    */
   nonstrict = this.passthrough;
 
@@ -2303,74 +2303,53 @@ export class ZodFunction<
       return INVALID;
     }
 
-    const handleArgs = (
-      args: any,
-      parsedArgs:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedArgs.success) {
-        const issue = makeIssue(
-          args,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_arguments,
-            argumentsError: parsedArgs.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedArgs.data;
-    };
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
 
-    const handleReturns = (
-      returns: any,
-      parsedReturns:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedReturns.success) {
-        const issue = makeIssue(
-          returns,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_return_type,
-            returnTypeError: parsedReturns.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedReturns.data;
-    };
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
 
     const params = { errorMap: ctx.params.errorMap };
     const fn = data;
 
     if (this._def.returns instanceof ZodPromise) {
       return OK(async (...args: any[]) => {
-        const parsedArgs = handleArgs(
-          args,
-          await this._def.args.spa(args, params)
-        );
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
+          });
         const result = await fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          await this._def.returns.spa(result, params)
-        );
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
+          });
+        return parsedReturns;
       });
     } else {
       return OK((...args: any[]) => {
-        const parsedArgs = handleArgs(
-          args,
-          this._def.args.safeParse(args, params)
-        );
-        const result = fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          this._def.returns.safeParse(result, params)
-        );
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;
       });
     }
   }
@@ -2748,6 +2727,7 @@ export class ZodEffects<
         return pathToArray(ctx.path);
       },
     };
+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
 
     let invalid = false;
     const applyEffect = (
diff --git a/package.json b/package.json
index 5cb6ddfba..678346b9d 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.7.1",
+  "version": "3.7.3",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./lib/index.d.ts",
diff --git a/src/benchmarks/index.ts b/src/benchmarks/index.ts
index 6cefe3838..10735fed4 100644
--- a/src/benchmarks/index.ts
+++ b/src/benchmarks/index.ts
@@ -1,6 +1,11 @@
 import objectBenchmarks from "./object";
 import stringBenchmarks from "./string";
+import unionBenchmarks from "./union";
 
-for (const suite of [...stringBenchmarks.suites, ...objectBenchmarks.suites]) {
+for (const suite of [
+  ...stringBenchmarks.suites,
+  ...objectBenchmarks.suites,
+  ...unionBenchmarks.suites,
+]) {
   suite.run();
 }
diff --git a/src/benchmarks/union.ts b/src/benchmarks/union.ts
new file mode 100644
index 000000000..daec4429c
--- /dev/null
+++ b/src/benchmarks/union.ts
@@ -0,0 +1,80 @@
+import Benchmark from "benchmark";
+
+import { z } from "../index";
+
+const doubleSuite = new Benchmark.Suite("z.union: double");
+const manySuite = new Benchmark.Suite("z.union: many");
+
+const aSchema = z.object({
+  type: z.literal("a"),
+});
+const objA = {
+  type: "a",
+};
+
+const bSchema = z.object({
+  type: z.literal("b"),
+});
+const objB = {
+  type: "b",
+};
+
+const cSchema = z.object({
+  type: z.literal("c"),
+});
+const objC = {
+  type: "c",
+};
+
+const dSchema = z.object({
+  type: z.literal("d"),
+});
+
+const double = z.union([aSchema, bSchema]);
+const many = z.union([aSchema, bSchema, cSchema, dSchema]);
+
+doubleSuite
+  .add("valid: a", () => {
+    double.parse(objA);
+  })
+  .add("valid: b", () => {
+    double.parse(objB);
+  })
+  .add("invalid: null", () => {
+    try {
+      double.parse(null);
+    } catch (err) {}
+  })
+  .add("invalid: wrong shape", () => {
+    try {
+      double.parse(objC);
+    } catch (err) {}
+  })
+  .on("cycle", (e: Benchmark.Event) => {
+    console.log(`${(doubleSuite as any).name}: ${e.target}`);
+  });
+
+manySuite
+  .add("valid: a", () => {
+    many.parse(objA);
+  })
+  .add("valid: c", () => {
+    many.parse(objC);
+  })
+  .add("invalid: null", () => {
+    try {
+      many.parse(null);
+    } catch (err) {}
+  })
+  .add("invalid: wrong shape", () => {
+    try {
+      many.parse({ type: "unknown" });
+    } catch (err) {}
+  })
+  .on("cycle", (e: Benchmark.Event) => {
+    console.log(`${(manySuite as any).name}: ${e.target}`);
+  });
+
+export default {
+  suites: [doubleSuite, manySuite],
+};
diff --git a/src/types.ts b/src/types.ts
index 3bd74482f..890bbb2cd 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -1515,7 +1515,7 @@ export class ZodObject<
 
   /**
    * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
-   * If you want to pass through unknown properies, use `.passthrough()` instead.
+   * If you want to pass through unknown properties, use `.passthrough()` instead.
    */
   nonstrict = this.passthrough;
 
@@ -2303,74 +2303,53 @@ export class ZodFunction<
       return INVALID;
     }
 
-    const handleArgs = (
-      args: any,
-      parsedArgs:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedArgs.success) {
-        const issue = makeIssue(
-          args,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_arguments,
-            argumentsError: parsedArgs.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedArgs.data;
-    };
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
 
-    const handleReturns = (
-      returns: any,
-      parsedReturns:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedReturns.success) {
-        const issue = makeIssue(
-          returns,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_return_type,
-            returnTypeError: parsedReturns.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedReturns.data;
-    };
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
 
     const params = { errorMap: ctx.params.errorMap };
     const fn = data;
 
     if (this._def.returns instanceof ZodPromise) {
       return OK(async (...args: any[]) => {
-        const parsedArgs = handleArgs(
-          args,
-          await this._def.args.spa(args, params)
-        );
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
+          });
         const result = await fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          await this._def.returns.spa(result, params)
-        );
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
+          });
+        return parsedReturns;
       });
     } else {
       return OK((...args: any[]) => {
-        const parsedArgs = handleArgs(
-          args,
-          this._def.args.safeParse(args, params)
-        );
-        const result = fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          this._def.returns.safeParse(result, params)
-        );
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;
       });
     }
   }
@@ -2748,6 +2727,7 @@ export class ZodEffects<
         return pathToArray(ctx.path);
       },
     };
+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
 
     let invalid = false;
     const applyEffect = (
