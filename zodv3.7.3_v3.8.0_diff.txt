diff --git a/CHANGELOG.md b/CHANGELOG.md
index 00b9e6bd6..da6323071 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,11 @@
 # Changelog
 
+### 3.8
+
+- Add `z.preprocess`
+- Implement CUID validation on ZodString (`z.string().cuid()`)
+- Improved `.deepPartial()`: now recursively operates on arrays, tuples, optionals, and nullables (in addition to objects)
+
 ### 3.7
 
 - Eliminate `ZodNonEmptyArray`, add `Cardinality` to `ZodArray`
diff --git a/README.md b/README.md
index 9c12188ef..780ef7931 100644
--- a/README.md
+++ b/README.md
@@ -321,6 +321,7 @@ z.string().length(5);
 z.string().email();
 z.string().url();
 z.string().uuid();
+z.string().cuid();
 z.string().regex(regex);
 
 // deprecated, equivalent to .min(1)
@@ -483,6 +484,7 @@ const user = z.object({
     latitude: z.number(),
     longitude: z.number(),
   }),
+  strings: z.array(z.object({ value: z.string() })),
 });
 
 const deepPartialUser = user.deepPartial();
@@ -493,12 +495,13 @@ const deepPartialUser = user.deepPartial();
   location?: {
     latitude?: number | undefined;
     longitude?: number | undefined;
-  } | undefined
+  } | undefined,
+  strings?: { value?: string}[]
 }
 */
 ```
 
-> Important limitation: deep partials only work as expected in direct hierarchies of object schemas. A nested object schema can't be optional, nullable, contain refinements, contain transforms, etc.
+> Important limitation: deep partials only work as expected in hierarchies of objects, arrays, and tuples.
 
 #### Unrecognized keys
 
diff --git a/coverage.svg b/coverage.svg
index 0a5d5c23d..4e2422f60 100644
--- a/coverage.svg
+++ b/coverage.svg
@@ -1 +1 @@
-<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 89.07%"><title>Coverage: 89.07%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#dfb317"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">89.07%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">89.07%</text></g></svg>
\ No newline at end of file
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 89.34%"><title>Coverage: 89.34%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#dfb317"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">89.34%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">89.34%</text></g></svg>
\ No newline at end of file
diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index 166ee5d8c..4ee50696b 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -59,7 +59,7 @@ export interface ZodInvalidDateIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.invalid_date;
 }
 
-export type StringValidation = "email" | "url" | "uuid" | "regex";
+export type StringValidation = "email" | "url" | "uuid" | "regex" | "cuid";
 
 export interface ZodInvalidStringIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.invalid_string;
@@ -324,7 +324,7 @@ export const defaultErrorMap = (
       message = `Invalid input`;
       break;
     case ZodIssueCode.invalid_intersection_types:
-      message = `Intersections only support objects`;
+      message = `Intersection results could not be merged`;
       break;
     default:
       message = _ctx.defaultError;
diff --git a/deno/lib/__tests__/partials.test.ts b/deno/lib/__tests__/partials.test.ts
index fdffaefc6..b5166ac86 100644
--- a/deno/lib/__tests__/partials.test.ts
+++ b/deno/lib/__tests__/partials.test.ts
@@ -4,6 +4,7 @@ const test = Deno.test;
 
 import { util } from "../helpers/util.ts";
 import * as z from "../index.ts";
+import { ZodNullable, ZodOptional } from "../index.ts";
 
 const nested = z.object({
   name: z.string(),
@@ -11,6 +12,7 @@ const nested = z.object({
   outer: z.object({
     inner: z.string(),
   }),
+  array: z.array(z.object({ asdf: z.string() })),
 });
 
 test("shallow inference", () => {
@@ -20,6 +22,7 @@ test("shallow inference", () => {
     name?: string | undefined;
     age?: number | undefined;
     outer?: { inner: string } | undefined;
+    array?: { asdf: string }[];
   };
   const t1: util.AssertEqual<shallow, correct> = true;
   t1;
@@ -36,8 +39,11 @@ test("shallow partial parse", () => {
 
 test("deep partial inference", () => {
   const deep = nested.deepPartial();
+  const asdf = deep.shape.array.unwrap().element.shape.asdf.unwrap();
+  asdf.parse("asdf");
   type deep = z.infer<typeof deep>;
   type correct = {
+    array?: { asdf?: string }[];
     name?: string | undefined;
     age?: number | undefined;
     outer?: { inner?: string | undefined } | undefined;
@@ -77,6 +83,57 @@ test("deep partial runtime tests", () => {
   });
 });
 
+test("deep partial optional/nullable", () => {
+  const schema = z
+    .object({
+      name: z.string().optional(),
+      age: z.number().nullable(),
+    })
+    .deepPartial();
+
+  expect(schema.shape.name.unwrap()).toBeInstanceOf(ZodOptional);
+  expect(schema.shape.age.unwrap()).toBeInstanceOf(ZodNullable);
+});
+
+test("deep partial tuple", () => {
+  const schema = z
+    .object({
+      tuple: z.tuple([
+        z.object({
+          name: z.string().optional(),
+          age: z.number().nullable(),
+        }),
+      ]),
+    })
+    .deepPartial();
+
+  expect(schema.shape.tuple.unwrap().items[0].shape.name).toBeInstanceOf(
+    ZodOptional
+  );
+});
+
+test("deep partial inference", () => {
+  const mySchema = z.object({
+    name: z.string(),
+    array: z.array(z.object({ asdf: z.string() })),
+    tuple: z.tuple([z.object({ value: z.string() })]),
+  });
+
+  const partialed = mySchema.deepPartial();
+  type partialed = z.infer<typeof partialed>;
+  type expected = {
+    name?: string | undefined;
+    array?:
+      | {
+          asdf?: string | undefined;
+        }[]
+      | undefined;
+    tuple?: [{ value?: string }] | undefined;
+  };
+  const f1: util.AssertEqual<expected, partialed> = true;
+  f1;
+});
+
 test("required", () => {
   const object = z.object({
     name: z.string(),
diff --git a/deno/lib/__tests__/string.test.ts b/deno/lib/__tests__/string.test.ts
index c12224d5a..22be848ce 100644
--- a/deno/lib/__tests__/string.test.ts
+++ b/deno/lib/__tests__/string.test.ts
@@ -101,6 +101,16 @@ test("bad uuid", () => {
   }
 });
 
+test("cuid", () => {
+  const cuid = z.string().cuid();
+  cuid.parse("ckopqwooh000001la8mbi2im9");
+  const result = cuid.safeParse("cifjhdsfhsd-invalid-cuid");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual("Invalid cuid");
+  }
+});
+
 test("regex", () => {
   z.string()
     .regex(/^moo+$/)
diff --git a/deno/lib/__tests__/transformer.test.ts b/deno/lib/__tests__/transformer.test.ts
index 445c18d19..8b6784c76 100644
--- a/deno/lib/__tests__/transformer.test.ts
+++ b/deno/lib/__tests__/transformer.test.ts
@@ -120,3 +120,10 @@ test("multiple transformers", () => {
   });
   expect(doubler.parse("5")).toEqual(10);
 });
+
+test("preprocess", () => {
+  const schema = z.preprocess((data) => [data], z.string().array());
+
+  const value = schema.parse("asdf");
+  expect(value).toEqual(["asdf"]);
+});
diff --git a/deno/lib/helpers/partialUtil.ts b/deno/lib/helpers/partialUtil.ts
index a95c2c73e..4229a66d5 100644
--- a/deno/lib/helpers/partialUtil.ts
+++ b/deno/lib/helpers/partialUtil.ts
@@ -1,37 +1,80 @@
-import { ZodObject, ZodOptional, ZodTypeAny } from "../index.ts";
-
-type AnyZodObject = ZodObject<any, any, any>;
+import type {
+  ZodArray,
+  ZodNullable,
+  ZodObject,
+  ZodOptional,
+  ZodTuple,
+  ZodTupleItems,
+  ZodTypeAny,
+} from "../index.ts";
 
 export namespace partialUtil {
-  export type RootDeepPartial<T extends ZodTypeAny> = {
-    // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
-    // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
-    object: T extends AnyZodObject
-      ? ZodObject<
-          { [k in keyof T["_shape"]]: DeepPartial<T["_shape"][k]> },
-          T["_unknownKeys"],
-          T["_catchall"]
-        >
-      : never;
-    rest: ReturnType<T["optional"]>; // ZodOptional<T>;
-  }[T extends AnyZodObject
-    ? "object" // T extends ZodOptional<any> // ? 'optional' // :
-    : "rest"];
+  // export type DeepPartial<T extends AnyZodObject> = T extends AnyZodObject
+  //   ? ZodObject<
+  //       { [k in keyof T["_shape"]]: InternalDeepPartial<T["_shape"][k]> },
+  //       T["_unknownKeys"],
+  //       T["_catchall"]
+  //     >
+  //   : T extends ZodArray<infer Type, infer Card>
+  //   ? ZodArray<InternalDeepPartial<Type>, Card>
+  //   : ZodOptional<T>;
+
+  // {
+  //   // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
+  //   // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
+  //   object: T extends AnyZodObject
+  //     ? ZodObject<
+  //         { [k in keyof T["_shape"]]: DeepPartial<T["_shape"][k]> },
+  //         T["_unknownKeys"],
+  //         T["_catchall"]
+  //       >
+  //     : never;
+  //   rest: ReturnType<T["optional"]>; // ZodOptional<T>;
+  // }[T extends AnyZodObject
+  //   ? "object" // T extends ZodOptional<any> // ? 'optional' // :
+  //   : "rest"];
 
-  export type DeepPartial<T extends ZodTypeAny> = {
-    // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
-    // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
-    object: T extends ZodObject<infer Shape, infer Params, infer Catchall>
-      ? ZodOptional<
-          ZodObject<
-            { [k in keyof Shape]: DeepPartial<Shape[k]> },
-            Params,
-            Catchall
-          >
-        >
-      : never;
-    rest: ReturnType<T["optional"]>;
-  }[T extends ZodObject<any>
-    ? "object" // T extends ZodOptional<any> // ? 'optional' // :
-    : "rest"];
+  export type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<
+    infer Shape,
+    infer Params,
+    infer Catchall
+  >
+    ? ZodObject<
+        { [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>> },
+        Params,
+        Catchall
+      >
+    : T extends ZodArray<infer Type, infer Card>
+    ? ZodArray<DeepPartial<Type>, Card>
+    : T extends ZodOptional<infer Type>
+    ? ZodOptional<DeepPartial<Type>>
+    : T extends ZodNullable<infer Type>
+    ? ZodNullable<DeepPartial<Type>>
+    : T extends ZodTuple<infer Items>
+    ? {
+        [k in keyof Items]: Items[k] extends ZodTypeAny
+          ? DeepPartial<Items[k]>
+          : never;
+      } extends infer PI
+      ? PI extends ZodTupleItems
+        ? ZodTuple<PI>
+        : never
+      : never
+    : T;
+  //  {
+  //     // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
+  //     // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
+  //     object: T extends ZodObject<infer Shape, infer Params, infer Catchall>
+  //       ? ZodOptional<
+  //           ZodObject<
+  //             { [k in keyof Shape]: DeepPartial<Shape[k]> },
+  //             Params,
+  //             Catchall
+  //           >
+  //         >
+  //       : never;
+  //     rest: ReturnType<T["optional"]>;
+  //   }[T extends ZodObject<any>
+  //     ? "object" // T extends ZodOptional<any> // ? 'optional' // :
+  //     : "rest"];
 }
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 302b9c3f6..dcd2c2684 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -314,6 +314,7 @@ type ZodStringCheck =
   | { kind: "email"; message?: string }
   | { kind: "url"; message?: string }
   | { kind: "uuid"; message?: string }
+  | { kind: "cuid"; message?: string }
   | { kind: "regex"; regex: RegExp; message?: string };
 
 export interface ZodStringDef extends ZodTypeDef {
@@ -321,6 +322,7 @@ export interface ZodStringDef extends ZodTypeDef {
   typeName: ZodFirstPartyTypeKind.ZodString;
 }
 
+const cuidRegex = /^c[^\s-]{8,}$/i;
 const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
 // from https://stackoverflow.com/a/46181/1550155
 // old version: too slow, didn't support unicode
@@ -386,6 +388,15 @@ export class ZodString extends ZodType<string, ZodStringDef> {
             message: check.message,
           });
         }
+      } else if (check.kind === "cuid") {
+        if (!cuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: "cuid",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
       } else if (check.kind === "url") {
         try {
           new URL(data);
@@ -450,6 +461,15 @@ export class ZodString extends ZodType<string, ZodStringDef> {
       ],
     });
 
+  cuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        { kind: "cuid", ...errorUtil.errToObj(message) },
+      ],
+    });
+
   regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
     new ZodString({
       ...this._def,
@@ -1373,6 +1393,33 @@ export type SomeZodObject = ZodObject<
   any,
   any
 >;
+
+function deepPartialify(schema: ZodTypeAny): any {
+  if (schema instanceof ZodObject) {
+    const newShape: any = {};
+
+    for (const key in schema.shape) {
+      const fieldSchema = schema.shape[key];
+      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
+    }
+    return new ZodObject({
+      ...schema._def,
+      shape: () => newShape,
+    }) as any;
+  } else if (schema instanceof ZodArray) {
+    return ZodArray.create(deepPartialify(schema.element));
+  } else if (schema instanceof ZodOptional) {
+    return ZodOptional.create(deepPartialify(schema.unwrap()));
+  } else if (schema instanceof ZodNullable) {
+    return ZodNullable.create(deepPartialify(schema.unwrap()));
+  } else if (schema instanceof ZodTuple) {
+    return ZodTuple.create(
+      schema.items.map((item: any) => deepPartialify(item))
+    );
+  } else {
+    return schema;
+  }
+}
 export class ZodObject<
   T extends ZodRawShape,
   UnknownKeys extends UnknownKeysParam = "strip",
@@ -1617,25 +1664,8 @@ export class ZodObject<
     }) as any;
   };
 
-  deepPartial: () => partialUtil.RootDeepPartial<this> = () => {
-    const newShape: any = {};
-
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      if (fieldSchema instanceof ZodObject) {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : (fieldSchema.deepPartial() as any).optional();
-      } else {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : fieldSchema.optional();
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
   };
 
   required = (): ZodObject<
@@ -1900,17 +1930,17 @@ export class ZodIntersection<
 //////////                    //////////
 ////////////////////////////////////////
 ////////////////////////////////////////
-export type OutputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
+export type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
   [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
 };
 
-export type InputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
   [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
 };
 
-export interface ZodTupleDef<
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodTypeDef {
+export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
+  extends ZodTypeDef {
   items: T;
   typeName: ZodFirstPartyTypeKind.ZodTuple;
 }
@@ -2699,6 +2729,7 @@ export interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny>
   extends ZodTypeDef {
   schema: T;
   typeName: ZodFirstPartyTypeKind.ZodEffects;
+  preprocess?: Mod<any>;
   effects?: Effect<any>[];
 }
 
@@ -2712,11 +2743,20 @@ export class ZodEffects<
 
   _parse(
     ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
+    initialData: any,
+    initialParsedType: ZodParsedType
   ): ParseReturnType<Output> {
     const isSync = ctx.params.async === false;
+    const preprocess = this._def.preprocess;
     const effects = this._def.effects || [];
+
+    let data = initialData;
+    let parsedType: ZodParsedType = initialParsedType;
+    if (preprocess) {
+      data = preprocess.transform(initialData);
+      parsedType = getParsedType(data);
+    }
+
     const checkCtx: RefinementCtx = {
       issueFound: false,
       addIssue: function (arg: MakeErrorData) {
@@ -2727,6 +2767,7 @@ export class ZodEffects<
         return pathToArray(ctx.path);
       },
     };
+
     checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
 
     let invalid = false;
@@ -2824,6 +2865,19 @@ export class ZodEffects<
 
     return newTx;
   };
+
+  static createWithPreprocess = <I extends ZodTypeAny>(
+    preprocess: (arg: unknown) => unknown,
+    schema: I
+  ): ZodEffects<I, I["_output"]> => {
+    const newTx = new ZodEffects({
+      schema,
+      preprocess: { type: "transform", transform: preprocess },
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+    });
+
+    return newTx;
+  };
 }
 
 export { ZodEffects as ZodTransformer };
@@ -3068,6 +3122,7 @@ const promiseType = ZodPromise.create;
 const effectsType = ZodEffects.create;
 const optionalType = ZodOptional.create;
 const nullableType = ZodNullable.create;
+const preprocessType = ZodEffects.createWithPreprocess;
 const ostring = () => stringType().optional();
 const onumber = () => numberType().optional();
 const oboolean = () => booleanType().optional();
@@ -3096,6 +3151,7 @@ export {
   onumber,
   optionalType as optional,
   ostring,
+  preprocessType as preprocess,
   promiseType as promise,
   recordType as record,
   setType as set,
diff --git a/package.json b/package.json
index 678346b9d..1c35c3e3c 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.7.3",
+  "version": "3.8.0",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./lib/index.d.ts",
diff --git a/src/ZodError.ts b/src/ZodError.ts
index 033aa5be2..c73a4080f 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -59,7 +59,7 @@ export interface ZodInvalidDateIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.invalid_date;
 }
 
-export type StringValidation = "email" | "url" | "uuid" | "regex";
+export type StringValidation = "email" | "url" | "uuid" | "regex" | "cuid";
 
 export interface ZodInvalidStringIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.invalid_string;
@@ -324,7 +324,7 @@ export const defaultErrorMap = (
       message = `Invalid input`;
       break;
     case ZodIssueCode.invalid_intersection_types:
-      message = `Intersections only support objects`;
+      message = `Intersection results could not be merged`;
       break;
     default:
       message = _ctx.defaultError;
diff --git a/src/__tests__/partials.test.ts b/src/__tests__/partials.test.ts
index b47cec69e..62ad5f0ad 100644
--- a/src/__tests__/partials.test.ts
+++ b/src/__tests__/partials.test.ts
@@ -3,6 +3,7 @@ import { expect, test } from "@jest/globals";
 
 import { util } from "../helpers/util";
 import * as z from "../index";
+import { ZodNullable, ZodOptional } from "../index";
 
 const nested = z.object({
   name: z.string(),
@@ -10,6 +11,7 @@ const nested = z.object({
   outer: z.object({
     inner: z.string(),
   }),
+  array: z.array(z.object({ asdf: z.string() })),
 });
 
 test("shallow inference", () => {
@@ -19,6 +21,7 @@ test("shallow inference", () => {
     name?: string | undefined;
     age?: number | undefined;
     outer?: { inner: string } | undefined;
+    array?: { asdf: string }[];
   };
   const t1: util.AssertEqual<shallow, correct> = true;
   t1;
@@ -35,8 +38,11 @@ test("shallow partial parse", () => {
 
 test("deep partial inference", () => {
   const deep = nested.deepPartial();
+  const asdf = deep.shape.array.unwrap().element.shape.asdf.unwrap();
+  asdf.parse("asdf");
   type deep = z.infer<typeof deep>;
   type correct = {
+    array?: { asdf?: string }[];
     name?: string | undefined;
     age?: number | undefined;
     outer?: { inner?: string | undefined } | undefined;
@@ -76,6 +82,57 @@ test("deep partial runtime tests", () => {
   });
 });
 
+test("deep partial optional/nullable", () => {
+  const schema = z
+    .object({
+      name: z.string().optional(),
+      age: z.number().nullable(),
+    })
+    .deepPartial();
+
+  expect(schema.shape.name.unwrap()).toBeInstanceOf(ZodOptional);
+  expect(schema.shape.age.unwrap()).toBeInstanceOf(ZodNullable);
+});
+
+test("deep partial tuple", () => {
+  const schema = z
+    .object({
+      tuple: z.tuple([
+        z.object({
+          name: z.string().optional(),
+          age: z.number().nullable(),
+        }),
+      ]),
+    })
+    .deepPartial();
+
+  expect(schema.shape.tuple.unwrap().items[0].shape.name).toBeInstanceOf(
+    ZodOptional
+  );
+});
+
+test("deep partial inference", () => {
+  const mySchema = z.object({
+    name: z.string(),
+    array: z.array(z.object({ asdf: z.string() })),
+    tuple: z.tuple([z.object({ value: z.string() })]),
+  });
+
+  const partialed = mySchema.deepPartial();
+  type partialed = z.infer<typeof partialed>;
+  type expected = {
+    name?: string | undefined;
+    array?:
+      | {
+          asdf?: string | undefined;
+        }[]
+      | undefined;
+    tuple?: [{ value?: string }] | undefined;
+  };
+  const f1: util.AssertEqual<expected, partialed> = true;
+  f1;
+});
+
 test("required", () => {
   const object = z.object({
     name: z.string(),
diff --git a/src/__tests__/string.test.ts b/src/__tests__/string.test.ts
index 6cc6e6acc..1ca8cede2 100644
--- a/src/__tests__/string.test.ts
+++ b/src/__tests__/string.test.ts
@@ -100,6 +100,16 @@ test("bad uuid", () => {
   }
 });
 
+test("cuid", () => {
+  const cuid = z.string().cuid();
+  cuid.parse("ckopqwooh000001la8mbi2im9");
+  const result = cuid.safeParse("cifjhdsfhsd-invalid-cuid");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual("Invalid cuid");
+  }
+});
+
 test("regex", () => {
   z.string()
     .regex(/^moo+$/)
diff --git a/src/__tests__/transformer.test.ts b/src/__tests__/transformer.test.ts
index 7221d5fdf..af0130862 100644
--- a/src/__tests__/transformer.test.ts
+++ b/src/__tests__/transformer.test.ts
@@ -119,3 +119,10 @@ test("multiple transformers", () => {
   });
   expect(doubler.parse("5")).toEqual(10);
 });
+
+test("preprocess", () => {
+  const schema = z.preprocess((data) => [data], z.string().array());
+
+  const value = schema.parse("asdf");
+  expect(value).toEqual(["asdf"]);
+});
diff --git a/src/helpers/partialUtil.ts b/src/helpers/partialUtil.ts
index b6390c937..c71feb774 100644
--- a/src/helpers/partialUtil.ts
+++ b/src/helpers/partialUtil.ts
@@ -1,37 +1,80 @@
-import { ZodObject, ZodOptional, ZodTypeAny } from "../index";
-
-type AnyZodObject = ZodObject<any, any, any>;
+import type {
+  ZodArray,
+  ZodNullable,
+  ZodObject,
+  ZodOptional,
+  ZodTuple,
+  ZodTupleItems,
+  ZodTypeAny,
+} from "../index";
 
 export namespace partialUtil {
-  export type RootDeepPartial<T extends ZodTypeAny> = {
-    // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
-    // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
-    object: T extends AnyZodObject
-      ? ZodObject<
-          { [k in keyof T["_shape"]]: DeepPartial<T["_shape"][k]> },
-          T["_unknownKeys"],
-          T["_catchall"]
-        >
-      : never;
-    rest: ReturnType<T["optional"]>; // ZodOptional<T>;
-  }[T extends AnyZodObject
-    ? "object" // T extends ZodOptional<any> // ? 'optional' // :
-    : "rest"];
+  // export type DeepPartial<T extends AnyZodObject> = T extends AnyZodObject
+  //   ? ZodObject<
+  //       { [k in keyof T["_shape"]]: InternalDeepPartial<T["_shape"][k]> },
+  //       T["_unknownKeys"],
+  //       T["_catchall"]
+  //     >
+  //   : T extends ZodArray<infer Type, infer Card>
+  //   ? ZodArray<InternalDeepPartial<Type>, Card>
+  //   : ZodOptional<T>;
+
+  // {
+  //   // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
+  //   // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
+  //   object: T extends AnyZodObject
+  //     ? ZodObject<
+  //         { [k in keyof T["_shape"]]: DeepPartial<T["_shape"][k]> },
+  //         T["_unknownKeys"],
+  //         T["_catchall"]
+  //       >
+  //     : never;
+  //   rest: ReturnType<T["optional"]>; // ZodOptional<T>;
+  // }[T extends AnyZodObject
+  //   ? "object" // T extends ZodOptional<any> // ? 'optional' // :
+  //   : "rest"];
 
-  export type DeepPartial<T extends ZodTypeAny> = {
-    // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
-    // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
-    object: T extends ZodObject<infer Shape, infer Params, infer Catchall>
-      ? ZodOptional<
-          ZodObject<
-            { [k in keyof Shape]: DeepPartial<Shape[k]> },
-            Params,
-            Catchall
-          >
-        >
-      : never;
-    rest: ReturnType<T["optional"]>;
-  }[T extends ZodObject<any>
-    ? "object" // T extends ZodOptional<any> // ? 'optional' // :
-    : "rest"];
+  export type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<
+    infer Shape,
+    infer Params,
+    infer Catchall
+  >
+    ? ZodObject<
+        { [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>> },
+        Params,
+        Catchall
+      >
+    : T extends ZodArray<infer Type, infer Card>
+    ? ZodArray<DeepPartial<Type>, Card>
+    : T extends ZodOptional<infer Type>
+    ? ZodOptional<DeepPartial<Type>>
+    : T extends ZodNullable<infer Type>
+    ? ZodNullable<DeepPartial<Type>>
+    : T extends ZodTuple<infer Items>
+    ? {
+        [k in keyof Items]: Items[k] extends ZodTypeAny
+          ? DeepPartial<Items[k]>
+          : never;
+      } extends infer PI
+      ? PI extends ZodTupleItems
+        ? ZodTuple<PI>
+        : never
+      : never
+    : T;
+  //  {
+  //     // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
+  //     // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
+  //     object: T extends ZodObject<infer Shape, infer Params, infer Catchall>
+  //       ? ZodOptional<
+  //           ZodObject<
+  //             { [k in keyof Shape]: DeepPartial<Shape[k]> },
+  //             Params,
+  //             Catchall
+  //           >
+  //         >
+  //       : never;
+  //     rest: ReturnType<T["optional"]>;
+  //   }[T extends ZodObject<any>
+  //     ? "object" // T extends ZodOptional<any> // ? 'optional' // :
+  //     : "rest"];
 }
diff --git a/src/types.ts b/src/types.ts
index 890bbb2cd..3283723df 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -314,6 +314,7 @@ type ZodStringCheck =
   | { kind: "email"; message?: string }
   | { kind: "url"; message?: string }
   | { kind: "uuid"; message?: string }
+  | { kind: "cuid"; message?: string }
   | { kind: "regex"; regex: RegExp; message?: string };
 
 export interface ZodStringDef extends ZodTypeDef {
@@ -321,6 +322,7 @@ export interface ZodStringDef extends ZodTypeDef {
   typeName: ZodFirstPartyTypeKind.ZodString;
 }
 
+const cuidRegex = /^c[^\s-]{8,}$/i;
 const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
 // from https://stackoverflow.com/a/46181/1550155
 // old version: too slow, didn't support unicode
@@ -386,6 +388,15 @@ export class ZodString extends ZodType<string, ZodStringDef> {
             message: check.message,
           });
         }
+      } else if (check.kind === "cuid") {
+        if (!cuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: "cuid",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
       } else if (check.kind === "url") {
         try {
           new URL(data);
@@ -450,6 +461,15 @@ export class ZodString extends ZodType<string, ZodStringDef> {
       ],
     });
 
+  cuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        { kind: "cuid", ...errorUtil.errToObj(message) },
+      ],
+    });
+
   regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
     new ZodString({
       ...this._def,
@@ -1373,6 +1393,33 @@ export type SomeZodObject = ZodObject<
   any,
   any
 >;
+
+function deepPartialify(schema: ZodTypeAny): any {
+  if (schema instanceof ZodObject) {
+    const newShape: any = {};
+
+    for (const key in schema.shape) {
+      const fieldSchema = schema.shape[key];
+      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
+    }
+    return new ZodObject({
+      ...schema._def,
+      shape: () => newShape,
+    }) as any;
+  } else if (schema instanceof ZodArray) {
+    return ZodArray.create(deepPartialify(schema.element));
+  } else if (schema instanceof ZodOptional) {
+    return ZodOptional.create(deepPartialify(schema.unwrap()));
+  } else if (schema instanceof ZodNullable) {
+    return ZodNullable.create(deepPartialify(schema.unwrap()));
+  } else if (schema instanceof ZodTuple) {
+    return ZodTuple.create(
+      schema.items.map((item: any) => deepPartialify(item))
+    );
+  } else {
+    return schema;
+  }
+}
 export class ZodObject<
   T extends ZodRawShape,
   UnknownKeys extends UnknownKeysParam = "strip",
@@ -1617,25 +1664,8 @@ export class ZodObject<
     }) as any;
   };
 
-  deepPartial: () => partialUtil.RootDeepPartial<this> = () => {
-    const newShape: any = {};
-
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      if (fieldSchema instanceof ZodObject) {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : (fieldSchema.deepPartial() as any).optional();
-      } else {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : fieldSchema.optional();
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
   };
 
   required = (): ZodObject<
@@ -1900,17 +1930,17 @@ export class ZodIntersection<
 //////////                    //////////
 ////////////////////////////////////////
 ////////////////////////////////////////
-export type OutputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
+export type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
   [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
 };
 
-export type InputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
   [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
 };
 
-export interface ZodTupleDef<
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodTypeDef {
+export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
+  extends ZodTypeDef {
   items: T;
   typeName: ZodFirstPartyTypeKind.ZodTuple;
 }
@@ -2699,6 +2729,7 @@ export interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny>
   extends ZodTypeDef {
   schema: T;
   typeName: ZodFirstPartyTypeKind.ZodEffects;
+  preprocess?: Mod<any>;
   effects?: Effect<any>[];
 }
 
@@ -2712,11 +2743,20 @@ export class ZodEffects<
 
   _parse(
     ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
+    initialData: any,
+    initialParsedType: ZodParsedType
   ): ParseReturnType<Output> {
     const isSync = ctx.params.async === false;
+    const preprocess = this._def.preprocess;
     const effects = this._def.effects || [];
+
+    let data = initialData;
+    let parsedType: ZodParsedType = initialParsedType;
+    if (preprocess) {
+      data = preprocess.transform(initialData);
+      parsedType = getParsedType(data);
+    }
+
     const checkCtx: RefinementCtx = {
       issueFound: false,
       addIssue: function (arg: MakeErrorData) {
@@ -2727,6 +2767,7 @@ export class ZodEffects<
         return pathToArray(ctx.path);
       },
     };
+
     checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
 
     let invalid = false;
@@ -2824,6 +2865,19 @@ export class ZodEffects<
 
     return newTx;
   };
+
+  static createWithPreprocess = <I extends ZodTypeAny>(
+    preprocess: (arg: unknown) => unknown,
+    schema: I
+  ): ZodEffects<I, I["_output"]> => {
+    const newTx = new ZodEffects({
+      schema,
+      preprocess: { type: "transform", transform: preprocess },
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+    });
+
+    return newTx;
+  };
 }
 
 export { ZodEffects as ZodTransformer };
@@ -3068,6 +3122,7 @@ const promiseType = ZodPromise.create;
 const effectsType = ZodEffects.create;
 const optionalType = ZodOptional.create;
 const nullableType = ZodNullable.create;
+const preprocessType = ZodEffects.createWithPreprocess;
 const ostring = () => stringType().optional();
 const onumber = () => numberType().optional();
 const oboolean = () => booleanType().optional();
@@ -3096,6 +3151,7 @@ export {
   onumber,
   optionalType as optional,
   ostring,
+  preprocessType as preprocess,
   promiseType as promise,
   recordType as record,
   setType as set,
