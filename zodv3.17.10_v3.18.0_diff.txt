diff --git a/README.md b/README.md
index bd04f1a5e..52507bd30 100644
--- a/README.md
+++ b/README.md
@@ -47,7 +47,7 @@
   - [Sponsors](#sponsors)
   - [Ecosystem](#ecosystem)
 - [Installation](#installation)
-  - [Node/npm](#Node/npm)
+  - [Node/npm](#nodenpm)
   - [Deno](#deno)
 - [Basic usage](#basic-usage)
 - [Primitives](#primitives)
@@ -90,6 +90,7 @@
 - [Instanceof](#instanceof)
 - [Function schemas](#function-schemas)
 - [Preprocess](#preprocess)
+- [Branded types](#branded-types)
 - [Schema methods](#schema-methods)
   - [.parse](#parse)
   - [.parseAsync](#parseasync)
@@ -227,7 +228,7 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
       <a href="https://seasoned.cc">seasoned.cc</a>
     </td>
     <td align="center">
-      <a href="https://seasoned.cc">
+      <a href="https://interval.com">
         <img src="https://avatars.githubusercontent.com/u/67802063?s=200&v=4" width="150px;" alt="" />
       </a>
       <br />
@@ -284,6 +285,17 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
       <a href="https://adaptable.io/">adaptable.io</a>
       <br />
     </td>
+    <td align="center">
+      <a href="https://www.avanawallet.com/">
+        <img src="https://avatars.githubusercontent.com/u/105452197?s=200&v=4" width="100px;" alt="Avana Wallet logo"/>
+      </a>
+      <br />
+      <b>Avana Wallet</b>
+      <br/>
+      <a href="https://www.avanawallet.com/">avanawallet.com</a><br/>
+      <span>Solana non-custodial wallet</span>
+      <br />
+    </td>
   </tr>
 </table>
 
@@ -316,6 +328,8 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`nestjs-graphql-zod`](https://github.com/incetarik/nestjs-graphql-zod): Generates NestJS GraphQL model classes from Zod schemas dynamically and provides GraphQL method decorators working with Zod schemas.
 - [`zod-xlsx`](https://github.com/sidwebworks/zod-xlsx): A xlsx based resource validator using Zod schemas.
 - [`remix-domains`](https://github.com/SeasonedSoftware/remix-domains/): Improves end-to-end type safety in [Remix](https://remix.run/) by leveraging Zod to parse the framework's inputs such as FormData, URLSearchParams, etc.
+- [`@zodios/core`](https://github.com/ecyrbe/zodios): A typescript API client with runtime and compile time validation backed by axios and zod.
+- [`@runtyping/zod`](https://github.com/johngeorgewright/runtyping/tree/master/packages/zod): Generate zod from static types & JSON schema.
 
 #### Form integrations
 
@@ -576,7 +590,7 @@ z.date().max(new Date(), { message: "Too young!" });
 
 **Supporting date strings**
 
-To write a schema that accepts either a `Date` or a date string, use (`z.preprocess`)[#preprocess].
+To write a schema that accepts either a `Date` or a date string, use [`z.preprocess`](#preprocess).
 
 ```ts
 const dateSchema = z.preprocess((arg) => {
@@ -1452,7 +1466,7 @@ All Zod schemas contain certain methods.
 
 ### `.parse`
 
-`.parse(data:unknown): T`
+`.parse(data: unknown): T`
 
 Given any Zod schema, you can call its `.parse` method to check `data` is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.
 
@@ -1864,6 +1878,47 @@ z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: st
 z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));
 ```
 
+### `.brand`
+
+`.brand<T>() => ZodBranded<this, B>`
+
+TypeScript's type system is structural, which means that any two types that are structurally equivalent are considered the same.
+
+```ts
+type Cat = { name: string };
+type Dog = { name: string };
+
+const petCat = (cat: Cat) => {};
+const fido: Dog = { name: "fido" };
+petCat(fido); // works fine
+```
+
+In some cases, its can be desirable to simulate _nominal typing_ inside TypeScript. For instance, you may wish to write a function that only accepts an input that has been validated by Zod. This can be achieved with _branded types_ (AKA _opaque types_).
+
+```ts
+const Cat = z.object({ name: z.string }).brand<"Cat">();
+type Cat = z.infer<typeof Cat>;
+
+const petCat = (cat: Cat) => {};
+
+// this works
+const simba = Cat.parse({ name: "simba" });
+petCat(simba);
+
+// this doesn't
+petCat({ name: "fido" });
+```
+
+Under the hood, this works by attaching a "brand" to the inferred type using an intersection type. This way, plain/unbranded data structures are no longer assignable to the inferred type of the schema.
+
+```ts
+const Cat = z.object({ name: z.string }).brand<"Cat">();
+type Cat = z.infer<typeof Cat>;
+// {name: string} & {[symbol]: "Cat"}
+```
+
+Note that branded types do not affect the runtime result of `.parse`. It is a static-only construct.
+
 ## Guides and concepts
 
 ### Type inference
diff --git a/README_ZH.md b/README_ZH.md
index 3e02eaf79..81a60cc9d 100644
--- a/README_ZH.md
+++ b/README_ZH.md
@@ -264,6 +264,17 @@ Zod 被设计成对开发者尽可能友好。其目的是消除重复的类型
       <a href="https://adaptable.io/">adaptable.io</a>
       <br />
     </td>
+    <td align="center">
+      <a href="https://www.avanawallet.com/">
+        <img src="https://avatars.githubusercontent.com/u/105452197?s=200&v=4" width="100px;" alt="Avana Wallet logo"/>
+      </a>
+      <br />
+      <b>Avana Wallet</b>
+      <br/>
+      <a href="https://www.avanawallet.com/">avanawallet.com</a><br/>
+      <span>Solana non-custodial wallet</span>
+      <br />
+    </td>
   </tr>
 </table>
 
diff --git a/deno/lib/README.md b/deno/lib/README.md
index bd04f1a5e..52507bd30 100644
--- a/deno/lib/README.md
+++ b/deno/lib/README.md
@@ -47,7 +47,7 @@
   - [Sponsors](#sponsors)
   - [Ecosystem](#ecosystem)
 - [Installation](#installation)
-  - [Node/npm](#Node/npm)
+  - [Node/npm](#nodenpm)
   - [Deno](#deno)
 - [Basic usage](#basic-usage)
 - [Primitives](#primitives)
@@ -90,6 +90,7 @@
 - [Instanceof](#instanceof)
 - [Function schemas](#function-schemas)
 - [Preprocess](#preprocess)
+- [Branded types](#branded-types)
 - [Schema methods](#schema-methods)
   - [.parse](#parse)
   - [.parseAsync](#parseasync)
@@ -227,7 +228,7 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
       <a href="https://seasoned.cc">seasoned.cc</a>
     </td>
     <td align="center">
-      <a href="https://seasoned.cc">
+      <a href="https://interval.com">
         <img src="https://avatars.githubusercontent.com/u/67802063?s=200&v=4" width="150px;" alt="" />
       </a>
       <br />
@@ -284,6 +285,17 @@ Sponsorship at any level is appreciated and encouraged. For individual developer
       <a href="https://adaptable.io/">adaptable.io</a>
       <br />
     </td>
+    <td align="center">
+      <a href="https://www.avanawallet.com/">
+        <img src="https://avatars.githubusercontent.com/u/105452197?s=200&v=4" width="100px;" alt="Avana Wallet logo"/>
+      </a>
+      <br />
+      <b>Avana Wallet</b>
+      <br/>
+      <a href="https://www.avanawallet.com/">avanawallet.com</a><br/>
+      <span>Solana non-custodial wallet</span>
+      <br />
+    </td>
   </tr>
 </table>
 
@@ -316,6 +328,8 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`nestjs-graphql-zod`](https://github.com/incetarik/nestjs-graphql-zod): Generates NestJS GraphQL model classes from Zod schemas dynamically and provides GraphQL method decorators working with Zod schemas.
 - [`zod-xlsx`](https://github.com/sidwebworks/zod-xlsx): A xlsx based resource validator using Zod schemas.
 - [`remix-domains`](https://github.com/SeasonedSoftware/remix-domains/): Improves end-to-end type safety in [Remix](https://remix.run/) by leveraging Zod to parse the framework's inputs such as FormData, URLSearchParams, etc.
+- [`@zodios/core`](https://github.com/ecyrbe/zodios): A typescript API client with runtime and compile time validation backed by axios and zod.
+- [`@runtyping/zod`](https://github.com/johngeorgewright/runtyping/tree/master/packages/zod): Generate zod from static types & JSON schema.
 
 #### Form integrations
 
@@ -576,7 +590,7 @@ z.date().max(new Date(), { message: "Too young!" });
 
 **Supporting date strings**
 
-To write a schema that accepts either a `Date` or a date string, use (`z.preprocess`)[#preprocess].
+To write a schema that accepts either a `Date` or a date string, use [`z.preprocess`](#preprocess).
 
 ```ts
 const dateSchema = z.preprocess((arg) => {
@@ -1452,7 +1466,7 @@ All Zod schemas contain certain methods.
 
 ### `.parse`
 
-`.parse(data:unknown): T`
+`.parse(data: unknown): T`
 
 Given any Zod schema, you can call its `.parse` method to check `data` is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.
 
@@ -1864,6 +1878,47 @@ z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: st
 z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));
 ```
 
+### `.brand`
+
+`.brand<T>() => ZodBranded<this, B>`
+
+TypeScript's type system is structural, which means that any two types that are structurally equivalent are considered the same.
+
+```ts
+type Cat = { name: string };
+type Dog = { name: string };
+
+const petCat = (cat: Cat) => {};
+const fido: Dog = { name: "fido" };
+petCat(fido); // works fine
+```
+
+In some cases, its can be desirable to simulate _nominal typing_ inside TypeScript. For instance, you may wish to write a function that only accepts an input that has been validated by Zod. This can be achieved with _branded types_ (AKA _opaque types_).
+
+```ts
+const Cat = z.object({ name: z.string }).brand<"Cat">();
+type Cat = z.infer<typeof Cat>;
+
+const petCat = (cat: Cat) => {};
+
+// this works
+const simba = Cat.parse({ name: "simba" });
+petCat(simba);
+
+// this doesn't
+petCat({ name: "fido" });
+```
+
+Under the hood, this works by attaching a "brand" to the inferred type using an intersection type. This way, plain/unbranded data structures are no longer assignable to the inferred type of the schema.
+
+```ts
+const Cat = z.object({ name: z.string }).brand<"Cat">();
+type Cat = z.infer<typeof Cat>;
+// {name: string} & {[symbol]: "Cat"}
+```
+
+Note that branded types do not affect the runtime result of `.parse`. It is a static-only construct.
+
 ## Guides and concepts
 
 ### Type inference
diff --git a/deno/lib/__tests__/all-errors.test.ts b/deno/lib/__tests__/all-errors.test.ts
index 1f4a902a7..7e69248ab 100644
--- a/deno/lib/__tests__/all-errors.test.ts
+++ b/deno/lib/__tests__/all-errors.test.ts
@@ -23,15 +23,11 @@ test("default flattened errors type inference", () => {
     fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };
   };
 
-  const t1: util.AssertEqual<
-    z.inferFlattenedErrors<typeof Test>,
-    TestTypeErrors
-  > = true;
-  const t2: util.AssertEqual<
+  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(true);
+  util.assertEqual<
     z.inferFlattenedErrors<typeof Test, { message: string }>,
     TestTypeErrors
-  > = false;
-  [t1, t2];
+  >(false);
 });
 
 test("custom flattened errors type inference", () => {
@@ -43,19 +39,15 @@ test("custom flattened errors type inference", () => {
     };
   };
 
-  const t1: util.AssertEqual<
-    z.inferFlattenedErrors<typeof Test>,
-    TestTypeErrors
-  > = false;
-  const t2: util.AssertEqual<
+  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(false);
+  util.assertEqual<
     z.inferFlattenedErrors<typeof Test, { message: string; code: number }>,
     TestTypeErrors
-  > = true;
-  const t3: util.AssertEqual<
+  >(true);
+  util.assertEqual<
     z.inferFlattenedErrors<typeof Test, { message: string }>,
     TestTypeErrors
-  > = false;
-  [t1, t2, t3];
+  >(false);
 });
 
 test("form errors type inference", () => {
@@ -64,11 +56,7 @@ test("form errors type inference", () => {
     fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };
   };
 
-  const t1: util.AssertEqual<
-    z.inferFlattenedErrors<typeof Test>,
-    TestTypeErrors
-  > = true;
-  [t1];
+  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(true);
 });
 
 test(".flatten() type assertion", () => {
diff --git a/deno/lib/__tests__/anyunknown.test.ts b/deno/lib/__tests__/anyunknown.test.ts
index 8ca24ee7e..439aa8860 100644
--- a/deno/lib/__tests__/anyunknown.test.ts
+++ b/deno/lib/__tests__/anyunknown.test.ts
@@ -10,8 +10,7 @@ test("check any inference", () => {
   t1.optional();
   t1.nullable();
   type t1 = z.infer<typeof t1>;
-  const f1: util.AssertEqual<t1, any> = true;
-  expect(f1).toBeTruthy();
+  util.assertEqual<t1, any>(true);
 });
 
 test("check unknown inference", () => {
@@ -19,8 +18,7 @@ test("check unknown inference", () => {
   t1.optional();
   t1.nullable();
   type t1 = z.infer<typeof t1>;
-  const f1: util.AssertEqual<t1, unknown> = true;
-  expect(f1).toBeTruthy();
+  util.assertEqual<t1, unknown>(true);
 });
 
 test("check never inference", () => {
diff --git a/deno/lib/__tests__/array.test.ts b/deno/lib/__tests__/array.test.ts
index fcf49904e..6fe0f335f 100644
--- a/deno/lib/__tests__/array.test.ts
+++ b/deno/lib/__tests__/array.test.ts
@@ -12,11 +12,10 @@ const intNum = z.string().array().nonempty();
 const nonEmptyMax = z.string().array().nonempty().max(2);
 
 type t1 = z.infer<typeof nonEmptyMax>;
-const f1: util.AssertEqual<[string, ...string[]], t1> = true;
-f1;
+util.assertEqual<[string, ...string[]], t1>(true);
+
 type t2 = z.infer<typeof minTwo>;
-const f2: util.AssertEqual<string[], t2> = true;
-f2;
+util.assertEqual<string[], t2>(true);
 
 test("passing validations", () => {
   minTwo.parse(["a", "a"]);
diff --git a/deno/lib/__tests__/base.test.ts b/deno/lib/__tests__/base.test.ts
index 366c8192d..beda584d7 100644
--- a/deno/lib/__tests__/base.test.ts
+++ b/deno/lib/__tests__/base.test.ts
@@ -13,11 +13,10 @@ test("type guard", () => {
   });
   type t1 = z.input<typeof s1>;
 
-  const data: any = "asdf";
+  const data = { stringToNumber: "asdf" };
   const parsed = s1.safeParse(data);
   if (parsed.success) {
-    const f1: util.AssertEqual<typeof data, t1> = true;
-    f1;
+    util.assertEqual<typeof data, t1>(true);
   }
 });
 
diff --git a/deno/lib/__tests__/branded.test.ts b/deno/lib/__tests__/branded.test.ts
new file mode 100644
index 000000000..56bd8a0bd
--- /dev/null
+++ b/deno/lib/__tests__/branded.test.ts
@@ -0,0 +1,52 @@
+// @ts-ignore TS6133
+import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
+const test = Deno.test;
+
+import { util } from "../helpers/util.ts";
+import * as z from "../index.ts";
+
+test("branded types", () => {
+  const mySchema = z
+    .object({
+      name: z.string(),
+    })
+    .brand<"superschema">();
+
+  // simple branding
+  type MySchema = z.infer<typeof mySchema>;
+  util.assertEqual<
+    MySchema,
+    { name: string } & { [z.BRAND]: { superschema: true } }
+  >(true);
+
+  const doStuff = (arg: MySchema) => arg;
+  doStuff(mySchema.parse({ name: "hello there" }));
+
+  // inheritance
+  const extendedSchema = mySchema.brand<"subschema">();
+  type ExtendedSchema = z.infer<typeof extendedSchema>;
+  util.assertEqual<
+    ExtendedSchema,
+    { name: string } & z.BRAND<"superschema"> & z.BRAND<"subschema">
+  >(true);
+
+  doStuff(extendedSchema.parse({ name: "hello again" }));
+
+  // number branding
+  const numberSchema = z.number().brand<42>();
+  type NumberSchema = z.infer<typeof numberSchema>;
+  util.assertEqual<NumberSchema, number & { [z.BRAND]: { 42: true } }>(true);
+
+  // symbol branding
+  const MyBrand: unique symbol = Symbol("hello");
+  type MyBrand = typeof MyBrand;
+  const symbolBrand = z.number().brand<"sup">().brand<typeof MyBrand>();
+  type SymbolBrand = z.infer<typeof symbolBrand>;
+  // number & { [z.BRAND]: { sup: true, [MyBrand]: true } }
+  util.assertEqual<SymbolBrand, number & z.BRAND<"sup"> & z.BRAND<MyBrand>>(
+    true
+  );
+
+  // @ts-expect-error
+  doStuff({ name: "hello there!" });
+});
diff --git a/deno/lib/__tests__/default.test.ts b/deno/lib/__tests__/default.test.ts
index 84a02eb19..04579a66e 100644
--- a/deno/lib/__tests__/default.test.ts
+++ b/deno/lib/__tests__/default.test.ts
@@ -22,11 +22,9 @@ test("default with transform", () => {
   );
 
   type inp = z.input<typeof stringWithDefault>;
-  const f1: util.AssertEqual<inp, string | undefined> = true;
+  util.assertEqual<inp, string | undefined>(true);
   type out = z.output<typeof stringWithDefault>;
-  const f2: util.AssertEqual<out, string> = true;
-  f1;
-  f2;
+  util.assertEqual<out, string>(true);
 });
 
 test("default on existing optional", () => {
@@ -39,22 +37,18 @@ test("default on existing optional", () => {
   );
 
   type inp = z.input<typeof stringWithDefault>;
-  const f1: util.AssertEqual<inp, string | undefined> = true;
+  util.assertEqual<inp, string | undefined>(true);
   type out = z.output<typeof stringWithDefault>;
-  const f2: util.AssertEqual<out, string> = true;
-  f1;
-  f2;
+  util.assertEqual<out, string>(true);
 });
 
 test("optional on default", () => {
   const stringWithDefault = z.string().default("asdf").optional();
 
   type inp = z.input<typeof stringWithDefault>;
-  const f1: util.AssertEqual<inp, string | undefined> = true;
+  util.assertEqual<inp, string | undefined>(true);
   type out = z.output<typeof stringWithDefault>;
-  const f2: util.AssertEqual<out, string | undefined> = true;
-  f1;
-  f2;
+  util.assertEqual<out, string | undefined>(true);
 });
 
 test("complex chain example", () => {
@@ -74,8 +68,7 @@ test("removeDefault", () => {
   const stringWithRemovedDefault = z.string().default("asdf").removeDefault();
 
   type out = z.output<typeof stringWithRemovedDefault>;
-  const f2: util.AssertEqual<out, string> = true;
-  f2;
+  util.assertEqual<out, string>(true);
 });
 
 test("nested", () => {
@@ -84,14 +77,9 @@ test("nested", () => {
     inner: undefined,
   });
   type input = z.input<typeof outer>;
-  const f1: util.AssertEqual<
-    input,
-    { inner?: string | undefined } | undefined
-  > = true;
+  util.assertEqual<input, { inner?: string | undefined } | undefined>(true);
   type out = z.output<typeof outer>;
-  const f2: util.AssertEqual<out, { inner: string }> = true;
-  f1;
-  f2;
+  util.assertEqual<out, { inner: string }>(true);
   expect(outer.parse(undefined)).toEqual({ inner: "asdf" });
   expect(outer.parse({})).toEqual({ inner: "asdf" });
   expect(outer.parse({ inner: undefined })).toEqual({ inner: "asdf" });
diff --git a/deno/lib/__tests__/enum.test.ts b/deno/lib/__tests__/enum.test.ts
index 21d7db2aa..343e07ee7 100644
--- a/deno/lib/__tests__/enum.test.ts
+++ b/deno/lib/__tests__/enum.test.ts
@@ -15,8 +15,7 @@ test("create enum", () => {
 test("infer enum", () => {
   const MyEnum = z.enum(["Red", "Green", "Blue"]);
   type MyEnum = z.infer<typeof MyEnum>;
-  const t1: util.AssertEqual<MyEnum, "Red" | "Green" | "Blue"> = true;
-  [t1];
+  util.assertEqual<MyEnum, "Red" | "Green" | "Blue">(true);
 });
 
 test("get options", () => {
@@ -27,8 +26,8 @@ test("readonly enum", () => {
   const HTTP_SUCCESS = ["200", "201"] as const;
   const arg = z.enum(HTTP_SUCCESS);
   type arg = z.infer<typeof arg>;
-  const f1: util.AssertEqual<arg, "200" | "201"> = true;
-  f1;
+  util.assertEqual<arg, "200" | "201">(true);
+
   arg.parse("201");
   expect(() => arg.parse("202")).toThrow();
 });
diff --git a/deno/lib/__tests__/firstparty.test.ts b/deno/lib/__tests__/firstparty.test.ts
index 085f4962c..39321571f 100644
--- a/deno/lib/__tests__/firstparty.test.ts
+++ b/deno/lib/__tests__/firstparty.test.ts
@@ -71,6 +71,8 @@ test("first party switch", () => {
       break;
     case z.ZodFirstPartyTypeKind.ZodPromise:
       break;
+    case z.ZodFirstPartyTypeKind.ZodBranded:
+      break;
     default:
       util.assertNever(def);
   }
diff --git a/deno/lib/__tests__/function.test.ts b/deno/lib/__tests__/function.test.ts
index 46aa8aab8..ac522d03d 100644
--- a/deno/lib/__tests__/function.test.ts
+++ b/deno/lib/__tests__/function.test.ts
@@ -32,15 +32,15 @@ test("function inference 1", () => {
 test("args method", () => {
   const t1 = z.function();
   type t1 = z.infer<typeof t1>;
-  util.assertEqual<t1, () => void>(true);
+  util.assertEqual<t1, (...args_1: unknown[]) => unknown>(true);
 
   const t2 = t1.args(z.string());
   type t2 = z.infer<typeof t2>;
-  util.assertEqual<t2, (arg: string) => void>(true);
+  util.assertEqual<t2, (arg: string, ...args_1: unknown[]) => unknown>(true);
 
   const t3 = t2.returns(z.boolean());
   type t3 = z.infer<typeof t3>;
-  util.assertEqual<t3, (arg: string) => boolean>(true);
+  util.assertEqual<t3, (arg: string, ...args_1: unknown[]) => boolean>(true);
 });
 
 const args2 = z.tuple([
@@ -219,7 +219,7 @@ test("inference with transforms", () => {
 
   util.assertEqual<
     typeof myFunc,
-    (arg: string) => { val: number; extra: string }
+    (arg: string, ...args_1: unknown[]) => { val: number; extra: string }
   >(true);
 });
 
@@ -233,5 +233,8 @@ test("fallback to OuterTypeOfFunction", () => {
     return { arg: val, arg2: false };
   });
 
-  util.assertEqual<typeof myFunc, (arg: string) => number>(true);
+  util.assertEqual<
+    typeof myFunc,
+    (arg: string, ...args_1: unknown[]) => number
+  >(true);
 });
diff --git a/deno/lib/__tests__/instanceof.test.ts b/deno/lib/__tests__/instanceof.test.ts
index dda1da47e..3b8428436 100644
--- a/deno/lib/__tests__/instanceof.test.ts
+++ b/deno/lib/__tests__/instanceof.test.ts
@@ -23,8 +23,7 @@ test("instanceof", async () => {
     /Input not instance of Test/
   );
 
-  const f1: util.AssertEqual<Test, z.infer<typeof TestSchema>> = true;
-  expect(f1).toBeTruthy();
+  util.assertEqual<Test, z.infer<typeof TestSchema>>(true);
 });
 
 test("instanceof fatal", () => {
diff --git a/deno/lib/__tests__/map.test.ts b/deno/lib/__tests__/map.test.ts
index a77424364..9a2a6d783 100644
--- a/deno/lib/__tests__/map.test.ts
+++ b/deno/lib/__tests__/map.test.ts
@@ -10,8 +10,7 @@ const stringMap = z.map(z.string(), z.string());
 type stringMap = z.infer<typeof stringMap>;
 
 test("type inference", () => {
-  const f1: util.AssertEqual<stringMap, Map<string, string>> = true;
-  f1;
+  util.assertEqual<stringMap, Map<string, string>>(true);
 });
 
 test("valid parse", () => {
diff --git a/deno/lib/__tests__/nativeEnum.test.ts b/deno/lib/__tests__/nativeEnum.test.ts
index bceedc6df..a8bdea148 100644
--- a/deno/lib/__tests__/nativeEnum.test.ts
+++ b/deno/lib/__tests__/nativeEnum.test.ts
@@ -16,8 +16,7 @@ test("nativeEnum test with consts", () => {
   fruitEnum.parse("banana");
   fruitEnum.parse(Fruits.Apple);
   fruitEnum.parse(Fruits.Banana);
-  const t1: util.AssertEqual<fruitEnum, "apple" | "banana"> = true;
-  [t1];
+  util.assertEqual<fruitEnum, "apple" | "banana">(true);
 });
 
 test("nativeEnum test with real enum", () => {
@@ -32,8 +31,7 @@ test("nativeEnum test with real enum", () => {
   fruitEnum.parse("banana");
   fruitEnum.parse(Fruits.Apple);
   fruitEnum.parse(Fruits.Banana);
-  const t1: util.AssertEqual<fruitEnum, Fruits> = true;
-  [t1];
+  util.assertIs<fruitEnum extends Fruits ? true : false>(true);
 });
 
 test("nativeEnum test with const with numeric keys", () => {
@@ -48,8 +46,7 @@ test("nativeEnum test with const with numeric keys", () => {
   fruitEnum.parse(20);
   fruitEnum.parse(FruitValues.Apple);
   fruitEnum.parse(FruitValues.Banana);
-  const t1: util.AssertEqual<fruitEnum, 10 | 20> = true;
-  [t1];
+  util.assertEqual<fruitEnum, 10 | 20>(true);
 });
 
 test("from enum", () => {
diff --git a/deno/lib/__tests__/object.test.ts b/deno/lib/__tests__/object.test.ts
index b43efccb2..6b32541c9 100644
--- a/deno/lib/__tests__/object.test.ts
+++ b/deno/lib/__tests__/object.test.ts
@@ -21,8 +21,7 @@ test("object type inference", () => {
     f4: { t: string | boolean }[];
   };
 
-  const t1: util.AssertEqual<z.TypeOf<typeof Test>, TestType> = true;
-  [t1];
+  util.assertEqual<z.TypeOf<typeof Test>, TestType>(true);
 });
 
 test("unknown throw", () => {
@@ -112,10 +111,8 @@ test("catchall inference", () => {
     .catchall(z.number());
 
   const d1 = o1.parse({ first: "asdf", num: 1243 });
-  const f1: util.AssertEqual<number, typeof d1["asdf"]> = true;
-  const f2: util.AssertEqual<string, typeof d1["first"]> = true;
-  f1;
-  f2;
+  util.assertEqual<number, typeof d1["asdf"]>(true);
+  util.assertEqual<string, typeof d1["first"]>(true);
 });
 
 test("catchall overrides strict", () => {
@@ -212,8 +209,7 @@ test("test async union", async () => {
 test("test inferred merged type", async () => {
   const asdf = z.object({ a: z.string() }).merge(z.object({ a: z.number() }));
   type asdf = z.infer<typeof asdf>;
-  const f1: util.AssertEqual<asdf, { a: number }> = true;
-  f1;
+  util.assertEqual<asdf, { a: number }>(true);
 });
 
 test("inferred merged object type with optional properties", async () => {
@@ -221,8 +217,7 @@ test("inferred merged object type with optional properties", async () => {
     .object({ a: z.string(), b: z.string().optional() })
     .merge(z.object({ a: z.string().optional(), b: z.string() }));
   type Merged = z.infer<typeof Merged>;
-  const f1: util.AssertEqual<Merged, { a?: string; b: string }> = true;
-  f1;
+  util.assertEqual<Merged, { a?: string; b: string }>(true);
 });
 
 test("inferred unioned object type with optional properties", async () => {
@@ -231,11 +226,10 @@ test("inferred unioned object type with optional properties", async () => {
     z.object({ a: z.string().optional(), b: z.string() }),
   ]);
   type Unioned = z.infer<typeof Unioned>;
-  const f1: util.AssertEqual<
+  util.assertEqual<
     Unioned,
     { a: string; b?: string } | { a?: string; b: string }
-  > = true;
-  f1;
+  >(true);
 });
 
 test("inferred enum type", async () => {
@@ -251,8 +245,7 @@ test("inferred enum type", async () => {
   });
   expect(Enum._def.values).toEqual(["a", "b"]);
   type Enum = z.infer<typeof Enum>;
-  const f1: util.AssertEqual<Enum, "a" | "b"> = true;
-  f1;
+  util.assertEqual<Enum, "a" | "b">(true);
 });
 
 test("inferred partial object type with optional properties", async () => {
@@ -260,8 +253,7 @@ test("inferred partial object type with optional properties", async () => {
     .object({ a: z.string(), b: z.string().optional() })
     .partial();
   type Partial = z.infer<typeof Partial>;
-  const f1: util.AssertEqual<Partial, { a?: string; b?: string }> = true;
-  f1;
+  util.assertEqual<Partial, { a?: string; b?: string }>(true);
 });
 
 test("inferred picked object type with optional properties", async () => {
@@ -269,8 +261,7 @@ test("inferred picked object type with optional properties", async () => {
     .object({ a: z.string(), b: z.string().optional() })
     .pick({ b: true });
   type Picked = z.infer<typeof Picked>;
-  const f1: util.AssertEqual<Picked, { b?: string }> = true;
-  f1;
+  util.assertEqual<Picked, { b?: string }>(true);
 });
 
 test("inferred type for unknown/any keys", () => {
@@ -281,7 +272,7 @@ test("inferred type for unknown/any keys", () => {
     unknownRequired: z.unknown(),
   });
   type myType = z.infer<typeof myType>;
-  const _f1: util.AssertEqual<
+  util.assertEqual<
     myType,
     {
       anyOptional?: any;
@@ -289,8 +280,7 @@ test("inferred type for unknown/any keys", () => {
       unknownOptional?: unknown;
       unknownRequired?: unknown;
     }
-  > = true;
-  _f1;
+  >(true);
 });
 
 test("setKey", () => {
@@ -298,8 +288,7 @@ test("setKey", () => {
   const withNewKey = base.setKey("age", z.number());
 
   type withNewKey = z.infer<typeof withNewKey>;
-  const _t1: util.AssertEqual<withNewKey, { name: string; age: number }> = true;
-  _t1;
+  util.assertEqual<withNewKey, { name: string; age: number }>(true);
   withNewKey.parse({ name: "asdf", age: 1234 });
 });
 
@@ -374,6 +363,5 @@ test("constructor key", () => {
   });
 
   type Example = z.infer<typeof Example>;
-  const f1: util.AssertEqual<keyof Example, "prop" | "opt" | "arr"> = true;
-  f1;
+  util.assertEqual<keyof Example, "prop" | "opt" | "arr">(true);
 });
diff --git a/deno/lib/__tests__/partials.test.ts b/deno/lib/__tests__/partials.test.ts
index 8646d82e3..95983ad70 100644
--- a/deno/lib/__tests__/partials.test.ts
+++ b/deno/lib/__tests__/partials.test.ts
@@ -24,8 +24,7 @@ test("shallow inference", () => {
     outer?: { inner: string } | undefined;
     array?: { asdf: string }[];
   };
-  const t1: util.AssertEqual<shallow, correct> = true;
-  t1;
+  util.assertEqual<shallow, correct>(true);
 });
 
 test("shallow partial parse", () => {
@@ -49,8 +48,7 @@ test("deep partial inference", () => {
     outer?: { inner?: string | undefined } | undefined;
   };
 
-  const t1: util.AssertEqual<deep, correct> = true;
-  t1;
+  util.assertEqual<deep, correct>(true);
 });
 
 test("deep partial parse", () => {
@@ -130,8 +128,7 @@ test("deep partial inference", () => {
       | undefined;
     tuple?: [{ value?: string }] | undefined;
   };
-  const f1: util.AssertEqual<expected, partialed> = true;
-  f1;
+  util.assertEqual<expected, partialed>(true);
 });
 
 test("required", () => {
diff --git a/deno/lib/__tests__/pickomit.test.ts b/deno/lib/__tests__/pickomit.test.ts
index fe4b54147..f19129995 100644
--- a/deno/lib/__tests__/pickomit.test.ts
+++ b/deno/lib/__tests__/pickomit.test.ts
@@ -14,8 +14,7 @@ const fish = z.object({
 test("pick type inference", () => {
   const nameonlyFish = fish.pick({ name: true });
   type nameonlyFish = z.infer<typeof nameonlyFish>;
-  const f1: util.AssertEqual<nameonlyFish, { name: string }> = true;
-  f1;
+  util.assertEqual<nameonlyFish, { name: string }>(true);
 });
 
 test("pick parse - success", () => {
@@ -41,8 +40,7 @@ test("pick parse - fail", () => {
 test("omit type inference", () => {
   const nonameFish = fish.omit({ name: true });
   type nonameFish = z.infer<typeof nonameFish>;
-  const f1: util.AssertEqual<nonameFish, { age: number; nested: {} }> = true;
-  f1;
+  util.assertEqual<nonameFish, { age: number; nested: {} }>(true);
 });
 
 test("omit parse - success", () => {
@@ -62,11 +60,9 @@ test("omit parse - fail", () => {
 });
 
 test("nonstrict inference", () => {
-  const laxfish = fish.nonstrict().pick({ name: true });
+  const laxfish = fish.pick({ name: true }).catchall(z.any());
   type laxfish = z.infer<typeof laxfish>;
-  const f1: util.AssertEqual<laxfish, { [k: string]: any; name: string }> =
-    true;
-  f1;
+  util.assertEqual<laxfish, { [k: string]: any; name: string }>(true);
 });
 
 test("nonstrict parsing - pass", () => {
diff --git a/deno/lib/__tests__/promise.test.ts b/deno/lib/__tests__/promise.test.ts
index a354d9b7c..3bc288a01 100644
--- a/deno/lib/__tests__/promise.test.ts
+++ b/deno/lib/__tests__/promise.test.ts
@@ -14,11 +14,9 @@ const promSchema = z.promise(
 
 test("promise inference", () => {
   type promSchemaType = z.infer<typeof promSchema>;
-  const t1: util.AssertEqual<
-    promSchemaType,
-    Promise<{ name: string; age: number }>
-  > = true;
-  expect(t1).toBeTruthy();
+  util.assertEqual<promSchemaType, Promise<{ name: string; age: number }>>(
+    true
+  );
 });
 
 test("promise parsing success", async () => {
diff --git a/deno/lib/__tests__/record.test.ts b/deno/lib/__tests__/record.test.ts
index 29a965791..b79d97c20 100644
--- a/deno/lib/__tests__/record.test.ts
+++ b/deno/lib/__tests__/record.test.ts
@@ -18,19 +18,17 @@ const recordWithLiteralKeys = z.record(
 type recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;
 
 test("type inference", () => {
-  const f1: util.AssertEqual<booleanRecord, Record<string, boolean>> = true;
-  f1;
+  util.assertEqual<booleanRecord, Record<string, boolean>>(true);
 
-  const f2: util.AssertEqual<
+  util.assertEqual<
     recordWithEnumKeys,
     Partial<Record<"Tuna" | "Salmon", string>>
-  > = true;
-  f2;
-  const f3: util.AssertEqual<
+  >(true);
+
+  util.assertEqual<
     recordWithLiteralKeys,
     Partial<Record<"Tuna" | "Salmon", string>>
-  > = true;
-  f3;
+  >(true);
 });
 
 test("methods", () => {
diff --git a/deno/lib/__tests__/refine.test.ts b/deno/lib/__tests__/refine.test.ts
index c85f94201..b5e83c27f 100644
--- a/deno/lib/__tests__/refine.test.ts
+++ b/deno/lib/__tests__/refine.test.ts
@@ -56,10 +56,8 @@ test("refinement type guard", () => {
   });
   type Schema = z.infer<typeof validationSchema>;
 
-  const f1: util.AssertEqual<"a", Schema["a"]> = true;
-  f1;
-  const f2: util.AssertEqual<"string", Schema["a"]> = false;
-  f2;
+  util.assertEqual<"a", Schema["a"]>(true);
+  util.assertEqual<"string", Schema["a"]>(false);
 });
 
 test("refinement Promise", async () => {
diff --git a/deno/lib/__tests__/set.test.ts b/deno/lib/__tests__/set.test.ts
index 24417a3e5..0626bac94 100644
--- a/deno/lib/__tests__/set.test.ts
+++ b/deno/lib/__tests__/set.test.ts
@@ -16,8 +16,7 @@ const nonEmpty = z.set(z.string()).nonempty();
 const nonEmptyMax = z.set(z.string()).nonempty().max(2);
 
 test("type inference", () => {
-  const f1: util.AssertEqual<stringSet, Set<string>> = true;
-  f1;
+  util.assertEqual<stringSet, Set<string>>(true);
 });
 
 test("valid parse", () => {
diff --git a/deno/lib/__tests__/transformer.test.ts b/deno/lib/__tests__/transformer.test.ts
index bb513b117..db1e72d00 100644
--- a/deno/lib/__tests__/transformer.test.ts
+++ b/deno/lib/__tests__/transformer.test.ts
@@ -159,10 +159,8 @@ test("object typing", () => {
   type t1 = z.input<typeof t1>;
   type t2 = z.output<typeof t1>;
 
-  const f1: util.AssertEqual<t1, { stringToNumber: string }> = true;
-  const f2: util.AssertEqual<t2, { stringToNumber: number }> = true;
-  f1;
-  f2;
+  util.assertEqual<t1, { stringToNumber: string }>(true);
+  util.assertEqual<t2, { stringToNumber: number }>(true);
 });
 
 test("transform method overloads", () => {
diff --git a/deno/lib/__tests__/tuple.test.ts b/deno/lib/__tests__/tuple.test.ts
index ad9c97bee..2271df9d9 100644
--- a/deno/lib/__tests__/tuple.test.ts
+++ b/deno/lib/__tests__/tuple.test.ts
@@ -19,8 +19,7 @@ test("tuple inference", () => {
   const returns1 = z.number();
   const func1 = z.function(args1, returns1);
   type func1 = z.TypeOf<typeof func1>;
-  const t1: util.AssertEqual<func1, (k: string) => number> = true;
-  [t1];
+  util.assertEqual<func1, (k: string) => number>(true);
 });
 
 test("successful validation", () => {
@@ -66,12 +65,10 @@ test("tuple with transformers", () => {
   const val = z.tuple([stringToNumber]);
 
   type t1 = z.input<typeof val>;
-  const f1: util.AssertEqual<t1, [string]> = true;
+  util.assertEqual<t1, [string]>(true);
   type t2 = z.output<typeof val>;
-  const f2: util.AssertEqual<t2, [number]> = true;
+  util.assertEqual<t2, [number]>(true);
   expect(val.parse(["1234"])).toEqual([4]);
-  f1;
-  f2;
 });
 
 test("tuple with rest schema", () => {
@@ -89,8 +86,7 @@ test("tuple with rest schema", () => {
   expect(() => myTuple.parse(["asdf", 1234, "asdf"])).toThrow();
   type t1 = z.output<typeof myTuple>;
 
-  const f1: util.AssertEqual<t1, [string, number, ...boolean[]]> = true;
-  f1;
+  util.assertEqual<t1, [string, number, ...boolean[]]>(true);
 });
 
 // test('tuple with optional elements', () => {
diff --git a/deno/lib/__tests__/void.test.ts b/deno/lib/__tests__/void.test.ts
index c6dadec17..d6e5eeed1 100644
--- a/deno/lib/__tests__/void.test.ts
+++ b/deno/lib/__tests__/void.test.ts
@@ -12,6 +12,5 @@ test("void", () => {
   expect(() => v.parse("")).toThrow();
 
   type v = z.infer<typeof v>;
-  const t1: util.AssertEqual<v, void> = true;
-  t1;
+  util.assertEqual<v, void>(true);
 });
diff --git a/deno/lib/helpers/util.ts b/deno/lib/helpers/util.ts
index dc00e94e6..0fb14668e 100644
--- a/deno/lib/helpers/util.ts
+++ b/deno/lib/helpers/util.ts
@@ -1,11 +1,12 @@
 export namespace util {
-  export type AssertEqual<T, Expected> = [T] extends [Expected]
-    ? [Expected] extends [T]
-      ? true
-      : false
+  type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <
+    V
+  >() => V extends U ? 1 : 2
+    ? true
     : false;
-  export function assertEqual<A, B>(_cond: AssertEqual<A, B>) {}
 
+  export const assertEqual = <A, B>(val: AssertEqual<A, B>) => val;
+  export function assertIs<T>(_arg: T): void {}
   export function assertNever(_x: never): never {
     throw new Error();
   }
@@ -66,7 +67,7 @@ export namespace util {
   };
 
   export type identity<T> = T;
-  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
+  export type flatten<T> = identity<{ [k in keyof T]: T[k] }>;
   export type noUndefined<T> = T extends undefined ? never : T;
 
   export const isInteger: NumberConstructor["isInteger"] =
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 4fb3c0c3a..69b5a60d2 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -420,6 +420,14 @@ export abstract class ZodType<
     }) as any;
   }
 
+  brand<B extends string | number | symbol>(): ZodBranded<this, B> {
+    return new ZodBranded({
+      typeName: ZodFirstPartyTypeKind.ZodBranded,
+      type: this,
+      ...processCreateParams(undefined),
+    });
+  }
+
   describe(description: string): this {
     const This = (this as any).constructor;
     return new This({
@@ -1637,9 +1645,6 @@ export class ZodObject<
   Output = objectOutputType<T, Catchall>,
   Input = objectInputType<T, Catchall>
 > extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
-  readonly _shape!: T;
-  readonly _unknownKeys!: UnknownKeys;
-  readonly _catchall!: Catchall;
   private _cached: { shape: T; keys: string[] } | null = null;
 
   _getCached(): { shape: T; keys: string[] } {
@@ -1813,7 +1818,11 @@ export class ZodObject<
   merge<Incoming extends AnyZodObject>(
     merging: Incoming
   ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
-  ZodObject<extendShape<T, Incoming["_shape"]>, UnknownKeys, Catchall> {
+  ZodObject<
+    extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
+    UnknownKeys,
+    Catchall
+  > {
     // const mergedShape = objectUtil.mergeShapes(
     //   this._def.shape(),
     //   merging._def.shape()
@@ -3681,13 +3690,13 @@ export class ZodDefault<T extends ZodTypeAny> extends ZodType<
   };
 }
 
-/////////////////////////////////////////
-/////////////////////////////////////////
-//////////                     //////////
-//////////      ZodNaN         //////////
-//////////                     //////////
-/////////////////////////////////////////
-/////////////////////////////////////////
+//////////////////////////////////////
+//////////////////////////////////////
+//////////                  //////////
+//////////      ZodNaN      //////////
+//////////                  //////////
+//////////////////////////////////////
+//////////////////////////////////////
 
 export interface ZodNaNDef extends ZodTypeDef {
   typeName: ZodFirstPartyTypeKind.ZodNaN;
@@ -3717,6 +3726,47 @@ export class ZodNaN extends ZodType<number, ZodNaNDef> {
   };
 }
 
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////                      //////////
+//////////      ZodBranded      //////////
+//////////                      //////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+
+export interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {
+  type: T;
+  typeName: ZodFirstPartyTypeKind.ZodBranded;
+}
+
+export const BRAND: unique symbol = Symbol("zod_brand");
+export type BRAND<T extends string | number | symbol> = {
+  [BRAND]: { [k in T]: true };
+};
+
+export class ZodBranded<
+  T extends ZodTypeAny,
+  B extends string | number | symbol
+> extends ZodType<
+  T["_output"] & BRAND<B>,
+  ZodBrandedDef<T>,
+  T["_input"] & BRAND<B>
+> {
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { ctx } = this._processInputParams(input);
+    const data = ctx.data;
+    return this._def.type._parse({
+      data,
+      path: ctx.path,
+      parent: ctx,
+    });
+  }
+
+  unwrap() {
+    return this._def.type;
+  }
+}
+
 export const custom = <T>(
   check?: (data: unknown) => any,
   params: Parameters<ZodTypeAny["refine"]>[1] = {},
@@ -3771,6 +3821,7 @@ export enum ZodFirstPartyTypeKind {
   ZodNullable = "ZodNullable",
   ZodDefault = "ZodDefault",
   ZodPromise = "ZodPromise",
+  ZodBranded = "ZodBranded",
 }
 export type ZodFirstPartySchemaTypes =
   | ZodString
@@ -3803,7 +3854,8 @@ export type ZodFirstPartySchemaTypes =
   | ZodOptional<any>
   | ZodNullable<any>
   | ZodDefault<any>
-  | ZodPromise<any>;
+  | ZodPromise<any>
+  | ZodBranded<any, any>;
 
 const instanceOfType = <T extends new (...args: any[]) => any>(
   cls: T,
diff --git a/package.json b/package.json
index 7a73c3557..e17ea2922 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.17.10",
+  "version": "3.18.0",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./index.d.ts",
@@ -59,7 +59,7 @@
     "test": "jest --coverage",
     "test:deno": "cd deno && deno test",
     "prepublishOnly": "npm run test && npm run build && npm run build:deno",
-    "play": "nodemon -e ts -w . -x esr src/playground.ts",
+    "play": "nodemon -e ts -w . -x tsx src/playground.ts",
     "depcruise": "depcruise -c .dependency-cruiser.js src",
     "benchmark": "esr src/benchmarks/index.ts",
     "prepare": "husky install"
@@ -73,8 +73,6 @@
     "@typescript-eslint/parser": "^5.15.0",
     "benchmark": "^2.1.4",
     "dependency-cruiser": "^9.19.0",
-    "esbuild": "^0.14.49",
-    "esbuild-runner": "^2.2.1",
     "eslint": "^8.11.0",
     "eslint-config-prettier": "^8.5.0",
     "eslint-plugin-ban": "^1.6.0",
@@ -91,6 +89,7 @@
     "ts-jest": "^27.1.3",
     "ts-morph": "^14.0.0",
     "tslib": "^2.3.1",
+    "tsx": "^3.8.0",
     "typescript": "4.1"
   },
   "lint-staged": {
diff --git a/src/__tests__/all-errors.test.ts b/src/__tests__/all-errors.test.ts
index 4b91178a5..7b5999b42 100644
--- a/src/__tests__/all-errors.test.ts
+++ b/src/__tests__/all-errors.test.ts
@@ -22,15 +22,11 @@ test("default flattened errors type inference", () => {
     fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };
   };
 
-  const t1: util.AssertEqual<
-    z.inferFlattenedErrors<typeof Test>,
-    TestTypeErrors
-  > = true;
-  const t2: util.AssertEqual<
+  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(true);
+  util.assertEqual<
     z.inferFlattenedErrors<typeof Test, { message: string }>,
     TestTypeErrors
-  > = false;
-  [t1, t2];
+  >(false);
 });
 
 test("custom flattened errors type inference", () => {
@@ -42,19 +38,15 @@ test("custom flattened errors type inference", () => {
     };
   };
 
-  const t1: util.AssertEqual<
-    z.inferFlattenedErrors<typeof Test>,
-    TestTypeErrors
-  > = false;
-  const t2: util.AssertEqual<
+  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(false);
+  util.assertEqual<
     z.inferFlattenedErrors<typeof Test, { message: string; code: number }>,
     TestTypeErrors
-  > = true;
-  const t3: util.AssertEqual<
+  >(true);
+  util.assertEqual<
     z.inferFlattenedErrors<typeof Test, { message: string }>,
     TestTypeErrors
-  > = false;
-  [t1, t2, t3];
+  >(false);
 });
 
 test("form errors type inference", () => {
@@ -63,11 +55,7 @@ test("form errors type inference", () => {
     fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };
   };
 
-  const t1: util.AssertEqual<
-    z.inferFlattenedErrors<typeof Test>,
-    TestTypeErrors
-  > = true;
-  [t1];
+  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(true);
 });
 
 test(".flatten() type assertion", () => {
diff --git a/src/__tests__/anyunknown.test.ts b/src/__tests__/anyunknown.test.ts
index 6e27bd001..59880f328 100644
--- a/src/__tests__/anyunknown.test.ts
+++ b/src/__tests__/anyunknown.test.ts
@@ -9,8 +9,7 @@ test("check any inference", () => {
   t1.optional();
   t1.nullable();
   type t1 = z.infer<typeof t1>;
-  const f1: util.AssertEqual<t1, any> = true;
-  expect(f1).toBeTruthy();
+  util.assertEqual<t1, any>(true);
 });
 
 test("check unknown inference", () => {
@@ -18,8 +17,7 @@ test("check unknown inference", () => {
   t1.optional();
   t1.nullable();
   type t1 = z.infer<typeof t1>;
-  const f1: util.AssertEqual<t1, unknown> = true;
-  expect(f1).toBeTruthy();
+  util.assertEqual<t1, unknown>(true);
 });
 
 test("check never inference", () => {
diff --git a/src/__tests__/array.test.ts b/src/__tests__/array.test.ts
index 92986ed23..00ae06618 100644
--- a/src/__tests__/array.test.ts
+++ b/src/__tests__/array.test.ts
@@ -11,11 +11,10 @@ const intNum = z.string().array().nonempty();
 const nonEmptyMax = z.string().array().nonempty().max(2);
 
 type t1 = z.infer<typeof nonEmptyMax>;
-const f1: util.AssertEqual<[string, ...string[]], t1> = true;
-f1;
+util.assertEqual<[string, ...string[]], t1>(true);
+
 type t2 = z.infer<typeof minTwo>;
-const f2: util.AssertEqual<string[], t2> = true;
-f2;
+util.assertEqual<string[], t2>(true);
 
 test("passing validations", () => {
   minTwo.parse(["a", "a"]);
diff --git a/src/__tests__/base.test.ts b/src/__tests__/base.test.ts
index 85b4a2ba0..9c5eeac6b 100644
--- a/src/__tests__/base.test.ts
+++ b/src/__tests__/base.test.ts
@@ -12,11 +12,10 @@ test("type guard", () => {
   });
   type t1 = z.input<typeof s1>;
 
-  const data: any = "asdf";
+  const data = { stringToNumber: "asdf" };
   const parsed = s1.safeParse(data);
   if (parsed.success) {
-    const f1: util.AssertEqual<typeof data, t1> = true;
-    f1;
+    util.assertEqual<typeof data, t1>(true);
   }
 });
 
diff --git a/src/__tests__/branded.test.ts b/src/__tests__/branded.test.ts
new file mode 100644
index 000000000..3e7fe4d66
--- /dev/null
+++ b/src/__tests__/branded.test.ts
@@ -0,0 +1,51 @@
+// @ts-ignore TS6133
+import { expect, test } from "@jest/globals";
+
+import { util } from "../helpers/util";
+import * as z from "../index";
+
+test("branded types", () => {
+  const mySchema = z
+    .object({
+      name: z.string(),
+    })
+    .brand<"superschema">();
+
+  // simple branding
+  type MySchema = z.infer<typeof mySchema>;
+  util.assertEqual<
+    MySchema,
+    { name: string } & { [z.BRAND]: { superschema: true } }
+  >(true);
+
+  const doStuff = (arg: MySchema) => arg;
+  doStuff(mySchema.parse({ name: "hello there" }));
+
+  // inheritance
+  const extendedSchema = mySchema.brand<"subschema">();
+  type ExtendedSchema = z.infer<typeof extendedSchema>;
+  util.assertEqual<
+    ExtendedSchema,
+    { name: string } & z.BRAND<"superschema"> & z.BRAND<"subschema">
+  >(true);
+
+  doStuff(extendedSchema.parse({ name: "hello again" }));
+
+  // number branding
+  const numberSchema = z.number().brand<42>();
+  type NumberSchema = z.infer<typeof numberSchema>;
+  util.assertEqual<NumberSchema, number & { [z.BRAND]: { 42: true } }>(true);
+
+  // symbol branding
+  const MyBrand: unique symbol = Symbol("hello");
+  type MyBrand = typeof MyBrand;
+  const symbolBrand = z.number().brand<"sup">().brand<typeof MyBrand>();
+  type SymbolBrand = z.infer<typeof symbolBrand>;
+  // number & { [z.BRAND]: { sup: true, [MyBrand]: true } }
+  util.assertEqual<SymbolBrand, number & z.BRAND<"sup"> & z.BRAND<MyBrand>>(
+    true
+  );
+
+  // @ts-expect-error
+  doStuff({ name: "hello there!" });
+});
diff --git a/src/__tests__/default.test.ts b/src/__tests__/default.test.ts
index 7867f21d7..b3fa33eba 100644
--- a/src/__tests__/default.test.ts
+++ b/src/__tests__/default.test.ts
@@ -21,11 +21,9 @@ test("default with transform", () => {
   );
 
   type inp = z.input<typeof stringWithDefault>;
-  const f1: util.AssertEqual<inp, string | undefined> = true;
+  util.assertEqual<inp, string | undefined>(true);
   type out = z.output<typeof stringWithDefault>;
-  const f2: util.AssertEqual<out, string> = true;
-  f1;
-  f2;
+  util.assertEqual<out, string>(true);
 });
 
 test("default on existing optional", () => {
@@ -38,22 +36,18 @@ test("default on existing optional", () => {
   );
 
   type inp = z.input<typeof stringWithDefault>;
-  const f1: util.AssertEqual<inp, string | undefined> = true;
+  util.assertEqual<inp, string | undefined>(true);
   type out = z.output<typeof stringWithDefault>;
-  const f2: util.AssertEqual<out, string> = true;
-  f1;
-  f2;
+  util.assertEqual<out, string>(true);
 });
 
 test("optional on default", () => {
   const stringWithDefault = z.string().default("asdf").optional();
 
   type inp = z.input<typeof stringWithDefault>;
-  const f1: util.AssertEqual<inp, string | undefined> = true;
+  util.assertEqual<inp, string | undefined>(true);
   type out = z.output<typeof stringWithDefault>;
-  const f2: util.AssertEqual<out, string | undefined> = true;
-  f1;
-  f2;
+  util.assertEqual<out, string | undefined>(true);
 });
 
 test("complex chain example", () => {
@@ -73,8 +67,7 @@ test("removeDefault", () => {
   const stringWithRemovedDefault = z.string().default("asdf").removeDefault();
 
   type out = z.output<typeof stringWithRemovedDefault>;
-  const f2: util.AssertEqual<out, string> = true;
-  f2;
+  util.assertEqual<out, string>(true);
 });
 
 test("nested", () => {
@@ -83,14 +76,9 @@ test("nested", () => {
     inner: undefined,
   });
   type input = z.input<typeof outer>;
-  const f1: util.AssertEqual<
-    input,
-    { inner?: string | undefined } | undefined
-  > = true;
+  util.assertEqual<input, { inner?: string | undefined } | undefined>(true);
   type out = z.output<typeof outer>;
-  const f2: util.AssertEqual<out, { inner: string }> = true;
-  f1;
-  f2;
+  util.assertEqual<out, { inner: string }>(true);
   expect(outer.parse(undefined)).toEqual({ inner: "asdf" });
   expect(outer.parse({})).toEqual({ inner: "asdf" });
   expect(outer.parse({ inner: undefined })).toEqual({ inner: "asdf" });
diff --git a/src/__tests__/enum.test.ts b/src/__tests__/enum.test.ts
index e9adbbf49..79d925bbd 100644
--- a/src/__tests__/enum.test.ts
+++ b/src/__tests__/enum.test.ts
@@ -14,8 +14,7 @@ test("create enum", () => {
 test("infer enum", () => {
   const MyEnum = z.enum(["Red", "Green", "Blue"]);
   type MyEnum = z.infer<typeof MyEnum>;
-  const t1: util.AssertEqual<MyEnum, "Red" | "Green" | "Blue"> = true;
-  [t1];
+  util.assertEqual<MyEnum, "Red" | "Green" | "Blue">(true);
 });
 
 test("get options", () => {
@@ -26,8 +25,8 @@ test("readonly enum", () => {
   const HTTP_SUCCESS = ["200", "201"] as const;
   const arg = z.enum(HTTP_SUCCESS);
   type arg = z.infer<typeof arg>;
-  const f1: util.AssertEqual<arg, "200" | "201"> = true;
-  f1;
+  util.assertEqual<arg, "200" | "201">(true);
+
   arg.parse("201");
   expect(() => arg.parse("202")).toThrow();
 });
diff --git a/src/__tests__/firstparty.test.ts b/src/__tests__/firstparty.test.ts
index 6ae872ed1..34932de82 100644
--- a/src/__tests__/firstparty.test.ts
+++ b/src/__tests__/firstparty.test.ts
@@ -70,6 +70,8 @@ test("first party switch", () => {
       break;
     case z.ZodFirstPartyTypeKind.ZodPromise:
       break;
+    case z.ZodFirstPartyTypeKind.ZodBranded:
+      break;
     default:
       util.assertNever(def);
   }
diff --git a/src/__tests__/function.test.ts b/src/__tests__/function.test.ts
index c50ab6504..8010f3de1 100644
--- a/src/__tests__/function.test.ts
+++ b/src/__tests__/function.test.ts
@@ -31,15 +31,15 @@ test("function inference 1", () => {
 test("args method", () => {
   const t1 = z.function();
   type t1 = z.infer<typeof t1>;
-  util.assertEqual<t1, () => void>(true);
+  util.assertEqual<t1, (...args_1: unknown[]) => unknown>(true);
 
   const t2 = t1.args(z.string());
   type t2 = z.infer<typeof t2>;
-  util.assertEqual<t2, (arg: string) => void>(true);
+  util.assertEqual<t2, (arg: string, ...args_1: unknown[]) => unknown>(true);
 
   const t3 = t2.returns(z.boolean());
   type t3 = z.infer<typeof t3>;
-  util.assertEqual<t3, (arg: string) => boolean>(true);
+  util.assertEqual<t3, (arg: string, ...args_1: unknown[]) => boolean>(true);
 });
 
 const args2 = z.tuple([
@@ -218,7 +218,7 @@ test("inference with transforms", () => {
 
   util.assertEqual<
     typeof myFunc,
-    (arg: string) => { val: number; extra: string }
+    (arg: string, ...args_1: unknown[]) => { val: number; extra: string }
   >(true);
 });
 
@@ -232,5 +232,8 @@ test("fallback to OuterTypeOfFunction", () => {
     return { arg: val, arg2: false };
   });
 
-  util.assertEqual<typeof myFunc, (arg: string) => number>(true);
+  util.assertEqual<
+    typeof myFunc,
+    (arg: string, ...args_1: unknown[]) => number
+  >(true);
 });
diff --git a/src/__tests__/instanceof.test.ts b/src/__tests__/instanceof.test.ts
index e72e8374d..f6f743f28 100644
--- a/src/__tests__/instanceof.test.ts
+++ b/src/__tests__/instanceof.test.ts
@@ -22,8 +22,7 @@ test("instanceof", async () => {
     /Input not instance of Test/
   );
 
-  const f1: util.AssertEqual<Test, z.infer<typeof TestSchema>> = true;
-  expect(f1).toBeTruthy();
+  util.assertEqual<Test, z.infer<typeof TestSchema>>(true);
 });
 
 test("instanceof fatal", () => {
diff --git a/src/__tests__/map.test.ts b/src/__tests__/map.test.ts
index 5cc1dd7b8..08405db3d 100644
--- a/src/__tests__/map.test.ts
+++ b/src/__tests__/map.test.ts
@@ -9,8 +9,7 @@ const stringMap = z.map(z.string(), z.string());
 type stringMap = z.infer<typeof stringMap>;
 
 test("type inference", () => {
-  const f1: util.AssertEqual<stringMap, Map<string, string>> = true;
-  f1;
+  util.assertEqual<stringMap, Map<string, string>>(true);
 });
 
 test("valid parse", () => {
diff --git a/src/__tests__/nativeEnum.test.ts b/src/__tests__/nativeEnum.test.ts
index e4f4116f5..11b7aff0d 100644
--- a/src/__tests__/nativeEnum.test.ts
+++ b/src/__tests__/nativeEnum.test.ts
@@ -15,8 +15,7 @@ test("nativeEnum test with consts", () => {
   fruitEnum.parse("banana");
   fruitEnum.parse(Fruits.Apple);
   fruitEnum.parse(Fruits.Banana);
-  const t1: util.AssertEqual<fruitEnum, "apple" | "banana"> = true;
-  [t1];
+  util.assertEqual<fruitEnum, "apple" | "banana">(true);
 });
 
 test("nativeEnum test with real enum", () => {
@@ -31,8 +30,7 @@ test("nativeEnum test with real enum", () => {
   fruitEnum.parse("banana");
   fruitEnum.parse(Fruits.Apple);
   fruitEnum.parse(Fruits.Banana);
-  const t1: util.AssertEqual<fruitEnum, Fruits> = true;
-  [t1];
+  util.assertIs<fruitEnum extends Fruits ? true : false>(true);
 });
 
 test("nativeEnum test with const with numeric keys", () => {
@@ -47,8 +45,7 @@ test("nativeEnum test with const with numeric keys", () => {
   fruitEnum.parse(20);
   fruitEnum.parse(FruitValues.Apple);
   fruitEnum.parse(FruitValues.Banana);
-  const t1: util.AssertEqual<fruitEnum, 10 | 20> = true;
-  [t1];
+  util.assertEqual<fruitEnum, 10 | 20>(true);
 });
 
 test("from enum", () => {
diff --git a/src/__tests__/object.test.ts b/src/__tests__/object.test.ts
index de8d5bc93..17e636989 100644
--- a/src/__tests__/object.test.ts
+++ b/src/__tests__/object.test.ts
@@ -20,8 +20,7 @@ test("object type inference", () => {
     f4: { t: string | boolean }[];
   };
 
-  const t1: util.AssertEqual<z.TypeOf<typeof Test>, TestType> = true;
-  [t1];
+  util.assertEqual<z.TypeOf<typeof Test>, TestType>(true);
 });
 
 test("unknown throw", () => {
@@ -111,10 +110,8 @@ test("catchall inference", () => {
     .catchall(z.number());
 
   const d1 = o1.parse({ first: "asdf", num: 1243 });
-  const f1: util.AssertEqual<number, typeof d1["asdf"]> = true;
-  const f2: util.AssertEqual<string, typeof d1["first"]> = true;
-  f1;
-  f2;
+  util.assertEqual<number, typeof d1["asdf"]>(true);
+  util.assertEqual<string, typeof d1["first"]>(true);
 });
 
 test("catchall overrides strict", () => {
@@ -211,8 +208,7 @@ test("test async union", async () => {
 test("test inferred merged type", async () => {
   const asdf = z.object({ a: z.string() }).merge(z.object({ a: z.number() }));
   type asdf = z.infer<typeof asdf>;
-  const f1: util.AssertEqual<asdf, { a: number }> = true;
-  f1;
+  util.assertEqual<asdf, { a: number }>(true);
 });
 
 test("inferred merged object type with optional properties", async () => {
@@ -220,8 +216,7 @@ test("inferred merged object type with optional properties", async () => {
     .object({ a: z.string(), b: z.string().optional() })
     .merge(z.object({ a: z.string().optional(), b: z.string() }));
   type Merged = z.infer<typeof Merged>;
-  const f1: util.AssertEqual<Merged, { a?: string; b: string }> = true;
-  f1;
+  util.assertEqual<Merged, { a?: string; b: string }>(true);
 });
 
 test("inferred unioned object type with optional properties", async () => {
@@ -230,11 +225,10 @@ test("inferred unioned object type with optional properties", async () => {
     z.object({ a: z.string().optional(), b: z.string() }),
   ]);
   type Unioned = z.infer<typeof Unioned>;
-  const f1: util.AssertEqual<
+  util.assertEqual<
     Unioned,
     { a: string; b?: string } | { a?: string; b: string }
-  > = true;
-  f1;
+  >(true);
 });
 
 test("inferred enum type", async () => {
@@ -250,8 +244,7 @@ test("inferred enum type", async () => {
   });
   expect(Enum._def.values).toEqual(["a", "b"]);
   type Enum = z.infer<typeof Enum>;
-  const f1: util.AssertEqual<Enum, "a" | "b"> = true;
-  f1;
+  util.assertEqual<Enum, "a" | "b">(true);
 });
 
 test("inferred partial object type with optional properties", async () => {
@@ -259,8 +252,7 @@ test("inferred partial object type with optional properties", async () => {
     .object({ a: z.string(), b: z.string().optional() })
     .partial();
   type Partial = z.infer<typeof Partial>;
-  const f1: util.AssertEqual<Partial, { a?: string; b?: string }> = true;
-  f1;
+  util.assertEqual<Partial, { a?: string; b?: string }>(true);
 });
 
 test("inferred picked object type with optional properties", async () => {
@@ -268,8 +260,7 @@ test("inferred picked object type with optional properties", async () => {
     .object({ a: z.string(), b: z.string().optional() })
     .pick({ b: true });
   type Picked = z.infer<typeof Picked>;
-  const f1: util.AssertEqual<Picked, { b?: string }> = true;
-  f1;
+  util.assertEqual<Picked, { b?: string }>(true);
 });
 
 test("inferred type for unknown/any keys", () => {
@@ -280,7 +271,7 @@ test("inferred type for unknown/any keys", () => {
     unknownRequired: z.unknown(),
   });
   type myType = z.infer<typeof myType>;
-  const _f1: util.AssertEqual<
+  util.assertEqual<
     myType,
     {
       anyOptional?: any;
@@ -288,8 +279,7 @@ test("inferred type for unknown/any keys", () => {
       unknownOptional?: unknown;
       unknownRequired?: unknown;
     }
-  > = true;
-  _f1;
+  >(true);
 });
 
 test("setKey", () => {
@@ -297,8 +287,7 @@ test("setKey", () => {
   const withNewKey = base.setKey("age", z.number());
 
   type withNewKey = z.infer<typeof withNewKey>;
-  const _t1: util.AssertEqual<withNewKey, { name: string; age: number }> = true;
-  _t1;
+  util.assertEqual<withNewKey, { name: string; age: number }>(true);
   withNewKey.parse({ name: "asdf", age: 1234 });
 });
 
@@ -373,6 +362,5 @@ test("constructor key", () => {
   });
 
   type Example = z.infer<typeof Example>;
-  const f1: util.AssertEqual<keyof Example, "prop" | "opt" | "arr"> = true;
-  f1;
+  util.assertEqual<keyof Example, "prop" | "opt" | "arr">(true);
 });
diff --git a/src/__tests__/partials.test.ts b/src/__tests__/partials.test.ts
index 5a57f4f36..f2792286c 100644
--- a/src/__tests__/partials.test.ts
+++ b/src/__tests__/partials.test.ts
@@ -23,8 +23,7 @@ test("shallow inference", () => {
     outer?: { inner: string } | undefined;
     array?: { asdf: string }[];
   };
-  const t1: util.AssertEqual<shallow, correct> = true;
-  t1;
+  util.assertEqual<shallow, correct>(true);
 });
 
 test("shallow partial parse", () => {
@@ -48,8 +47,7 @@ test("deep partial inference", () => {
     outer?: { inner?: string | undefined } | undefined;
   };
 
-  const t1: util.AssertEqual<deep, correct> = true;
-  t1;
+  util.assertEqual<deep, correct>(true);
 });
 
 test("deep partial parse", () => {
@@ -129,8 +127,7 @@ test("deep partial inference", () => {
       | undefined;
     tuple?: [{ value?: string }] | undefined;
   };
-  const f1: util.AssertEqual<expected, partialed> = true;
-  f1;
+  util.assertEqual<expected, partialed>(true);
 });
 
 test("required", () => {
diff --git a/src/__tests__/pickomit.test.ts b/src/__tests__/pickomit.test.ts
index a73aecc34..f5baa10c6 100644
--- a/src/__tests__/pickomit.test.ts
+++ b/src/__tests__/pickomit.test.ts
@@ -13,8 +13,7 @@ const fish = z.object({
 test("pick type inference", () => {
   const nameonlyFish = fish.pick({ name: true });
   type nameonlyFish = z.infer<typeof nameonlyFish>;
-  const f1: util.AssertEqual<nameonlyFish, { name: string }> = true;
-  f1;
+  util.assertEqual<nameonlyFish, { name: string }>(true);
 });
 
 test("pick parse - success", () => {
@@ -40,8 +39,7 @@ test("pick parse - fail", () => {
 test("omit type inference", () => {
   const nonameFish = fish.omit({ name: true });
   type nonameFish = z.infer<typeof nonameFish>;
-  const f1: util.AssertEqual<nonameFish, { age: number; nested: {} }> = true;
-  f1;
+  util.assertEqual<nonameFish, { age: number; nested: {} }>(true);
 });
 
 test("omit parse - success", () => {
@@ -61,11 +59,9 @@ test("omit parse - fail", () => {
 });
 
 test("nonstrict inference", () => {
-  const laxfish = fish.nonstrict().pick({ name: true });
+  const laxfish = fish.pick({ name: true }).catchall(z.any());
   type laxfish = z.infer<typeof laxfish>;
-  const f1: util.AssertEqual<laxfish, { [k: string]: any; name: string }> =
-    true;
-  f1;
+  util.assertEqual<laxfish, { [k: string]: any; name: string }>(true);
 });
 
 test("nonstrict parsing - pass", () => {
diff --git a/src/__tests__/promise.test.ts b/src/__tests__/promise.test.ts
index f33d43148..cda9d711f 100644
--- a/src/__tests__/promise.test.ts
+++ b/src/__tests__/promise.test.ts
@@ -13,11 +13,9 @@ const promSchema = z.promise(
 
 test("promise inference", () => {
   type promSchemaType = z.infer<typeof promSchema>;
-  const t1: util.AssertEqual<
-    promSchemaType,
-    Promise<{ name: string; age: number }>
-  > = true;
-  expect(t1).toBeTruthy();
+  util.assertEqual<promSchemaType, Promise<{ name: string; age: number }>>(
+    true
+  );
 });
 
 test("promise parsing success", async () => {
diff --git a/src/__tests__/record.test.ts b/src/__tests__/record.test.ts
index 25971c62c..c3b744e73 100644
--- a/src/__tests__/record.test.ts
+++ b/src/__tests__/record.test.ts
@@ -17,19 +17,17 @@ const recordWithLiteralKeys = z.record(
 type recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;
 
 test("type inference", () => {
-  const f1: util.AssertEqual<booleanRecord, Record<string, boolean>> = true;
-  f1;
+  util.assertEqual<booleanRecord, Record<string, boolean>>(true);
 
-  const f2: util.AssertEqual<
+  util.assertEqual<
     recordWithEnumKeys,
     Partial<Record<"Tuna" | "Salmon", string>>
-  > = true;
-  f2;
-  const f3: util.AssertEqual<
+  >(true);
+
+  util.assertEqual<
     recordWithLiteralKeys,
     Partial<Record<"Tuna" | "Salmon", string>>
-  > = true;
-  f3;
+  >(true);
 });
 
 test("methods", () => {
diff --git a/src/__tests__/refine.test.ts b/src/__tests__/refine.test.ts
index e678a5c80..52f484c14 100644
--- a/src/__tests__/refine.test.ts
+++ b/src/__tests__/refine.test.ts
@@ -55,10 +55,8 @@ test("refinement type guard", () => {
   });
   type Schema = z.infer<typeof validationSchema>;
 
-  const f1: util.AssertEqual<"a", Schema["a"]> = true;
-  f1;
-  const f2: util.AssertEqual<"string", Schema["a"]> = false;
-  f2;
+  util.assertEqual<"a", Schema["a"]>(true);
+  util.assertEqual<"string", Schema["a"]>(false);
 });
 
 test("refinement Promise", async () => {
diff --git a/src/__tests__/set.test.ts b/src/__tests__/set.test.ts
index f69fbaaea..5526a4f3a 100644
--- a/src/__tests__/set.test.ts
+++ b/src/__tests__/set.test.ts
@@ -15,8 +15,7 @@ const nonEmpty = z.set(z.string()).nonempty();
 const nonEmptyMax = z.set(z.string()).nonempty().max(2);
 
 test("type inference", () => {
-  const f1: util.AssertEqual<stringSet, Set<string>> = true;
-  f1;
+  util.assertEqual<stringSet, Set<string>>(true);
 });
 
 test("valid parse", () => {
diff --git a/src/__tests__/transformer.test.ts b/src/__tests__/transformer.test.ts
index 8686f032b..398c465b8 100644
--- a/src/__tests__/transformer.test.ts
+++ b/src/__tests__/transformer.test.ts
@@ -158,10 +158,8 @@ test("object typing", () => {
   type t1 = z.input<typeof t1>;
   type t2 = z.output<typeof t1>;
 
-  const f1: util.AssertEqual<t1, { stringToNumber: string }> = true;
-  const f2: util.AssertEqual<t2, { stringToNumber: number }> = true;
-  f1;
-  f2;
+  util.assertEqual<t1, { stringToNumber: string }>(true);
+  util.assertEqual<t2, { stringToNumber: number }>(true);
 });
 
 test("transform method overloads", () => {
diff --git a/src/__tests__/tuple.test.ts b/src/__tests__/tuple.test.ts
index 9a3bead18..a1e4aa50e 100644
--- a/src/__tests__/tuple.test.ts
+++ b/src/__tests__/tuple.test.ts
@@ -18,8 +18,7 @@ test("tuple inference", () => {
   const returns1 = z.number();
   const func1 = z.function(args1, returns1);
   type func1 = z.TypeOf<typeof func1>;
-  const t1: util.AssertEqual<func1, (k: string) => number> = true;
-  [t1];
+  util.assertEqual<func1, (k: string) => number>(true);
 });
 
 test("successful validation", () => {
@@ -65,12 +64,10 @@ test("tuple with transformers", () => {
   const val = z.tuple([stringToNumber]);
 
   type t1 = z.input<typeof val>;
-  const f1: util.AssertEqual<t1, [string]> = true;
+  util.assertEqual<t1, [string]>(true);
   type t2 = z.output<typeof val>;
-  const f2: util.AssertEqual<t2, [number]> = true;
+  util.assertEqual<t2, [number]>(true);
   expect(val.parse(["1234"])).toEqual([4]);
-  f1;
-  f2;
 });
 
 test("tuple with rest schema", () => {
@@ -88,8 +85,7 @@ test("tuple with rest schema", () => {
   expect(() => myTuple.parse(["asdf", 1234, "asdf"])).toThrow();
   type t1 = z.output<typeof myTuple>;
 
-  const f1: util.AssertEqual<t1, [string, number, ...boolean[]]> = true;
-  f1;
+  util.assertEqual<t1, [string, number, ...boolean[]]>(true);
 });
 
 // test('tuple with optional elements', () => {
diff --git a/src/__tests__/void.test.ts b/src/__tests__/void.test.ts
index 137699de5..c27ecf86a 100644
--- a/src/__tests__/void.test.ts
+++ b/src/__tests__/void.test.ts
@@ -11,6 +11,5 @@ test("void", () => {
   expect(() => v.parse("")).toThrow();
 
   type v = z.infer<typeof v>;
-  const t1: util.AssertEqual<v, void> = true;
-  t1;
+  util.assertEqual<v, void>(true);
 });
diff --git a/src/helpers/util.ts b/src/helpers/util.ts
index dc00e94e6..0fb14668e 100644
--- a/src/helpers/util.ts
+++ b/src/helpers/util.ts
@@ -1,11 +1,12 @@
 export namespace util {
-  export type AssertEqual<T, Expected> = [T] extends [Expected]
-    ? [Expected] extends [T]
-      ? true
-      : false
+  type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <
+    V
+  >() => V extends U ? 1 : 2
+    ? true
     : false;
-  export function assertEqual<A, B>(_cond: AssertEqual<A, B>) {}
 
+  export const assertEqual = <A, B>(val: AssertEqual<A, B>) => val;
+  export function assertIs<T>(_arg: T): void {}
   export function assertNever(_x: never): never {
     throw new Error();
   }
@@ -66,7 +67,7 @@ export namespace util {
   };
 
   export type identity<T> = T;
-  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
+  export type flatten<T> = identity<{ [k in keyof T]: T[k] }>;
   export type noUndefined<T> = T extends undefined ? never : T;
 
   export const isInteger: NumberConstructor["isInteger"] =
diff --git a/src/types.ts b/src/types.ts
index d32b5ecdc..af635eefc 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -420,6 +420,14 @@ export abstract class ZodType<
     }) as any;
   }
 
+  brand<B extends string | number | symbol>(): ZodBranded<this, B> {
+    return new ZodBranded({
+      typeName: ZodFirstPartyTypeKind.ZodBranded,
+      type: this,
+      ...processCreateParams(undefined),
+    });
+  }
+
   describe(description: string): this {
     const This = (this as any).constructor;
     return new This({
@@ -1637,9 +1645,6 @@ export class ZodObject<
   Output = objectOutputType<T, Catchall>,
   Input = objectInputType<T, Catchall>
 > extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
-  readonly _shape!: T;
-  readonly _unknownKeys!: UnknownKeys;
-  readonly _catchall!: Catchall;
   private _cached: { shape: T; keys: string[] } | null = null;
 
   _getCached(): { shape: T; keys: string[] } {
@@ -1813,7 +1818,11 @@ export class ZodObject<
   merge<Incoming extends AnyZodObject>(
     merging: Incoming
   ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
-  ZodObject<extendShape<T, Incoming["_shape"]>, UnknownKeys, Catchall> {
+  ZodObject<
+    extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
+    UnknownKeys,
+    Catchall
+  > {
     // const mergedShape = objectUtil.mergeShapes(
     //   this._def.shape(),
     //   merging._def.shape()
@@ -3681,13 +3690,13 @@ export class ZodDefault<T extends ZodTypeAny> extends ZodType<
   };
 }
 
-/////////////////////////////////////////
-/////////////////////////////////////////
-//////////                     //////////
-//////////      ZodNaN         //////////
-//////////                     //////////
-/////////////////////////////////////////
-/////////////////////////////////////////
+//////////////////////////////////////
+//////////////////////////////////////
+//////////                  //////////
+//////////      ZodNaN      //////////
+//////////                  //////////
+//////////////////////////////////////
+//////////////////////////////////////
 
 export interface ZodNaNDef extends ZodTypeDef {
   typeName: ZodFirstPartyTypeKind.ZodNaN;
@@ -3717,6 +3726,47 @@ export class ZodNaN extends ZodType<number, ZodNaNDef> {
   };
 }
 
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////                      //////////
+//////////      ZodBranded      //////////
+//////////                      //////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+
+export interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {
+  type: T;
+  typeName: ZodFirstPartyTypeKind.ZodBranded;
+}
+
+export const BRAND: unique symbol = Symbol("zod_brand");
+export type BRAND<T extends string | number | symbol> = {
+  [BRAND]: { [k in T]: true };
+};
+
+export class ZodBranded<
+  T extends ZodTypeAny,
+  B extends string | number | symbol
+> extends ZodType<
+  T["_output"] & BRAND<B>,
+  ZodBrandedDef<T>,
+  T["_input"] & BRAND<B>
+> {
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { ctx } = this._processInputParams(input);
+    const data = ctx.data;
+    return this._def.type._parse({
+      data,
+      path: ctx.path,
+      parent: ctx,
+    });
+  }
+
+  unwrap() {
+    return this._def.type;
+  }
+}
+
 export const custom = <T>(
   check?: (data: unknown) => any,
   params: Parameters<ZodTypeAny["refine"]>[1] = {},
@@ -3771,6 +3821,7 @@ export enum ZodFirstPartyTypeKind {
   ZodNullable = "ZodNullable",
   ZodDefault = "ZodDefault",
   ZodPromise = "ZodPromise",
+  ZodBranded = "ZodBranded",
 }
 export type ZodFirstPartySchemaTypes =
   | ZodString
@@ -3803,7 +3854,8 @@ export type ZodFirstPartySchemaTypes =
   | ZodOptional<any>
   | ZodNullable<any>
   | ZodDefault<any>
-  | ZodPromise<any>;
+  | ZodPromise<any>
+  | ZodBranded<any, any>;
 
 const instanceOfType = <T extends new (...args: any[]) => any>(
   cls: T,
diff --git a/yarn.lock b/yarn.lock
index ea8536642..aa6448e7e 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -504,6 +504,30 @@
   resolved "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz"
   integrity sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==
 
+"@esbuild-kit/cjs-loader@^2.3.1":
+  version "2.3.1"
+  resolved "https://registry.yarnpkg.com/@esbuild-kit/cjs-loader/-/cjs-loader-2.3.1.tgz#462981d49d9af0dba1c9d8f0f1b73ba0b57f187d"
+  integrity sha512-ov6ALYD9xZSPoo5mmGOQtEC/b0xXeUlPy65p8aHMHLF4DfBEe8Y+iquH2lTDsy6Iskc1uMTadF+SVADTSTNJMA==
+  dependencies:
+    "@esbuild-kit/core-utils" "^2.1.0"
+    get-tsconfig "^4.1.0"
+
+"@esbuild-kit/core-utils@^2.1.0":
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/@esbuild-kit/core-utils/-/core-utils-2.1.0.tgz#90f3a22b68305ae739a83b02e24ed0cdcba2917f"
+  integrity sha512-fZirrc2KjeTumVjE4bpleWOk2gD83b7WuGeQqOceKFQL+heNKKkNB5G5pekOUTLzfSBc0hP7hCSBoD9TuR0hLw==
+  dependencies:
+    esbuild "~0.14.47"
+    source-map-support "^0.5.21"
+
+"@esbuild-kit/esm-loader@^2.4.1":
+  version "2.4.1"
+  resolved "https://registry.yarnpkg.com/@esbuild-kit/esm-loader/-/esm-loader-2.4.1.tgz#5319a95fb46f89ce9d8bdf657c7ac67ebe61b1f9"
+  integrity sha512-6x44rygVfNODm27v0RW3wX5y61mqSrXDvB39G0nomgWWqxG3mjiKtPSwrFppdkrA39QIqDgVlD4gJmPOxnleSw==
+  dependencies:
+    "@esbuild-kit/core-utils" "^2.1.0"
+    get-tsconfig "^4.1.0"
+
 "@eslint/eslintrc@^1.2.1":
   version "1.2.1"
   resolved "https://registry.yarnpkg.com/@eslint/eslintrc/-/eslintrc-1.2.1.tgz#8b5e1c49f4077235516bc9ec7d41378c0f69b8c6"
@@ -2037,14 +2061,6 @@ esbuild-openbsd-64@0.14.49:
   resolved "https://registry.yarnpkg.com/esbuild-openbsd-64/-/esbuild-openbsd-64-0.14.49.tgz#1f8bdc49f8a44396e73950a3fb6b39828563631d"
   integrity sha512-lP06UQeLDGmVPw9Rg437Btu6J9/BmyhdoefnQ4gDEJTtJvKtQaUcOQrhjTq455ouZN4EHFH1h28WOJVANK41kA==
 
-esbuild-runner@^2.2.1:
-  version "2.2.1"
-  resolved "https://registry.yarnpkg.com/esbuild-runner/-/esbuild-runner-2.2.1.tgz#3866fca62cbf9645e939b43a0c65446f9a53064f"
-  integrity sha512-VP0VfJJZiZ3cKzdOH59ZceDxx/GzBKra7tiGM8MfFMLv6CR1/cpsvtQ3IsJI3pz7HyeYxtbPyecj3fHwR+3XcQ==
-  dependencies:
-    source-map-support "0.5.19"
-    tslib "2.3.1"
-
 esbuild-sunos-64@0.14.49:
   version "0.14.49"
   resolved "https://registry.yarnpkg.com/esbuild-sunos-64/-/esbuild-sunos-64-0.14.49.tgz#47d042739365b61aa8ca642adb69534a8eef9f7a"
@@ -2065,7 +2081,7 @@ esbuild-windows-arm64@0.14.49:
   resolved "https://registry.yarnpkg.com/esbuild-windows-arm64/-/esbuild-windows-arm64-0.14.49.tgz#d83c03ff6436caf3262347cfa7e16b0a8049fae7"
   integrity sha512-v+HYNAXzuANrCbbLFJ5nmO3m5y2PGZWLe3uloAkLt87aXiO2mZr3BTmacZdjwNkNEHuH3bNtN8cak+mzVjVPfA==
 
-esbuild@^0.14.49:
+esbuild@~0.14.47:
   version "0.14.49"
   resolved "https://registry.yarnpkg.com/esbuild/-/esbuild-0.14.49.tgz#b82834760eba2ddc17b44f05cfcc0aaca2bae492"
   integrity sha512-/TlVHhOaq7Yz8N1OJrjqM3Auzo5wjvHFLk+T8pIue+fhnhIMpfAzsG6PLVMbFveVxqD2WOp3QHei+52IMUNmCw==
@@ -2537,6 +2553,11 @@ get-symbol-description@^1.0.0:
     call-bind "^1.0.2"
     get-intrinsic "^1.1.1"
 
+get-tsconfig@^4.1.0:
+  version "4.2.0"
+  resolved "https://registry.yarnpkg.com/get-tsconfig/-/get-tsconfig-4.2.0.tgz#ff368dd7104dab47bf923404eb93838245c66543"
+  integrity sha512-X8u8fREiYOE6S8hLbq99PeykTDoLVnxvF4DjWKJmz9xy2nNRdUcV8ZN9tniJFeKyTU3qnC9lL8n4Chd6LmVKHg==
+
 glob-parent@^5.1.2, glob-parent@~5.1.2:
   version "5.1.2"
   resolved "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz"
@@ -4488,10 +4509,10 @@ slice-ansi@^5.0.0:
     ansi-styles "^6.0.0"
     is-fullwidth-code-point "^4.0.0"
 
-source-map-support@0.5.19:
-  version "0.5.19"
-  resolved "https://registry.yarnpkg.com/source-map-support/-/source-map-support-0.5.19.tgz#a98b62f86dcaf4f67399648c085291ab9e8fed61"
-  integrity sha512-Wonm7zOCIJzBGQdB+thsPar0kYuCIzYvxZwlBa87yi/Mdjv7Tip2cyVbLj5o0cFPN4EVkuTwb3GDDyUx2DGnGw==
+source-map-support@^0.5.21:
+  version "0.5.21"
+  resolved "https://registry.yarnpkg.com/source-map-support/-/source-map-support-0.5.21.tgz#04fe7c7f9e1ed2d662233c28cb2b35b9f63f6e4f"
+  integrity sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==
   dependencies:
     buffer-from "^1.0.0"
     source-map "^0.6.0"
@@ -4818,6 +4839,17 @@ tsutils@^3.21.0:
   dependencies:
     tslib "^1.8.1"
 
+tsx@^3.8.0:
+  version "3.8.0"
+  resolved "https://registry.yarnpkg.com/tsx/-/tsx-3.8.0.tgz#40528c8e5d44fa98877db9dfd463b46fb1c00a23"
+  integrity sha512-PcvTwRXTm6hDWfPihA4n5WW/9SmgFNxKaDKqvLLG+FKNEPA4crsipChzC7PVozPtdOaMfR5QctDlkC/hKoIsxw==
+  dependencies:
+    "@esbuild-kit/cjs-loader" "^2.3.1"
+    "@esbuild-kit/core-utils" "^2.1.0"
+    "@esbuild-kit/esm-loader" "^2.4.1"
+  optionalDependencies:
+    fsevents "~2.3.2"
+
 type-check@^0.4.0, type-check@~0.4.0:
   version "0.4.0"
   resolved "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz"
