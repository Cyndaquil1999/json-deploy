diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index b391b575256..13565497377 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -14,7 +14,7 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        deno: ["v1.x"]
+        deno: ["canary", "v1.x"]
         os: [macOS-latest, windows-latest, ubuntu-latest]
         include:
         - os: ubuntu-latest
@@ -59,10 +59,5 @@ jobs:
       - name: Type check project
         run: deno task check:types
 
-      - name: Run tests Windows
-        if: matrix.os == 'windows-latest'
-        run: deno test -A
-
-      - name: Run tests macOS + Linux
-        if: matrix.os != 'windows-latest'
-        run: deno test -A --parallel
+      - name: Run tests
+        run: deno task test
diff --git a/.gitignore b/.gitignore
index 03b773a3a49..5a0f580b785 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,2 @@
 _fresh/
+tmp/
diff --git a/.vscode/import_map.json b/.vscode/import_map.json
index eb692025c58..5416453a89e 100644
--- a/.vscode/import_map.json
+++ b/.vscode/import_map.json
@@ -6,11 +6,11 @@
     "$fresh/": "../",
     "twind": "https://esm.sh/twind@0.16.19",
     "twind/": "https://esm.sh/twind@0.16.19/",
-    "preact": "https://esm.sh/preact@10.15.1",
-    "preact/": "https://esm.sh/preact@10.15.1/",
-    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.1",
-    "@preact/signals": "https://esm.sh/*@preact/signals@1.1.3",
-    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.2.3",
+    "preact": "https://esm.sh/preact@10.18.1",
+    "preact/": "https://esm.sh/preact@10.18.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.2",
+    "@preact/signals": "https://esm.sh/*@preact/signals@1.2.1",
+    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.5.0",
     "@preact/signals-core@1.2.3": "https://esm.sh/@preact/signals-core@1.2.3",
     "@preact/signals-core@1.3.0": "https://esm.sh/@preact/signals-core@1.3.0",
     "$std/": "https://deno.land/std@0.193.0/",
diff --git a/.vscode/settings.json b/.vscode/settings.json
index dd9c96476c7..71c61549bc3 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -3,6 +3,7 @@
   "deno.lint": true,
   "deno.importMap": "./.vscode/import_map.json",
   "deno.codeLens.test": true,
+  "deno.documentPreloadLimit": 2000,
   "editor.formatOnSave": true,
   "editor.defaultFormatter": "denoland.vscode-deno",
   "[typescriptreact]": {
diff --git a/_typos.toml b/_typos.toml
new file mode 100644
index 00000000000..7451c3d6d6a
--- /dev/null
+++ b/_typos.toml
@@ -0,0 +1,2 @@
+[files]
+extend-exclude = ["tests/fixture_partials/routes/scroll_restoration/index.tsx"]
diff --git a/deno.json b/deno.json
index 0284e689ea4..793d2390f85 100644
--- a/deno.json
+++ b/deno.json
@@ -1,13 +1,17 @@
 {
   "lock": false,
   "tasks": {
-    "test": "deno test -A --parallel",
+    "test": "deno test -A --parallel --trace-ops --unstable",
     "fixture": "deno run -A --watch=static/,routes/ tests/fixture/dev.ts",
     "www": "deno task --cwd=www start",
     "screenshot": "deno run -A www/utils/screenshot.ts",
     "check:types": "deno check **/*.ts && deno check **/*.tsx",
     "ok": "deno fmt --check && deno lint && deno task check:types && deno task test"
   },
+  "exclude": [
+    "**/_fresh/*",
+    "**/tmp/*"
+  ],
   "importMap": "./.vscode/import_map.json",
   "compilerOptions": {
     "jsx": "react-jsx",
diff --git a/docs/latest/concepts/ahead-of-time-builds.md b/docs/latest/concepts/ahead-of-time-builds.md
index e569f067a59..5ee4436cd68 100644
--- a/docs/latest/concepts/ahead-of-time-builds.md
+++ b/docs/latest/concepts/ahead-of-time-builds.md
@@ -30,9 +30,9 @@ This will create a `_fresh` folder in the project directory. That folder
 contains the optimized assets and a `snapshot.json` file which includes some
 metadata for Fresh.
 
-> ℹ️ The `_fresh` folder should not be committed to the repository. Add an entry
-> in the `.gitignore` file to ensure that it is not committed. Create that file
-> at the root of your git repository if not present.
+> [info]: The `_fresh` folder should not be committed to the repository. Add an
+> entry in the `.gitignore` file to ensure that it is not committed. Create that
+> file at the root of your git repository if not present.
 >
 > ```gitignore .gitignore
 > # Ignore fresh build directory
diff --git a/docs/latest/concepts/app-wrapper.md b/docs/latest/concepts/app-wrapper.md
index a564591b5bb..13b51ff3e21 100644
--- a/docs/latest/concepts/app-wrapper.md
+++ b/docs/latest/concepts/app-wrapper.md
@@ -21,7 +21,7 @@ export default function App({ Component, state }: AppProps) {
   return (
     <html>
       <head>
-        <meta charSet="utf-8" />
+        <meta charset="utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>My Fresh app</title>
       </head>
@@ -48,7 +48,7 @@ export default async function App(req: Request, ctx: AppContext) {
   return (
     <html>
       <head>
-        <meta charSet="utf-8" />
+        <meta charset="utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>My Fresh app</title>
       </head>
@@ -75,7 +75,7 @@ export default defineApp(async (req, ctx) => {
   return (
     <html>
       <head>
-        <meta charSet="utf-8" />
+        <meta charset="utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>My Fresh app</title>
       </head>
diff --git a/docs/latest/concepts/middleware.md b/docs/latest/concepts/middleware.md
index d0a53ee3c6c..6191678abaf 100644
--- a/docs/latest/concepts/middleware.md
+++ b/docs/latest/concepts/middleware.md
@@ -209,12 +209,11 @@ export function handler(req: Request): Response {
 `307` stands for temporary redirect. You can also use `301` for permanent
 redirect. You can also redirect to a relative path by doing:
 
-````ts
+```ts
 export function handler(req: Request): Response {
   return new Response("", {
     status: 307,
     headers: { Location: "/my/new/relative/path" },
   });
 }
-```****
-````
+```
diff --git a/docs/latest/concepts/partials.md b/docs/latest/concepts/partials.md
new file mode 100644
index 00000000000..ae2a403459c
--- /dev/null
+++ b/docs/latest/concepts/partials.md
@@ -0,0 +1,198 @@
+---
+description: |
+  Partials allow areas of a page to be updated without causing the browser to reload the page. They enable optimized fine grained UI updates and can be used to do client-side navigation.
+---
+
+Partials allow areas of the page to be updated with new content by the server
+without causing the browser to reload the page. They make your website feel more
+app-like because only the parts of the page that need to be updated will
+updated.
+
+## Enabling partials
+
+Partials are enabled by adding a `f-client-nav` attribute to an HTML element and
+wrapping one or more areas in the page with a
+`<Partial name="my-partial">`-component.
+
+The quickest way to get started is to enable partials for every page in
+`routes/_app.tsx` by making the following changes.
+
+```diff routes/_app.tsx
+  import { AppProps } from "$fresh/server.ts";
++ import { Partial } from "$fresh/runtime.ts";
+
+  export default function App({ Component }: AppProps) {
+    return (
+      <html>
+        <head>
+          <meta charset="utf-8" />
+          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+          <title>My Fresh app</title>
+        </head>
+-       <body>
++       <body f-client-nav>
++         <Partial name="body">
+            <Component />
++         </Partial>
+        </body>
+      </html>
+    );
+  }
+```
+
+By adding the `f-client-nav` attribute, we enable partials for every element
+beneath the `<body>`-tag. To mark an area of the page as a partial we wrap it
+with a `<Partial>`-component with a unique name.
+
+Behind the scenes, when the user clicks an `<a>`-tag, Fresh fetches the new page
+and only pulls out the relevant content out of the HTML response. When it finds
+a matching partial area it will update the content inside the partial.
+
+> ℹ️ The `name` prop of the `<Partial>` component is expected to be unique among
+> Partials. That's how Fresh knows which parts of the response need to go on the
+> current page.
+
+> ℹ️ Passing `f-client-nav={false}` disables client side navigation and partials
+> for the current elements and the elements below it.
+
+### Optimizing partial requests
+
+By default, with `f-client-nav` set, Fresh fetches the full next page and only
+picks out the relevant parts of the response. We can optimize this pattern
+further by only rendering the parts we need, instead of always rendering the
+full page. This is done by adding the `f-partial` attribute to a link.
+
+```diff
+- <a href="/docs/routes">Routes</a>
++ <a href="/docs/routes" f-partial="/partials/docs/routes">Routes</a>
+```
+
+When the `f-partial` attribute is present, Fresh will navigate to the page URL
+defined in the `href` attribute, but fetch the updated UI from the URL specified
+in `f-partial` instead. This can be a highly optimized route that only delivers
+the content you care about.
+
+Let's use a typical documentation page layout as an example. It often features a
+main content area and a sidebar of links to switch between pages of the
+documentation (marked green here).
+
+![A sketched layout of a typical documentation page with the sidebar on the left composed of green links and a main content area on the right. The main content area is labeled as Partial "docs-content"](/docs/fresh-partial-docs.png)
+
+The code for such a page (excluding styling) might look like this:
+
+```tsx routes/docs/[id].tsx
+export default defineRoute(async (req, ctx) => {
+  const content = await loadContent(props.params.id);
+
+  return (
+    <div>
+      <aside>
+        <a href="/docs/page1">Page 1</a>
+        <a href="/docs/page2">Page 2</a>
+      </aside>
+      <Partial name="docs-content">
+        {content}
+      </Partial>
+    </div>
+  );
+});
+```
+
+An optimal route that only renders the content instead of the outer layout with
+the sidebar might look like this respectively.
+
+```tsx partials/docs/[id].tsx
+import { defineRoute, RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+
+// We only want to render the content, so disable
+// the `_app.tsx` template as well as any potentially
+// inherited layouts
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute(async (req, ctx) => {
+  const content = await loadContent(props.params.id);
+
+  // Only render the new content
+  return (
+    <Partial name="docs-content">
+      {content}
+    </Partial>
+  );
+});
+```
+
+By adding the `f-partial` attribute we tell Fresh to fetch the content from our
+newly added `/partials/docs/[id].tsx` route.
+
+```diff routes/docs/[id].tsx
+  <aside>
+-   <a href="/docs/page1">Page 1</a>
+-   <a href="/docs/page2">Page 2</a>
++   <a href="/docs/page1" f-partial="/partials/docs/page1">Page 1</a>
++   <a href="/docs/page2" f-partial="/partials/docs/page2">Page 2</a>
+  </aside>
+```
+
+With this in place, Fresh will navigate to the new page when clicking any of the
+two links and _only_ load the content rendered by our optimized partial route.
+
+> Currently, `f-partial` is scoped to `<a>`, `<button>` and `<form>` elements.
+> This might be extended to more elements in the future.
+
+## Sending multiple Partials at the same time
+
+A neat aspect of partials in Fresh is that a response can return as many
+partials as desired. That way you can update multiple unrelated areas on your
+page in one single HTTP response. A scenario where this is useful are online
+shops for example.
+
+```tsx routes/partials/cart
+export default function AddToCartPartial() {
+  return (
+    <>
+      <Partial name="cart-items" mode="append">
+        {/* Render the new cart item here */}
+      </Partial>
+      <Partial name="total-price">
+        <p>Total: {totalPrice} €</p>
+      </Partial>
+    </>
+  );
+}
+```
+
+Both partials will be applied to the current page.
+
+## Replacement mode
+
+By default the whole content inside a partial will be replaced, but there are
+scenarios where you want to prepend or append new content instead. This can be
+achieved by adding the `mode` prop to a `Partial` component.
+
+- `replace` - Swap out the content of the existing partial (default)
+- `prepend` - Insert the new content before the existing content
+- `append` - Insert the new content after the existing content
+
+Personally, we’ve found that the `append` mode is really useful when you have an
+UI which displays log messages or similar list-like data.
+
+```tsx
+export default function LogView() {
+  const lines = getNewLogLines();
+
+  return (
+    <Partial name="logs-list" mode="append">
+      {lines.map((line) => {
+        return <li key={line}>{line}</li>;
+      })}
+    </Partial>
+  );
+}
+```
+
+> ℹ️ When picking the `prepend` or `append` mode, make sure to add keys to the
+> elements.
diff --git a/docs/latest/concepts/routing.md b/docs/latest/concepts/routing.md
index 7072e8190e8..7aa73fe5a98 100644
--- a/docs/latest/concepts/routing.md
+++ b/docs/latest/concepts/routing.md
@@ -28,14 +28,15 @@ File names are mapped to route patterns as follows:
 Here is a table of file names, which route patterns they map to, and which paths
 they might match:
 
-| File name                 | Route pattern          | Matching paths             |
-| ------------------------- | ---------------------- | -------------------------- |
-| `index.ts`                | `/`                    | `/`                        |
-| `about.ts`                | `/about`               | `/about`                   |
-| `blog/index.ts`           | `/blog`                | `/blog`                    |
-| `blog/[slug].ts`          | `/blog/:slug`          | `/blog/foo`, `/blog/bar`   |
-| `blog/[slug]/comments.ts` | `/blog/:slug/comments` | `/blog/foo/comments`       |
-| `old/[...path].ts`        | `/old/:path*`          | `/old/foo`, `/old/bar/baz` |
+| File name                   | Route pattern          | Matching paths                          |
+| --------------------------- | ---------------------- | --------------------------------------- |
+| `index.ts`                  | `/`                    | `/`                                     |
+| `about.ts`                  | `/about`               | `/about`                                |
+| `blog/index.ts`             | `/blog`                | `/blog`                                 |
+| `blog/[slug].ts`            | `/blog/:slug`          | `/blog/foo`, `/blog/bar`                |
+| `blog/[slug]/comments.ts`   | `/blog/:slug/comments` | `/blog/foo/comments`                    |
+| `old/[...path].ts`          | `/old/:path*`          | `/old/foo`, `/old/bar/baz`              |
+| `docs/[[version]]/index.ts` | `/docs{/:version}?`    | `/docs`, `/docs/latest`, `/docs/canary` |
 
 Advanced use-cases can require that a more complex pattern be used for matching.
 A custom [URL pattern][urlpattern] can be specified in the route configuration.
@@ -96,8 +97,9 @@ a folder and use a different `_layout` file for each group.
         └── contact.tsx
 ```
 
-> ℹ️ Be careful about routes in different groups which match to the same URL.
-> Such scenarios will lead to ambiguity as to which route file should be picked.
+> [warn]: Be careful about routes in different groups which match to the same
+> URL. Such scenarios will lead to ambiguity as to which route file should be
+> picked.
 >
 > ```txt Project structure
 > └── routes
diff --git a/docs/latest/concepts/updating.md b/docs/latest/concepts/updating.md
index 165956f334f..b3ae1daa3dd 100644
--- a/docs/latest/concepts/updating.md
+++ b/docs/latest/concepts/updating.md
@@ -42,7 +42,7 @@ To run the auto updater, run the following command from the root of your
 project:
 
 ```sh Terminal
-$ deno run -A -r https://fresh.deno.dev/update .
+$ deno run -A -r https://fresh.deno.dev/update
 ```
 
 You will be prompted to confirm the changes that will be made to your project.
diff --git a/docs/latest/examples/active-links.md b/docs/latest/examples/active-links.md
new file mode 100644
index 00000000000..f05c8f91e63
--- /dev/null
+++ b/docs/latest/examples/active-links.md
@@ -0,0 +1,43 @@
+---
+description: |
+  Style active links with ease in Fresh
+---
+
+When Fresh renders an `<a>`-element, it will automatically add a
+[data attribute](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes)
+to the link which can be used for styling purposes. Fresh will add one of the
+two following attributes:
+
+- `data-current` - Added to links with an exact path match
+- `data-ancestor` - Added to links which partially match the current URL
+
+## Styling with CSS
+
+`data-*` attributes can be natively styled in CSS via attribute selectors.
+
+```css
+/* Give links pointing to the current page a green color */
+a[data-current] {
+  color: green;
+}
+
+/* Color all ancestor links of the current page */
+a[data-ancestor] {
+  color: peachpuff;
+}
+```
+
+## Tailwind / Twind
+
+In tailwind or tailwind like styling solutions you can style `data-*`-attributes
+by prepending the classes with `[data-current]:`
+
+```tsx
+function Menu() {
+  return (
+    <a href="/foo" class="[data-current]:text-green-600">
+      link to some page
+    </a>
+  );
+}
+```
diff --git a/docs/latest/examples/modifying-the-head.md b/docs/latest/examples/modifying-the-head.md
index d65d22ecd78..ba1d2d048c1 100644
--- a/docs/latest/examples/modifying-the-head.md
+++ b/docs/latest/examples/modifying-the-head.md
@@ -15,7 +15,6 @@ the web page. Some uses include:
 
 ```tsx routes/index.tsx
 import { Head } from "$fresh/runtime.ts";
-import Counter from "../islands/Counter.tsx";
 
 export default function Home() {
   return (
@@ -37,3 +36,44 @@ export default function Home() {
   );
 }
 ```
+
+## Avoiding duplicate tags
+
+You might end up with duplicate tags, when multiple `<Head />` components are
+rendered on the same page. This can happen when you render `<Head />` in a route
+and another `<Head />` in another component for example.
+
+```tsx
+// routes/page-a.tsx
+<Head>
+  <meta name="og:title" content="This is a title" />
+</Head>
+
+// components/MyTitle.tsx
+<Head>
+  <meta name="og:title" content="Other title" />
+</Head>
+```
+
+To ensure that the tag is not duplicated, Fresh supports setting the `key` prop.
+By giving matching elements the same `key` prop, only the last one will be
+rendered.
+
+```diff
+  // routes/page-a.tsx
+  <Head>
+-   <meta name="og:title" content="This is a title" />
++   <meta name="og:title" content="This is a title" key="title" />
+  </Head>
+
+  // components/MyTitle.tsx
+  <Head>
+-   <meta name="og:title" content="Other title" />
++   <meta name="og:title" content="Other title" key="title" />
+  </Head>
+```
+
+The rendered page will only include the `<meta>`-tag with `"Other title"`.
+
+> [info]: The `<title>`-tag is automatically deduplicated, even without a `key`
+> prop.
diff --git a/docs/latest/examples/using-deno-kv-oauth.md b/docs/latest/examples/using-deno-kv-oauth.md
index 12f66d2de67..33d58ccd3c3 100644
--- a/docs/latest/examples/using-deno-kv-oauth.md
+++ b/docs/latest/examples/using-deno-kv-oauth.md
@@ -1,5 +1,5 @@
 ---
-description: Easily integrate OAuth 2.0 to your Fresh project with Deno KV OAuth.
+description: Easily integrate OAuth 2.0 into your Fresh project with the official Deno KV OAuth plugin.
 ---
 
 > ⚠️ Please note that this functionality relies on
@@ -11,138 +11,160 @@ description: Easily integrate OAuth 2.0 to your Fresh project with Deno KV OAuth
 > change**. See [the documentation](https://deno.land/x/deno_kv_oauth) for
 > further details.
 
-## Getting Started
+> ⚠️ Please note that the **minimum required version** for plugins in Fresh is
+> **1.3.0**.
 
-This example uses GitHub as the OAuth 2.0 provider. However there is a suite of
-[pre-configured providers](https://deno.land/x/deno_kv_oauth#pre-configured-oauth-20-clients)
-available.
+Fresh comes with an official Deno KV OAuth plugin based on the first-party
+[Deno KV OAuth](https://deno.land/x/deno_kv_oauth) module. This plugin creates
+and configures your OAuth routes for your Fresh project.
 
-1. Register a [new GitHub OAuth](https://github.com/settings/applications/new)
-   application, if you haven't already.
-2. Create your pre-configured OAuth client instance. For reusability the
-   instance is stored in `utils/oauth2_client.ts`.
+## Basic Setup
 
-   ```ts utils/oauth2_client.ts
-   import { createGitHubOAuth2Client } from "https://deno.land/x/deno_kv_oauth@v0.2.4/mod.ts";
+The most basic setup is that using a single provider with a pre-defined OAuth
+configuration. This automatically creates the following routes:
 
-   export const oauth2Client = createGitHubOAuth2Client();
+- `GET /oauth/signin`
+- `GET /oauth/callback`
+- `GET /oauth/signout`
+
+This is implemented as follows:
+
+1. Create your OAuth 2.0 application for your given provider.
+
+   > This example uses GitHub. However, you can choose from a list of providers
+   > that have pre-defined configurations
+   > [here](https://deno.land/x/deno_kv_oauth#providers).
+
+1. Create your pre-defined OAuth configuration and configure Fresh to use the
+   plugin.
+
+   ```ts main.ts
+   import { start } from "$fresh/server.ts";
+   import {
+     createGitHubOAuth2Client,
+     createRoutes,
+   } from "$fresh/plugins/kv_oauth.ts";
+   import manifest from "./fresh.gen.ts";
+
+   await start(manifest, {
+     plugins: [
+       {
+         name: "kv-oauth",
+         routes: createRoutes(createGitHubOAuth2Client()),
+       },
+     ],
+   });
    ```
 
-3. Using the OAuth 2.0 client instance, insert the authentication flow functions
-   into your authentication routes. In this example, there are dedicated handler
-   routes at `routes/signin.ts`, `routes/signout.ts` and `routes/callback.ts`.
-   Please ensure that the `callback` handler matches the authorization callback
-   URL in the configured OAuth application.
+1. Create and configure your protected route(s) using
+   [`getSessionId()`](https://deno.land/x/deno_kv_oauth/mod.ts?s=getSessionId).
 
-   ```ts routes/signin.ts
-   import { Handlers } from "$fresh/server.ts";
-   import { signIn } from "https://deno.land/x/deno_kv_oauth@v0.2.4/mod.ts";
-   import { oauth2Client } from "../utils/oauth2_client.ts";
+   ```ts routes/protected.ts
+   import type { Handlers } from "$fresh/server.ts";
+   import { getSessionId } from "$fresh/plugins/kv_oauth.ts";
 
    export const handler: Handlers = {
      async GET(req) {
-       return await signIn(req, oauth2Client);
+       return getSessionId(request) === undefined
+         ? new Response("Unauthorized", { status: 401 })
+         : new Response("You are allowed");
      },
    };
    ```
 
-   ```ts routes/signout.ts
-   import { Handlers } from "$fresh/server.ts";
-   import { signOut } from "https://deno.land/x/deno_kv_oauth@v0.2.4/mod.ts";
+1. ⚠️ While Deno KV is still **experimental** you need to add the `--unstable`
+   option to the `start` task in the `deno.json` file.
 
-   export const handler: Handlers = {
-     async GET(req) {
-       return await signOut(req);
-     },
-   };
+   ```json
+   "start": "deno run -A --watch=static/,routes/ --unstable dev.ts",
    ```
 
-   ```ts routes/callback.ts
-   import { Handlers } from "$fresh/server.ts";
-   import { handleCallback } from "https://deno.land/x/deno_kv_oauth@v0.2.4/mod.ts";
-   import { oauth2Client } from "../utils/oauth2_client.ts";
+1. Start your project with the necessary environment variables.
 
-   export const handler: Handlers = {
-     async GET(req) {
-       // Return object also includes `accessToken` and `sessionId` properties.
-       const { response } = await handleCallback(req, oauth2Client);
-       return response;
-     },
-   };
+   ```sh
+   GITHUB_CLIENT_ID=xxx GITHUB_CLIENT_SECRET=xxx deno task start
    ```
 
-4. Use Deno KV OAuth's helper functions where needed.
+## Further Setup
+
+The plugin is capable of having multiple providers, custom OAuth configurations
+and custom parent OAuth routes. These are implemented similar to the above
+example, as follows:
 
-   ```tsx routes/index.tsx
-   import { Handlers, PageProps } from "$fresh/server.ts";
+1. Create your OAuth 2.0 applications for your given providers.
+
+1. Create your configurations and configure Fresh to use the plugin.
+
+   ```ts main.ts
+   import { start } from "$fresh/server.ts";
    import {
-     getSessionAccessToken,
-     getSessionId,
-   } from "https://deno.land/x/deno_kv_oauth@v0.2.4/mod.ts";
-   import { oauth2Client } from "../utils/oauth2_client.ts";
-
-   interface User {
-     login: string;
-     name: string;
-     avatar_url: string;
-   }
-
-   export const handler: Handlers<User | null> = {
-     async GET(req, ctx) {
-       const sessionId = await getSessionId(req);
-
-       if (!sessionId) {
-         return ctx.render(null);
-       }
-
-       const accessToken = await getSessionAccessToken(oauth2Client, sessionId);
-       const response = await fetch("https://api.github.com/user", {
-         headers: {
-           authorization: `bearer ${accessToken}`,
-         },
-       });
-       const user: User = await response.json();
-       return ctx.render(user);
+     createNotionOAuthConfig,
+     createRoutes,
+   } from "$fresh/plugins/kv_oauth.ts";
+   import manifest from "./fresh.gen.ts";
+
+   await start(manifest, {
+     plugins: [
+       {
+         name: "kv-oauth",
+         routes: [
+           ...createRoutes(createNotionOAuthConfig(), "/oauth/notion"),
+           ...createRoutes({
+             clientId: getRequiredEnv("CUSTOM_CLIENT_ID"),
+             clientSecret: getRequiredEnv("CUSTOM_CLIENT_SECRET"),
+             authorizationEndpointUri: "https://custom.com/oauth/authorize",
+             tokenUri: "https://custom.com/oauth/token",
+             redirectUri: "https://my-site.com/oauth/custom/callback",
+           }, "/oauth/custom"),
+         ],
+       },
+     ],
+   });
+   ```
+
+   > Here, the 2nd parameter of `createRoutes()` is used to set the parent path
+   > for OAuth routes.
+
+1. Create and configure your protected route(s) using
+   [`getSessionId()`](https://deno.land/x/deno_kv_oauth/mod.ts?s=getSessionId).
+
+   ```ts routes/protected.ts
+   import type { Handlers } from "$fresh/server.ts";
+   import { getSessionId } from "$fresh/plugins/kv_oauth.ts";
+
+   export const handler: Handlers = {
+     async GET(req) {
+       return getSessionId(request) === undefined
+         ? new Response("Unauthorized", { status: 401 })
+         : new Response("You are allowed");
      },
    };
-
-   export default function Page({ data }: PageProps<User | null>) {
-     if (!data) {
-       return <a href="/signin">Sign In</a>;
-     }
-
-     return (
-       <div>
-         <img src={data.avatar_url} width={64} height={64} />
-         <h1>{data.name}</h1>
-         <p>{data.login}</p>
-         <a href="/signout">Sign Out</a>
-       </div>
-     );
-   }
    ```
 
-5. ⚠️ While Deno KV is still **experimental** you need to add the `--unstable`
+1. ⚠️ While Deno KV is still **experimental** you need to add the `--unstable`
    option to the `start` task in the `deno.json` file.
 
    ```json
    "start": "deno run -A --watch=static/,routes/ --unstable dev.ts",
    ```
 
-6. Start your project with the necessary environment variables.
+1. Start your project with the necessary environment variables.
 
    ```sh
-   GITHUB_CLIENT_ID=xxx GITHUB_CLIENT_SECRET=xxx deno task start
+   NOTION_CLIENT_ID=xxx NOTION_CLIENT_SECRET=xxx CUSTOM_CLIENT_ID=yyy CUSTOM_CLIENT_SECRET=yyy deno task start
    ```
 
-## More on Deno KV OAuth
+### Advanced Setups
 
-Follow the links to read more about:
+If you require more advanced setups, you can create your own custom plugin that
+defines the routes and their behaviors. To do this, check out the following
+resources:
 
-- Using a provider from the list of
-  [pre-configured providers](https://deno.land/x/deno_kv_oauth#pre-configured-oauth-20-clients)
-- Configuring a
-  [custom OAuth 2.0 client](https://deno.land/x/deno_kv_oauth#custom-oauth-20-client)
-- Setting the mandatory
-  [environment variables](https://deno.land/x/deno_kv_oauth#environment-variables)
-- Exploring a [live demo](https://fresh-deno-kv-oauth-demo.deno.dev/)
+- The [source code](plugins/kv_oauth.ts) for the Deno KV OAuth plugin
+- The [documentation](https://fresh.deno.dev/docs/concepts/plugins) for plugins
+- The
+  [Fresh + Deno KV OAuth demo](https://github.com/denoland/fresh-deno-kv-oauth-demo)
+  which uses the Fresh plugin
+- [Deno SaaSKit](https://saaskit.deno.dev/)'s custom
+  [plugin implementation](https://github.com/denoland/saaskit/blob/3accffdc44c2d2eb6dba28126f8d4cb525eba340/plugins/kv_oauth.ts)
+  as an example
diff --git a/docs/latest/getting-started/create-a-route.md b/docs/latest/getting-started/create-a-route.md
index b5f6dec4569..0356f5ffa27 100644
--- a/docs/latest/getting-started/create-a-route.md
+++ b/docs/latest/getting-started/create-a-route.md
@@ -29,7 +29,7 @@ this, one needs to create a new `routes/about.tsx` file. In this file, we can
 declare a component that should be rendered every time a user visits the page.
 This is done with JSX.
 
-> ℹ️ To learn more about JSX, you can read [this article][jsx] in the React
+> [info]: To learn more about JSX, you can read [this article][jsx] in the React
 > documentation. Beware that Fresh does not use React, but rather
 > [Preact][preact], a lighter weight virtual dom library that works similar to
 > React.
diff --git a/docs/toc.ts b/docs/toc.ts
index 65090aa5055..d0dd258b08b 100644
--- a/docs/toc.ts
+++ b/docs/toc.ts
@@ -55,6 +55,7 @@ const toc: RawTableOfContents = {
           ["static-files", "Static files", "link:latest"],
           ["middleware", "Middlewares", "link:latest"],
           ["error-pages", "Error pages", "link:latest"],
+          ["partials", "Partials", "link:latest"],
           ["data-fetching", "Data fetching", "link:latest"],
           ["ahead-of-time-builds", "Ahead-of-time Builds", "link:latest"],
           ["deployment", "Deployment", "link:latest"],
@@ -96,6 +97,7 @@ const toc: RawTableOfContents = {
           ],
           ["using-deno-kv-oauth", "Using Deno KV OAuth", "link:latest"],
           ["using-csp", "Using CSP", "link:latest"],
+          ["active-links", "Styling active links", "link:latest"],
         ],
       },
     },
@@ -134,6 +136,7 @@ const toc: RawTableOfContents = {
           ["static-files", "Static files"],
           ["middleware", "Middlewares"],
           ["error-pages", "Error pages"],
+          ["partials", "Partials"],
           ["data-fetching", "Data fetching"],
           ["ahead-of-time-builds", "Ahead-of-time Builds"],
           ["deployment", "Deployment"],
@@ -161,6 +164,7 @@ const toc: RawTableOfContents = {
           ["sharing-state-between-islands", "Sharing state between islands"],
           ["using-deno-kv-oauth", "Using Deno KV OAuth"],
           ["using-csp", "Using CSP"],
+          ["active-links", "Styling active links"],
         ],
       },
     },
diff --git a/init.ts b/init.ts
index fd7969edbee..47571eaf51e 100644
--- a/init.ts
+++ b/init.ts
@@ -91,10 +91,12 @@ const useVSCode = flags.vscode === null
 
 const useDocker = flags.docker;
 
-await Deno.mkdir(join(resolvedDirectory, "routes", "api"), { recursive: true });
-await Deno.mkdir(join(resolvedDirectory, "islands"), { recursive: true });
-await Deno.mkdir(join(resolvedDirectory, "static"), { recursive: true });
-await Deno.mkdir(join(resolvedDirectory, "components"), { recursive: true });
+await Promise.all([
+  Deno.mkdir(join(resolvedDirectory, "routes", "api"), { recursive: true }),
+  Deno.mkdir(join(resolvedDirectory, "islands"), { recursive: true }),
+  Deno.mkdir(join(resolvedDirectory, "static"), { recursive: true }),
+  Deno.mkdir(join(resolvedDirectory, "components"), { recursive: true }),
+]);
 if (useVSCode) {
   await Deno.mkdir(join(resolvedDirectory, ".vscode"), { recursive: true });
 }
@@ -166,10 +168,6 @@ export default function Home() {
   );
 }
 `;
-await Deno.writeTextFile(
-  join(resolvedDirectory, "routes", "index.tsx"),
-  ROUTES_INDEX_TSX,
-);
 
 const COMPONENTS_BUTTON_TSX = `import { JSX } from "preact";
 import { IS_BROWSER } from "$fresh/runtime.ts";
@@ -184,10 +182,6 @@ export function Button(props: JSX.HTMLAttributes<HTMLButtonElement>) {
   );
 }
 `;
-await Deno.writeTextFile(
-  join(resolvedDirectory, "components", "Button.tsx"),
-  COMPONENTS_BUTTON_TSX,
-);
 
 const ISLANDS_COUNTER_TSX = `import type { Signal } from "@preact/signals";
 import { Button } from "../components/Button.tsx";
@@ -206,24 +200,6 @@ export default function Counter(props: CounterProps) {
   );
 }
 `;
-await Deno.writeTextFile(
-  join(resolvedDirectory, "islands", "Counter.tsx"),
-  ISLANDS_COUNTER_TSX,
-);
-
-const ROUTES_GREET_TSX = `import { PageProps } from "$fresh/server.ts";
-
-export default function Greet(props: PageProps) {
-  return <div>Hello {props.params.name}</div>;
-}
-`;
-await Deno.mkdir(join(resolvedDirectory, "routes", "greet"), {
-  recursive: true,
-});
-await Deno.writeTextFile(
-  join(resolvedDirectory, "routes", "greet", "[name].tsx"),
-  ROUTES_GREET_TSX,
-);
 
 // 404 page
 const ROUTES_404_PAGE = `import { Head } from "$fresh/runtime.ts";
@@ -254,10 +230,37 @@ export default function Error404() {
   );
 }
 `;
+await Promise.all([
+  Deno.writeTextFile(
+    join(resolvedDirectory, "routes", "index.tsx"),
+    ROUTES_INDEX_TSX,
+  ),
+  Deno.writeTextFile(
+    join(resolvedDirectory, "components", "Button.tsx"),
+    COMPONENTS_BUTTON_TSX,
+  ),
+  Deno.writeTextFile(
+    join(resolvedDirectory, "islands", "Counter.tsx"),
+    ISLANDS_COUNTER_TSX,
+  ),
+  Deno.writeTextFile(
+    join(resolvedDirectory, "routes", "_404.tsx"),
+    ROUTES_404_PAGE,
+  ),
+]);
 
+const ROUTES_GREET_TSX = `import { PageProps } from "$fresh/server.ts";
+
+export default function Greet(props: PageProps) {
+  return <div>Hello {props.params.name}</div>;
+}
+`;
+await Deno.mkdir(join(resolvedDirectory, "routes", "greet"), {
+  recursive: true,
+});
 await Deno.writeTextFile(
-  join(resolvedDirectory, "routes", "_404.tsx"),
-  ROUTES_404_PAGE,
+  join(resolvedDirectory, "routes", "greet", "[name].tsx"),
+  ROUTES_GREET_TSX,
 );
 
 const ROUTES_API_JOKE_TS = `import { HandlerContext } from "$fresh/server.ts";
@@ -423,7 +426,7 @@ html {
 .rounded {
   border-radius: 0.25rem;
 }
-.hover\:bg-gray-200:hover {
+.hover\\:bg-gray-200:hover {
   background-color: #e5e7eb;
 }
 `;
@@ -435,7 +438,7 @@ export default function App({ Component }: AppProps) {
   return (
     <html>
       <head>
-        <meta charSet="utf-8" />
+        <meta charset="utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>${basename(resolvedDirectory)}</title>
       </head>
@@ -452,7 +455,7 @@ export default function App({ Component }: AppProps) {
   return (
     <html>
       <head>
-        <meta charSet="utf-8" />
+        <meta charset="utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>${basename(resolvedDirectory)}</title>
         <link rel="stylesheet" href="/styles.css" />
@@ -503,13 +506,14 @@ try {
 
 let FRESH_CONFIG_TS = `import { defineConfig } from "$fresh/server.ts";\n`;
 if (useTwind) {
-  FRESH_CONFIG_TS += `import twindPlugin from "$fresh/plugins/twind.ts"
-import twindConfig from "./twind.config.ts";`;
+  FRESH_CONFIG_TS += `import twindPlugin from "$fresh/plugins/twind.ts";
+import twindConfig from "./twind.config.ts";
+`;
 }
 
 FRESH_CONFIG_TS += `
 export default defineConfig({${
-  useTwind ? `\n  plugins: [twindPlugin(twindConfig)]\n` : ""
+  useTwind ? `\n  plugins: [twindPlugin(twindConfig)],\n` : ""
 }});
 `;
 const CONFIG_TS_PATH = join(resolvedDirectory, "fresh.config.ts");
@@ -564,11 +568,8 @@ const config = {
     rules: {
       tags: ["fresh", "recommended"],
     },
-    exclude: ["_fresh"],
-  },
-  fmt: {
-    exclude: ["_fresh"],
   },
+  exclude: ["**/_fresh/*"],
   imports: {} as Record<string, string>,
   compilerOptions: {
     jsx: "react-jsx",
diff --git a/plugins/kv_oauth.ts b/plugins/kv_oauth.ts
new file mode 100644
index 00000000000..aa186af17c8
--- /dev/null
+++ b/plugins/kv_oauth.ts
@@ -0,0 +1,72 @@
+import {
+  createAuth0OAuthConfig,
+  createDiscordOAuthConfig,
+  createDropboxOAuthConfig,
+  createFacebookOAuthConfig,
+  createGitHubOAuthConfig,
+  createGitLabOAuthConfig,
+  createGoogleOAuthConfig,
+  createNotionOAuthConfig,
+  createOktaOAuthConfig,
+  createPatreonOAuthConfig,
+  createSlackOAuthConfig,
+  createSpotifyOAuthConfig,
+  createTwitterOAuthConfig,
+  getRequiredEnv,
+  handleCallback,
+  type OAuth2ClientConfig,
+  signIn,
+  signOut,
+} from "https://deno.land/x/deno_kv_oauth@v0.9.1/mod.ts";
+import type { Handler } from "$fresh/server.ts";
+
+export {
+  createAuth0OAuthConfig,
+  createDiscordOAuthConfig,
+  createDropboxOAuthConfig,
+  createFacebookOAuthConfig,
+  createGitHubOAuthConfig,
+  createGitLabOAuthConfig,
+  createGoogleOAuthConfig,
+  createNotionOAuthConfig,
+  createOktaOAuthConfig,
+  createPatreonOAuthConfig,
+  createSlackOAuthConfig,
+  createSpotifyOAuthConfig,
+  createTwitterOAuthConfig,
+  getRequiredEnv,
+  type OAuth2ClientConfig,
+};
+
+/** @see {@link https://fresh.deno.dev/docs/examples/using-deno-kv-oauth} */
+export function createRoutes<T extends string = "/oauth">(
+  oauthConfig: OAuth2ClientConfig,
+  /** Parent path for sign-in, callback and sign-out pages. */
+  oauthPath = "/oauth" as T,
+): [
+  { path: `${T}/signin`; handler: Handler },
+  { path: `${T}/callback`; handler: Handler },
+  { path: `${T}/signout`; handler: Handler },
+] {
+  return [
+    {
+      path: `${oauthPath}/signin`,
+      handler: async (req) => await signIn(req, oauthConfig),
+    },
+    {
+      path: `${oauthPath}/callback`,
+      handler: async (req) => {
+        // Return object also includes `accessToken` and `sessionId` properties.
+        const { response } = await handleCallback(
+          req,
+          oauthConfig,
+        );
+        return response;
+      },
+    },
+    {
+      path: `${oauthPath}/signout`,
+      handler: signOut,
+    },
+  ];
+}
diff --git a/plugins/kv_oauth_test.ts b/plugins/kv_oauth_test.ts
new file mode 100644
index 00000000000..fd3da688516
--- /dev/null
+++ b/plugins/kv_oauth_test.ts
@@ -0,0 +1,48 @@
+// Copyright 2023 the Deno authors. All rights reserved. MIT license.
+import { assertArrayIncludes } from "$std/testing/asserts.ts";
+import { colors } from "$fresh/src/server/deps.ts";
+import { createRoutes } from "$fresh/plugins/kv_oauth.ts";
+
+function randomOAuthConfig() {
+  return {
+    clientId: crypto.randomUUID(),
+    clientSecret: crypto.randomUUID(),
+    authorizationEndpointUri: `http://${crypto.randomUUID()}.com/authorize`,
+    tokenUri: `http://${crypto.randomUUID()}.com/token`,
+  };
+}
+
+// @ts-ignore openKv is only available with --unstable
+const isKvEnabled = typeof Deno.openKv === "function";
+if (!isKvEnabled) {
+  console.log(
+    colors.yellow(`Skipping Deno KV tests. Pass "--unstable" to run them.`),
+  );
+}
+
+Deno.test({
+  name: "createRoutes() has all handlers defined with default OAuth path",
+  ignore: !isKvEnabled,
+  fn: () => {
+    const routes = createRoutes(randomOAuthConfig());
+    assertArrayIncludes(routes.map((route) => route.path), [
+      "/oauth/signin",
+      "/oauth/callback",
+      "/oauth/signout",
+    ]);
+  },
+});
+
+Deno.test({
+  name: "createRoutes() has all handlers defined with set OAuth path",
+  ignore: !isKvEnabled,
+  fn: () => {
+    const oauthPath = "/" + crypto.randomUUID();
+    const routes = createRoutes(randomOAuthConfig(), oauthPath);
+    assertArrayIncludes(routes.map((route) => route.path), [
+      oauthPath + "/signin",
+      oauthPath + "/callback",
+      oauthPath + "/signout",
+    ]);
+  },
+});
diff --git a/plugins/twindv1/shared.ts b/plugins/twindv1/shared.ts
index 0e3e9934267..fb03888fe2d 100644
--- a/plugins/twindv1/shared.ts
+++ b/plugins/twindv1/shared.ts
@@ -1,11 +1,18 @@
 import { JSX, options as preactOptions, VNode } from "preact";
-import { setup as twSetup, Sheet, tw, TwindConfig } from "../twindv1_deps.ts";
+import {
+  BaseTheme,
+  setup as twSetup,
+  Sheet,
+  tw,
+  TwindConfig,
+} from "$fresh/plugins/twindv1_deps.ts";
 
 type PreactOptions = typeof preactOptions & { __b?: (vnode: VNode) => void };
 
 export const STYLE_ELEMENT_ID = "__FRSH_TWIND";
 
-export interface Options extends TwindConfig {
+export interface Options<Theme extends BaseTheme = BaseTheme>
+  extends TwindConfig<Theme> {
   /** The import.meta.url of the module defining these options. */
   selfURL: string;
 }
@@ -19,7 +26,10 @@ declare module "preact" {
   }
 }
 
-export function setup({ selfURL: _selfURL, ...config }: Options, sheet: Sheet) {
+export function setup<Theme extends BaseTheme = BaseTheme>(
+  { selfURL: _selfURL, ...config }: Options<Theme>,
+  sheet: Sheet,
+) {
   twSetup(config, sheet);
 
   // Hook into options._diff which is called whenever a new comparison
diff --git a/runtime.ts b/runtime.ts
index 3a8a6bb79b6..df42b5f9950 100644
--- a/runtime.ts
+++ b/runtime.ts
@@ -1,3 +1,5 @@
+import "./src/types.ts";
 export * from "./src/runtime/utils.ts";
 export * from "./src/runtime/head.ts";
 export * from "./src/runtime/csp.ts";
+export * from "./src/runtime/Partial.tsx";
diff --git a/server.ts b/server.ts
index f519fbba179..e81fecdd210 100644
--- a/server.ts
+++ b/server.ts
@@ -1 +1,2 @@
+import "./src/types.ts";
 export * from "./src/server/mod.ts";
diff --git a/src/build/deps.ts b/src/build/deps.ts
index f1db2fd7156..7a3996cad4d 100644
--- a/src/build/deps.ts
+++ b/src/build/deps.ts
@@ -6,15 +6,15 @@ export {
 export { escape as regexpEscape } from "https://deno.land/std@0.193.0/regexp/escape.ts";
 
 // -- esbuild --
-// @deno-types="https://deno.land/x/esbuild@v0.18.11/mod.d.ts"
-import * as esbuildWasm from "https://deno.land/x/esbuild@v0.18.11/wasm.js";
-import * as esbuildNative from "https://deno.land/x/esbuild@v0.18.11/mod.js";
+// @deno-types="https://deno.land/x/esbuild@v0.19.4/mod.d.ts"
+import * as esbuildWasm from "https://deno.land/x/esbuild@v0.19.4/wasm.js";
+import * as esbuildNative from "https://deno.land/x/esbuild@v0.19.4/mod.js";
 // @ts-ignore trust me
 // deno-lint-ignore no-deprecated-deno-api
 const esbuild: typeof esbuildWasm = Deno.run === undefined
   ? esbuildWasm
   : esbuildNative;
-const esbuildWasmURL = new URL("./esbuild_v0.18.11.wasm", import.meta.url).href;
+const esbuildWasmURL = new URL("./esbuild_v0.19.4.wasm", import.meta.url).href;
 export { esbuild, esbuildWasm as esbuildTypes, esbuildWasmURL };
 
-export { denoPlugins } from "https://deno.land/x/esbuild_deno_loader@0.8.1/mod.ts";
+export { denoPlugins } from "https://deno.land/x/esbuild_deno_loader@0.8.2/mod.ts";
diff --git a/src/build/esbuild.ts b/src/build/esbuild.ts
index 66bbad17475..33d7843cc73 100644
--- a/src/build/esbuild.ts
+++ b/src/build/esbuild.ts
@@ -20,6 +20,7 @@ export interface EsbuildBuilderOptions {
   configPath: string;
   /** The JSX configuration. */
   jsxConfig: JSXConfig;
+  target: string | string[];
 }
 
 export interface JSXConfig {
@@ -55,7 +56,7 @@ export class EsbuildBuilder implements Builder {
         entryPoints: opts.entrypoints,
 
         platform: "browser",
-        target: ["chrome99", "firefox99", "safari15"],
+        target: this.#options.target,
 
         format: "esm",
         bundle: true,
@@ -88,6 +89,11 @@ export class EsbuildBuilder implements Builder {
         files.set(path, file.contents);
       }
 
+      files.set(
+        "metafile.json",
+        new TextEncoder().encode(JSON.stringify(bundle.metafile)),
+      );
+
       const metaOutputs = new Map(Object.entries(bundle.metafile.outputs));
 
       for (const [path, entry] of metaOutputs.entries()) {
diff --git a/src/build/esbuild_v0.18.11.wasm b/src/build/esbuild_v0.19.4.wasm
old mode 100755
new mode 100644
similarity index 64%
rename from src/build/esbuild_v0.18.11.wasm
rename to src/build/esbuild_v0.19.4.wasm
index 7d2ef267fe2..6e4654796ca
Binary files a/src/build/esbuild_v0.18.11.wasm and b/src/build/esbuild_v0.19.4.wasm differ
diff --git a/src/constants.ts b/src/constants.ts
new file mode 100644
index 00000000000..ae57771bd58
--- /dev/null
+++ b/src/constants.ts
@@ -0,0 +1,13 @@
+export const PARTIAL_SEARCH_PARAM = "fresh-partial";
+export const PARTIAL_ATTR = "f-partial";
+export const LOADING_ATTR = "f-loading";
+export const CLIENT_NAV_ATTR = "f-client-nav";
+export const DATA_KEY_ATTR = "data-fresh-key";
+export const DATA_CURRENT = "data-current";
+export const DATA_ANCESTOR = "data-ancestor";
+
+export const enum PartialMode {
+  REPLACE,
+  APPEND,
+  PREPEND,
+}
diff --git a/src/dev/build.ts b/src/dev/build.ts
index ddc3ad4a68b..3e61139120b 100644
--- a/src/dev/build.ts
+++ b/src/dev/build.ts
@@ -1,28 +1,20 @@
-import { ServerContext } from "../server/context.ts";
-import { FreshOptions, Manifest } from "../server/mod.ts";
-import { dirname, fromFileUrl, join, toFileUrl } from "../server/deps.ts";
-import { fs } from "./deps.ts";
+import { getServerContext } from "../server/context.ts";
+import { join } from "../server/deps.ts";
+import { colors, fs } from "./deps.ts";
 import { BuildSnapshotJson } from "../build/mod.ts";
-import { BUILD_ID } from "$fresh/src/server/build_id.ts";
+import { BUILD_ID } from "../server/build_id.ts";
+import { InternalFreshOptions } from "../server/types.ts";
 
 export async function build(
-  manifestPath: string,
-  opts: FreshOptions,
+  config: InternalFreshOptions,
 ) {
-  const manifest = (await import(toFileUrl(manifestPath).href))
-    .default as Manifest;
-
-  const outDir = join(dirname(fromFileUrl(manifest.baseUrl)), "_fresh");
-
   // Ensure that build dir is empty
-  await fs.emptyDir(outDir);
+  await fs.emptyDir(config.build.outDir);
 
-  const ctx = await ServerContext.fromManifest(manifest, {
-    ...opts,
-    skipSnapshot: true,
-  });
+  await Promise.all(config.plugins.map((plugin) => plugin.buildStart?.()));
 
   // Bundle assets
+  const ctx = await getServerContext(config);
   const snapshot = await ctx.buildSnapshot();
 
   // Write output files to disk
@@ -30,7 +22,7 @@ export async function build(
     const data = await snapshot.read(fileName);
     if (data === null) return;
 
-    return Deno.writeFile(join(outDir, fileName), data);
+    return Deno.writeFile(join(config.build.outDir, fileName), data);
   }));
 
   // Write dependency snapshot file to disk
@@ -43,6 +35,12 @@ export async function build(
     jsonSnapshot.files[filePath] = dependencies;
   }
 
-  const snapshotPath = join(outDir, "snapshot.json");
+  const snapshotPath = join(config.build.outDir, "snapshot.json");
   await Deno.writeTextFile(snapshotPath, JSON.stringify(jsonSnapshot, null, 2));
+
+  console.log(
+    `Assets written to: ${colors.green(config.build.outDir)}`,
+  );
+
+  await Promise.all(config.plugins.map((plugin) => plugin.buildEnd?.()));
 }
diff --git a/src/dev/dev_command.ts b/src/dev/dev_command.ts
index 8e7c780a2ec..dd3d5c9340e 100644
--- a/src/dev/dev_command.ts
+++ b/src/dev/dev_command.ts
@@ -1,26 +1,22 @@
 import { updateCheck } from "./update_check.ts";
-import { DAY, dirname, fromFileUrl, fs, join, toFileUrl } from "./deps.ts";
-import {
-  FreshOptions,
-  Manifest as ServerManifest,
-  ServerContext,
-} from "../server/mod.ts";
+import { DAY, dirname, fromFileUrl, join, toFileUrl } from "./deps.ts";
+import { FreshOptions, Manifest as ServerManifest } from "../server/mod.ts";
 import { build } from "./build.ts";
 import { collect, ensureMinDenoVersion, generate, Manifest } from "./mod.ts";
 import { startFromContext } from "../server/boot.ts";
+import { getFreshConfigWithDefaults } from "../server/config.ts";
+import { getServerContext } from "$fresh/src/server/context.ts";
 
 export async function dev(
   base: string,
   entrypoint: string,
-  options: FreshOptions = {},
+  options?: FreshOptions,
 ) {
   ensureMinDenoVersion();
 
   // Run update check in background
   updateCheck(DAY).catch(() => {});
 
-  entrypoint = new URL(entrypoint, base).href;
-
   const dir = dirname(fromFileUrl(base));
 
   let currentManifest: Manifest;
@@ -30,7 +26,7 @@ export async function dev(
   } else {
     currentManifest = { islands: [], routes: [] };
   }
-  const newManifest = await collect(dir);
+  const newManifest = await collect(dir, options?.router?.ignoreFilePattern);
   Deno.env.set("FRSH_DEV_PREVIOUS_MANIFEST", JSON.stringify(newManifest));
 
   const manifestChanged =
@@ -42,25 +38,29 @@ export async function dev(
   const manifest = (await import(toFileUrl(join(dir, "fresh.gen.ts")).href))
     .default as ServerManifest;
 
-  const outDir = join(dir, "_fresh");
-
-  const isBuild = Deno.args.includes("build");
-  const ctx = await ServerContext.fromManifest(manifest, {
-    ...options,
-    skipSnapshot: true,
-    dev: !isBuild,
-  });
-
-  if (isBuild) {
-    // Ensure that build dir is empty
-    await fs.emptyDir(outDir);
-    await build(join(dir, "fresh.gen.ts"), options);
+  if (Deno.args.includes("build")) {
+    const config = await getFreshConfigWithDefaults(
+      manifest,
+      options ?? {},
+    );
+    config.dev = false;
+    config.loadSnapshot = false;
+    await build(config);
   } else if (options) {
-    await startFromContext(ctx, options);
+    const config = await getFreshConfigWithDefaults(
+      manifest,
+      options,
+    );
+    config.dev = true;
+    config.loadSnapshot = false;
+    const ctx = await getServerContext(config);
+    await startFromContext(ctx, config.server);
   } else {
     // Legacy entry point: Back then `dev.ts` would call `main.ts` but
     // this causes duplicate plugin instantiation if both `dev.ts` and
     // `main.ts` instantiate plugins.
+    Deno.env.set("__FRSH_LEGACY_DEV", "true");
+    entrypoint = new URL(entrypoint, base).href;
     await import(entrypoint);
   }
 }
diff --git a/src/dev/imports.ts b/src/dev/imports.ts
index 54e47f8b431..b257a2e72d8 100644
--- a/src/dev/imports.ts
+++ b/src/dev/imports.ts
@@ -1,7 +1,7 @@
-export const RECOMMENDED_PREACT_VERSION = "10.15.1";
-export const RECOMMENDED_PREACT_RTS_VERSION = "6.2.1";
-export const RECOMMENDED_PREACT_SIGNALS_VERSION = "1.1.3";
-export const RECOMMENDED_PREACT_SIGNALS_CORE_VERSION = "1.2.3";
+export const RECOMMENDED_PREACT_VERSION = "10.18.1";
+export const RECOMMENDED_PREACT_RTS_VERSION = "6.2.2";
+export const RECOMMENDED_PREACT_SIGNALS_VERSION = "1.2.1";
+export const RECOMMENDED_PREACT_SIGNALS_CORE_VERSION = "1.5.0";
 export const RECOMMENDED_TWIND_VERSION = "0.16.19";
 export const RECOMMENDED_STD_VERSION = "0.193.0";
 
diff --git a/src/dev/mod.ts b/src/dev/mod.ts
index 834802f1bb8..401ec4bd5fa 100644
--- a/src/dev/mod.ts
+++ b/src/dev/mod.ts
@@ -1,7 +1,7 @@
 import { gte, join, posix, relative, walk, WalkEntry } from "./deps.ts";
 import { error } from "./error.ts";
-
 const MIN_DENO_VERSION = "1.31.0";
+const TEST_FILE_PATTERN = /[._]test\.(?:[tj]sx?|[mc][tj]s)$/;
 
 export function ensureMinDenoVersion() {
   // Check that the minimum supported Deno version is being used.
@@ -23,6 +23,7 @@ export function ensureMinDenoVersion() {
 async function collectDir(
   dir: string,
   callback: (entry: WalkEntry, dir: string) => void,
+  ignoreFilePattern = TEST_FILE_PATTERN,
 ): Promise<void> {
   // Check if provided path is a directory
   try {
@@ -37,6 +38,7 @@ async function collectDir(
     includeDirs: false,
     includeFiles: true,
     exts: ["tsx", "jsx", "ts", "js"],
+    skip: [ignoreFilePattern],
   });
 
   for await (const entry of routesFolder) {
@@ -50,7 +52,10 @@ export interface Manifest {
 }
 
 const GROUP_REG = /[/\\\\]\((_[^/\\\\]+)\)[/\\\\]/;
-export async function collect(directory: string): Promise<Manifest> {
+export async function collect(
+  directory: string,
+  ignoreFilePattern?: RegExp,
+): Promise<Manifest> {
   const filePaths = new Set<string>();
 
   const routes: string[] = [];
@@ -78,11 +83,11 @@ export async function collect(directory: string): Promise<Manifest> {
       }
       filePaths.add(normalized);
       routes.push(rel);
-    }),
+    }, ignoreFilePattern),
     collectDir(join(directory, "./islands"), (entry, dir) => {
       const rel = join("islands", relative(dir, entry.path));
       islands.push(rel);
-    }),
+    }, ignoreFilePattern),
   ]);
 
   routes.sort();
diff --git a/src/dev/update_check.ts b/src/dev/update_check.ts
index d327c841299..21338e17e1f 100644
--- a/src/dev/update_check.ts
+++ b/src/dev/update_check.ts
@@ -128,9 +128,7 @@ export async function updateCheck(
       `    Fresh ${latest} is available. You're on ${current}`,
     );
     console.log(
-      colors.dim(
-        `    To upgrade, run: `,
-      ) + colors.dim(`deno run -A -r https://fresh.deno.dev/update .`),
+      `    To upgrade, run: deno run -A -r https://fresh.deno.dev/update`,
     );
     console.log();
   }
diff --git a/src/runtime/Partial.tsx b/src/runtime/Partial.tsx
new file mode 100644
index 00000000000..caa837e5d10
--- /dev/null
+++ b/src/runtime/Partial.tsx
@@ -0,0 +1,20 @@
+import { ComponentChildren, VNode } from "preact";
+
+export interface PartialProps {
+  children?: ComponentChildren;
+  /**
+   * The name of the partial. This value must be unique across partials.
+   */
+  name: string;
+  /**
+   * Define how the new HTML should be applied.
+   * @default {"replace"}
+   */
+  mode?: "replace" | "prepend" | "append";
+}
+
+export function Partial(props: PartialProps): VNode {
+  // deno-lint-ignore no-explicit-any
+  return props.children as any;
+}
+Partial.displayName = "Partial";
diff --git a/src/runtime/active_url.ts b/src/runtime/active_url.ts
new file mode 100644
index 00000000000..60f4418aeba
--- /dev/null
+++ b/src/runtime/active_url.ts
@@ -0,0 +1,44 @@
+import { VNode } from "preact";
+import { DATA_ANCESTOR, DATA_CURRENT } from "../constants.ts";
+
+export const enum UrlMatchKind {
+  None,
+  Ancestor,
+  Current,
+}
+
+export function matchesUrl(current: string, needle: string): UrlMatchKind {
+  let href = new URL(needle, "http://localhost").pathname;
+  if (href !== "/" && href.endsWith("/")) {
+    href = href.slice(0, -1);
+  }
+
+  if (current !== "/" && current.endsWith("/")) {
+    current = current.slice(0, -1);
+  }
+
+  if (current === href) {
+    return UrlMatchKind.Current;
+  } else if (current.startsWith(href + "/") || href === "/") {
+    return UrlMatchKind.Ancestor;
+  }
+
+  return UrlMatchKind.None;
+}
+
+/**
+ * Mark active or ancestor link
+ * Note: This function is used both on the server and the client
+ */
+export function setActiveUrl(vnode: VNode, pathname: string): void {
+  const props = vnode.props as Record<string, unknown>;
+  const hrefProp = props.href;
+  if (typeof hrefProp === "string" && hrefProp.startsWith("/")) {
+    const match = matchesUrl(pathname, hrefProp);
+    if (match === UrlMatchKind.Current) {
+      props[DATA_CURRENT] = "true";
+    } else if (match === UrlMatchKind.Ancestor) {
+      props[DATA_ANCESTOR] = "true";
+    }
+  }
+}
diff --git a/src/runtime/entrypoints/main.ts b/src/runtime/entrypoints/main.ts
index 96ecc883b2d..88a01d2e248 100644
--- a/src/runtime/entrypoints/main.ts
+++ b/src/runtime/entrypoints/main.ts
@@ -1,26 +1,61 @@
+import "../polyfills.ts";
 import {
+  Component,
   ComponentChildren,
   ComponentType,
   Fragment,
   h,
+  isValidElement,
   options,
   render,
   VNode,
 } from "preact";
-import { assetHashingHook } from "../utils.ts";
+import { assetHashingHook, INTERNAL_PREFIX } from "../utils.ts";
+import { type SerializedState } from "../../server/rendering/fresh_tags.tsx";
+import type { Signal } from "@preact/signals";
+import {
+  CLIENT_NAV_ATTR,
+  DATA_ANCESTOR,
+  DATA_CURRENT,
+  DATA_KEY_ATTR,
+  LOADING_ATTR,
+  PARTIAL_ATTR,
+  PARTIAL_SEARCH_PARAM,
+  PartialMode,
+} from "../../constants.ts";
+import { matchesUrl, setActiveUrl, UrlMatchKind } from "../active_url.ts";
 
 function createRootFragment(
   parent: Element,
-  replaceNode: Node | Node[],
-  endMarker: Text,
+  startMarker: Text | Comment,
+  // We need an end marker for islands because multiple
+  // islands can share the same parent node. Since
+  // islands are root-level render calls any calls to
+  // `.appendChild` would lead to a wrong result.
+  endMarker: Text | Comment,
 ) {
-  replaceNode = ([] as Node[]).concat(replaceNode);
   // @ts-ignore this is fine
   return parent.__k = {
+    _frshRootFrag: true,
     nodeType: 1,
     parentNode: parent,
-    firstChild: replaceNode[0],
-    childNodes: replaceNode,
+    nextSibling: null,
+    get firstChild() {
+      const child = startMarker.nextSibling;
+      if (child === endMarker) return null;
+      return child;
+    },
+    get childNodes() {
+      const children: ChildNode[] = [];
+
+      let child = startMarker.nextSibling;
+      while (child !== null && child !== endMarker) {
+        children.push(child);
+        child = child.nextSibling;
+      }
+
+      return children;
+    },
     insertBefore(node: Node, child: Node | null) {
       parent.insertBefore(node, child ?? endMarker);
     },
@@ -44,14 +79,17 @@ function isTextNode(node: Node): node is Text {
   return node.nodeType === Node.TEXT_NODE;
 }
 function isElementNode(node: Node): node is HTMLElement {
-  return node.nodeType === Node.ELEMENT_NODE;
+  return node.nodeType === Node.ELEMENT_NODE && !("_frshRootFrag" in node);
 }
 
+type IslandRegistry = Record<string, Record<string, ComponentType>>;
+
 export function revive(
-  islands: Record<string, Record<string, ComponentType>>,
+  islands: IslandRegistry,
   // deno-lint-ignore no-explicit-any
   props: any[],
 ) {
+  const result: RenderRequest[] = [];
   _walkInner(
     islands,
     props,
@@ -59,13 +97,37 @@ export function revive(
     [],
     // Keep a root node in the vnode stack to save a couple of checks
     // later during iteration
-    [h(Fragment, null)],
+    [h(Fragment, null) as VNode],
     document.body,
+    result,
   );
+
+  for (let i = 0; i < result.length; i++) {
+    const { vnode, marker, rootFragment } = result[i];
+    const _render = () => {
+      render(
+        vnode,
+        rootFragment,
+      );
+
+      if (marker.kind === MarkerKind.Partial) {
+        // deno-lint-ignore no-explicit-any
+        partials.set(marker.text, (vnode as any).__c);
+      }
+    };
+
+    "scheduler" in window
+      // `scheduler.postTask` is async but that can easily
+      // fire in the background. We don't want waiting for
+      // the hydration of an island block us.
+      // @ts-ignore scheduler API is not in types yet
+      ? scheduler!.postTask(_render)
+      : setTimeout(_render, 0);
+  }
 }
 
 function ServerComponent(
-  props: { children: ComponentChildren },
+  props: { children: ComponentChildren; id: string },
 ): ComponentChildren {
   return props.children;
 }
@@ -73,7 +135,7 @@ ServerComponent.displayName = "PreactServerComponent";
 
 function addPropsChild(parent: VNode, vnode: ComponentChildren) {
   const props = parent.props;
-  if (props.children === null) {
+  if (props.children == null) {
     props.children = vnode;
   } else {
     if (!Array.isArray(props.children)) {
@@ -84,21 +146,110 @@ function addPropsChild(parent: VNode, vnode: ComponentChildren) {
   }
 }
 
+class PartialComp extends Component<
+  { children?: ComponentChildren; mode: number; name: string }
+> {
+  render() {
+    return this.props.children;
+  }
+}
+
 const enum MarkerKind {
   Island,
   Slot,
+  Partial,
 }
 
 interface Marker {
   kind: MarkerKind;
-  // We can remove this once we drop support for RTS <6.1.0 where
-  // we rendered incorrect comments leading to `!--` and `--` being
-  // included in the comment text. Therefore this is a normalized
-  // string representing the actual intended comment value which makes
-  // a bunch of stuff easier.
   text: string;
-  startNode: Comment | null;
-  endNode: Comment | null;
+  startNode: Text | Comment | null;
+  endNode: Text | Comment | null;
+}
+
+export interface RenderRequest {
+  vnode: VNode;
+  marker: Marker;
+  rootFragment: HTMLElement;
+}
+
+// Useful for debugging
+const SHOW_MARKERS = false;
+
+const partials = new Map<string, PartialComp>();
+
+/**
+ * Replace comment markers with empty text nodes to hide them
+ * in DevTools. This is done to avoid user confusion.
+ */
+function hideMarker(marker: Marker) {
+  const { startNode, endNode } = marker;
+  const parent = endNode!.parentNode!;
+
+  if (
+    !SHOW_MARKERS && startNode !== null &&
+    startNode.nodeType === Node.COMMENT_NODE
+  ) {
+    const text = new Text("");
+    marker.startNode = text;
+    parent.insertBefore(text, startNode);
+    startNode.remove();
+  }
+
+  if (
+    !SHOW_MARKERS && endNode !== null && endNode.nodeType === Node.COMMENT_NODE
+  ) {
+    const text = new Text("");
+    marker.endNode = text;
+    parent.insertBefore(text, endNode);
+    endNode.remove();
+  }
+}
+
+/**
+ * If an islands children are `null` then it might be a conditionally
+ * rendered one which was initially not visible. In these cases we
+ * send a `<template>` tag with the "would be rendered" children to
+ * the client. This function checks for that
+ */
+function addChildrenFromTemplate(
+  islands: Record<string, Record<string, ComponentType>>,
+  // deno-lint-ignore no-explicit-any
+  props: any[],
+  markerStack: Marker[],
+  vnodeStack: VNode[],
+  comment: string,
+  result: RenderRequest[],
+) {
+  const [id, exportName, n] = comment.slice("/frsh-".length).split(
+    ":",
+  );
+
+  const sel = `#frsh-slot-${id}-${exportName}-${n}-children`;
+  const template = document.querySelector(sel) as
+    | HTMLTemplateElement
+    | null;
+
+  if (template !== null) {
+    markerStack.push({
+      kind: MarkerKind.Slot,
+      endNode: null,
+      startNode: null,
+      text: comment.slice(1),
+    });
+
+    const node = template.content.cloneNode(true);
+    _walkInner(
+      islands,
+      props,
+      markerStack,
+      vnodeStack,
+      node,
+      result,
+    );
+
+    markerStack.pop();
+  }
 }
 
 /**
@@ -136,6 +287,7 @@ function _walkInner(
   markerStack: Marker[],
   vnodeStack: VNode[],
   node: Node | Comment,
+  result: RenderRequest[],
 ) {
   let sib: Node | null = node;
   while (sib !== null) {
@@ -160,7 +312,30 @@ function _walkInner(
           kind: MarkerKind.Slot,
         });
         // @ts-ignore TS gets confused
-        vnodeStack.push(h(ServerComponent, { key: comment }));
+        vnodeStack.push(h(ServerComponent, { id: comment }));
+      } else if (comment.startsWith("frsh-partial")) {
+        // TODO: Partial key
+        const [_, name, mode, key] = comment.split(":");
+        markerStack.push({
+          startNode: sib,
+          text: name,
+          endNode: null,
+          kind: MarkerKind.Partial,
+        });
+
+        vnodeStack.push(
+          h(PartialComp, { name, key, mode: +mode }) as VNode,
+        );
+      } else if (comment.startsWith("frsh-key")) {
+        const key = comment.slice("frsh-key:".length);
+        vnodeStack.push(h(Fragment, { key }) as VNode);
+      } else if (comment.startsWith("/frsh-key")) {
+        const vnode = vnodeStack.pop();
+        const parent = vnodeStack[vnodeStack.length - 1]!;
+        addPropsChild(parent, vnode);
+
+        sib = sib.nextSibling;
+        continue;
       } else if (
         marker !== null && (
           comment.startsWith("/frsh") ||
@@ -172,123 +347,103 @@ function _walkInner(
         marker.endNode = sib;
 
         markerStack.pop();
-        const parent = markerStack.length > 0
-          ? markerStack[markerStack.length - 1]
-          : null;
 
         if (marker.kind === MarkerKind.Slot) {
           // If we're closing a slot than it's assumed that we're
           // inside an island
-          if (parent?.kind === MarkerKind.Island) {
-            const vnode = vnodeStack.pop();
-
-            // For now only `props.children` is supported.
-            const islandParent = vnodeStack[vnodeStack.length - 1]!;
-            // Overwrite serialized `{__slot: "children"}` with the
-            // actual vnode child.
-            islandParent.props.children = vnode;
-          }
+          const vnode = vnodeStack.pop();
 
-          // Remove markers
-          marker.startNode?.remove();
-          sib = sib.nextSibling;
-          marker.endNode.remove();
+          // For now only `props.children` is supported.
+          const islandParent = vnodeStack[vnodeStack.length - 1]!;
+          // Overwrite serialized `{__slot: "children"}` with the
+          // actual vnode child.
+          islandParent.props.children = vnode;
+
+          hideMarker(marker);
+          sib = marker.endNode.nextSibling;
           continue;
-        } else if (marker.kind === MarkerKind.Island) {
-          // We're ready to revive this island if it has
+        } else if (
+          marker !== null && (
+            marker.kind === MarkerKind.Island ||
+            marker.kind === MarkerKind.Partial
+          )
+        ) {
+          // We're ready to revive this island or partial if it has
           // no roots of its own. Otherwise we'll treat it
           // as a standard component
           if (markerStack.length === 0) {
-            const children: Node[] = [];
-
-            let child: Node | null = marker.startNode;
-            while (
-              (child = child!.nextSibling) !== null && child !== marker.endNode
-            ) {
-              children.push(child);
-            }
-
             const vnode = vnodeStack[vnodeStack.length - 1];
 
             if (vnode.props.children == null) {
-              const [id, exportName, n] = comment.slice("/frsh-".length).split(
-                ":",
+              addChildrenFromTemplate(
+                islands,
+                props,
+                markerStack,
+                vnodeStack,
+                comment,
+                result,
               );
-
-              const sel = `#frsh-slot-${id}-${exportName}-${n}-children`;
-              const template = document.querySelector(sel) as
-                | HTMLTemplateElement
-                | null;
-
-              if (template !== null) {
-                markerStack.push({
-                  kind: MarkerKind.Slot,
-                  endNode: null,
-                  startNode: null,
-                  text: "foo",
-                });
-
-                const node = template.content.cloneNode(true);
-                _walkInner(
-                  islands,
-                  props,
-                  markerStack,
-                  vnodeStack,
-                  node,
-                );
-
-                markerStack.pop();
-              }
             }
             vnodeStack.pop();
 
             const parentNode = sib.parentNode! as HTMLElement;
 
-            // We need an end marker for islands because multiple
-            // islands can share the same parent node. Since
-            // islands are root-level render calls any calls to
-            // `.appendChild` would lead to a wrong result.
-            const endMarker = new Text("");
-            parentNode.insertBefore(
-              endMarker,
+            hideMarker(marker);
+
+            const rootFragment = createRootFragment(
+              parentNode,
+              marker.startNode!,
               marker.endNode,
-            );
-
-            const _render = () =>
-              render(
-                vnode,
-                createRootFragment(
-                  parentNode,
-                  children,
-                  endMarker,
-                  // deno-lint-ignore no-explicit-any
-                ) as any as HTMLElement,
-              );
+              // deno-lint-ignore no-explicit-any
+            ) as any as HTMLElement;
+
+            result.push({
+              vnode,
+              marker,
+              rootFragment,
+            });
 
-            "scheduler" in window
-              // `scheduler.postTask` is async but that can easily
-              // fire in the background. We don't want waiting for
-              // the hydration of an island block us.
-              // @ts-ignore scheduler API is not in types yet
-              ? scheduler!.postTask(_render)
-              : setTimeout(_render, 0);
-
-            // Remove markers
-            marker.startNode?.remove();
-            sib = sib.nextSibling;
-            marker.endNode.remove();
+            sib = marker.endNode.nextSibling;
             continue;
-          } else if (parent?.kind === MarkerKind.Slot) {
-            // Treat the island as a standard component when it
-            // has an island parent or a slot parent
-            const vnode = vnodeStack.pop();
+          } else {
+            // Treat as a standard component
+            const vnode = vnodeStack[vnodeStack.length - 1];
+            if (vnode && vnode.props.children == null) {
+              addChildrenFromTemplate(
+                islands,
+                props,
+                markerStack,
+                vnodeStack,
+                comment,
+                result,
+              );
+
+              // Didn't find any template tag, proceed as usual
+              if (vnode.props.children == null) {
+                vnodeStack.pop();
+              }
+            } else {
+              vnodeStack.pop();
+            }
+
+            marker.endNode = sib;
+            hideMarker(marker);
+
             const parent = vnodeStack[vnodeStack.length - 1]!;
             addPropsChild(parent, vnode);
+
+            if (marker.kind === MarkerKind.Partial) {
+              // deno-lint-ignore no-explicit-any
+              partials.set(marker.text, (vnode as any).__c);
+            }
+
+            sib = marker.endNode.nextSibling;
+            continue;
           }
         }
       } else if (comment.startsWith("frsh")) {
         // We're opening a new island
-        const [id, exportName, n] = comment.slice(5).split(":");
+        const [id, exportName, n, key] = comment.slice(5).split(":");
         const islandProps = props[Number(n)];
 
         markerStack.push({
@@ -297,71 +452,600 @@ function _walkInner(
           text: comment,
           kind: MarkerKind.Island,
         });
-        const vnode = h(islands[id][exportName], islandProps);
+
+        const vnode = h(islands[id][exportName], islandProps) as VNode;
+        if (key) vnode.key = key;
         vnodeStack.push(vnode);
       }
     } else if (isTextNode(sib)) {
       const parentVNode = vnodeStack[vnodeStack.length - 1]!;
       if (
-        marker !== null && marker.kind === MarkerKind.Slot
+        marker !== null &&
+        (marker.kind === MarkerKind.Slot ||
+          marker.kind === MarkerKind.Partial)
       ) {
         addPropsChild(parentVNode, sib.data);
       }
     } else {
       const parentVNode = vnodeStack[vnodeStack.length - 1];
-      if (
-        marker !== null &&
-        marker.kind === MarkerKind.Slot && isElementNode(sib)
-      ) {
-        // Parse the server rendered DOM into vnodes that we can
-        // attach to the virtual-dom tree. In the future, once
-        // Preact supports a way to skip over subtrees, this
-        // can be dropped.
-        const childLen = sib.childNodes.length;
-        const props: Record<string, unknown> = {
-          children: childLen <= 1 ? null : [],
-        };
-        for (let i = 0; i < sib.attributes.length; i++) {
-          const attr = sib.attributes[i];
-
-          // Boolean attributes are always `true` when present.
-          // See: https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML
-          props[attr.nodeName] =
+
+      if (isElementNode(sib)) {
+        if (
+          marker !== null &&
+          (marker.kind === MarkerKind.Slot ||
+            marker.kind === MarkerKind.Partial)
+        ) {
+          // Parse the server rendered DOM into vnodes that we can
+          // attach to the virtual-dom tree. In the future, once
+          // Preact supports a way to skip over subtrees, this
+          // can be dropped.
+          const childLen = sib.childNodes.length;
+          const newProps: Record<string, unknown> = {
+            children: childLen <= 1 ? null : [],
+          };
+          let hasKey = false;
+          for (let i = 0; i < sib.attributes.length; i++) {
+            const attr = sib.attributes[i];
+
+            if (attr.nodeName === DATA_KEY_ATTR) {
+              hasKey = true;
+              newProps.key = attr.nodeValue;
+              continue;
+            } else if (attr.nodeName === LOADING_ATTR) {
+              const idx = attr.nodeValue;
+              const sig = props[Number(idx)][LOADING_ATTR].value;
+              // deno-lint-ignore no-explicit-any
+              (sib as any)._freshIndicator = sig;
+            }
+
+            // Boolean attributes are always `true` when present.
+            // See: https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML
+            newProps[attr.nodeName] =
+              // deno-lint-ignore no-explicit-any
+              typeof (sib as any)[attr.nodeName] === "boolean"
+                ? true
+                : attr.nodeValue;
+          }
+
+          // Remove internal fresh key
+          if (hasKey) sib.removeAttribute(DATA_KEY_ATTR);
+
+          const vnode = h(sib.localName, newProps) as VNode;
+          addPropsChild(parentVNode, vnode);
+          vnodeStack.push(vnode);
+        } else {
+          // Outside of any partial or island
+          const idx = sib.getAttribute(LOADING_ATTR);
+          if (idx !== null) {
+            const sig = props[Number(idx)][LOADING_ATTR].value;
             // deno-lint-ignore no-explicit-any
-            typeof (sib as any)[attr.nodeName] === "boolean"
-              ? true
-              : attr.nodeValue;
+            (sib as any)._freshIndicator = sig;
+          }
         }
-        const vnode = h(sib.localName, props);
-        addPropsChild(parentVNode, vnode);
-        vnodeStack.push(vnode);
       }
 
       // TODO: What about script tags?
       if (
         sib.firstChild && (sib.nodeName !== "SCRIPT")
       ) {
-        _walkInner(islands, props, markerStack, vnodeStack, sib.firstChild);
+        _walkInner(
+          islands,
+          props,
+          markerStack,
+          vnodeStack,
+          sib.firstChild,
+          result,
+        );
       }
 
-      // Pop vnode if current marker is a slot or we are an island marker
-      // that was created inside another island
+      // Pop vnode if current marker is not the a top rendering
+      // component
       if (
         marker !== null &&
-        (marker.kind === MarkerKind.Slot ||
-          markerStack.length > 1 &&
-            markerStack[markerStack.length - 2].kind === MarkerKind.Island)
+        marker.kind !== MarkerKind.Island
       ) {
         vnodeStack.pop();
       }
     }
 
+    if (sib !== null) {
+      sib = sib.nextSibling;
+    }
+  }
+}
+
+const partialErrorMessage = `Unable to process partial response.`;
+
+async function fetchPartials(url: URL, init?: RequestInit) {
+  url.searchParams.set(PARTIAL_SEARCH_PARAM, "true");
+  const res = await fetch(url, init);
+  await applyPartials(res);
+}
+
+function updateLinks(url: URL) {
+  document.querySelectorAll("a").forEach((link) => {
+    const match = matchesUrl(url.pathname, link.href);
+
+    if (match === UrlMatchKind.Current) {
+      link.setAttribute(DATA_CURRENT, "true");
+      link.removeAttribute(DATA_ANCESTOR);
+    } else if (match === UrlMatchKind.Ancestor) {
+      link.setAttribute(DATA_ANCESTOR, "true");
+      link.removeAttribute(DATA_CURRENT);
+    } else {
+      link.removeAttribute(DATA_CURRENT);
+      link.removeAttribute(DATA_ANCESTOR);
+    }
+  });
+}
+
+function collectPartials(
+  encounteredPartials: RenderRequest[],
+  islands: IslandRegistry,
+  state: SerializedState,
+  node: Node,
+) {
+  let startNode = null;
+  let sib: ChildNode | null = node.firstChild;
+  let partialCount = 0;
+  while (sib !== null) {
+    if (isCommentNode(sib)) {
+      const comment = sib.data;
+      if (comment.startsWith("frsh-partial")) {
+        startNode = sib;
+        partialCount++;
+      } else if (comment.startsWith("/frsh-partial")) {
+        partialCount--;
+        // Create a fake DOM node that spans the partial we discovered.
+        // We need to include the partial markers itself for _walkInner
+        // to register them.
+        const rootFrag = {
+          _frshRootFrag: true,
+          nodeType: 1,
+          nextSibling: null,
+          firstChild: startNode,
+          parentNode: node,
+          get childNodes() {
+            const children: ChildNode[] = [startNode!];
+            let node = startNode!;
+            while ((node = node.nextSibling) !== null) {
+              children.push(node);
+            }
+
+            return children;
+          },
+          // deno-lint-ignore no-explicit-any
+        } as any as HTMLElement;
+
+        _walkInner(
+          islands,
+          state[0] ?? [],
+          [],
+          [h(Fragment, null) as VNode],
+          rootFrag,
+          encounteredPartials,
+        );
+      }
+    } else if (partialCount === 0 && isElementNode(sib)) {
+      // Do not recurse if we know that we are inisde a partial
+      collectPartials(encounteredPartials, islands, state, sib);
+    }
+
     sib = sib.nextSibling;
   }
 }
 
+class NoPartialsError extends Error {}
+
+/**
+ * Apply partials from a HTML response
+ */
+export async function applyPartials(res: Response): Promise<void> {
+  if (!res.ok) {
+    throw new Error(partialErrorMessage);
+  }
+
+  const contentType = res.headers.get("Content-Type");
+  if (contentType !== "text/html; charset=utf-8") {
+    throw new Error(partialErrorMessage);
+  }
+
+  const resText = await res.text();
+  const doc = new DOMParser().parseFromString(resText, "text/html") as Document;
+
+  const promises: Promise<void>[] = [];
+
+  // Preload all islands because they need to be available synchronously
+  // for rendering later
+  const islands: IslandRegistry = {};
+  const dataRaw = doc.getElementById("__FRSH_PARTIAL_DATA")!;
+  let data: {
+    islands: Record<string, string>;
+    signals: string | null;
+    deserializer: string | null;
+  } | null = null;
+  if (dataRaw !== null) {
+    data = JSON.parse(dataRaw.textContent!);
+
+    promises.push(
+      ...Array.from(Object.entries(data!.islands)).map(async (entry) => {
+        islands[entry[0]] = await import(`${entry[1]}`);
+      }),
+    );
+  }
+
+  const stateDom = doc.getElementById("__FRSH_STATE")?.textContent;
+  let state: SerializedState = [[], []];
+
+  // Load all dependencies
+  let signal: (<T>(value: T) => Signal<T>) | undefined;
+  if (data !== null && data.signals !== null) {
+    promises.push(
+      import(data.signals).then((m) => {
+        signal = m.signal;
+      }),
+    );
+  }
+
+  let deserialize:
+    | ((str: string, signal?: <T>(value: T) => Signal<T>) => unknown)
+    | undefined;
+  if (stateDom && data && data.deserializer !== null) {
+    promises.push(
+      import(data.deserializer).then((mod) => deserialize = mod.deserialize),
+    );
+  }
+
+  await Promise.all(promises);
+
+  if (stateDom) {
+    state = deserialize
+      ? deserialize(stateDom, signal) as SerializedState
+      : JSON.parse(stateDom)?.v;
+  }
+
+  // Collect all partials and build up the vnode tree
+  const encounteredPartials: RenderRequest[] = [];
+  collectPartials(encounteredPartials, islands, state, doc.body);
+
+  if (encounteredPartials.length === 0) {
+    throw new NoPartialsError(
+      `Found no partials in HTML response. Please make sure to render at least one partial. Requested url: ${res.url}`,
+    );
+  }
+
+  // Update <head>
+  document.title = doc.title;
+
+  // Needs to be converted to an array otherwise somehow <link>-tags
+  // are missing.
+  Array.from(doc.head.childNodes).forEach((childNode) => {
+    const child = childNode as HTMLElement;
+
+    if (child.nodeName === "TITLE") return;
+    if (child.nodeName === "META") {
+      const meta = child as HTMLMetaElement;
+
+      // Ignore charset which is usually set site wide anyway
+      if (meta.hasAttribute("charset")) return;
+
+      const name = meta.name;
+      if (name !== "") {
+        const existing = document.head.querySelector(`meta[name="${name}"]`) as
+          | HTMLMetaElement
+          | null;
+        if (existing !== null) {
+          if (existing.content !== meta.content) {
+            existing.content = meta.content;
+          }
+        } else {
+          document.head.appendChild(meta);
+        }
+      } else {
+        const property = child.getAttribute("property");
+        const existing = document.head.querySelector(
+          `meta[property="${property}"]`,
+        ) as HTMLMetaElement | null;
+        if (existing !== null) {
+          if (existing.content !== meta.content) {
+            existing.content = meta.content;
+          }
+        } else {
+          document.head.appendChild(meta);
+        }
+      }
+    } else if (child.nodeName === "LINK") {
+      const link = child as HTMLLinkElement;
+      if (link.rel === "modulepreload") return;
+      if (link.rel === "stylesheet") {
+        // The `href` attribute may be root relative. This ensures
+        // that they both have the same format
+        const existing = Array.from(document.head.querySelectorAll("link"))
+          .find((existingLink) => existingLink.href === link.href);
+        if (existing === undefined) {
+          document.head.appendChild(link);
+        }
+      }
+    } else if (child.nodeName === "SCRIPT") {
+      const script = child as HTMLScriptElement;
+      if (script.src === `${INTERNAL_PREFIX}/refresh.js`) return;
+      // TODO: What to do with script tags?
+    } else if (child.nodeName === "STYLE") {
+      const style = child as HTMLStyleElement;
+      // TODO: Do we need a smarter merging strategy?
+      // Don't overwrie existing style sheets that are flagged as unique
+      if (style.id === "") {
+        document.head.appendChild(style);
+      }
+    }
+  });
+
+  // Update all encountered partials
+  for (let i = 0; i < encounteredPartials.length; i++) {
+    const { vnode, marker } = encounteredPartials[i];
+    const instance = partials.get(marker.text);
+
+    if (!instance) {
+      console.warn(`Partial "${marker.text}" not found. Skipping...`);
+    } else {
+      // deno-lint-ignore no-explicit-any
+      const mode = (vnode.props as any).mode;
+      let children = vnode.props.children;
+
+      // Modify children depending on the replace mode
+      if (mode === PartialMode.REPLACE) {
+        instance.props.children = children;
+      } else {
+        const oldChildren = instance.props.children;
+        const newChildren = Array.isArray(oldChildren)
+          ? oldChildren
+          : [oldChildren];
+
+        if (mode === PartialMode.APPEND) {
+          newChildren.push(children);
+        } else {
+          // Workaround for missing keys
+          if (!isValidElement(children)) {
+            children = h(Fragment, null, children);
+          }
+
+          if ((children as VNode).key == null) {
+            (children as VNode).key = newChildren.length;
+          }
+
+          // Update rendered children keys if necessary
+          // deno-lint-ignore no-explicit-any
+          const renderedChildren = (instance as any).__v.__k as VNode[] | null;
+          if (Array.isArray(renderedChildren)) {
+            for (let i = 0; i < renderedChildren.length; i++) {
+              const child = renderedChildren[i];
+              if (child.key == null) {
+                child.key = i;
+              } else {
+                // Assume list is keyed. We don't support mixed
+                // keyed an unkeyed
+                break;
+              }
+            }
+          }
+
+          for (let i = 0; i < newChildren.length; i++) {
+            const child = newChildren[i];
+            if (child.key == null) {
+              child.key = i;
+            } else {
+              // Assume list is keyed. We don't support mixed
+              // keyed an unkeyed
+              break;
+            }
+          }
+
+          newChildren.unshift(children);
+        }
+
+        instance.props.children = newChildren;
+      }
+
+      instance.setState({});
+    }
+  }
+}
+
 const originalHook = options.vnode;
 options.vnode = (vnode) => {
   assetHashingHook(vnode);
+
+  // Mark active or ancestor links
+  if (vnode.type === "a") {
+    setActiveUrl(vnode, location.pathname);
+  }
+
   if (originalHook) originalHook(vnode);
 };
+
+export interface FreshHistoryState {
+  index: number;
+  scrollX: number;
+  scrollY: number;
+}
+
+function checkClientNavEnabled() {
+  return document.querySelector(`[${CLIENT_NAV_ATTR}]`) !== null;
+}
+
+// Keep track of history state to apply forward or backward animations
+let index = history.state?.index || 0;
+if (!history.state) {
+  const state: FreshHistoryState = {
+    index,
+    scrollX,
+    scrollY,
+  };
+  history.replaceState(state, document.title);
+}
+
+document.addEventListener("click", async (e) => {
+  let el = e.target;
+  if (el && el instanceof HTMLElement) {
+    const originalEl = el;
+
+    // Check if we clicked inside an anchor link
+    if (el.nodeName !== "A") {
+      el = el.closest("a");
+    }
+
+    if (
+      // Check that we're still dealing with an anchor tag
+      el && el instanceof HTMLAnchorElement &&
+      // Check if it's an internal link
+      el.href && (!el.target || el.target === "_self") &&
+      el.origin === location.origin &&
+      // Check if it was a left click and not a right click
+      e.button === 0 &&
+      // Check that the user doesn't press a key combo to open the
+      // link in a new tab or something
+      !(e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button) &&
+      // Check that the event isn't aborted already
+      !e.defaultPrevented
+    ) {
+      const partial = el.getAttribute(PARTIAL_ATTR);
+
+      // Check if the user opted out of client side navigation.
+      if (
+        !checkClientNavEnabled() ||
+        el.closest(`[${CLIENT_NAV_ATTR}="true"]`) === null
+      ) {
+        return;
+      }
+
+      // deno-lint-ignore no-explicit-any
+      const indicator = (el as any)._freshIndicator;
+      if (indicator !== undefined) {
+        indicator.value = true;
+      }
+
+      e.preventDefault();
+
+      const nextUrl = new URL(el.href);
+      try {
+        // Only add history entry when URL is new. Still apply
+        // the partials because sometimes users click a link to
+        // "refresh" the current page.
+        if (el.href !== window.location.href) {
+          const state: FreshHistoryState = {
+            index,
+            scrollX: window.scrollX,
+            scrollY: window.scrollY,
+          };
+
+          // Store current scroll position
+          history.replaceState({ ...state }, "", location.href);
+
+          // Now store the new position
+          index++;
+          state.scrollX = 0;
+          state.scrollY = 0;
+          history.pushState(state, "", nextUrl.href);
+        }
+
+        const partialUrl = new URL(
+          partial ? partial : nextUrl.href,
+          location.href,
+        );
+        await fetchPartials(partialUrl);
+        updateLinks(nextUrl);
+        scrollTo({ left: 0, top: 0, behavior: "instant" });
+      } finally {
+        if (indicator !== undefined) {
+          indicator.value = false;
+        }
+      }
+    } else {
+      let button: HTMLButtonElement | HTMLElement | null = originalEl;
+      // Check if we clicked on a button
+      if (button.nodeName !== "A") {
+        button = button.closest("button");
+      }
+
+      if (button !== null && button instanceof HTMLButtonElement) {
+        const partial = button.getAttribute(PARTIAL_ATTR);
+
+        // Check if the user opted out of client side navigation.
+        if (
+          partial === null ||
+          !checkClientNavEnabled() ||
+          button.closest(`[${CLIENT_NAV_ATTR}="true"]`) === null
+        ) {
+          return;
+        }
+
+        const partialUrl = new URL(
+          partial,
+          location.href,
+        );
+        await fetchPartials(partialUrl);
+      }
+    }
+  }
+});
+
+addEventListener("popstate", async (e) => {
+  // When state is `null` then the browser navigated to a document
+  // fragment. In this case we do nothing.
+  if (e.state === null) {
+    // Reset to browser default
+    if (history.scrollRestoration) {
+      history.scrollRestoration = "auto";
+    }
+    return;
+  }
+
+  const state: FreshHistoryState = history.state;
+  const nextIdx = state.index ?? index + 1;
+  index = nextIdx;
+
+  if (!checkClientNavEnabled()) {
+    location.reload();
+    return;
+  }
+
+  // We need to keep track of that ourselves since we do client side
+  // navigation.
+  if (history.scrollRestoration) {
+    history.scrollRestoration = "manual";
+  }
+
+  const url = new URL(location.href, location.origin);
+  try {
+    await fetchPartials(url);
+    updateLinks(url);
+    scrollTo({
+      left: state.scrollX ?? 0,
+      top: state.scrollY ?? 0,
+      behavior: "instant",
+    });
+  } catch (err) {
+    // If the response didn't contain a partial, then we can only
+    // do a reload.
+    if (err instanceof NoPartialsError) {
+      location.reload();
+      return;
+    }
+
+    throw err;
+  }
+});
+
+// Form submit
+document.addEventListener("submit", async (e) => {
+  const el = e.target;
+  if (el !== null && el instanceof HTMLFormElement && !e.defaultPrevented) {
+    const partial = el.getAttribute(PARTIAL_ATTR);
+    if (partial !== null) {
+      e.preventDefault();
+
+      const url = new URL(partial, location.href);
+      await fetchPartials(url);
+    }
+  }
+});
diff --git a/src/runtime/polyfills.ts b/src/runtime/polyfills.ts
new file mode 100644
index 00000000000..948fa5f1863
--- /dev/null
+++ b/src/runtime/polyfills.ts
@@ -0,0 +1,5 @@
+// Polyfill for old safari versions
+if (typeof globalThis === "undefined") {
+  // @ts-ignore polyfill
+  window.globalThis = window;
+}
diff --git a/src/server/__snapshots__/code_frame_test.ts.snap b/src/server/__snapshots__/code_frame_test.ts.snap
new file mode 100644
index 00000000000..f123ffd0ea2
--- /dev/null
+++ b/src/server/__snapshots__/code_frame_test.ts.snap
@@ -0,0 +1,58 @@
+export const snapshot = {};
+
+snapshot[`createCodeFrame markers 1`] = `
+"
+  1 | foo
+> 2 | bar
+    |   ^
+  3 | baz
+"
+`;
+
+snapshot[`createCodeFrame markers 2`] = `
+"
+> 1 | foo
+    | ^
+  2 | bar
+  3 | baz
+"
+`;
+
+snapshot[`createCodeFrame markers 3`] = `
+"
+  1 | foo
+  2 | bar
+> 3 | baz
+    |   ^
+"
+`;
+
+snapshot[`createCodeFrame markers 4`] = `
+"
+   7 | 
+   8 | 
+>  9 | bar
+     | ^
+  10 | 
+  11 | 
+  12 | bar
+"
+`;
+
+snapshot[`createCodeFrame with indentation 1`] = `
+"
+  1 | foo
+> 2 |       bar
+    |       ^
+  3 | baz
+"
+`;
+
+snapshot[`createCodeFrame with indentation 2`] = `
+"
+  1 | foo
+> 2 |     bar
+    |     ^
+  3 | baz
+"
+`;
diff --git a/src/server/boot.ts b/src/server/boot.ts
index b949289e60d..bf44efdf9a9 100644
--- a/src/server/boot.ts
+++ b/src/server/boot.ts
@@ -1,8 +1,11 @@
 import { ServerContext } from "./context.ts";
 import { colors } from "./deps.ts";
-import { ServeHandler, StartOptions } from "./types.ts";
+import { ServeHandler } from "./types.ts";
 
-export async function startFromContext(ctx: ServerContext, opts: StartOptions) {
+export async function startFromContext(
+  ctx: ServerContext,
+  opts: Partial<Deno.ServeTlsOptions>,
+) {
   if (!opts.onListen) {
     opts.onListen = (params) => {
       console.log();
@@ -56,11 +59,25 @@ export async function startFromContext(ctx: ServerContext, opts: StartOptions) {
   }
 }
 
-async function bootServer(handler: ServeHandler, opts: StartOptions) {
+async function bootServer(
+  handler: ServeHandler,
+  opts: Partial<Deno.ServeTlsOptions>,
+) {
   // @ts-ignore Ignore type error when type checking with Deno versions
   if (typeof Deno.serve === "function") {
     // @ts-ignore Ignore type error when type checking with Deno versions
-    await Deno.serve(opts, handler).finished;
+    await Deno.serve(
+      opts,
+      (r, { remoteAddr }) =>
+        handler(r, {
+          remoteAddr,
+          localAddr: {
+            transport: "tcp",
+            hostname: opts.hostname ?? "localhost",
+            port: opts.port,
+          } as Deno.NetAddr,
+        }),
+    ).finished;
   } else {
     // @ts-ignore Deprecated std serve way
     await serve(handler, opts);
diff --git a/src/server/code_frame.ts b/src/server/code_frame.ts
new file mode 100644
index 00000000000..6827dafcd05
--- /dev/null
+++ b/src/server/code_frame.ts
@@ -0,0 +1,127 @@
+import { colors, fromFileUrl } from "./deps.ts";
+
+function tabs2Spaces(str: string) {
+  return str.replace(/^\t+/, (tabs) => "  ".repeat(tabs.length));
+}
+
+/**
+ * Generate an excerpt of the location in the source around the
+ * specified position.
+ */
+export function createCodeFrame(
+  text: string,
+  lineNum: number,
+  columnNum: number,
+): string | undefined {
+  // Default settings
+  const before = 2;
+  const after = 3;
+
+  const lines = text.split("\n");
+
+  // Check if specified range is valid
+  if (lines.length <= lineNum || lines[lineNum].length < columnNum) {
+    return;
+  }
+
+  const start = Math.max(0, lineNum - before);
+  const end = Math.min(lines.length, lineNum + after + 1);
+
+  // Maximum space needed for line numbering in the current range.
+  // Necessary when the amount of digits of the line numbering grows:
+  //  999 | asdf
+  // 1000 | asdjadfjsa
+  const maxLineNum = String(end).length;
+  const padding = " ".repeat(maxLineNum);
+
+  // Normalize all indentation (=tabs) to use 2 spaces. We need to
+  // apply the difference to the marker position to move it back in
+  // place.
+  const spaceLines: string[] = [];
+  let maxLineLen = 0;
+  for (let i = start; i < end; i++) {
+    const line = tabs2Spaces(lines[i]);
+    spaceLines.push(line);
+
+    if (line.length > maxLineLen) maxLineLen = line.length;
+  }
+
+  const activeLine = spaceLines[lineNum - start];
+  // Move marker into correct place by taking the amount of
+  // normalized tabs into account
+  const count = Math.max(
+    0,
+    activeLine.length - lines[lineNum].length + columnNum,
+  );
+
+  const sep = colors.dim("|");
+  let out = "";
+
+  for (let i = 0; i < spaceLines.length; i++) {
+    const line = spaceLines[i];
+    const currentLine = colors.dim(
+      (padding + (i + start + 1)).slice(-maxLineNum),
+    );
+
+    // Line where the error occurred
+    if (i === lineNum - start) {
+      out += colors.red(">") +
+        ` ${currentLine} ${sep} ${line}\n`;
+
+      const columnMarker = colors.bold(colors.red("^"));
+      out += `  ${padding} ${sep} ${" ".repeat(count)}${columnMarker}\n`;
+    } else {
+      out += `  ${currentLine} ${sep} ${line}\n`;
+    }
+  }
+
+  return out;
+}
+
+const STACK_FRAME = /^\s*at\s+(?:(.*)\s+)?\((.*):(\d+):(\d+)\)$/;
+export interface StackFrame {
+  fnName: string;
+  file: string;
+  line: number;
+  column: number;
+}
+export function getFirstUserFile(stack: string): StackFrame | undefined {
+  const lines = stack.split("\n");
+  for (let i = 0; i < lines.length; i++) {
+    const match = lines[i].match(STACK_FRAME);
+    if (match && match) {
+      const fnName = match[1] ?? "";
+      const file = match[2];
+      const line = +match[3];
+      const column = +match[4];
+
+      if (file.startsWith("file://")) {
+        return {
+          fnName,
+          file,
+          line,
+          column,
+        };
+      }
+    }
+  }
+}
+
+export async function getCodeFrame(error: Error) {
+  if (!error.stack) return;
+
+  const file = getFirstUserFile(error.stack);
+  if (file) {
+    try {
+      const filePath = fromFileUrl(file.file);
+      const text = await Deno.readTextFile(filePath);
+      return createCodeFrame(
+        text,
+        file.line - 1,
+        file.column - 1,
+      );
+    } catch {
+      // Ignore
+    }
+  }
+}
diff --git a/src/server/code_frame_test.ts b/src/server/code_frame_test.ts
new file mode 100644
index 00000000000..826de1e23af
--- /dev/null
+++ b/src/server/code_frame_test.ts
@@ -0,0 +1,59 @@
+import { assertEquals } from "$std/testing/asserts.ts";
+import { assertSnapshot } from "$std/testing/snapshot.ts";
+import { createCodeFrame, getFirstUserFile } from "./code_frame.ts";
+import { colors } from "./deps.ts";
+
+function testCodeFrame(text: string, line: number, column: number) {
+  const codeFrame = createCodeFrame(text, line, column);
+  if (codeFrame !== undefined) {
+    return "\n" + colors.stripColor(codeFrame);
+  }
+  return codeFrame;
+}
+
+const FILE = `file://example.com/foo.js`;
+
+Deno.test("getFirstUserFile", () => {
+  let stack = `Some message
+  at asdf.foo (https://example.com/foo.js:8:20)
+  at asdf.foo (${FILE}:8:20)
+  `;
+  assertEquals(getFirstUserFile(stack), {
+    fnName: "asdf.foo",
+    file: FILE,
+    column: 20,
+    line: 8,
+  });
+
+  stack = `Some message
+  at asdf.foo (https://example.com/foo.js:8:20)
+  at (${FILE}:8:20)
+  `;
+  assertEquals(getFirstUserFile(stack), {
+    fnName: "",
+    file: FILE,
+    column: 20,
+    line: 8,
+  });
+});
+
+Deno.test("createCodeFrame invalid ranges", () => {
+  assertEquals(createCodeFrame("", 2, 10), undefined);
+  assertEquals(createCodeFrame("asdf", 2, 10), undefined);
+  assertEquals(createCodeFrame("asdf", 1, 10), undefined);
+});
+
+Deno.test("createCodeFrame markers", async (t) => {
+  await assertSnapshot(t, testCodeFrame("foo\nbar\nbaz", 1, 2));
+  await assertSnapshot(t, testCodeFrame("foo\nbar\nbaz", 0, 0));
+  await assertSnapshot(t, testCodeFrame("foo\nbar\nbaz", 2, 2));
+  await assertSnapshot(
+    t,
+    testCodeFrame("foo\n\n\n\n\n\n\n\nbar\n\n\nbar", 8, 0),
+  );
+});
+
+Deno.test("createCodeFrame with indentation", async (t) => {
+  await assertSnapshot(t, testCodeFrame("foo\n      bar\nbaz", 1, 6));
+  await assertSnapshot(t, testCodeFrame("foo\n\t\tbar\nbaz", 1, 2));
+});
diff --git a/src/server/config.ts b/src/server/config.ts
new file mode 100644
index 00000000000..da382e8a79f
--- /dev/null
+++ b/src/server/config.ts
@@ -0,0 +1,116 @@
+import { dirname, fromFileUrl, isAbsolute, join, JSONC } from "./deps.ts";
+import { FromManifestOptions, Manifest } from "./mod.ts";
+import { DenoConfig, InternalFreshOptions } from "./types.ts";
+
+export async function readDenoConfig(
+  directory: string,
+): Promise<{ config: DenoConfig; path: string }> {
+  let dir = directory;
+  while (true) {
+    for (const name of ["deno.json", "deno.jsonc"]) {
+      const path = join(dir, name);
+      try {
+        const file = await Deno.readTextFile(path);
+        if (name.endsWith(".jsonc")) {
+          return { config: JSONC.parse(file) as DenoConfig, path };
+        } else {
+          return { config: JSON.parse(file), path };
+        }
+      } catch (err) {
+        if (!(err instanceof Deno.errors.NotFound)) {
+          throw err;
+        }
+      }
+    }
+    const parent = dirname(dir);
+    if (parent === dir) {
+      throw new Error(
+        `Could not find a deno.json file in the current directory or any parent directory.`,
+      );
+    }
+    dir = parent;
+  }
+}
+
+function isObject(value: unknown) {
+  return value !== null && typeof value === "object" &&
+    !Array.isArray(value);
+}
+
+export async function getFreshConfigWithDefaults(
+  manifest: Manifest,
+  opts: FromManifestOptions,
+): Promise<InternalFreshOptions> {
+  const base = dirname(fromFileUrl(manifest.baseUrl));
+  const { config: denoJson, path: denoJsonPath } = await readDenoConfig(base);
+
+  if (typeof denoJson.importMap !== "string" && !isObject(denoJson.imports)) {
+    throw new Error(
+      "deno.json must contain an 'importMap' or 'imports' property.",
+    );
+  }
+
+  const config: InternalFreshOptions = {
+    loadSnapshot: typeof opts.skipSnapshot === "boolean"
+      ? !opts.skipSnapshot
+      : false,
+    dev: opts.dev ?? false,
+    denoJsonPath,
+    denoJson,
+    manifest,
+    build: {
+      outDir: "",
+      target: opts.build?.target ?? ["chrome99", "firefox99", "safari15"],
+    },
+    plugins: opts.plugins ?? [],
+    staticDir: "",
+    render: opts.render,
+    router: opts.router,
+    server: opts.server ?? {},
+  };
+
+  if (opts.cert) {
+    config.server.cert = opts.cert;
+  }
+  if (opts.hostname) {
+    config.server.hostname = opts.hostname;
+  }
+  if (opts.key) {
+    config.server.key = opts.key;
+  }
+  if (opts.onError) {
+    config.server.onError = opts.onError;
+  }
+  if (opts.onListen) {
+    config.server.onListen = opts.onListen;
+  }
+  if (opts.port) {
+    config.server.port = opts.port;
+  }
+  if (opts.reusePort) {
+    config.server.reusePort = opts.reusePort;
+  }
+  if (opts.signal) {
+    config.server.signal = opts.signal;
+  }
+
+  config.build.outDir = opts.build?.outDir
+    ? parseFileOrUrl(opts.build.outDir, base)
+    : join(base, "_fresh");
+
+  config.staticDir = opts.staticDir
+    ? parseFileOrUrl(opts.staticDir, base)
+    : join(base, "static");
+
+  return config;
+}
+
+function parseFileOrUrl(input: string, base: string) {
+  if (input.startsWith("file://")) {
+    return fromFileUrl(input);
+  } else if (!isAbsolute(input)) {
+    return join(base, input);
+  }
+
+  return input;
+}
diff --git a/src/server/context.ts b/src/server/context.ts
index 5491c4a9b64..4b2af5ad861 100644
--- a/src/server/context.ts
+++ b/src/server/context.ts
@@ -1,10 +1,7 @@
 import {
   colors,
-  dirname,
   extname,
-  fromFileUrl,
   join,
-  JSONC,
   Status,
   toFileUrl,
   typeByExtension,
@@ -12,10 +9,10 @@ import {
 } from "./deps.ts";
 import { ComponentType, h } from "preact";
 import * as router from "./router.ts";
-import { DenoConfig, Manifest } from "./mod.ts";
+import { Manifest } from "./mod.ts";
 import { ALIVE_URL, JS_PREFIX, REFRESH_JS_URL } from "./constants.ts";
 import { BUILD_ID, setBuildId } from "./build_id.ts";
-import DefaultErrorHandler from "./default_error_page.ts";
+import DefaultErrorHandler from "./default_error_page.tsx";
 import {
   AppModule,
   BaseRoute,
@@ -23,6 +20,7 @@ import {
   ErrorPageModule,
   FreshOptions,
   Handler,
+  InternalFreshOptions,
   Island,
   LayoutModule,
   LayoutRoute,
@@ -58,6 +56,8 @@ import {
 } from "../build/mod.ts";
 import { InternalRoute } from "./router.ts";
 import { setAllIslands } from "./rendering/preact_hooks.ts";
+import { getCodeFrame } from "./code_frame.ts";
+import { getFreshConfigWithDefaults } from "./config.ts";
 
 const DEFAULT_CONN_INFO: ServeHandlerInfo = {
   localAddr: { transport: "tcp", hostname: "localhost", port: 8080 },
@@ -66,17 +66,6 @@ const DEFAULT_CONN_INFO: ServeHandlerInfo = {
 
 const ROOT_BASE_ROUTE = toBaseRoute("/");
 
-function isObject(value: unknown) {
-  return typeof value === "object" &&
-    !Array.isArray(value) &&
-    value !== null;
-}
-
-function isDevMode() {
-  // Env var is only set in prod (on Deploy).
-  return Deno.env.get("DENO_DEPLOYMENT_ID") === undefined;
-}
-
 interface StaticFile {
   /** The URL to the static file on disk. */
   localUrl: URL;
@@ -90,6 +79,322 @@ interface StaticFile {
   etag: string;
 }
 
+export type FromManifestOptions = FreshOptions & {
+  skipSnapshot?: boolean;
+  dev?: boolean;
+};
+
+export async function getServerContext(opts: InternalFreshOptions) {
+  const { manifest, denoJson: config, denoJsonPath: configPath } = opts;
+  // Get the manifest' base URL.
+  const baseUrl = new URL("./", manifest.baseUrl).href;
+
+  // Restore snapshot if available
+  let snapshot: BuildSnapshot | null = null;
+  if (opts.loadSnapshot) {
+    const snapshotDirPath = opts.build.outDir;
+    try {
+      if ((await Deno.stat(snapshotDirPath)).isDirectory) {
+        console.log(
+          `Using snapshot found at ${colors.cyan(snapshotDirPath)}`,
+        );
+
+        const snapshotPath = join(snapshotDirPath, "snapshot.json");
+        const json = JSON.parse(
+          await Deno.readTextFile(snapshotPath),
+        ) as BuildSnapshotJson;
+        setBuildId(json.build_id);
+
+        const dependencies = new Map<string, string[]>(
+          Object.entries(json.files),
+        );
+
+        const files = new Map<string, string>();
+        Object.keys(json.files).forEach((name) => {
+          const filePath = join(snapshotDirPath, name);
+          files.set(name, filePath);
+        });
+
+        snapshot = new AotSnapshot(files, dependencies);
+      }
+    } catch (err) {
+      if (!(err instanceof Deno.errors.NotFound)) {
+        throw err;
+      }
+    }
+  }
+
+  config.compilerOptions ??= {};
+
+  let jsx: "react" | "react-jsx";
+  switch (config.compilerOptions.jsx) {
+    case "react":
+    case undefined:
+      jsx = "react";
+      break;
+    case "react-jsx":
+      jsx = "react-jsx";
+      break;
+    default:
+      throw new Error("Unknown jsx option: " + config.compilerOptions.jsx);
+  }
+
+  const jsxConfig: JSXConfig = {
+    jsx,
+    jsxImportSource: config.compilerOptions.jsxImportSource,
+  };
+
+  // Extract all routes, and prepare them into the `Page` structure.
+  const routes: Route[] = [];
+  const islands: Island[] = [];
+  const middlewares: MiddlewareRoute[] = [];
+  let app: AppModule = DEFAULT_APP;
+  const layouts: LayoutRoute[] = [];
+  let notFound: UnknownPage = DEFAULT_NOT_FOUND;
+  let error: ErrorPage = DEFAULT_ERROR;
+  const allRoutes = [
+    ...Object.entries(manifest.routes),
+    ...(opts.plugins ? getMiddlewareRoutesFromPlugins(opts.plugins) : []),
+    ...(opts.plugins ? getRoutesFromPlugins(opts.plugins) : []),
+  ];
+
+  // Presort all routes so that we only need to sort once
+  allRoutes.sort((a, b) => sortRoutePaths(a[0], b[0]));
+
+  for (
+    const [self, module] of allRoutes
+  ) {
+    const url = new URL(self, baseUrl).href;
+    if (!url.startsWith(baseUrl + "routes")) {
+      throw new TypeError("Page is not a child of the basepath.");
+    }
+    const path = url.substring(baseUrl.length).substring("routes".length);
+    const baseRoute = path.substring(1, path.length - extname(path).length);
+    const name = baseRoute.replace("/", "-");
+    const isLayout = path.endsWith("/_layout.tsx") ||
+      path.endsWith("/_layout.ts") || path.endsWith("/_layout.jsx") ||
+      path.endsWith("/_layout.js");
+    const isMiddleware = path.endsWith("/_middleware.tsx") ||
+      path.endsWith("/_middleware.ts") || path.endsWith("/_middleware.jsx") ||
+      path.endsWith("/_middleware.js");
+    if (
+      !path.startsWith("/_") && !isLayout && !isMiddleware
+    ) {
+      const { default: component, config } = module as RouteModule;
+      let pattern = pathToPattern(baseRoute);
+      if (config?.routeOverride) {
+        pattern = String(config.routeOverride);
+      }
+      let { handler } = module as RouteModule;
+      if (!handler && "handlers" in module) {
+        throw new Error(
+          `Found named export "handlers" in ${self} instead of "handler". Did you mean "handler"?`,
+        );
+      }
+      handler ??= {};
+      if (
+        component && typeof handler === "object" && handler.GET === undefined
+      ) {
+        handler.GET = (_req, { render }) => render();
+      }
+      if (
+        typeof handler === "object" && handler.GET !== undefined &&
+        handler.HEAD === undefined
+      ) {
+        const GET = handler.GET;
+        handler.HEAD = async (req, ctx) => {
+          const resp = await GET(req, ctx);
+          resp.body?.cancel();
+          return new Response(null, {
+            headers: resp.headers,
+            status: resp.status,
+            statusText: resp.statusText,
+          });
+        };
+      }
+      const route: Route = {
+        baseRoute: toBaseRoute(baseRoute),
+        pattern,
+        url,
+        name,
+        component,
+        handler,
+        csp: Boolean(config?.csp ?? false),
+        appWrapper: !config?.skipAppWrapper,
+        inheritLayouts: !config?.skipInheritedLayouts,
+      };
+      routes.push(route);
+    } else if (isMiddleware) {
+      middlewares.push({
+        baseRoute: toBaseRoute(baseRoute),
+        module: module as MiddlewareModule,
+      });
+    } else if (
+      path === "/_app.tsx" || path === "/_app.ts" ||
+      path === "/_app.jsx" || path === "/_app.js"
+    ) {
+      app = module as AppModule;
+    } else if (isLayout) {
+      const mod = module as LayoutModule;
+      const config = mod.config;
+      layouts.push({
+        baseRoute: toBaseRoute(baseRoute),
+        handler: mod.handler,
+        component: mod.default,
+        appWrapper: !config?.skipAppWrapper,
+        inheritLayouts: !config?.skipInheritedLayouts,
+      });
+    } else if (
+      path === "/_404.tsx" || path === "/_404.ts" ||
+      path === "/_404.jsx" || path === "/_404.js"
+    ) {
+      const { default: component, config } = module as UnknownPageModule;
+      let { handler } = module as UnknownPageModule;
+      if (component && handler === undefined) {
+        handler = (_req, { render }) => render();
+      }
+
+      notFound = {
+        baseRoute: ROOT_BASE_ROUTE,
+        pattern: pathToPattern(baseRoute),
+        url,
+        name,
+        component,
+        handler: handler ?? ((req) => router.defaultOtherHandler(req)),
+        csp: Boolean(config?.csp ?? false),
+        appWrapper: !config?.skipAppWrapper,
+        inheritLayouts: !config?.skipInheritedLayouts,
+      };
+    } else if (
+      path === "/_500.tsx" || path === "/_500.ts" ||
+      path === "/_500.jsx" || path === "/_500.js"
+    ) {
+      const { default: component, config } = module as ErrorPageModule;
+      let { handler } = module as ErrorPageModule;
+      if (component && handler === undefined) {
+        handler = (_req, { render }) => render();
+      }
+
+      error = {
+        baseRoute: toBaseRoute("/"),
+        pattern: pathToPattern(baseRoute),
+        url,
+        name,
+        component,
+        handler: (req, ctx) => {
+          if (opts.dev) {
+            const prevComp = error.component;
+            error.component = DefaultErrorHandler;
+            try {
+              return ctx.render();
+            } finally {
+              error.component = prevComp;
+            }
+          }
+
+          return handler
+            ? handler(req, ctx)
+            : router.defaultErrorHandler(req, ctx, ctx.error);
+        },
+        csp: Boolean(config?.csp ?? false),
+        appWrapper: !config?.skipAppWrapper,
+        inheritLayouts: !config?.skipInheritedLayouts,
+      };
+    }
+  }
+
+  for (const [self, module] of Object.entries(manifest.islands)) {
+    const url = new URL(self, baseUrl).href;
+    if (!url.startsWith(baseUrl)) {
+      throw new TypeError("Island is not a child of the basepath.");
+    }
+    let path = url.substring(baseUrl.length);
+    if (path.startsWith("islands")) {
+      path = path.slice("islands".length + 1);
+    }
+    const baseRoute = path.substring(0, path.length - extname(path).length);
+
+    for (const [exportName, exportedFunction] of Object.entries(module)) {
+      if (typeof exportedFunction !== "function") {
+        continue;
+      }
+      const name = sanitizeIslandName(baseRoute);
+      const id = `${name}_${exportName}`.toLowerCase();
+      islands.push({
+        id,
+        name,
+        url,
+        component: exportedFunction,
+        exportName,
+      });
+    }
+  }
+
+  const staticFiles: StaticFile[] = [];
+  try {
+    const staticDirUrl = toFileUrl(opts.staticDir);
+    const entries = walk(opts.staticDir, {
+      includeFiles: true,
+      includeDirs: false,
+      followSymlinks: false,
+    });
+    const encoder = new TextEncoder();
+    for await (const entry of entries) {
+      const localUrl = toFileUrl(entry.path);
+      const path = localUrl.href.substring(staticDirUrl.href.length);
+      const stat = await Deno.stat(localUrl);
+      const contentType = typeByExtension(extname(path)) ??
+        "application/octet-stream";
+      const etag = await crypto.subtle.digest(
+        "SHA-1",
+        encoder.encode(BUILD_ID + path),
+      ).then((hash) =>
+        Array.from(new Uint8Array(hash))
+          .map((byte) => byte.toString(16).padStart(2, "0"))
+          .join("")
+      );
+      const staticFile: StaticFile = {
+        localUrl,
+        path,
+        size: stat.size,
+        contentType,
+        etag,
+      };
+      staticFiles.push(staticFile);
+    }
+  } catch (err) {
+    if (err.cause instanceof Deno.errors.NotFound) {
+      // Do nothing.
+    } else {
+      throw err;
+    }
+  }
+
+  if (opts.dev) {
+    // Ensure that debugging hooks are set up for SSR rendering
+    await import("preact/debug");
+  }
+
+  return new ServerContext(
+    routes,
+    islands,
+    staticFiles,
+    opts.render ?? DEFAULT_RENDER_FN,
+    middlewares,
+    app,
+    layouts,
+    notFound,
+    error,
+    opts.plugins ?? [],
+    configPath,
+    jsxConfig,
+    opts.dev,
+    opts.router ?? DEFAULT_ROUTER_OPTIONS,
+    opts.build.target,
+    snapshot,
+  );
+}
+
 export class ServerContext {
   #dev: boolean;
   #routes: Route[];
@@ -118,8 +423,9 @@ export class ServerContext {
     plugins: Plugin[],
     configPath: string,
     jsxConfig: JSXConfig,
-    dev: boolean = isDevMode(),
+    dev: boolean,
     routerOptions: RouterOptions,
+    target: string | string[],
     snapshot: BuildSnapshot | null = null,
   ) {
     this.#routes = routes;
@@ -139,6 +445,7 @@ export class ServerContext {
       configPath,
       dev: this.#dev,
       jsxConfig,
+      target,
     });
     this.#routerOptions = routerOptions;
   }
@@ -148,316 +455,18 @@ export class ServerContext {
    */
   static async fromManifest(
     manifest: Manifest,
-    opts: FreshOptions & { skipSnapshot?: boolean; dev?: boolean },
+    opts: FromManifestOptions,
   ): Promise<ServerContext> {
-    // Get the manifest' base URL.
-    const baseUrl = new URL("./", manifest.baseUrl).href;
-
-    const { config, path: configPath } = await readDenoConfig(
-      fromFileUrl(baseUrl),
-    );
-    if (typeof config.importMap !== "string" && !isObject(config.imports)) {
-      throw new Error(
-        "deno.json must contain an 'importMap' or 'imports' property.",
-      );
-    }
+    const isLegacyDev = Deno.env.get("__FRSH_LEGACY_DEV") === "true";
+    opts.dev = isLegacyDev ||
+      Boolean(opts.dev);
 
-    // Restore snapshot if available
-    let snapshot: BuildSnapshot | null = null;
-    // Load from snapshot if not explicitly requested not to
-    const loadFromSnapshot = !opts.skipSnapshot;
-    if (loadFromSnapshot) {
-      const snapshotDirPath = join(dirname(configPath), "_fresh");
-      try {
-        if ((await Deno.stat(snapshotDirPath)).isDirectory) {
-          console.log(
-            `Using snapshot found at ${colors.cyan(snapshotDirPath)}`,
-          );
-
-          const snapshotPath = join(snapshotDirPath, "snapshot.json");
-          const json = JSON.parse(
-            await Deno.readTextFile(snapshotPath),
-          ) as BuildSnapshotJson;
-          setBuildId(json.build_id);
-
-          const dependencies = new Map<string, string[]>(
-            Object.entries(json.files),
-          );
-
-          const files = new Map<string, string>();
-          Object.keys(json.files).forEach((name) => {
-            const filePath = join(snapshotDirPath, name);
-            files.set(name, filePath);
-          });
-
-          snapshot = new AotSnapshot(files, dependencies);
-        }
-      } catch (err) {
-        if (!(err instanceof Deno.errors.NotFound)) {
-          throw err;
-        }
-      }
-    }
-
-    config.compilerOptions ??= {};
-
-    let jsx: "react" | "react-jsx";
-    switch (config.compilerOptions.jsx) {
-      case "react":
-      case undefined:
-        jsx = "react";
-        break;
-      case "react-jsx":
-        jsx = "react-jsx";
-        break;
-      default:
-        throw new Error("Unknown jsx option: " + config.compilerOptions.jsx);
+    if (isLegacyDev) {
+      opts.skipSnapshot = true;
     }
 
-    const jsxConfig: JSXConfig = {
-      jsx,
-      jsxImportSource: config.compilerOptions.jsxImportSource,
-    };
-
-    // Extract all routes, and prepare them into the `Page` structure.
-    const routes: Route[] = [];
-    const islands: Island[] = [];
-    const middlewares: MiddlewareRoute[] = [];
-    let app: AppModule = DEFAULT_APP;
-    const layouts: LayoutRoute[] = [];
-    let notFound: UnknownPage = DEFAULT_NOT_FOUND;
-    let error: ErrorPage = DEFAULT_ERROR;
-    const allRoutes = [
-      ...Object.entries(manifest.routes),
-      ...(opts.plugins ? getMiddlewareRoutesFromPlugins(opts.plugins) : []),
-      ...(opts.plugins ? getRoutesFromPlugins(opts.plugins) : []),
-    ];
-
-    // Presort all routes so that we only need to sort once
-    allRoutes.sort((a, b) => sortRoutePaths(a[0], b[0]));
-
-    for (
-      const [self, module] of allRoutes
-    ) {
-      const url = new URL(self, baseUrl).href;
-      if (!url.startsWith(baseUrl + "routes")) {
-        throw new TypeError("Page is not a child of the basepath.");
-      }
-      const path = url.substring(baseUrl.length).substring("routes".length);
-      const baseRoute = path.substring(1, path.length - extname(path).length);
-      const name = baseRoute.replace("/", "-");
-      const isLayout = path.endsWith("/_layout.tsx") ||
-        path.endsWith("/_layout.ts") || path.endsWith("/_layout.jsx") ||
-        path.endsWith("/_layout.js");
-      const isMiddleware = path.endsWith("/_middleware.tsx") ||
-        path.endsWith("/_middleware.ts") || path.endsWith("/_middleware.jsx") ||
-        path.endsWith("/_middleware.js");
-      if (
-        !path.startsWith("/_") && !isLayout && !isMiddleware
-      ) {
-        const { default: component, config } = module as RouteModule;
-        let pattern = pathToPattern(baseRoute);
-        if (config?.routeOverride) {
-          pattern = String(config.routeOverride);
-        }
-        let { handler } = module as RouteModule;
-        if (!handler && "handlers" in module) {
-          throw new Error(
-            `Found named export "handlers" in ${self} instead of "handler". Did you mean "handler"?`,
-          );
-        }
-        handler ??= {};
-        if (
-          component && typeof handler === "object" && handler.GET === undefined
-        ) {
-          handler.GET = (_req, { render }) => render();
-        }
-        if (
-          typeof handler === "object" && handler.GET !== undefined &&
-          handler.HEAD === undefined
-        ) {
-          const GET = handler.GET;
-          handler.HEAD = async (req, ctx) => {
-            const resp = await GET(req, ctx);
-            resp.body?.cancel();
-            return new Response(null, {
-              headers: resp.headers,
-              status: resp.status,
-              statusText: resp.statusText,
-            });
-          };
-        }
-        const route: Route = {
-          baseRoute: toBaseRoute(baseRoute),
-          pattern,
-          url,
-          name,
-          component,
-          handler,
-          csp: Boolean(config?.csp ?? false),
-          appWrapper: !config?.skipAppWrapper,
-          inheritLayouts: !config?.skipInheritedLayouts,
-        };
-        routes.push(route);
-      } else if (isMiddleware) {
-        middlewares.push({
-          baseRoute: toBaseRoute(baseRoute),
-          module: module as MiddlewareModule,
-        });
-      } else if (
-        path === "/_app.tsx" || path === "/_app.ts" ||
-        path === "/_app.jsx" || path === "/_app.js"
-      ) {
-        app = module as AppModule;
-      } else if (isLayout) {
-        const mod = module as LayoutModule;
-        const config = mod.config;
-        layouts.push({
-          baseRoute: toBaseRoute(baseRoute),
-          handler: mod.handler,
-          component: mod.default,
-          appWrapper: !config?.skipAppWrapper,
-          inheritLayouts: !config?.skipInheritedLayouts,
-        });
-      } else if (
-        path === "/_404.tsx" || path === "/_404.ts" ||
-        path === "/_404.jsx" || path === "/_404.js"
-      ) {
-        const { default: component, config } = module as UnknownPageModule;
-        let { handler } = module as UnknownPageModule;
-        if (component && handler === undefined) {
-          handler = (_req, { render }) => render();
-        }
-
-        notFound = {
-          baseRoute: ROOT_BASE_ROUTE,
-          pattern: pathToPattern(baseRoute),
-          url,
-          name,
-          component,
-          handler: handler ?? ((req) => router.defaultOtherHandler(req)),
-          csp: Boolean(config?.csp ?? false),
-          appWrapper: !config?.skipAppWrapper,
-          inheritLayouts: !config?.skipInheritedLayouts,
-        };
-      } else if (
-        path === "/_500.tsx" || path === "/_500.ts" ||
-        path === "/_500.jsx" || path === "/_500.js"
-      ) {
-        const { default: component, config } = module as ErrorPageModule;
-        let { handler } = module as ErrorPageModule;
-        if (component && handler === undefined) {
-          handler = (_req, { render }) => render();
-        }
-
-        error = {
-          baseRoute: toBaseRoute("/"),
-          pattern: pathToPattern(baseRoute),
-          url,
-          name,
-          component,
-          handler: handler ??
-            ((req, ctx) => router.defaultErrorHandler(req, ctx, ctx.error)),
-          csp: Boolean(config?.csp ?? false),
-          appWrapper: !config?.skipAppWrapper,
-          inheritLayouts: !config?.skipInheritedLayouts,
-        };
-      }
-    }
-
-    for (const [self, module] of Object.entries(manifest.islands)) {
-      const url = new URL(self, baseUrl).href;
-      if (!url.startsWith(baseUrl)) {
-        throw new TypeError("Island is not a child of the basepath.");
-      }
-      let path = url.substring(baseUrl.length);
-      if (path.startsWith("islands")) {
-        path = path.slice("islands".length + 1);
-      }
-      const baseRoute = path.substring(0, path.length - extname(path).length);
-
-      for (const [exportName, exportedFunction] of Object.entries(module)) {
-        if (typeof exportedFunction !== "function") {
-          continue;
-        }
-        const name = sanitizeIslandName(baseRoute);
-        const id = `${name}_${exportName}`.toLowerCase();
-        islands.push({
-          id,
-          name,
-          url,
-          component: exportedFunction,
-          exportName,
-        });
-      }
-    }
-
-    const staticFiles: StaticFile[] = [];
-    try {
-      const staticFolder = new URL(
-        opts.staticDir ?? "./static",
-        manifest.baseUrl,
-      );
-      const entries = walk(fromFileUrl(staticFolder), {
-        includeFiles: true,
-        includeDirs: false,
-        followSymlinks: false,
-      });
-      const encoder = new TextEncoder();
-      for await (const entry of entries) {
-        const localUrl = toFileUrl(entry.path);
-        const path = localUrl.href.substring(staticFolder.href.length);
-        const stat = await Deno.stat(localUrl);
-        const contentType = typeByExtension(extname(path)) ??
-          "application/octet-stream";
-        const etag = await crypto.subtle.digest(
-          "SHA-1",
-          encoder.encode(BUILD_ID + path),
-        ).then((hash) =>
-          Array.from(new Uint8Array(hash))
-            .map((byte) => byte.toString(16).padStart(2, "0"))
-            .join("")
-        );
-        const staticFile: StaticFile = {
-          localUrl,
-          path,
-          size: stat.size,
-          contentType,
-          etag,
-        };
-        staticFiles.push(staticFile);
-      }
-    } catch (err) {
-      if (err.cause instanceof Deno.errors.NotFound) {
-        // Do nothing.
-      } else {
-        throw err;
-      }
-    }
-
-    const dev = opts.dev ?? isDevMode();
-    if (dev) {
-      // Ensure that debugging hooks are set up for SSR rendering
-      await import("preact/debug");
-    }
-
-    return new ServerContext(
-      routes,
-      islands,
-      staticFiles,
-      opts.render ?? DEFAULT_RENDER_FN,
-      middlewares,
-      app,
-      layouts,
-      notFound,
-      error,
-      opts.plugins ?? [],
-      configPath,
-      jsxConfig,
-      dev,
-      opts.router ?? DEFAULT_ROUTER_OPTIONS,
-      snapshot,
-    );
+    const config = await getFreshConfigWithDefaults(manifest, opts);
+    return getServerContext(config);
   }
 
   /**
@@ -783,12 +792,12 @@ export class ServerContext {
         // deno-lint-ignore no-explicit-any
         ctx?: any,
         error?: unknown,
+        codeFrame?: string,
       ) => {
         return async (data?: Data, options?: RenderOptions) => {
           if (route.component === undefined) {
             throw new Error("This page does not have a component to render.");
           }
-
           const layouts = selectSharedRoutes(route.baseRoute, this.#layouts);
 
           const resp = await internalRender({
@@ -811,6 +820,7 @@ export class ServerContext {
             data,
             state: ctx?.state,
             error,
+            codeFrame,
           });
 
           if (resp instanceof Response) {
@@ -888,7 +898,7 @@ export class ServerContext {
       this.#error,
       Status.InternalServerError,
     );
-    const errorHandler: router.ErrorHandler<RouterState> = (
+    const errorHandler: router.ErrorHandler<RouterState> = async (
       req,
       ctx,
       error,
@@ -896,14 +906,24 @@ export class ServerContext {
       console.error(
         "%cAn error occurred during route handling or page rendering.",
         "color:red",
-        error,
       );
+      let codeFrame: string | undefined;
+      if (this.#dev && error instanceof Error) {
+        codeFrame = await getCodeFrame(error);
+
+        if (codeFrame) {
+          console.error();
+          console.error(codeFrame);
+        }
+      }
+      console.error(error);
+
       return this.#error.handler(
         req,
         {
           ...ctx,
           error,
-          render: errorHandlerRender(req, {}, ctx, error),
+          render: errorHandlerRender(req, {}, ctx, error, codeFrame),
         },
       );
     };
@@ -1159,6 +1179,7 @@ export function pathToPattern(path: string): string {
       );
     }
 
+    // Case: /[[id]].tsx
     // Case: /[id].tsx
     // Case: /[id]@[bar].tsx
     // Case: /[id]-asdf.tsx
@@ -1166,12 +1187,36 @@ export function pathToPattern(path: string): string {
     // Case: /asdf[bar].tsx
     let pattern = "";
     let groupOpen = 0;
+    let optional = false;
     for (let j = 0; j < part.length; j++) {
       const char = part[j];
       if (char === "[") {
+        if (part[j + 1] === "[") {
+          // Disallow optional dynamic params like `foo-[[bar]]`
+          if (part[j - 1] !== "/" && !!part[j - 1]) {
+            throw new SyntaxError(
+              `Invalid route pattern: "${path}". An optional parameter needs to be a full segment.`,
+            );
+          }
+          groupOpen++;
+          optional = true;
+          pattern += "{/";
+          j++;
+        }
         pattern += ":";
         groupOpen++;
       } else if (char === "]") {
+        if (part[j + 1] === "]") {
+          // Disallow optional dynamic params like `[[foo]]-bar`
+          if (part[j + 2] !== "/" && !!part[j + 2]) {
+            throw new SyntaxError(
+              `Invalid route pattern: "${path}". An optional parameter needs to be a full segment.`,
+            );
+          }
+          groupOpen--;
+          pattern += "}?";
+          j++;
+        }
         if (--groupOpen < 0) {
           throw new SyntaxError(`Invalid route pattern: "${path}"`);
         }
@@ -1180,7 +1225,7 @@ export function pathToPattern(path: string): string {
       }
     }
 
-    route += "/" + pattern;
+    route += (optional ? "" : "/") + pattern;
   }
 
   // Case: /(group)/index.tsx
@@ -1301,36 +1346,6 @@ function collectEntrypoints(
   return entryPoints;
 }
 
-async function readDenoConfig(
-  directory: string,
-): Promise<{ config: DenoConfig; path: string }> {
-  let dir = directory;
-  while (true) {
-    for (const name of ["deno.json", "deno.jsonc"]) {
-      const path = join(dir, name);
-      try {
-        const file = await Deno.readTextFile(path);
-        if (name.endsWith(".jsonc")) {
-          return { config: JSONC.parse(file) as DenoConfig, path };
-        } else {
-          return { config: JSON.parse(file), path };
-        }
-      } catch (err) {
-        if (!(err instanceof Deno.errors.NotFound)) {
-          throw err;
-        }
-      }
-    }
-    const parent = dirname(dir);
-    if (parent === dir) {
-      throw new Error(
-        `Could not find a deno.json file in the current directory or any parent directory.`,
-      );
-    }
-    dir = parent;
-  }
-}
-
 function formatMiddlewarePath(path: string): string {
   const prefix = !path.startsWith("/") ? "/" : "";
   const suffix = !path.endsWith("/") ? "/" : "";
diff --git a/src/server/context_test.ts b/src/server/context_test.ts
index 959c552d202..417b48f94e1 100644
--- a/src/server/context_test.ts
+++ b/src/server/context_test.ts
@@ -21,14 +21,28 @@ Deno.test("pathToPattern", async (t) => {
 
   await t.step("parses multiple params in same part", () => {
     assertEquals(pathToPattern("foo/[mod]@[version]"), "/foo/:mod@:version");
-
     assertEquals(pathToPattern("foo/[bar].json"), "/foo/:bar.json");
     assertEquals(pathToPattern("foo/foo[bar]"), "/foo/foo:bar");
   });
 
+  await t.step("parses optional params", () => {
+    assertEquals(pathToPattern("foo/[[name]]"), "/foo{/:name}?");
+    assertEquals(pathToPattern("foo/[name]/[[bob]]"), "/foo/:name{/:bob}?");
+    assertEquals(pathToPattern("foo/[[name]]/bar"), "/foo{/:name}?/bar");
+    assertEquals(
+      pathToPattern("foo/[[name]]/bar/[[bob]]"),
+      "/foo{/:name}?/bar{/:bob}?",
+    );
+  });
+
   await t.step("throws on invalid patterns", () => {
     assertThrows(() => pathToPattern("foo/[foo][bar]"));
     assertThrows(() => pathToPattern("foo/foo]"));
     assertThrows(() => pathToPattern("foo/[foo]]"));
+    assertThrows(() => pathToPattern("foo/foo-[[name]]-bar/baz"));
+    assertThrows(() => pathToPattern("foo/[[name]]-bar/baz"));
+    assertThrows(() => pathToPattern("foo/foo-[[name]]/baz"));
+    assertThrows(() => pathToPattern("foo/foo-[[name]]"));
+    assertThrows(() => pathToPattern("foo/[[name]]-bar"));
   });
 });
diff --git a/src/server/default_error_page.ts b/src/server/default_error_page.ts
deleted file mode 100644
index 43a6209673b..00000000000
--- a/src/server/default_error_page.ts
+++ /dev/null
@@ -1,58 +0,0 @@
-import { h } from "preact";
-import { DEBUG } from "./constants.ts";
-import type { ErrorPageProps } from "./types.ts";
-
-export default function DefaultErrorPage(props: ErrorPageProps) {
-  const { error } = props;
-
-  let message = undefined;
-  if (DEBUG) {
-    if (error instanceof Error) {
-      message = error.stack;
-    } else {
-      message = String(error);
-    }
-  }
-
-  return h(
-    "div",
-    {
-      class: "frsh-error-page",
-      style: {
-        display: "flex",
-        justifyContent: "center",
-        alignItems: "center",
-      },
-    },
-    h(
-      "div",
-      {
-        style: {
-          border: "#f3f4f6 2px solid",
-          borderTop: "red 4px solid",
-          background: "#f9fafb",
-          margin: 16,
-          minWidth: "300px",
-        },
-      },
-      h("p", {
-        style: {
-          margin: 0,
-          fontSize: "12pt",
-          padding: 16,
-          fontFamily: "sans-serif",
-        },
-      }, "An error occurred during route handling or page rendering."),
-      message && h("pre", {
-        style: {
-          margin: 0,
-          fontSize: "12pt",
-          overflowY: "auto",
-          padding: 16,
-          paddingTop: 0,
-          fontFamily: "monospace",
-        },
-      }, message),
-    ),
-  );
-}
diff --git a/src/server/default_error_page.tsx b/src/server/default_error_page.tsx
new file mode 100644
index 00000000000..f6d5463dd7c
--- /dev/null
+++ b/src/server/default_error_page.tsx
@@ -0,0 +1,134 @@
+import { ComponentChildren, h } from "preact";
+import { DEBUG } from "./constants.ts";
+import type { ErrorPageProps, RouteConfig } from "./types.ts";
+import { colors } from "$fresh/src/server/deps.ts";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+// Just to get some syntax highlighting
+const css = (arr: TemplateStringsArray, ...exts: never[]) => {
+  if (exts.length) throw new Error("Not allowed");
+  return arr[0];
+};
+
+const errorCss = css`
+  :root {
+			--bg: #fff;
+			--bg-code-frame: rgb(255, 0, 32, 0.1);
+			--bg-active-line: #fbcecc;
+			--text: #222;
+			--text2: #444;
+			--title: #e84644;
+			--code: #333;
+			font-family: sans-serif;
+			line-height: 1.4;
+			color: var(--text);
+			background: var(--bg);
+		}
+
+		* {
+			box-sizing: border-box;
+		}
+
+		@media (prefers-color-scheme: dark) {
+			:root {
+				--bg-code-frame: rgba(251, 93, 113, 0.2);
+				--bg-active-line: #4f1919;
+				--bg: #353535;
+				--text: #f7f7f7;
+				--text2: #ddd;
+				--code: #fdd1d1;
+			}
+		}
+
+		.inner {
+			max-width: 48rem;
+			padding: 4rem 1rem;
+			margin: 0 auto;
+		}
+
+		.title {
+			color: var(--title);
+			font-weight: normal;
+			font-size: 1.5rem;
+		}
+
+		.code-frame {
+			overflow: auto;
+			padding: 0.5rem;
+      margin-bottom: 0.5rem;
+			background: var(--bg-code-frame);
+			color: var(--code);
+		}
+		.line {
+			padding: 0.25rem 0.5rem;
+		}
+		.active-line {
+			display: inline-block;
+			width: 100%;
+			background: var(--bg-active-line);
+		}
+
+    .stack {
+      overflow-x: auto;
+    }
+`;
+
+export default function DefaultErrorPage(
+  props: ErrorPageProps,
+) {
+  const { error } = props;
+
+  let title = "An error occurred during route handling or page rendering.";
+
+  let codeFrame;
+  let stack;
+
+  if (DEBUG) {
+    if (error instanceof Error) {
+      title = error.message;
+      codeFrame = props.codeFrame;
+      stack = error.stack ?? "";
+    } else {
+      title = String(error);
+    }
+  }
+
+  return (
+    <div class="frsh-error-page">
+      <style id="fresh_error_styles">{errorCss}</style>
+      <div class="inner">
+        <h1 class="title">{title}</h1>
+        {codeFrame ? <CodeFrame codeFrame={codeFrame} /> : null}
+        {stack ? <pre class="stack">{stack}</pre> : null}
+      </div>
+    </div>
+  );
+}
+
+function CodeFrame(props: { codeFrame: string }) {
+  const lines: ComponentChildren[] = [];
+
+  colors.stripColor(props.codeFrame.trimEnd()).split("\n").forEach(
+    (line, i, arr) => {
+      const vnode = (
+        <span
+          class={"line" + (line.startsWith(">") ? " active-line" : "")}
+        >
+          {line}
+        </span>
+      );
+
+      lines.push(vnode);
+      if (i < arr.length - 1) lines.push("\n");
+    },
+  );
+  return (
+    <pre class="code-frame">
+      <code>{lines}</code>
+    </pre>
+  );
+}
diff --git a/src/server/deps.ts b/src/server/deps.ts
index 23e66404377..e048212bd7f 100644
--- a/src/server/deps.ts
+++ b/src/server/deps.ts
@@ -3,6 +3,7 @@ export {
   dirname,
   extname,
   fromFileUrl,
+  isAbsolute,
   join,
   toFileUrl,
 } from "https://deno.land/std@0.193.0/path/mod.ts";
diff --git a/src/server/mod.ts b/src/server/mod.ts
index 2ca0572dd29..ac35c723fd8 100644
--- a/src/server/mod.ts
+++ b/src/server/mod.ts
@@ -1,12 +1,12 @@
-import { LayoutConfig } from "$fresh/server.ts";
-import { ComponentChildren } from "preact";
 import { ServerContext } from "./context.ts";
+export type { FromManifestOptions } from "./context.ts";
 export { Status } from "./deps.ts";
 import {
   ErrorHandler,
   Handler,
   Handlers,
   IslandModule,
+  LayoutConfig,
   MiddlewareModule,
   RouteConfig,
   ServeHandlerInfo,
@@ -23,6 +23,7 @@ export {
 export type {
   AppContext,
   AppProps,
+  DenoConfig,
   ErrorHandler,
   ErrorHandlerContext,
   ErrorPageProps,
@@ -70,7 +71,8 @@ export interface Manifest {
         propsOrRequest: any,
         // deno-lint-ignore no-explicit-any
         ctx: any,
-      ) => Promise<ComponentChildren | Response> | ComponentChildren;
+        // deno-lint-ignore no-explicit-any
+      ) => Promise<any | Response> | any;
       // deno-lint-ignore no-explicit-any
       handler?: Handler<any, any> | Handlers<any, any> | UnknownHandler;
       config?: RouteConfig | LayoutConfig | ErrorHandler;
@@ -80,23 +82,6 @@ export interface Manifest {
   baseUrl: string;
 }
 
-export interface DenoConfig {
-  imports?: Record<string, string>;
-  importMap?: string;
-  tasks?: Record<string, string>;
-  lint?: {
-    rules: { tags?: string[] };
-    exclude?: string[];
-  };
-  fmt?: {
-    exclude?: string[];
-  };
-  compilerOptions?: {
-    jsx?: string;
-    jsxImportSource?: string;
-  };
-}
-
 export { ServerContext };
 
 export async function createHandler(
@@ -110,6 +95,10 @@ export async function createHandler(
 }
 
 export async function start(routes: Manifest, opts: StartOptions = {}) {
-  const ctx = await ServerContext.fromManifest(routes, opts);
-  await startFromContext(ctx, opts);
+  const ctx = await ServerContext.fromManifest(routes, {
+    ...opts,
+    skipSnapshot: false,
+    dev: false,
+  });
+  await startFromContext(ctx, opts.server ?? opts);
 }
diff --git a/src/server/render.ts b/src/server/render.ts
index 41765918aa8..6372980996f 100644
--- a/src/server/render.ts
+++ b/src/server/render.ts
@@ -39,6 +39,7 @@ export interface RenderOptions<Data> {
   data?: Data;
   state?: Record<string, unknown>;
   error?: unknown;
+  codeFrame?: string;
   lang?: string;
 }
 
@@ -153,6 +154,9 @@ export async function render<Data>(
   if (opts.error) {
     props.error = opts.error;
   }
+  if (opts.codeFrame) {
+    props.codeFrame = opts.codeFrame;
+  }
 
   const csp: ContentSecurityPolicy | undefined = opts.route.csp
     ? defaultCsp()
@@ -226,7 +230,15 @@ export async function render<Data>(
       componentFn.displayName = (fn as any).displayName || fn.name;
       componentStack[i] = componentFn;
     } else {
-      componentStack[i] = fn;
+      componentStack[i] = () => {
+        return h(fn, {
+          ...props,
+          Component() {
+            return h(componentStack[i + 1], null);
+          },
+          // deno-lint-ignore no-explicit-any
+        } as any);
+      };
     }
   }
 
@@ -311,6 +323,9 @@ export async function render<Data>(
   }
 
   await renderAsync();
+  if (renderState.error !== null) {
+    throw renderState.error;
+  }
 
   const idx = renderState.headVNodes.findIndex((vnode) =>
     vnode !== null && typeof vnode === "object" && "type" in vnode &&
diff --git a/src/server/rendering/fresh_tags.tsx b/src/server/rendering/fresh_tags.tsx
index 56685511623..fdb95329501 100644
--- a/src/server/rendering/fresh_tags.tsx
+++ b/src/server/rendering/fresh_tags.tsx
@@ -6,20 +6,7 @@ import { Plugin, PluginRenderResult, PluginRenderStyleTag } from "../types.ts";
 import { ContentSecurityPolicy, nonce } from "../../runtime/csp.ts";
 import { h } from "preact";
 
-function getRandomNonce(
-  opts: { randomNonce?: string; csp?: ContentSecurityPolicy },
-): string {
-  if (opts.randomNonce === undefined) {
-    opts.randomNonce = crypto.randomUUID().replace(/-/g, "");
-    if (opts.csp) {
-      opts.csp.directives.scriptSrc = [
-        ...opts.csp.directives.scriptSrc ?? [],
-        nonce(opts.randomNonce),
-      ];
-    }
-  }
-  return opts.randomNonce;
-}
+export type SerializedState = [islands: unknown[], plugins: unknown[]];
 
 export function renderFreshTags(
   renderState: RenderState,
@@ -33,23 +20,34 @@ export function renderFreshTags(
     pluginRenderResults: [Plugin, PluginRenderResult][];
   },
 ) {
+  const { isPartial } = renderState;
+
+  if (opts.csp) {
+    opts.csp.directives.scriptSrc = [
+      ...opts.csp.directives.scriptSrc ?? [],
+      nonce(renderState.getNonce()),
+    ];
+  }
+
   const moduleScripts: [string, string][] = [];
   for (const url of opts.imports) {
-    moduleScripts.push([url, getRandomNonce(opts)]);
+    moduleScripts.push([url, renderState.getNonce()]);
   }
 
   const preloadSet = new Set<string>();
   function addImport(path: string): string {
     const url = bundleAssetUrl(`/${path}`);
-    preloadSet.add(url);
-    for (const depPath of opts.dependenciesFn(path)) {
-      const url = bundleAssetUrl(`/${depPath}`);
+    if (!isPartial) {
       preloadSet.add(url);
+      for (const depPath of opts.dependenciesFn(path)) {
+        const url = bundleAssetUrl(`/${depPath}`);
+        preloadSet.add(url);
+      }
     }
     return url;
   }
 
-  const state: [islands: unknown[], plugins: unknown[]] = [
+  const state: SerializedState = [
     renderState.islandProps,
     [],
   ];
@@ -70,11 +68,16 @@ export function renderFreshTags(
   // Serialize the state into the <script id=__FRSH_STATE> tag and generate the
   // inline script to deserialize it. This script starts by deserializing the
   // state in the tag. This potentially requires importing @preact/signals.
+  let hasSignals = false;
+  let requiresDeserializer = false;
   if (state[0].length > 0 || state[1].length > 0) {
     const res = serialize(state);
     const escapedState = htmlEscapeJsonString(res.serialized);
     opts.bodyHtml +=
-      `<script id="__FRSH_STATE" type="application/json">${escapedState}</script>`;
+      `<script id="__FRSH_STATE" type="application/json" nonce="${renderState.getNonce()}">${escapedState}</script>`;
+
+    hasSignals = res.hasSignals;
+    requiresDeserializer = res.requiresDeserializer;
 
     if (res.requiresDeserializer) {
       const url = addImport("deserializer.js");
@@ -99,34 +102,64 @@ export function renderFreshTags(
 
   // Then it imports all plugin scripts and executes them (with their respective
   // state).
+  if (pluginScripts.length > 0) {
+    // Use `reportError` if available, otherwise throw in a different event
+    // loop tick to avoid halting the current script.
+    script +=
+      `function runPlugin(fn,args){try{fn(args)}catch(err){setTimeout(() => {throw err})}}`;
+  }
   for (const [pluginName, entrypoint, i] of pluginScripts) {
     const url = addImport(`plugin-${pluginName}-${entrypoint}.js`);
-    script += `import p${i} from "${url}";p${i}(STATE[1][${i}]);`;
+    script += `import p${i} from "${url}";runPlugin(p${i},STATE[1][${i}]);`;
   }
 
-  // Finally, it loads all island scripts and hydrates the islands using the
-  // reviver from the "main" script.
-  if (renderState.encounteredIslands.size > 0) {
+  const needsMainScript = renderState.encounteredIslands.size > 0 ||
+    renderState.partialCount > 0;
+  if (needsMainScript) {
     // Load the main.js script
     const url = addImport("main.js");
     script += `import { revive } from "${url}";`;
+  }
 
+  // Finally, it loads all island scripts and hydrates the islands using the
+  // reviver from the "main" script.
+  let islandRegistry = "";
+  const islandMapping: Record<string, string> = {};
+  if (renderState.encounteredIslands.size > 0) {
     // Prepare the inline script that loads and revives the islands
-    let islandRegistry = "";
     for (const island of renderState.encounteredIslands) {
       const url = addImport(`island-${island.id}.js`);
       script +=
         `import * as ${island.name}_${island.exportName} from "${url}";`;
       islandRegistry += `${island.id}:${island.name}_${island.exportName},`;
+      islandMapping[island.id] = url;
     }
-    script += `revive({${islandRegistry}}, STATE[0]);`;
+  }
+
+  // Always revive to detect partials
+  if (needsMainScript) {
+    script += `const propsArr = typeof STATE !== "undefined" ? STATE[0] : [];`;
+    script += `revive({${islandRegistry}}, propsArr);`;
   }
 
   // Append the inline script.
+  if (isPartial && Object.keys(islandMapping).length > 0) {
+    const escapedData = htmlEscapeJsonString(
+      JSON.stringify({
+        islands: islandMapping,
+        signals: hasSignals ? addImport("signals.js") : null,
+        deserializer: requiresDeserializer
+          ? addImport("deserializer.js")
+          : null,
+      }),
+    );
+    const nonce = renderState.csp ? ` nonce="${renderState.getNonce()}` : "";
+    opts.bodyHtml +=
+      `<script id="__FRSH_PARTIAL_DATA" type="application/json"${nonce}">${escapedData}</script>`;
+  }
   if (script !== "") {
-    opts.bodyHtml += `<script type="module" nonce="${
-      getRandomNonce(opts)
-    }">${script}</script>`;
+    opts.bodyHtml +=
+      `<script type="module" nonce="${renderState.getNonce()}">${script}</script>`;
   }
 
   if (opts.styles.length > 0) {
diff --git a/src/server/rendering/preact_hooks.ts b/src/server/rendering/preact_hooks.ts
index 122f5106540..455c6623d25 100644
--- a/src/server/rendering/preact_hooks.ts
+++ b/src/server/rendering/preact_hooks.ts
@@ -1,6 +1,7 @@
 import {
   Component,
   type ComponentChildren,
+  ComponentType,
   Fragment,
   h,
   isValidElement,
@@ -9,9 +10,33 @@ import {
   type VNode,
 } from "preact";
 import { assetHashingHook } from "../../runtime/utils.ts";
+import { Partial, PartialProps } from "../../runtime/Partial.tsx";
 import { renderToString } from "preact-render-to-string";
 import { RenderState } from "./state.ts";
 import { Island } from "../types.ts";
+import {
+  CLIENT_NAV_ATTR,
+  DATA_KEY_ATTR,
+  LOADING_ATTR,
+  PartialMode,
+} from "../../constants.ts";
+import { setActiveUrl } from "../../runtime/active_url.ts";
+
+// See: https://github.com/preactjs/preact/blob/7748dcb83cedd02e37b3713634e35b97b26028fd/src/internal.d.ts#L3C1-L16
+enum HookType {
+  useState = 1,
+  useReducer = 2,
+  useEffect = 3,
+  useLayoutEffect = 4,
+  useRef = 5,
+  useImperativeHandle = 6,
+  useMemo = 7,
+  useCallback = 8,
+  useContext = 9,
+  useErrorBoundary = 10,
+  // Not a real hook, but the devtools treat is as such
+  useDebugvalue = 11,
+}
 
 // These hooks are long stable, but when we originally added them we
 // weren't sure if they should be public.
@@ -23,6 +48,8 @@ interface AdvancedPreactOptions extends PreactOptions {
   errorBoundaries?: boolean;
   /** before diff hook */
   __b?(vnode: VNode): void;
+  /** Attach a hook that is invoked before a hook's state is queried. */
+  __h?(component: Component, index: number, type: HookType): void;
 }
 const options = preactOptions as AdvancedPreactOptions;
 
@@ -37,7 +64,7 @@ let current: RenderState | null = null;
 // passed as children.
 let ownerStack: VNode[] = [];
 // Keep track of all available islands
-const islandByComponent = new Map();
+const islandByComponent = new Map<ComponentType, Island>();
 export function setAllIslands(islands: Island[]) {
   for (let i = 0; i < islands.length; i++) {
     const island = islands[i];
@@ -55,7 +82,7 @@ export function setRenderState(state: RenderState | null): void {
 const supportsUnstableComments = renderToString(h(Fragment, {
   // @ts-ignore unstable features not supported in types
   UNSTABLE_comment: "foo",
-})) !== "";
+}) as VNode) !== "";
 
 if (!supportsUnstableComments) {
   console.warn(
@@ -115,12 +142,36 @@ function excludeChildren(props: Record<string, unknown>) {
   return out;
 }
 
+/**
+ * Check if the current component was rendered in an island
+ */
+function hasIslandOwner(current: RenderState, vnode: VNode): boolean {
+  let tmpVNode = vnode;
+  let owner;
+  while ((owner = current.owners.get(tmpVNode)) !== undefined) {
+    if (islandByComponent.has(owner.type as ComponentType)) {
+      return true;
+    }
+    tmpVNode = owner;
+  }
+
+  return false;
+}
+
+function encodePartialMode(mode: PartialProps["mode"]): PartialMode {
+  if (mode === "replace") return PartialMode.REPLACE;
+  else if (mode === "append") return PartialMode.APPEND;
+  else if (mode === "prepend") return PartialMode.PREPEND;
+  throw new Error(`Unknown partial mode "${mode}"`);
+}
+
 const patched = new WeakSet<VNode>();
 
 const oldVNodeHook = options.vnode;
 const oldDiff = options.__b;
 const oldDiffed = options.diffed;
 const oldRender = options.__r;
+const oldHook = options.__h;
 
 options.vnode = (vnode) => {
   assetHashingHook(vnode);
@@ -140,6 +191,22 @@ options.vnode = (vnode) => {
         props["ON" + key.slice(2)] = value;
       }
     }
+    // Don't do key preservation for nodes in <head>.
+    if (
+      vnode.key && vnode.type !== "meta" && vnode.type !== "title" &&
+      vnode.type !== "style" && vnode.type !== "script" && vnode.type !== "link"
+    ) {
+      props[DATA_KEY_ATTR] = vnode.key;
+    }
+
+    if (props[LOADING_ATTR]) {
+      // Avoid automatic signals unwrapping
+      props[LOADING_ATTR] = { value: props[LOADING_ATTR] };
+    }
+
+    if (typeof props[CLIENT_NAV_ATTR] === "boolean") {
+      props[CLIENT_NAV_ATTR] = props[CLIENT_NAV_ATTR] ? "true" : null;
+    }
   } else if (
     current && typeof vnode.type === "function" && vnode.type !== Fragment &&
     ownerStack.length > 0
@@ -151,6 +218,13 @@ options.vnode = (vnode) => {
 };
 
 options.__b = (vnode: VNode<Record<string, unknown>>) => {
+  // Add CSP nonce to inline script tags
+  if (typeof vnode.type === "string" && vnode.type === "script") {
+    if (!vnode.props.nonce) {
+      vnode.props.nonce = current!.getNonce();
+    }
+  }
+
   if (
     current && current.renderingUserTemplate
   ) {
@@ -195,28 +269,33 @@ options.__b = (vnode: VNode<Record<string, unknown>>) => {
           });
         }
         vnode.type = Fragment;
+      } else if (LOADING_ATTR in vnode.props) {
+        current.islandProps.push({
+          [LOADING_ATTR]: vnode.props[LOADING_ATTR],
+        });
+        vnode.props[LOADING_ATTR] = current.islandProps.length - 1;
+      } else if (vnode.type === "a") {
+        setActiveUrl(vnode, current.url.pathname);
       }
-    } else if (typeof vnode.type === "function" && vnode.type !== Fragment) {
+    } else if (typeof vnode.type === "function") {
       // Detect island vnodes and wrap them with a marker
       const island = islandByComponent.get(vnode.type);
       patchIsland:
       if (
+        vnode.type !== Fragment &&
         island &&
         !patched.has(vnode)
       ) {
+        current.islandDepth++;
+
         // Check if an island is rendered inside another island, not just
         // passed as a child.In that case we treat it like a normal
         // Component. Example:
-        //   function Island() {}
+        //   function Island() {
         //     return <OtherIsland />
         //   }
-        let tmpVNode = vnode;
-        let owner;
-        while ((owner = current.owners.get(tmpVNode)) !== undefined) {
-          if (islandByComponent.has(owner.type)) {
-            break patchIsland;
-          }
-          tmpVNode = owner;
+        if (hasIslandOwner(current, vnode)) {
+          break patchIsland;
         }
 
         // At this point we know that we need to patch the island. Mark the
@@ -268,15 +347,43 @@ options.__b = (vnode: VNode<Record<string, unknown>>) => {
             );
           }
 
-          const child = h(originalType, props);
+          const child = h(originalType, props) as VNode;
           patched.add(child);
           islandProps.push(props);
 
           return wrapWithMarker(
             child,
-            `frsh-${island.id}:${island.exportName}:${islandProps.length - 1}`,
+            `frsh-${island.id}:${island.exportName}:${islandProps.length - 1}:${
+              vnode.key ?? ""
+            }`,
           );
         };
+        // deno-lint-ignore no-explicit-any
+      } else if (vnode.type === (Partial as any)) {
+        current.partialCount++;
+        current.partialDepth++;
+        if (hasIslandOwner(current, vnode)) {
+          throw new Error(
+            `<Partial> components cannot be used inside islands.`,
+          );
+        }
+
+        const mode = encodePartialMode(
+          // deno-lint-ignore no-explicit-any
+          (vnode.props as any).mode ?? "replace",
+        );
+        vnode.props.children = wrapWithMarker(
+          vnode.props.children,
+          `frsh-partial:${vnode.props.name}:${mode}:${vnode.key ?? ""}`,
+        );
+      } else if (
+        vnode.key && (current.islandDepth > 0 || current.partialDepth > 0)
+      ) {
+        const child = h(vnode.type, vnode.props);
+        vnode.type = Fragment;
+        vnode.props = {
+          children: wrapWithMarker(child, `frsh-key:${vnode.key}`),
+        };
       }
     }
   }
@@ -294,6 +401,14 @@ options.__r = (vnode) => {
 options.diffed = (vnode: VNode<Record<string, unknown>>) => {
   if (typeof vnode.type === "function") {
     if (vnode.type !== Fragment) {
+      if (current) {
+        if (islandByComponent.has(vnode.type)) {
+          current.islandDepth--;
+        } else if (vnode.type === Partial as ComponentType) {
+          current.partialDepth--;
+        }
+      }
+
       ownerStack.pop();
     } else if (vnode.props.__freshHead) {
       if (current) {
@@ -303,3 +418,26 @@ options.diffed = (vnode: VNode<Record<string, unknown>>) => {
   }
   oldDiffed?.(vnode);
 };
+
+options.__h = (component, idx, type) => {
+  // deno-lint-ignore no-explicit-any
+  const vnode = (component as any).__v;
+  // Warn when using stateful hooks outside of islands
+  if (
+    // Only error for stateful hooks for now.
+    (type === HookType.useState || type === HookType.useReducer) && current &&
+    !islandByComponent.has(vnode.type) && !hasIslandOwner(current, vnode) &&
+    !current.error
+  ) {
+    const name = HookType[type];
+    const message =
+      `Hook "${name}" cannot be used outside of an island component.`;
+    const hint = type === HookType.useState
+      ? `\n\nInstead, use the "useSignal" hook to share state across islands.`
+      : "";
+
+    // Don't throw here because that messes up internal Preact state
+    current.error = new Error(message + hint);
+  }
+  oldHook?.(component, idx, type);
+};
diff --git a/src/server/rendering/state.ts b/src/server/rendering/state.ts
index d865e6b2238..d953b2308bb 100644
--- a/src/server/rendering/state.ts
+++ b/src/server/rendering/state.ts
@@ -1,6 +1,7 @@
 import { type ComponentChildren, type VNode } from "preact";
 import { Island } from "../types.ts";
 import { ContentSecurityPolicy } from "../../runtime/csp.ts";
+import { PARTIAL_SEARCH_PARAM } from "../../constants.ts";
 
 export interface RenderStateRouteOptions {
   url: URL;
@@ -35,6 +36,13 @@ export class RenderState {
   // Preact state
   ownerStack: VNode[] = [];
   owners = new Map<VNode, VNode>();
+  #nonce = "";
+  error: Error | null = null;
+  isPartial: boolean;
+  partialCount = 0;
+  partialDepth = 0;
+  islandDepth = 0;
+  url: URL;
 
   constructor(
     routeOptions: RenderStateRouteOptions,
@@ -46,10 +54,19 @@ export class RenderState {
     this.routeOptions = routeOptions;
     this.csp = csp;
     this.componentStack = componentStack;
+    this.url = routeOptions.url;
+    this.isPartial = routeOptions.url.searchParams.has(PARTIAL_SEARCH_PARAM);
 
     if (error) this.routeOptions.error = error;
   }
 
+  getNonce(): string {
+    if (this.#nonce === "") {
+      this.#nonce = crypto.randomUUID().replace(/-/g, "");
+    }
+    return this.#nonce;
+  }
+
   clearTmpState() {
     this.renderingUserTemplate = false;
     this.ownerStack = [];
diff --git a/src/server/rendering/template.tsx b/src/server/rendering/template.tsx
index ea948f177b0..e3bb6f135c0 100644
--- a/src/server/rendering/template.tsx
+++ b/src/server/rendering/template.tsx
@@ -1,7 +1,14 @@
 import { RenderState } from "./state.ts";
 import { setRenderState } from "./preact_hooks.ts";
 import { renderToString } from "preact-render-to-string";
-import { Fragment, h } from "preact";
+import {
+  ComponentType,
+  Fragment,
+  h,
+  isValidElement,
+  toChildArray,
+  VNode,
+} from "preact";
 import { HEAD_CONTEXT } from "../../runtime/head.ts";
 import { CSP_CONTEXT } from "../../runtime/csp.ts";
 
@@ -13,12 +20,12 @@ export function renderHtml(state: RenderState) {
   const componentStack = state.componentStack;
   try {
     const routeComponent = componentStack[componentStack.length - 1];
-    let finalComp = h(routeComponent, state.routeOptions);
+    let finalComp = h(routeComponent, state.routeOptions) as VNode;
 
     // Skip page component
     let i = componentStack.length - 1;
     while (i--) {
-      const component = componentStack[i];
+      const component = componentStack[i] as ComponentType;
       const curComp = finalComp;
 
       finalComp = h(component, {
@@ -26,7 +33,8 @@ export function renderHtml(state: RenderState) {
         Component() {
           return curComp;
         },
-      });
+        // deno-lint-ignore no-explicit-any
+      } as any) as VNode;
     }
 
     const app = h(
@@ -37,12 +45,12 @@ export function renderHtml(state: RenderState) {
         value: state.headVNodes,
         children: finalComp,
       }),
-    );
+    ) as VNode;
 
     let html = renderToString(app);
 
     for (const [id, children] of state.slots.entries()) {
-      const slotHtml = renderToString(h(Fragment, null, children));
+      const slotHtml = renderToString(h(Fragment, null, children) as VNode);
       const templateId = id.replace(/:/g, "-");
       html += `<template id="${templateId}">${slotHtml}</template>`;
     }
@@ -66,11 +74,36 @@ export function renderOuterDocument(
     docHtml,
     docHead,
     renderedHtmlTag,
-    docTitle,
     docBody,
     docHeadNodes,
     headVNodes,
   } = state;
+  let docTitle = state.docTitle;
+
+  // Filter out duplicate head vnodes by "key" if set
+  const filteredHeadNodes: VNode[] = [];
+
+  if (headVNodes.length > 0) {
+    const seen = new Map<string, VNode>();
+    const userChildren = toChildArray(headVNodes);
+    for (let i = 0; i < userChildren.length; i++) {
+      const child = userChildren[i];
+
+      if (isValidElement(child)) {
+        if (child.type === "title") {
+          docTitle = child;
+        } else if (child.key !== undefined) {
+          seen.set(child.key, child);
+        } else {
+          filteredHeadNodes.push(child);
+        }
+      }
+    }
+
+    if (seen.size > 0) {
+      filteredHeadNodes.push(...seen.values());
+    }
+  }
 
   const page = h(
     "html",
@@ -78,7 +111,7 @@ export function renderOuterDocument(
     h(
       "head",
       docHead,
-      !renderedHtmlTag ? h("meta", { charSet: "utf-8" }) : null,
+      !renderedHtmlTag ? h("meta", { charset: "utf-8" }) : null,
       !renderedHtmlTag
         ? (h("meta", {
           name: "viewport",
@@ -93,13 +126,13 @@ export function renderOuterDocument(
       opts.moduleScripts.map(([src, nonce]) =>
         h("script", { src: src, nonce, type: "module" })
       ),
-      headVNodes,
+      filteredHeadNodes,
     ),
     h("body", {
       ...docBody,
       dangerouslySetInnerHTML: { __html: opts.bodyHtml },
     }),
-  );
+  ) as VNode;
 
   try {
     setRenderState(state);
diff --git a/src/server/types.ts b/src/server/types.ts
index 3051cac5ffe..01aba104400 100644
--- a/src/server/types.ts
+++ b/src/server/types.ts
@@ -1,16 +1,120 @@
 import { ComponentChildren, ComponentType, VNode } from "preact";
 import * as router from "./router.ts";
 import { InnerRenderFunction, RenderContext } from "./render.ts";
+import { Manifest } from "./mod.ts";
+
+export interface DenoConfig {
+  imports?: Record<string, string>;
+  importMap?: string;
+  tasks?: Record<string, string>;
+  lint?: {
+    rules: { tags?: string[] };
+    exclude?: string[];
+  };
+  fmt?: {
+    exclude?: string[];
+  };
+  exclude?: string[];
+  compilerOptions?: {
+    jsx?: string;
+    jsxImportSource?: string;
+  };
+}
 
 // --- APPLICATION CONFIGURATION ---
 
-export type StartOptions = Partial<Deno.ServeTlsOptions> & FreshOptions;
+export type StartOptions = FreshOptions;
 
 export interface FreshOptions {
+  build?: {
+    /**
+     * The directory to write generated files to when `dev.ts build` is run.
+     * This can be an absolute path, a file URL or a relative path.
+     */
+    outDir?: string;
+    /**
+     * This sets the target environment for the generated code. Newer
+     * language constructs will be transformed to match the specified
+     * support range. See https://esbuild.github.io/api/#target
+     * @default {"es2022"}
+     */
+    target?: string | string[];
+  };
   render?: RenderFunction;
   plugins?: Plugin[];
   staticDir?: string;
   router?: RouterOptions;
+  server?: Partial<Deno.ServeTlsOptions>;
+
+  // Older versions of Fresh merged the `Deno.ServeTlsOptions` directly.
+  // We've moved this to `server`.
+
+  /**
+   * Server private key in PEM format
+   * @deprecated Use `server.cert` instead
+   */
+  cert?: string;
+  /**
+   * Cert chain in PEM format
+   * @deprecated Use `server.key` instead
+   */
+  key?: string;
+  /**
+   * The port to listen on.
+   * @default {8000}
+   * @deprecated Use `server.port` instead
+   */
+  port?: number;
+  /**
+   * A literal IP address or host name that can be resolved to an IP address.
+   *
+   * __Note about `0.0.0.0`__ While listening `0.0.0.0` works on all platforms,
+   * the browsers on Windows don't work with the address `0.0.0.0`.
+   * You should show the message like `server running on localhost:8080` instead of
+   * `server running on 0.0.0.0:8080` if your program supports Windows.
+   *
+   * @default {"0.0.0.0"}
+   * @deprecated Use `server.hostname` instead
+   */
+  hostname?: string;
+  /**
+   * An {@linkcode AbortSignal} to close the server and all connections.
+   * @deprecated Use `server.signal` instead
+   */
+  signal?: AbortSignal;
+  /**
+   * Sets `SO_REUSEPORT` on POSIX systems.
+   * @deprecated Use `server.reusePort` instead
+   */
+  reusePort?: boolean;
+  /**
+   * The handler to invoke when route handlers throw an error.
+   * @deprecated Use `server.onError` instead
+   */
+  onError?: (error: unknown) => Response | Promise<Response>;
+
+  /**
+   * The callback which is called when the server starts listening.
+   * @deprecated Use `server.onListen` instead
+   */
+  onListen?: (params: { hostname: string; port: number }) => void;
+}
+
+export interface InternalFreshOptions {
+  dev: boolean;
+  loadSnapshot: boolean;
+  denoJsonPath: string;
+  denoJson: DenoConfig;
+  manifest: Manifest;
+  build: {
+    outDir: string;
+    target: string | string[];
+  };
+  render?: RenderFunction;
+  plugins: Plugin[];
+  staticDir: string;
+  router?: RouterOptions;
+  server: Partial<Deno.ServeTlsOptions>;
 }
 
 export interface RouterOptions {
@@ -19,6 +123,15 @@ export interface RouterOptions {
    *  @default {false}
    */
   trailingSlash?: boolean;
+  /**
+   *  Configures the pattern of files to ignore in islands and routes.
+   *
+   *  By default Fresh will ignore test files,
+   *  for example files with a `.test.ts` or a `_test.ts` suffix.
+   *
+   *  @default {/(?:[^/]*_|[^/]*\.|)test\.(?:ts|tsx|mts|js|mjs|jsx|)\/*$/}
+   */
+  ignoreFilePattern?: RegExp;
 }
 
 export type RenderFunction = (
@@ -118,14 +231,17 @@ export type ServeHandler = (
   info: ServeHandlerInfo,
 ) => Response | Promise<Response>;
 
-export interface HandlerContext<Data = unknown, State = Record<string, unknown>>
-  extends ServeHandlerInfo {
+export interface HandlerContext<
+  Data = unknown,
+  State = Record<string, unknown>,
+  NotFoundData = Data,
+> extends ServeHandlerInfo {
   params: Record<string, string>;
   render: (
     data?: Data,
     options?: RenderOptions,
   ) => Response | Promise<Response>;
-  renderNotFound: (data?: Data) => Response | Promise<Response>;
+  renderNotFound: (data?: NotFoundData) => Response | Promise<Response>;
   state: State;
 }
 
@@ -302,6 +418,9 @@ export interface ErrorPageProps {
 
   /** The error that caused the error page to be loaded. */
   error: unknown;
+
+  /** Sringified code frame (only in development mode) */
+  codeFrame?: string;
 }
 
 export interface ErrorHandlerContext<State = Record<string, unknown>>
@@ -415,6 +534,15 @@ export interface Plugin<State = Record<string, unknown>> {
    */
   renderAsync?(ctx: PluginAsyncRenderContext): Promise<PluginRenderResult>;
 
+  /**
+   * Called before running the Fresh build task
+   */
+  buildStart?(): Promise<void> | void;
+  /**
+   * Called after completing the Fresh build task
+   */
+  buildEnd?(): Promise<void> | void;
+
   routes?: PluginRoute[];
 
   middlewares?: PluginMiddleware<State>[];
diff --git a/src/types.ts b/src/types.ts
new file mode 100644
index 00000000000..fc03cfc9ae1
--- /dev/null
+++ b/src/types.ts
@@ -0,0 +1,21 @@
+export interface SignalLike<T> {
+  value: T;
+  peek(): T;
+  subscribe(fn: (value: T) => void): () => void;
+}
+
+declare global {
+  namespace preact.createElement.JSX {
+    interface HTMLAttributes {
+      /**
+       * Alternative url to fetch partials from on `<a>` or `<form>` tags
+       */
+      "f-partial"?: string | SignalLike<string>;
+      /**
+       * Enable or disable client side navigation and partials for this
+       * particular node and its children.
+       */
+      "f-client-nav"?: boolean | SignalLike<boolean>;
+    }
+  }
+}
diff --git a/tests/build_test.ts b/tests/build_test.ts
index 7b80910a982..043e4dbcdf2 100644
--- a/tests/build_test.ts
+++ b/tests/build_test.ts
@@ -1,35 +1,49 @@
 import * as path from "$std/path/mod.ts";
 import { puppeteer } from "./deps.ts";
 import { assert } from "$std/_util/asserts.ts";
-import { startFreshServer, waitForText } from "$fresh/tests/test_utils.ts";
+import {
+  getStdOutput,
+  startFreshServer,
+  waitForText,
+} from "$fresh/tests/test_utils.ts";
 import { BuildSnapshotJson } from "$fresh/src/build/mod.ts";
 import { assertStringIncludes } from "$std/testing/asserts.ts";
 import { assertNotMatch } from "$std/testing/asserts.ts";
 
-Deno.test("build snapshot and restore from it", async (t) => {
-  const fixture = path.join(Deno.cwd(), "tests", "fixture_build");
-  const outDir = path.join(fixture, "_fresh");
+function runBuild(fixture: string, subDirPath: string, outDir: string) {
+  return new Deno.Command(Deno.execPath(), {
+    args: [
+      "run",
+      "-A",
+      path.join(fixture, subDirPath, "dev.ts"),
+      "build",
+    ],
+    env: {
+      GITHUB_SHA: "__BUILD_ID__",
+      DENO_DEPLOYMENT_ID: "__BUILD_ID__",
+      FRESH_TEST_OUTDIR: outDir,
+    },
+    stdin: "null",
+    stdout: "piped",
+    stderr: "piped",
+  }).output();
+}
+
+async function testBuild(
+  t: Deno.TestContext,
+  fixture: string,
+  options: {
+    subDirPath?: string;
+    outDir?: string;
+  } = {},
+) {
+  const subDirPath = options.subDirPath ?? "";
+  const outDir = options.outDir ?? path.join(fixture, subDirPath, "_fresh");
 
   try {
     await t.step("build snapshot", async () => {
-      const res = await new Deno.Command(Deno.execPath(), {
-        args: [
-          "run",
-          "-A",
-          path.join(fixture, "dev.ts"),
-          "build",
-        ],
-        env: {
-          GITHUB_SHA: "__BUILD_ID__",
-          DENO_DEPLOYMENT_ID: "__BUILD_ID__",
-        },
-        stdin: "null",
-        stdout: "piped",
-        stderr: "inherit",
-      }).output();
-
-      const decoder = new TextDecoder();
-      const stdout = decoder.decode(res.stdout);
+      const res = await runBuild(fixture, subDirPath, outDir);
+      const { stdout } = getStdOutput(res);
       assert(
         !/Using snapshot found at/.test(stdout),
         "Using snapshot message was shown during build",
@@ -55,10 +69,6 @@ Deno.test("build snapshot and restore from it", async (t) => {
         Array.isArray(snapshot.files["signals.js"]),
         "signals.js output file not found in snapshot",
       );
-      assert(
-        Array.isArray(snapshot.files["deserializer.js"]),
-        "deserializer.js output file not found in snapshot",
-      );
 
       // Should not include `preact/debug`
       const mainJs = await Deno.readTextFile(path.join(outDir, "main.js"));
@@ -70,7 +80,7 @@ Deno.test("build snapshot and restore from it", async (t) => {
         args: [
           "run",
           "-A",
-          path.join(fixture, "./main.ts"),
+          path.join(fixture, subDirPath, "main.ts"),
         ],
       });
 
@@ -112,9 +122,11 @@ Deno.test("build snapshot and restore from it", async (t) => {
           await browser.close();
         }
       } finally {
-        await lines.cancel();
         serverProcess.kill("SIGTERM");
         await serverProcess.status;
+
+        // Drain the lines stream
+        for await (const _ of lines) { /* noop */ }
       }
     });
 
@@ -123,7 +135,7 @@ Deno.test("build snapshot and restore from it", async (t) => {
         args: [
           "run",
           "-A",
-          path.join(fixture, "./dev.ts"),
+          path.join(fixture, subDirPath, "dev.ts"),
         ],
       });
 
@@ -134,12 +146,113 @@ Deno.test("build snapshot and restore from it", async (t) => {
           "Restoring from snapshot message should not appear in dev mode",
         );
       } finally {
-        await lines.cancel();
         serverProcess.kill("SIGTERM");
         await serverProcess.status;
+
+        // Drain the lines stream
+        for await (const _ of lines) { /* noop */ }
       }
     });
   } finally {
-    await Deno.remove(path.join(fixture, "_fresh"), { recursive: true });
+    await Deno.remove(path.join(fixture, subDirPath, "_fresh"), {
+      recursive: true,
+    });
   }
+}
+
+Deno.test("build snapshot and restore from it", async (t) => {
+  // Note: If you change the fixture_build directory, you must also update fixture_build_sub_dir
+  const fixture = path.join(Deno.cwd(), "tests", "fixture_build");
+  await testBuild(t, fixture);
+});
+
+Deno.test("build snapshot and restore from it when has sub dirs", async (t) => {
+  const fixture = path.join(Deno.cwd(), "tests", "fixture_build_sub_dir");
+  await testBuild(t, fixture, { subDirPath: "src" });
+});
+
+Deno.test(
+  "build snapshot with custom build.outDir",
+  async (t) => {
+    async function assertOutputDir(outDir: string, out: Deno.CommandOutput) {
+      const { stdout, stderr } = getStdOutput(out);
+
+      const msg =
+        `Missing output directory: ${outDir}\n\nCLI output:\n${stdout}\n${stderr}`;
+
+      const dir: string | URL = outDir.startsWith("file://")
+        ? new URL(outDir)
+        : outDir;
+      try {
+        assert((await Deno.stat(dir)).isDirectory, msg);
+      } catch (err) {
+        throw new Error(msg, { cause: err });
+      }
+    }
+
+    await t.step("uses on relative outDir", async () => {
+      const fixture = path.join(Deno.cwd(), "tests", "fixture_build_out_dir");
+      const out = await runBuild(fixture, "", "./tmp/asdf");
+      const outDir = path.join(fixture, "tmp", "asdf");
+
+      await assertOutputDir(outDir, out);
+    });
+
+    await t.step("uses absolute outDir", async () => {
+      const fixture = path.join(
+        Deno.cwd(),
+        "tests",
+        "fixture_build_out_dir_sub",
+      );
+
+      const outDir = path.join(fixture, "tmp");
+      const out = await runBuild(fixture, "src", outDir);
+
+      await assertOutputDir(outDir, out);
+    });
+
+    await t.step("uses file:// outDir", async () => {
+      const fixture = path.join(
+        Deno.cwd(),
+        "tests",
+        "fixture_build_out_dir_sub2",
+      );
+
+      const outDirPath = path.join(fixture, "tmp");
+      const outDir = path.toFileUrl(outDirPath).href;
+      const out = await runBuild(fixture, "src", outDir);
+      await assertOutputDir(outDir, out);
+    });
+  },
+);
+
+Deno.test("pass target options", async () => {
+  const fixture = path.join(Deno.cwd(), "tests", "fixture_build_target");
+  const out = await new Deno.Command(Deno.execPath(), {
+    args: [
+      "run",
+      "-A",
+      path.join(fixture, "dev.ts"),
+      "build",
+    ],
+    env: {
+      GITHUB_SHA: "__BUILD_ID__",
+      DENO_DEPLOYMENT_ID: "__BUILD_ID__",
+      FRESH_TEST_TARGET: "es2015",
+    },
+    stdin: "null",
+    stdout: "piped",
+    stderr: "piped",
+  }).output();
+
+  const { stdout, stderr } = getStdOutput(out);
+  const txt = await Deno.readTextFile(
+    path.join(fixture, "_fresh", "island-counter_default.js"),
+  );
+
+  assertNotMatch(
+    txt,
+    /\?\?/,
+    `Asset contained ?? despite target es2015\n\n${stdout}\n${stderr}`,
+  );
 });
diff --git a/tests/cli_update_check_test.ts b/tests/cli_update_check_test.ts
index af19f4c34f6..1ce4158c6ec 100644
--- a/tests/cli_update_check_test.ts
+++ b/tests/cli_update_check_test.ts
@@ -1,4 +1,4 @@
-import { colors, join } from "../src/server/deps.ts";
+import { join } from "../src/server/deps.ts";
 import {
   assert,
   assertEquals,
@@ -9,18 +9,7 @@ import {
 import versions from "../versions.json" assert { type: "json" };
 import { CheckFile } from "$fresh/src/dev/update_check.ts";
 import { WEEK } from "$fresh/src/dev/deps.ts";
-
-function getStdOutput(
-  out: Deno.CommandOutput,
-): { stdout: string; stderr: string } {
-  const decoder = new TextDecoder();
-  const stdout = colors.stripColor(decoder.decode(out.stdout));
-
-  const decoderErr = new TextDecoder();
-  const stderr = colors.stripColor(decoderErr.decode(out.stderr));
-
-  return { stdout, stderr };
-}
+import { getStdOutput } from "$fresh/tests/test_utils.ts";
 
 Deno.test({
   name: "stores update check file in $HOME/fresh",
@@ -116,7 +105,6 @@ Deno.test({
 
     await Deno.remove(tmpDirName, { recursive: true });
   },
-  sanitizeResources: false,
 });
 
 Deno.test({
diff --git a/tests/deps.ts b/tests/deps.ts
index acfe0d3b32f..360beb2990f 100644
--- a/tests/deps.ts
+++ b/tests/deps.ts
@@ -7,8 +7,10 @@
 export {
   assert,
   assertEquals,
+  assertExists,
   assertMatch,
   assertNotMatch,
+  assertRejects,
   assertStringIncludes,
 } from "https://deno.land/std@0.193.0/testing/asserts.ts";
 export { assertSnapshot } from "https://deno.land/std@0.193.0/testing/snapshot.ts";
@@ -30,3 +32,9 @@ export {
 export { defineConfig, type Preset } from "https://esm.sh/@twind/core@1.1.3";
 export { default as presetTailwind } from "https://esm.sh/@twind/preset-tailwind@1.1.4";
 export * as fs from "https://deno.land/std@0.195.0/fs/mod.ts";
+export {
+  basename,
+  dirname,
+  fromFileUrl,
+  join,
+} from "https://deno.land/std@0.193.0/path/mod.ts";
diff --git a/tests/dev_command_test.ts b/tests/dev_command_test.ts
new file mode 100644
index 00000000000..3896a4a2993
--- /dev/null
+++ b/tests/dev_command_test.ts
@@ -0,0 +1,170 @@
+import { assertEquals, assertStringIncludes } from "./deps.ts";
+import { Status } from "../server.ts";
+import {
+  assertNotSelector,
+  assertSelector,
+  assertTextMany,
+  assertTextMatch,
+  fetchHtml,
+  waitForStyle,
+  withFakeServe,
+  withFresh,
+  withPageName,
+} from "./test_utils.ts";
+
+Deno.test({
+  name: "dev_command config",
+  async fn() {
+    await withPageName(
+      "./tests/fixture_dev_config/main.ts",
+      async (page, address) => {
+        await page.goto(`${address}`);
+        await waitForStyle(page, "h1", "color", "rgb(220, 38, 38)");
+      },
+    );
+  },
+});
+
+Deno.test({
+  name: "dev_command config: shows codeframe",
+  async fn() {
+    await withFakeServe(
+      "./tests/fixture_dev_config/dev.ts",
+      async (server) => {
+        const doc = await server.getHtml("/codeframe");
+        assertSelector(doc, ".frsh-error-page");
+        assertSelector(doc, ".code-frame");
+      },
+    );
+  },
+});
+
+Deno.test({
+  name: "dev_command legacy",
+  async fn() {
+    await withPageName(
+      "./tests/fixture_dev_legacy/main.ts",
+      async (page, address) => {
+        await page.goto(`${address}`);
+        await waitForStyle(page, "h1", "color", "rgb(220, 38, 38)");
+      },
+    );
+  },
+});
+
+Deno.test({
+  name: "dev_command legacy: shows codeframe",
+  async fn() {
+    await withFakeServe(
+      "./tests/fixture_dev_legacy/dev.ts",
+      async (server) => {
+        const doc = await server.getHtml("/codeframe");
+        assertSelector(doc, ".frsh-error-page");
+        assertSelector(doc, ".code-frame");
+      },
+    );
+  },
+});
+
+Deno.test("adds refresh script to html", async () => {
+  await withFakeServe("./tests/fixture/dev.ts", async (server) => {
+    const doc = await server.getHtml("/");
+    assertSelector(doc, `script[src="/_frsh/refresh.js"]`);
+
+    const res = await server.get(`/_frsh/refresh.js`);
+    assertEquals(
+      res.headers.get("content-type"),
+      "application/javascript; charset=utf-8",
+    );
+    await res.body?.cancel();
+  });
+});
+
+Deno.test("preact/debug is active in dev mode", async () => {
+  await withFakeServe(
+    "./tests/fixture_render_error/dev.ts",
+    async (server) => {
+      // SSR error is shown
+      const resp = await server.get("/");
+      const text = await resp.text();
+      assertEquals(resp.status, Status.InternalServerError);
+      assertStringIncludes(text, "Objects are not valid as a child");
+
+      const html = await server.getHtml("/");
+
+      // Error page is shown with error message
+      const text2 = html.querySelector(".frsh-error-page")!.textContent!;
+      assertStringIncludes(text2, "Objects are not valid as a child");
+    },
+  );
+});
+
+Deno.test("middleware destination internal", async () => {
+  await withFakeServe("./tests/fixture/dev.ts", async (server) => {
+    const resp = await server.get(`/_frsh/refresh.js`);
+    assertEquals(resp.headers.get("destination"), "internal");
+    await resp.body?.cancel();
+  });
+});
+
+Deno.test("warns when using hooks in server components", async (t) => {
+  await withFakeServe("./tests/fixture/main.ts", async (server) => {
+    await t.step("useState", async () => {
+      const doc = await server.getHtml(`/hooks-server/useState`);
+      assertTextMatch(doc, "p", /Hook "useState" cannot be used/);
+      // Check for hint
+      assertTextMatch(doc, "p", /Instead, use the "useSignal" hook/);
+    });
+
+    await t.step("useReducer", async () => {
+      const doc = await server.getHtml(`/hooks-server/useReducer`);
+      assertTextMatch(doc, "p", /Hook "useReducer" cannot be used/);
+    });
+
+    // Valid
+    await t.step("does not warn in island", async () => {
+      const doc = await server.getHtml(`/hooks-server/island`);
+      assertTextMany(doc, "p", ["0"]);
+    });
+  });
+});
+
+Deno.test("shows custom 500 page for rendering errors when not in dev", async (t) => {
+  await withFresh({
+    name: "./tests/fixture/main.ts",
+    options: {
+      env: {
+        DENO_DEPLOYMENT_ID: "foo",
+      },
+    },
+  }, async (address) => {
+    await t.step("useState", async () => {
+      const doc = await fetchHtml(`${address}/hooks-server/useState`);
+      assertNotSelector(doc, "pre");
+    });
+
+    await t.step("useReducer", async () => {
+      const doc = await fetchHtml(`${address}/hooks-server/useReducer`);
+      assertNotSelector(doc, "pre");
+    });
+  });
+});
+
+Deno.test("show codeframe in dev mode even with custom 500", async () => {
+  await withFakeServe(
+    "./tests/fixture_dev_codeframe/dev.ts",
+    async (server) => {
+      const doc = await server.getHtml(`/`);
+      assertSelector(doc, ".frsh-error-page");
+    },
+  );
+
+  await withFakeServe(
+    "./tests/fixture_dev_codeframe/main.ts",
+    async (server) => {
+      const doc = await server.getHtml(`/`);
+      assertNotSelector(doc, ".frsh-error-page");
+      assertSelector(doc, "h1");
+    },
+  );
+});
diff --git a/tests/dev_test.ts b/tests/dev_test.ts
new file mode 100644
index 00000000000..0c82e293b39
--- /dev/null
+++ b/tests/dev_test.ts
@@ -0,0 +1,46 @@
+import { collect } from "../src/dev/mod.ts";
+import { assert, dirname, fromFileUrl, join } from "./deps.ts";
+
+Deno.test({
+  name: "routes collect",
+  fn: async () => {
+    const { routes } = await collect(
+      join(dirname(fromFileUrl(import.meta.url)), "fixture"),
+    );
+
+    assert(
+      !routes.includes("routes/not_found.test.ts") &&
+        !routes.includes("routes\\not_found.test.ts"),
+    );
+    assert(
+      !routes.includes("routes/_404_test.tsx") &&
+        !routes.includes("routes\\_404_test.tsx"),
+    );
+    assert(
+      !routes.includes("routes/islands/test_test.tsx") &&
+        !routes.includes("routes\\islands\\test_test.tsx"),
+    );
+  },
+});
+
+Deno.test({
+  name: "routes collect with custom pattern",
+  fn: async () => {
+    const { routes } = await collect(
+      join(
+        dirname(fromFileUrl(import.meta.url)),
+        "fixture_router_ignore_files",
+      ),
+      /[\.|_]cy\.[t|j]s(x)?$/,
+    );
+
+    assert(
+      !routes.includes("routes/index.cy.ts") &&
+        !routes.includes("routes\\index.cy.ts"),
+    );
+    assert(
+      routes.includes("routes/index.tsx") ||
+        routes.includes("routes\\index.tsx"),
+    );
+  },
+});
diff --git a/tests/error_test.ts b/tests/error_test.ts
index b8a0c4492a0..a58ec770fbb 100644
--- a/tests/error_test.ts
+++ b/tests/error_test.ts
@@ -1,9 +1,8 @@
 import { ServerContext, Status } from "../server.ts";
-import { REFRESH_JS_URL } from "../src/server/constants.ts";
 import { assert, assertEquals, assertStringIncludes } from "./deps.ts";
 import manifest from "./fixture_error/fresh.gen.ts";
 
-const ctx = await ServerContext.fromManifest(manifest, {});
+const ctx = await ServerContext.fromManifest(manifest, { dev: true });
 const handler = ctx.handler();
 const router = (req: Request) => {
   return handler(req, {
@@ -21,21 +20,6 @@ Deno.test("error page rendered", async () => {
   assertEquals(resp.status, Status.InternalServerError);
   assertEquals(resp.headers.get("content-type"), "text/html; charset=utf-8");
   const body = await resp.text();
-  assertStringIncludes(
-    body,
-    `An error occurred during route handling or page rendering.`,
-  );
   assertStringIncludes(body, `Error: boom!`);
   assertStringIncludes(body, `at render`);
 });
-Deno.test("refresh.js rendered", async () => {
-  const resp = await router(
-    new Request("https://fresh.deno.dev" + REFRESH_JS_URL),
-  );
-  assert(resp);
-  assertEquals(resp.status, Status.OK);
-  assertEquals(
-    resp.headers.get("content-type"),
-    "application/javascript; charset=utf-8",
-  );
-});
diff --git a/tests/explicit_app_template_test.ts b/tests/explicit_app_template_test.ts
index 731f1924984..f929c62849e 100644
--- a/tests/explicit_app_template_test.ts
+++ b/tests/explicit_app_template_test.ts
@@ -2,16 +2,15 @@ import {
   assertNotSelector,
   assertSelector,
   assertTextMany,
-  fetchHtml,
-  withFresh,
+  withFakeServe,
 } from "$fresh/tests/test_utils.ts";
 import { assertNotMatch } from "$std/testing/asserts.ts";
 
 Deno.test("doesn't apply internal app template", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_explicit_app/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}`);
+    async (server) => {
+      const doc = await server.getHtml(`/`);
 
       // Doesn't render internal app template
       assertNotSelector(doc, "body body");
@@ -32,10 +31,10 @@ Deno.test("doesn't apply internal app template", async () => {
 });
 
 Deno.test("user _app works with <Head>", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_explicit_app/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/head`);
+    async (server) => {
+      const doc = await server.getHtml(`/head`);
 
       // Doesn't render internal app template
       assertNotSelector(doc, "body body");
@@ -59,20 +58,20 @@ Deno.test("user _app works with <Head>", async () => {
 });
 
 Deno.test("don't duplicate <title>", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_explicit_app/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/title`);
+    async (server) => {
+      const doc = await server.getHtml(`/title`);
       assertTextMany(doc, "title", ["foo bar"]);
     },
   );
 });
 
 Deno.test("sets <html> + <head> + <body> classes", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_explicit_app/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}`);
+    async (server) => {
+      const doc = await server.getHtml(``);
       assertSelector(doc, "html.html");
       assertSelector(doc, "head.head");
       assertSelector(doc, "body.body");
@@ -82,10 +81,10 @@ Deno.test("sets <html> + <head> + <body> classes", async () => {
 
 // Issue: https://github.com/denoland/fresh/issues/1666
 Deno.test("renders valid html document", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_explicit_app/main.ts",
-    async (address) => {
-      const res = await fetch(address);
+    async (server) => {
+      const res = await server.get("/");
       const text = await res.text();
 
       assertNotMatch(text, /<\/body><\/head>/);
diff --git a/tests/fixture/fresh.gen.ts b/tests/fixture/fresh.gen.ts
index 8b79bb55461..879c0fee32e 100644
--- a/tests/fixture/fresh.gen.ts
+++ b/tests/fixture/fresh.gen.ts
@@ -18,69 +18,76 @@ import * as $12 from "./routes/event_handler_string.tsx";
 import * as $13 from "./routes/event_handler_string_island.tsx";
 import * as $14 from "./routes/evil.tsx";
 import * as $15 from "./routes/failure.ts";
-import * as $16 from "./routes/index.tsx";
-import * as $17 from "./routes/intercept.tsx";
-import * as $18 from "./routes/intercept_args.tsx";
-import * as $19 from "./routes/islands/index.tsx";
-import * as $20 from "./routes/islands/multiple_island_exports.tsx";
-import * as $21 from "./routes/islands/returning_null.tsx";
-import * as $22 from "./routes/islands/root_fragment.tsx";
-import * as $23 from "./routes/islands/root_fragment_conditional_first.tsx";
-import * as $24 from "./routes/layeredMdw/_middleware.ts";
-import * as $25 from "./routes/layeredMdw/layer2-no-mw/without_mw.ts";
-import * as $26 from "./routes/layeredMdw/layer2-with-params/[tenantId]/[id].ts";
-import * as $27 from "./routes/layeredMdw/layer2-with-params/[tenantId]/_middleware.ts";
-import * as $28 from "./routes/layeredMdw/layer2-with-params/_middleware.ts";
-import * as $29 from "./routes/layeredMdw/layer2/_middleware.ts";
-import * as $30 from "./routes/layeredMdw/layer2/abc.ts";
-import * as $31 from "./routes/layeredMdw/layer2/index.ts";
-import * as $32 from "./routes/layeredMdw/layer2/layer3/[id].ts";
-import * as $33 from "./routes/layeredMdw/layer2/layer3/_middleware.ts";
-import * as $34 from "./routes/layeredMdw/nesting/[tenant]/[environment]/[id].tsx";
-import * as $35 from "./routes/layeredMdw/nesting/[tenant]/[environment]/_middleware.ts";
-import * as $36 from "./routes/layeredMdw/nesting/[tenant]/_middleware.ts";
-import * as $37 from "./routes/layeredMdw/nesting/_middleware.ts";
-import * as $38 from "./routes/middleware-error-handler/_middleware.ts";
-import * as $39 from "./routes/middleware-error-handler/index.tsx";
-import * as $40 from "./routes/middleware_root.ts";
-import * as $41 from "./routes/movies/[foo].json.ts";
-import * as $42 from "./routes/movies/[foo]@[bar].ts";
-import * as $43 from "./routes/not_found.ts";
-import * as $44 from "./routes/params.tsx";
-import * as $45 from "./routes/preact/boolean_attrs.tsx";
-import * as $46 from "./routes/props/[id].tsx";
-import * as $47 from "./routes/route-groups-islands/index.tsx";
-import * as $48 from "./routes/route-groups/(bar)/(baz)/_layout.tsx";
-import * as $49 from "./routes/route-groups/(bar)/(baz)/baz.tsx";
-import * as $50 from "./routes/route-groups/(bar)/_layout.tsx";
-import * as $51 from "./routes/route-groups/(bar)/bar.tsx";
-import * as $52 from "./routes/route-groups/(bar)/boof/index.tsx";
-import * as $53 from "./routes/route-groups/(foo)/_layout.tsx";
-import * as $54 from "./routes/route-groups/(foo)/index.tsx";
-import * as $55 from "./routes/signal_shared.tsx";
-import * as $56 from "./routes/state-in-props/_middleware.ts";
-import * as $57 from "./routes/state-in-props/index.tsx";
-import * as $58 from "./routes/state-middleware/_middleware.ts";
-import * as $59 from "./routes/state-middleware/foo/_middleware.ts";
-import * as $60 from "./routes/state-middleware/foo/index.tsx";
-import * as $61 from "./routes/static.tsx";
-import * as $62 from "./routes/status_overwrite.tsx";
-import * as $63 from "./routes/umlaut-äöüß.tsx";
-import * as $64 from "./routes/wildcard.tsx";
+import * as $16 from "./routes/head_deduplicate.tsx";
+import * as $17 from "./routes/hooks-server/island.tsx";
+import * as $18 from "./routes/hooks-server/useReducer.tsx";
+import * as $19 from "./routes/hooks-server/useState.tsx";
+import * as $20 from "./routes/i18n/[[lang]]/lang.tsx";
+import * as $21 from "./routes/index.tsx";
+import * as $22 from "./routes/intercept.tsx";
+import * as $23 from "./routes/intercept_args.tsx";
+import * as $24 from "./routes/islands/index.tsx";
+import * as $25 from "./routes/islands/multiple_island_exports.tsx";
+import * as $26 from "./routes/islands/returning_null.tsx";
+import * as $27 from "./routes/islands/root_fragment.tsx";
+import * as $28 from "./routes/islands/root_fragment_conditional_first.tsx";
+import * as $29 from "./routes/layeredMdw/_middleware.ts";
+import * as $30 from "./routes/layeredMdw/layer2-no-mw/without_mw.ts";
+import * as $31 from "./routes/layeredMdw/layer2-with-params/[tenantId]/[id].ts";
+import * as $32 from "./routes/layeredMdw/layer2-with-params/[tenantId]/_middleware.ts";
+import * as $33 from "./routes/layeredMdw/layer2-with-params/_middleware.ts";
+import * as $34 from "./routes/layeredMdw/layer2/_middleware.ts";
+import * as $35 from "./routes/layeredMdw/layer2/abc.ts";
+import * as $36 from "./routes/layeredMdw/layer2/index.ts";
+import * as $37 from "./routes/layeredMdw/layer2/layer3/[id].ts";
+import * as $38 from "./routes/layeredMdw/layer2/layer3/_middleware.ts";
+import * as $39 from "./routes/layeredMdw/nesting/[tenant]/[environment]/[id].tsx";
+import * as $40 from "./routes/layeredMdw/nesting/[tenant]/[environment]/_middleware.ts";
+import * as $41 from "./routes/layeredMdw/nesting/[tenant]/_middleware.ts";
+import * as $42 from "./routes/layeredMdw/nesting/_middleware.ts";
+import * as $43 from "./routes/middleware-error-handler/_middleware.ts";
+import * as $44 from "./routes/middleware-error-handler/index.tsx";
+import * as $45 from "./routes/middleware_root.ts";
+import * as $46 from "./routes/movies/[foo].json.ts";
+import * as $47 from "./routes/movies/[foo]@[bar].ts";
+import * as $48 from "./routes/nonce_inline.tsx";
+import * as $49 from "./routes/not_found.ts";
+import * as $50 from "./routes/params.tsx";
+import * as $51 from "./routes/preact/boolean_attrs.tsx";
+import * as $52 from "./routes/props/[id].tsx";
+import * as $53 from "./routes/route-groups-islands/index.tsx";
+import * as $54 from "./routes/route-groups/(bar)/(baz)/_layout.tsx";
+import * as $55 from "./routes/route-groups/(bar)/(baz)/baz.tsx";
+import * as $56 from "./routes/route-groups/(bar)/_layout.tsx";
+import * as $57 from "./routes/route-groups/(bar)/bar.tsx";
+import * as $58 from "./routes/route-groups/(bar)/boof/index.tsx";
+import * as $59 from "./routes/route-groups/(foo)/_layout.tsx";
+import * as $60 from "./routes/route-groups/(foo)/index.tsx";
+import * as $61 from "./routes/signal_shared.tsx";
+import * as $62 from "./routes/state-in-props/_middleware.ts";
+import * as $63 from "./routes/state-in-props/index.tsx";
+import * as $64 from "./routes/state-middleware/_middleware.ts";
+import * as $65 from "./routes/state-middleware/foo/_middleware.ts";
+import * as $66 from "./routes/state-middleware/foo/index.tsx";
+import * as $67 from "./routes/static.tsx";
+import * as $68 from "./routes/status_overwrite.tsx";
+import * as $69 from "./routes/umlaut-äöüß.tsx";
+import * as $70 from "./routes/wildcard.tsx";
 import * as $$0 from "./islands/Counter.tsx";
 import * as $$1 from "./islands/FormIsland.tsx";
 import * as $$2 from "./islands/Greeter.tsx";
-import * as $$3 from "./islands/MultipleCounters.tsx";
-import * as $$4 from "./islands/ReturningNull.tsx";
-import * as $$5 from "./islands/RootFragment.tsx";
-import * as $$6 from "./islands/RootFragmentWithConditionalFirst.tsx";
-import * as $$7 from "./islands/StringEventIsland.tsx";
-import * as $$8 from "./islands/Test.tsx";
-import * as $$9 from "./islands/folder/Counter.tsx";
-import * as $$10 from "./islands/folder/subfolder/Counter.tsx";
-import * as $$11 from "./islands/kebab-case-counter-test.tsx";
-import * as $$12 from "./routes/route-groups-islands/(_islands)/Counter.tsx";
-import * as $$13 from "./routes/route-groups-islands/(_islands)/invalid.tsx";
+import * as $$3 from "./islands/HookIsland.tsx";
+import * as $$4 from "./islands/MultipleCounters.tsx";
+import * as $$5 from "./islands/ReturningNull.tsx";
+import * as $$6 from "./islands/RootFragment.tsx";
+import * as $$7 from "./islands/RootFragmentWithConditionalFirst.tsx";
+import * as $$8 from "./islands/StringEventIsland.tsx";
+import * as $$9 from "./islands/Test.tsx";
+import * as $$10 from "./islands/folder/Counter.tsx";
+import * as $$11 from "./islands/folder/subfolder/Counter.tsx";
+import * as $$12 from "./islands/kebab-case-counter-test.tsx";
+import * as $$13 from "./routes/route-groups-islands/(_islands)/Counter.tsx";
+import * as $$14 from "./routes/route-groups-islands/(_islands)/invalid.tsx";
 
 const manifest = {
   routes: {
@@ -100,71 +107,78 @@ const manifest = {
     "./routes/event_handler_string_island.tsx": $13,
     "./routes/evil.tsx": $14,
     "./routes/failure.ts": $15,
-    "./routes/index.tsx": $16,
-    "./routes/intercept.tsx": $17,
-    "./routes/intercept_args.tsx": $18,
-    "./routes/islands/index.tsx": $19,
-    "./routes/islands/multiple_island_exports.tsx": $20,
-    "./routes/islands/returning_null.tsx": $21,
-    "./routes/islands/root_fragment.tsx": $22,
-    "./routes/islands/root_fragment_conditional_first.tsx": $23,
-    "./routes/layeredMdw/_middleware.ts": $24,
-    "./routes/layeredMdw/layer2-no-mw/without_mw.ts": $25,
-    "./routes/layeredMdw/layer2-with-params/[tenantId]/[id].ts": $26,
-    "./routes/layeredMdw/layer2-with-params/[tenantId]/_middleware.ts": $27,
-    "./routes/layeredMdw/layer2-with-params/_middleware.ts": $28,
-    "./routes/layeredMdw/layer2/_middleware.ts": $29,
-    "./routes/layeredMdw/layer2/abc.ts": $30,
-    "./routes/layeredMdw/layer2/index.ts": $31,
-    "./routes/layeredMdw/layer2/layer3/[id].ts": $32,
-    "./routes/layeredMdw/layer2/layer3/_middleware.ts": $33,
-    "./routes/layeredMdw/nesting/[tenant]/[environment]/[id].tsx": $34,
-    "./routes/layeredMdw/nesting/[tenant]/[environment]/_middleware.ts": $35,
-    "./routes/layeredMdw/nesting/[tenant]/_middleware.ts": $36,
-    "./routes/layeredMdw/nesting/_middleware.ts": $37,
-    "./routes/middleware-error-handler/_middleware.ts": $38,
-    "./routes/middleware-error-handler/index.tsx": $39,
-    "./routes/middleware_root.ts": $40,
-    "./routes/movies/[foo].json.ts": $41,
-    "./routes/movies/[foo]@[bar].ts": $42,
-    "./routes/not_found.ts": $43,
-    "./routes/params.tsx": $44,
-    "./routes/preact/boolean_attrs.tsx": $45,
-    "./routes/props/[id].tsx": $46,
-    "./routes/route-groups-islands/index.tsx": $47,
-    "./routes/route-groups/(bar)/(baz)/_layout.tsx": $48,
-    "./routes/route-groups/(bar)/(baz)/baz.tsx": $49,
-    "./routes/route-groups/(bar)/_layout.tsx": $50,
-    "./routes/route-groups/(bar)/bar.tsx": $51,
-    "./routes/route-groups/(bar)/boof/index.tsx": $52,
-    "./routes/route-groups/(foo)/_layout.tsx": $53,
-    "./routes/route-groups/(foo)/index.tsx": $54,
-    "./routes/signal_shared.tsx": $55,
-    "./routes/state-in-props/_middleware.ts": $56,
-    "./routes/state-in-props/index.tsx": $57,
-    "./routes/state-middleware/_middleware.ts": $58,
-    "./routes/state-middleware/foo/_middleware.ts": $59,
-    "./routes/state-middleware/foo/index.tsx": $60,
-    "./routes/static.tsx": $61,
-    "./routes/status_overwrite.tsx": $62,
-    "./routes/umlaut-äöüß.tsx": $63,
-    "./routes/wildcard.tsx": $64,
+    "./routes/head_deduplicate.tsx": $16,
+    "./routes/hooks-server/island.tsx": $17,
+    "./routes/hooks-server/useReducer.tsx": $18,
+    "./routes/hooks-server/useState.tsx": $19,
+    "./routes/i18n/[[lang]]/lang.tsx": $20,
+    "./routes/index.tsx": $21,
+    "./routes/intercept.tsx": $22,
+    "./routes/intercept_args.tsx": $23,
+    "./routes/islands/index.tsx": $24,
+    "./routes/islands/multiple_island_exports.tsx": $25,
+    "./routes/islands/returning_null.tsx": $26,
+    "./routes/islands/root_fragment.tsx": $27,
+    "./routes/islands/root_fragment_conditional_first.tsx": $28,
+    "./routes/layeredMdw/_middleware.ts": $29,
+    "./routes/layeredMdw/layer2-no-mw/without_mw.ts": $30,
+    "./routes/layeredMdw/layer2-with-params/[tenantId]/[id].ts": $31,
+    "./routes/layeredMdw/layer2-with-params/[tenantId]/_middleware.ts": $32,
+    "./routes/layeredMdw/layer2-with-params/_middleware.ts": $33,
+    "./routes/layeredMdw/layer2/_middleware.ts": $34,
+    "./routes/layeredMdw/layer2/abc.ts": $35,
+    "./routes/layeredMdw/layer2/index.ts": $36,
+    "./routes/layeredMdw/layer2/layer3/[id].ts": $37,
+    "./routes/layeredMdw/layer2/layer3/_middleware.ts": $38,
+    "./routes/layeredMdw/nesting/[tenant]/[environment]/[id].tsx": $39,
+    "./routes/layeredMdw/nesting/[tenant]/[environment]/_middleware.ts": $40,
+    "./routes/layeredMdw/nesting/[tenant]/_middleware.ts": $41,
+    "./routes/layeredMdw/nesting/_middleware.ts": $42,
+    "./routes/middleware-error-handler/_middleware.ts": $43,
+    "./routes/middleware-error-handler/index.tsx": $44,
+    "./routes/middleware_root.ts": $45,
+    "./routes/movies/[foo].json.ts": $46,
+    "./routes/movies/[foo]@[bar].ts": $47,
+    "./routes/nonce_inline.tsx": $48,
+    "./routes/not_found.ts": $49,
+    "./routes/params.tsx": $50,
+    "./routes/preact/boolean_attrs.tsx": $51,
+    "./routes/props/[id].tsx": $52,
+    "./routes/route-groups-islands/index.tsx": $53,
+    "./routes/route-groups/(bar)/(baz)/_layout.tsx": $54,
+    "./routes/route-groups/(bar)/(baz)/baz.tsx": $55,
+    "./routes/route-groups/(bar)/_layout.tsx": $56,
+    "./routes/route-groups/(bar)/bar.tsx": $57,
+    "./routes/route-groups/(bar)/boof/index.tsx": $58,
+    "./routes/route-groups/(foo)/_layout.tsx": $59,
+    "./routes/route-groups/(foo)/index.tsx": $60,
+    "./routes/signal_shared.tsx": $61,
+    "./routes/state-in-props/_middleware.ts": $62,
+    "./routes/state-in-props/index.tsx": $63,
+    "./routes/state-middleware/_middleware.ts": $64,
+    "./routes/state-middleware/foo/_middleware.ts": $65,
+    "./routes/state-middleware/foo/index.tsx": $66,
+    "./routes/static.tsx": $67,
+    "./routes/status_overwrite.tsx": $68,
+    "./routes/umlaut-äöüß.tsx": $69,
+    "./routes/wildcard.tsx": $70,
   },
   islands: {
     "./islands/Counter.tsx": $$0,
     "./islands/FormIsland.tsx": $$1,
     "./islands/Greeter.tsx": $$2,
-    "./islands/MultipleCounters.tsx": $$3,
-    "./islands/ReturningNull.tsx": $$4,
-    "./islands/RootFragment.tsx": $$5,
-    "./islands/RootFragmentWithConditionalFirst.tsx": $$6,
-    "./islands/StringEventIsland.tsx": $$7,
-    "./islands/Test.tsx": $$8,
-    "./islands/folder/Counter.tsx": $$9,
-    "./islands/folder/subfolder/Counter.tsx": $$10,
-    "./islands/kebab-case-counter-test.tsx": $$11,
-    "./routes/route-groups-islands/(_islands)/Counter.tsx": $$12,
-    "./routes/route-groups-islands/(_islands)/invalid.tsx": $$13,
+    "./islands/HookIsland.tsx": $$3,
+    "./islands/MultipleCounters.tsx": $$4,
+    "./islands/ReturningNull.tsx": $$5,
+    "./islands/RootFragment.tsx": $$6,
+    "./islands/RootFragmentWithConditionalFirst.tsx": $$7,
+    "./islands/StringEventIsland.tsx": $$8,
+    "./islands/Test.tsx": $$9,
+    "./islands/folder/Counter.tsx": $$10,
+    "./islands/folder/subfolder/Counter.tsx": $$11,
+    "./islands/kebab-case-counter-test.tsx": $$12,
+    "./routes/route-groups-islands/(_islands)/Counter.tsx": $$13,
+    "./routes/route-groups-islands/(_islands)/invalid.tsx": $$14,
   },
   baseUrl: import.meta.url,
 };
diff --git a/tests/fixture/islands/Counter.test.ts b/tests/fixture/islands/Counter.test.ts
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/tests/fixture/islands/HookIsland.tsx b/tests/fixture/islands/HookIsland.tsx
new file mode 100644
index 00000000000..9b59ee19999
--- /dev/null
+++ b/tests/fixture/islands/HookIsland.tsx
@@ -0,0 +1,11 @@
+import { useState } from "preact/hooks";
+
+export function HookIsland() {
+  const [v, set] = useState(0);
+  return (
+    <div>
+      <p>{v}</p>
+      <button onClick={() => set((v) => v + 1)}>update</button>
+    </div>
+  );
+}
diff --git a/tests/fixture/islands/test_test.ts b/tests/fixture/islands/test_test.ts
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/tests/fixture/routes/_404_test.tsx b/tests/fixture/routes/_404_test.tsx
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/tests/fixture/routes/head_deduplicate.tsx b/tests/fixture/routes/head_deduplicate.tsx
new file mode 100644
index 00000000000..406f3b2a3fb
--- /dev/null
+++ b/tests/fixture/routes/head_deduplicate.tsx
@@ -0,0 +1,19 @@
+import { Head } from "$fresh/runtime.ts";
+
+export default function Page() {
+  return (
+    <>
+      <h1>Card head css deduplication</h1>
+      <Head>
+        <title>foo</title>
+        <link rel="stylesheet" href="/card.css" key="card.css" />
+        <meta property="og:title" content="My page title" key="title" />
+      </Head>
+      <Head>
+        <title>bar</title>
+        <link rel="stylesheet" href="/card.css" key="card.css" />
+        <meta property="og:title" content="Other title" key="title" />
+      </Head>
+    </>
+  );
+}
diff --git a/tests/fixture/routes/hooks-server/island.tsx b/tests/fixture/routes/hooks-server/island.tsx
new file mode 100644
index 00000000000..a814fa5ce73
--- /dev/null
+++ b/tests/fixture/routes/hooks-server/island.tsx
@@ -0,0 +1,5 @@
+import { HookIsland } from "../../islands/HookIsland.tsx";
+
+export default function Page() {
+  return <HookIsland />;
+}
diff --git a/tests/fixture/routes/hooks-server/useReducer.tsx b/tests/fixture/routes/hooks-server/useReducer.tsx
new file mode 100644
index 00000000000..cb4ef079376
--- /dev/null
+++ b/tests/fixture/routes/hooks-server/useReducer.tsx
@@ -0,0 +1,6 @@
+import { useReducer } from "preact/hooks";
+
+export default function Page() {
+  useReducer(() => {}, undefined);
+  return <h1>useReducer</h1>;
+}
diff --git a/tests/fixture/routes/hooks-server/useState.tsx b/tests/fixture/routes/hooks-server/useState.tsx
new file mode 100644
index 00000000000..f33ca543d2d
--- /dev/null
+++ b/tests/fixture/routes/hooks-server/useState.tsx
@@ -0,0 +1,6 @@
+import { useState } from "preact/hooks";
+
+export default function Page() {
+  useState();
+  return <h1>useState</h1>;
+}
diff --git a/tests/fixture/routes/i18n/[[lang]]/lang.tsx b/tests/fixture/routes/i18n/[[lang]]/lang.tsx
new file mode 100644
index 00000000000..31602290cf2
--- /dev/null
+++ b/tests/fixture/routes/i18n/[[lang]]/lang.tsx
@@ -0,0 +1,9 @@
+interface Props {
+  params: Record<string, string | string[]>;
+}
+
+export default function Lang(props: Props) {
+  return props.params.lang
+    ? <div>Hello {props.params.lang}</div>
+    : <div>Hello</div>;
+}
diff --git a/tests/fixture/routes/nonce_inline.tsx b/tests/fixture/routes/nonce_inline.tsx
new file mode 100644
index 00000000000..6bee8c8ea4d
--- /dev/null
+++ b/tests/fixture/routes/nonce_inline.tsx
@@ -0,0 +1,15 @@
+import { useSignal } from "@preact/signals";
+import Counter from "../islands/Counter.tsx";
+
+export default function Page() {
+  const sig = useSignal(0);
+  return (
+    <div>
+      <script
+        id="inline-script"
+        dangerouslySetInnerHTML={{ __html: "console.log('hey')" }}
+      />
+      <Counter id="foo" count={sig} />
+    </div>
+  );
+}
diff --git a/tests/fixture/routes/not_found.test.ts b/tests/fixture/routes/not_found.test.ts
new file mode 100644
index 00000000000..6b409d8c65c
--- /dev/null
+++ b/tests/fixture/routes/not_found.test.ts
@@ -0,0 +1,3 @@
+Deno.test("not really", () => {
+  return;
+});
diff --git a/tests/fixture/static/card.css b/tests/fixture/static/card.css
new file mode 100644
index 00000000000..adc68fa6a4d
--- /dev/null
+++ b/tests/fixture/static/card.css
@@ -0,0 +1,3 @@
+h1 {
+  color: red;
+}
diff --git a/tests/fixture_async_app/routes/_app.tsx b/tests/fixture_async_app/routes/_app.tsx
index 48ad41c4e90..81ae68bd41a 100644
--- a/tests/fixture_async_app/routes/_app.tsx
+++ b/tests/fixture_async_app/routes/_app.tsx
@@ -7,7 +7,7 @@ export default async function App(req: Request, ctx: AppContext) {
   return (
     <html lang="fr">
       <head>
-        <meta charSet="utf-8" />
+        <meta charset="utf-8" />
         <meta
           name="viewport"
           content="width=device-width, initial-scale=1.0"
diff --git a/tests/fixture_build_out_dir/deno.json b/tests/fixture_build_out_dir/deno.json
new file mode 100644
index 00000000000..9d782057e20
--- /dev/null
+++ b/tests/fixture_build_out_dir/deno.json
@@ -0,0 +1,15 @@
+{
+  "lock": false,
+  "imports": {
+    "$fresh/": "../../",
+    "preact": "https://esm.sh/preact@10.15.1",
+    "preact/": "https://esm.sh/preact@10.15.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.0",
+    "@preact/signals": "https://esm.sh/*@preact/signals@1.1.3",
+    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.2.3"
+  },
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "jsxImportSource": "preact"
+  }
+}
diff --git a/tests/fixture_build_out_dir/dev.ts b/tests/fixture_build_out_dir/dev.ts
new file mode 100755
index 00000000000..f2ab753ba74
--- /dev/null
+++ b/tests/fixture_build_out_dir/dev.ts
@@ -0,0 +1,9 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+
+await dev(import.meta.url, "./main.ts", {
+  build: {
+    outDir: Deno.env.get("FRESH_TEST_OUTDIR") ?? undefined,
+  },
+});
diff --git a/tests/fixture_build_out_dir/fresh.gen.ts b/tests/fixture_build_out_dir/fresh.gen.ts
new file mode 100644
index 00000000000..fa16c42d32f
--- /dev/null
+++ b/tests/fixture_build_out_dir/fresh.gen.ts
@@ -0,0 +1,18 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/index.tsx";
+import * as $$0 from "./islands/Counter.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/index.tsx": $0,
+  },
+  islands: {
+    "./islands/Counter.tsx": $$0,
+  },
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_build_out_dir/islands/Counter.tsx b/tests/fixture_build_out_dir/islands/Counter.tsx
new file mode 100644
index 00000000000..5f015b1ee1f
--- /dev/null
+++ b/tests/fixture_build_out_dir/islands/Counter.tsx
@@ -0,0 +1,22 @@
+import type { Signal } from "@preact/signals";
+import { IS_BROWSER } from "$fresh/runtime.ts";
+
+interface CounterProps {
+  count: Signal<number>;
+  id: string;
+}
+
+export default function Counter(props: CounterProps) {
+  return (
+    <div id={props.id}>
+      <p>{props.count}</p>
+      <button
+        id={`b-${props.id}`}
+        onClick={() => props.count.value += 1}
+        disabled={!IS_BROWSER}
+      >
+        +1
+      </button>
+    </div>
+  );
+}
diff --git a/tests/fixture_build_out_dir/main.ts b/tests/fixture_build_out_dir/main.ts
new file mode 100644
index 00000000000..bb97cc80de2
--- /dev/null
+++ b/tests/fixture_build_out_dir/main.ts
@@ -0,0 +1,10 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import routes from "./fresh.gen.ts";
+
+await start(routes);
diff --git a/tests/fixture_build_out_dir/routes/index.tsx b/tests/fixture_build_out_dir/routes/index.tsx
new file mode 100644
index 00000000000..7473a787edb
--- /dev/null
+++ b/tests/fixture_build_out_dir/routes/index.tsx
@@ -0,0 +1,15 @@
+import { useSignal } from "@preact/signals";
+import Counter from "../islands/Counter.tsx";
+import { asset, Head } from "$fresh/runtime.ts";
+
+export default function Home() {
+  const signal = useSignal(0);
+  return (
+    <div>
+      <Head>
+        <link rel="stylesheet" href={asset("/style.css")} />
+      </Head>
+      <Counter id="counter" count={signal} />
+    </div>
+  );
+}
diff --git a/tests/fixture_build_out_dir_sub/deno.json b/tests/fixture_build_out_dir_sub/deno.json
new file mode 100644
index 00000000000..9d782057e20
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub/deno.json
@@ -0,0 +1,15 @@
+{
+  "lock": false,
+  "imports": {
+    "$fresh/": "../../",
+    "preact": "https://esm.sh/preact@10.15.1",
+    "preact/": "https://esm.sh/preact@10.15.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.0",
+    "@preact/signals": "https://esm.sh/*@preact/signals@1.1.3",
+    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.2.3"
+  },
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "jsxImportSource": "preact"
+  }
+}
diff --git a/tests/fixture_build_out_dir_sub/src/dev.ts b/tests/fixture_build_out_dir_sub/src/dev.ts
new file mode 100755
index 00000000000..f2ab753ba74
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub/src/dev.ts
@@ -0,0 +1,9 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+
+await dev(import.meta.url, "./main.ts", {
+  build: {
+    outDir: Deno.env.get("FRESH_TEST_OUTDIR") ?? undefined,
+  },
+});
diff --git a/tests/fixture_build_out_dir_sub/src/fresh.gen.ts b/tests/fixture_build_out_dir_sub/src/fresh.gen.ts
new file mode 100644
index 00000000000..fa16c42d32f
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub/src/fresh.gen.ts
@@ -0,0 +1,18 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/index.tsx";
+import * as $$0 from "./islands/Counter.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/index.tsx": $0,
+  },
+  islands: {
+    "./islands/Counter.tsx": $$0,
+  },
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_build_out_dir_sub/src/islands/Counter.tsx b/tests/fixture_build_out_dir_sub/src/islands/Counter.tsx
new file mode 100644
index 00000000000..5f015b1ee1f
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub/src/islands/Counter.tsx
@@ -0,0 +1,22 @@
+import type { Signal } from "@preact/signals";
+import { IS_BROWSER } from "$fresh/runtime.ts";
+
+interface CounterProps {
+  count: Signal<number>;
+  id: string;
+}
+
+export default function Counter(props: CounterProps) {
+  return (
+    <div id={props.id}>
+      <p>{props.count}</p>
+      <button
+        id={`b-${props.id}`}
+        onClick={() => props.count.value += 1}
+        disabled={!IS_BROWSER}
+      >
+        +1
+      </button>
+    </div>
+  );
+}
diff --git a/tests/fixture_build_out_dir_sub/src/main.ts b/tests/fixture_build_out_dir_sub/src/main.ts
new file mode 100644
index 00000000000..bb97cc80de2
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub/src/main.ts
@@ -0,0 +1,10 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import routes from "./fresh.gen.ts";
+
+await start(routes);
diff --git a/tests/fixture_build_out_dir_sub/src/routes/index.tsx b/tests/fixture_build_out_dir_sub/src/routes/index.tsx
new file mode 100644
index 00000000000..7473a787edb
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub/src/routes/index.tsx
@@ -0,0 +1,15 @@
+import { useSignal } from "@preact/signals";
+import Counter from "../islands/Counter.tsx";
+import { asset, Head } from "$fresh/runtime.ts";
+
+export default function Home() {
+  const signal = useSignal(0);
+  return (
+    <div>
+      <Head>
+        <link rel="stylesheet" href={asset("/style.css")} />
+      </Head>
+      <Counter id="counter" count={signal} />
+    </div>
+  );
+}
diff --git a/tests/fixture_build_out_dir_sub2/deno.json b/tests/fixture_build_out_dir_sub2/deno.json
new file mode 100644
index 00000000000..9d782057e20
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub2/deno.json
@@ -0,0 +1,15 @@
+{
+  "lock": false,
+  "imports": {
+    "$fresh/": "../../",
+    "preact": "https://esm.sh/preact@10.15.1",
+    "preact/": "https://esm.sh/preact@10.15.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.0",
+    "@preact/signals": "https://esm.sh/*@preact/signals@1.1.3",
+    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.2.3"
+  },
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "jsxImportSource": "preact"
+  }
+}
diff --git a/tests/fixture_build_out_dir_sub2/src/dev.ts b/tests/fixture_build_out_dir_sub2/src/dev.ts
new file mode 100755
index 00000000000..f2ab753ba74
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub2/src/dev.ts
@@ -0,0 +1,9 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+
+await dev(import.meta.url, "./main.ts", {
+  build: {
+    outDir: Deno.env.get("FRESH_TEST_OUTDIR") ?? undefined,
+  },
+});
diff --git a/tests/fixture_build_out_dir_sub2/src/fresh.gen.ts b/tests/fixture_build_out_dir_sub2/src/fresh.gen.ts
new file mode 100644
index 00000000000..fa16c42d32f
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub2/src/fresh.gen.ts
@@ -0,0 +1,18 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/index.tsx";
+import * as $$0 from "./islands/Counter.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/index.tsx": $0,
+  },
+  islands: {
+    "./islands/Counter.tsx": $$0,
+  },
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_build_out_dir_sub2/src/islands/Counter.tsx b/tests/fixture_build_out_dir_sub2/src/islands/Counter.tsx
new file mode 100644
index 00000000000..5f015b1ee1f
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub2/src/islands/Counter.tsx
@@ -0,0 +1,22 @@
+import type { Signal } from "@preact/signals";
+import { IS_BROWSER } from "$fresh/runtime.ts";
+
+interface CounterProps {
+  count: Signal<number>;
+  id: string;
+}
+
+export default function Counter(props: CounterProps) {
+  return (
+    <div id={props.id}>
+      <p>{props.count}</p>
+      <button
+        id={`b-${props.id}`}
+        onClick={() => props.count.value += 1}
+        disabled={!IS_BROWSER}
+      >
+        +1
+      </button>
+    </div>
+  );
+}
diff --git a/tests/fixture_build_out_dir_sub2/src/main.ts b/tests/fixture_build_out_dir_sub2/src/main.ts
new file mode 100644
index 00000000000..bb97cc80de2
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub2/src/main.ts
@@ -0,0 +1,10 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import routes from "./fresh.gen.ts";
+
+await start(routes);
diff --git a/tests/fixture_build_out_dir_sub2/src/routes/index.tsx b/tests/fixture_build_out_dir_sub2/src/routes/index.tsx
new file mode 100644
index 00000000000..7473a787edb
--- /dev/null
+++ b/tests/fixture_build_out_dir_sub2/src/routes/index.tsx
@@ -0,0 +1,15 @@
+import { useSignal } from "@preact/signals";
+import Counter from "../islands/Counter.tsx";
+import { asset, Head } from "$fresh/runtime.ts";
+
+export default function Home() {
+  const signal = useSignal(0);
+  return (
+    <div>
+      <Head>
+        <link rel="stylesheet" href={asset("/style.css")} />
+      </Head>
+      <Counter id="counter" count={signal} />
+    </div>
+  );
+}
diff --git a/tests/fixture_build_sub_dir/deno.json b/tests/fixture_build_sub_dir/deno.json
new file mode 100644
index 00000000000..9d782057e20
--- /dev/null
+++ b/tests/fixture_build_sub_dir/deno.json
@@ -0,0 +1,15 @@
+{
+  "lock": false,
+  "imports": {
+    "$fresh/": "../../",
+    "preact": "https://esm.sh/preact@10.15.1",
+    "preact/": "https://esm.sh/preact@10.15.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.0",
+    "@preact/signals": "https://esm.sh/*@preact/signals@1.1.3",
+    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.2.3"
+  },
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "jsxImportSource": "preact"
+  }
+}
diff --git a/tests/fixture_build_sub_dir/src/dev.ts b/tests/fixture_build_sub_dir/src/dev.ts
new file mode 100755
index 00000000000..2d85d6c183c
--- /dev/null
+++ b/tests/fixture_build_sub_dir/src/dev.ts
@@ -0,0 +1,5 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+
+await dev(import.meta.url, "./main.ts");
diff --git a/tests/fixture_build_sub_dir/src/fresh.gen.ts b/tests/fixture_build_sub_dir/src/fresh.gen.ts
new file mode 100644
index 00000000000..fa16c42d32f
--- /dev/null
+++ b/tests/fixture_build_sub_dir/src/fresh.gen.ts
@@ -0,0 +1,18 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/index.tsx";
+import * as $$0 from "./islands/Counter.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/index.tsx": $0,
+  },
+  islands: {
+    "./islands/Counter.tsx": $$0,
+  },
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_build_sub_dir/src/islands/Counter.tsx b/tests/fixture_build_sub_dir/src/islands/Counter.tsx
new file mode 100644
index 00000000000..5f015b1ee1f
--- /dev/null
+++ b/tests/fixture_build_sub_dir/src/islands/Counter.tsx
@@ -0,0 +1,22 @@
+import type { Signal } from "@preact/signals";
+import { IS_BROWSER } from "$fresh/runtime.ts";
+
+interface CounterProps {
+  count: Signal<number>;
+  id: string;
+}
+
+export default function Counter(props: CounterProps) {
+  return (
+    <div id={props.id}>
+      <p>{props.count}</p>
+      <button
+        id={`b-${props.id}`}
+        onClick={() => props.count.value += 1}
+        disabled={!IS_BROWSER}
+      >
+        +1
+      </button>
+    </div>
+  );
+}
diff --git a/tests/fixture_build_sub_dir/src/main.ts b/tests/fixture_build_sub_dir/src/main.ts
new file mode 100644
index 00000000000..bb97cc80de2
--- /dev/null
+++ b/tests/fixture_build_sub_dir/src/main.ts
@@ -0,0 +1,10 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import routes from "./fresh.gen.ts";
+
+await start(routes);
diff --git a/tests/fixture_build_sub_dir/src/routes/index.tsx b/tests/fixture_build_sub_dir/src/routes/index.tsx
new file mode 100644
index 00000000000..7473a787edb
--- /dev/null
+++ b/tests/fixture_build_sub_dir/src/routes/index.tsx
@@ -0,0 +1,15 @@
+import { useSignal } from "@preact/signals";
+import Counter from "../islands/Counter.tsx";
+import { asset, Head } from "$fresh/runtime.ts";
+
+export default function Home() {
+  const signal = useSignal(0);
+  return (
+    <div>
+      <Head>
+        <link rel="stylesheet" href={asset("/style.css")} />
+      </Head>
+      <Counter id="counter" count={signal} />
+    </div>
+  );
+}
diff --git a/tests/fixture_build_sub_dir/src/static/style.css b/tests/fixture_build_sub_dir/src/static/style.css
new file mode 100644
index 00000000000..573746210c7
--- /dev/null
+++ b/tests/fixture_build_sub_dir/src/static/style.css
@@ -0,0 +1,3 @@
+body {
+  background: peachpuff;
+}
diff --git a/tests/fixture_build_target/deno.json b/tests/fixture_build_target/deno.json
new file mode 100644
index 00000000000..9d782057e20
--- /dev/null
+++ b/tests/fixture_build_target/deno.json
@@ -0,0 +1,15 @@
+{
+  "lock": false,
+  "imports": {
+    "$fresh/": "../../",
+    "preact": "https://esm.sh/preact@10.15.1",
+    "preact/": "https://esm.sh/preact@10.15.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.0",
+    "@preact/signals": "https://esm.sh/*@preact/signals@1.1.3",
+    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.2.3"
+  },
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "jsxImportSource": "preact"
+  }
+}
diff --git a/tests/fixture_build_target/dev.ts b/tests/fixture_build_target/dev.ts
new file mode 100755
index 00000000000..6fc1d8ebf20
--- /dev/null
+++ b/tests/fixture_build_target/dev.ts
@@ -0,0 +1,9 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+
+await dev(import.meta.url, "./main.ts", {
+  build: {
+    target: Deno.env.get("FRESH_TEST_TARGET"),
+  },
+});
diff --git a/tests/fixture_build_target/fresh.gen.ts b/tests/fixture_build_target/fresh.gen.ts
new file mode 100644
index 00000000000..fa16c42d32f
--- /dev/null
+++ b/tests/fixture_build_target/fresh.gen.ts
@@ -0,0 +1,18 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/index.tsx";
+import * as $$0 from "./islands/Counter.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/index.tsx": $0,
+  },
+  islands: {
+    "./islands/Counter.tsx": $$0,
+  },
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_build_target/islands/Counter.tsx b/tests/fixture_build_target/islands/Counter.tsx
new file mode 100644
index 00000000000..a59caf91896
--- /dev/null
+++ b/tests/fixture_build_target/islands/Counter.tsx
@@ -0,0 +1,4 @@
+export default function Counter(props: { text?: string }) {
+  const text = props.text ?? "check output";
+  return <h1>{text}</h1>;
+}
diff --git a/tests/fixture_build_target/main.ts b/tests/fixture_build_target/main.ts
new file mode 100644
index 00000000000..bb97cc80de2
--- /dev/null
+++ b/tests/fixture_build_target/main.ts
@@ -0,0 +1,10 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import routes from "./fresh.gen.ts";
+
+await start(routes);
diff --git a/tests/fixture_build_target/routes/index.tsx b/tests/fixture_build_target/routes/index.tsx
new file mode 100644
index 00000000000..efaa376121a
--- /dev/null
+++ b/tests/fixture_build_target/routes/index.tsx
@@ -0,0 +1,5 @@
+import Counter from "../islands/Counter.tsx";
+
+export default function Home() {
+  return <Counter />;
+}
diff --git a/tests/fixture_config/deno.json b/tests/fixture_config/deno.json
new file mode 100644
index 00000000000..9d782057e20
--- /dev/null
+++ b/tests/fixture_config/deno.json
@@ -0,0 +1,15 @@
+{
+  "lock": false,
+  "imports": {
+    "$fresh/": "../../",
+    "preact": "https://esm.sh/preact@10.15.1",
+    "preact/": "https://esm.sh/preact@10.15.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.0",
+    "@preact/signals": "https://esm.sh/*@preact/signals@1.1.3",
+    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.2.3"
+  },
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "jsxImportSource": "preact"
+  }
+}
diff --git a/tests/fixture_config/dev.ts b/tests/fixture_config/dev.ts
new file mode 100755
index 00000000000..59dfdfdea1a
--- /dev/null
+++ b/tests/fixture_config/dev.ts
@@ -0,0 +1,20 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+
+const TEST_CONFIG_SERVER = Deno.env.get("TEST_CONFIG_SERVER") === "true";
+const onListen = (params: { hostname: string; port: number }) => {
+  console.log("it works");
+  console.log(`http://localhost:${params.port}`);
+};
+const onListen2 = (params: { hostname: string; port: number }) => {
+  console.log("it works #2");
+  console.log(`http://localhost:${params.port}`);
+};
+
+await dev(import.meta.url, "./main.ts", {
+  server: {
+    onListen: TEST_CONFIG_SERVER ? onListen2 : undefined,
+  },
+  onListen: TEST_CONFIG_SERVER ? undefined : onListen,
+});
diff --git a/tests/fixture_config/fresh.gen.ts b/tests/fixture_config/fresh.gen.ts
new file mode 100644
index 00000000000..b321c0e078e
--- /dev/null
+++ b/tests/fixture_config/fresh.gen.ts
@@ -0,0 +1,15 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/index.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/index.tsx": $0,
+  },
+  islands: {},
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_config/main.ts b/tests/fixture_config/main.ts
new file mode 100644
index 00000000000..0df18bfc634
--- /dev/null
+++ b/tests/fixture_config/main.ts
@@ -0,0 +1,25 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import routes from "./fresh.gen.ts";
+
+const TEST_CONFIG_SERVER = Deno.env.get("TEST_CONFIG_SERVER") === "true";
+const onListen = (params: { hostname: string; port: number }) => {
+  console.log("it works");
+  console.log(`http://localhost:${params.port}`);
+};
+const onListen2 = (params: { hostname: string; port: number }) => {
+  console.log("it works #2");
+  console.log(`http://localhost:${params.port}`);
+};
+
+await start(routes, {
+  server: {
+    onListen: TEST_CONFIG_SERVER ? onListen2 : undefined,
+  },
+  onListen: TEST_CONFIG_SERVER ? undefined : onListen,
+});
diff --git a/tests/fixture_config/routes/index.tsx b/tests/fixture_config/routes/index.tsx
new file mode 100644
index 00000000000..9025646dc1f
--- /dev/null
+++ b/tests/fixture_config/routes/index.tsx
@@ -0,0 +1,3 @@
+export default function Home() {
+  return <h1>hello</h1>;
+}
diff --git a/tests/fixture_dev_codeframe/dev.ts b/tests/fixture_dev_codeframe/dev.ts
new file mode 100644
index 00000000000..1b53e2e77cf
--- /dev/null
+++ b/tests/fixture_dev_codeframe/dev.ts
@@ -0,0 +1,4 @@
+import { dev } from "$fresh/src/dev/dev_command.ts";
+import config from "./fresh.config.ts";
+
+await dev(import.meta.url, "./main.ts", config);
diff --git a/tests/fixture_dev_codeframe/fresh.config.ts b/tests/fixture_dev_codeframe/fresh.config.ts
new file mode 100644
index 00000000000..889a6862f1f
--- /dev/null
+++ b/tests/fixture_dev_codeframe/fresh.config.ts
@@ -0,0 +1,8 @@
+import { defineConfig } from "$fresh/server.ts";
+import twind from "$fresh/plugins/twind.ts";
+
+export default defineConfig({
+  plugins: [twind({
+    selfURL: import.meta.url,
+  })],
+});
diff --git a/tests/fixture_dev_codeframe/fresh.gen.ts b/tests/fixture_dev_codeframe/fresh.gen.ts
new file mode 100644
index 00000000000..f4af4a31b86
--- /dev/null
+++ b/tests/fixture_dev_codeframe/fresh.gen.ts
@@ -0,0 +1,17 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/_500.tsx";
+import * as $1 from "./routes/index.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/_500.tsx": $0,
+    "./routes/index.tsx": $1,
+  },
+  islands: {},
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_dev_codeframe/main.ts b/tests/fixture_dev_codeframe/main.ts
new file mode 100644
index 00000000000..fc9359215e3
--- /dev/null
+++ b/tests/fixture_dev_codeframe/main.ts
@@ -0,0 +1,11 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import manifest from "./fresh.gen.ts";
+import config from "./fresh.config.ts";
+
+await start(manifest, config);
diff --git a/tests/fixture_dev_codeframe/routes/_500.tsx b/tests/fixture_dev_codeframe/routes/_500.tsx
new file mode 100644
index 00000000000..97672e97c4f
--- /dev/null
+++ b/tests/fixture_dev_codeframe/routes/_500.tsx
@@ -0,0 +1,3 @@
+export default function Error() {
+  return <h1>500 page</h1>;
+}
diff --git a/tests/fixture_dev_codeframe/routes/index.tsx b/tests/fixture_dev_codeframe/routes/index.tsx
new file mode 100644
index 00000000000..d9aa8fce0d2
--- /dev/null
+++ b/tests/fixture_dev_codeframe/routes/index.tsx
@@ -0,0 +1,4 @@
+// deno-lint-ignore no-explicit-any
+export default function Page(): any {
+  throw new Error("fail");
+}
diff --git a/tests/fixture_dev_config/dev.ts b/tests/fixture_dev_config/dev.ts
new file mode 100644
index 00000000000..1b53e2e77cf
--- /dev/null
+++ b/tests/fixture_dev_config/dev.ts
@@ -0,0 +1,4 @@
+import { dev } from "$fresh/src/dev/dev_command.ts";
+import config from "./fresh.config.ts";
+
+await dev(import.meta.url, "./main.ts", config);
diff --git a/tests/fixture_dev_config/fresh.config.ts b/tests/fixture_dev_config/fresh.config.ts
new file mode 100644
index 00000000000..889a6862f1f
--- /dev/null
+++ b/tests/fixture_dev_config/fresh.config.ts
@@ -0,0 +1,8 @@
+import { defineConfig } from "$fresh/server.ts";
+import twind from "$fresh/plugins/twind.ts";
+
+export default defineConfig({
+  plugins: [twind({
+    selfURL: import.meta.url,
+  })],
+});
diff --git a/tests/fixture_dev_config/fresh.gen.ts b/tests/fixture_dev_config/fresh.gen.ts
new file mode 100644
index 00000000000..386fd9bd17f
--- /dev/null
+++ b/tests/fixture_dev_config/fresh.gen.ts
@@ -0,0 +1,17 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/codeframe.tsx";
+import * as $1 from "./routes/index.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/codeframe.tsx": $0,
+    "./routes/index.tsx": $1,
+  },
+  islands: {},
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_dev_config/main.ts b/tests/fixture_dev_config/main.ts
new file mode 100644
index 00000000000..fc9359215e3
--- /dev/null
+++ b/tests/fixture_dev_config/main.ts
@@ -0,0 +1,11 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import manifest from "./fresh.gen.ts";
+import config from "./fresh.config.ts";
+
+await start(manifest, config);
diff --git a/tests/fixture_dev_config/routes/codeframe.tsx b/tests/fixture_dev_config/routes/codeframe.tsx
new file mode 100644
index 00000000000..d9aa8fce0d2
--- /dev/null
+++ b/tests/fixture_dev_config/routes/codeframe.tsx
@@ -0,0 +1,4 @@
+// deno-lint-ignore no-explicit-any
+export default function Page(): any {
+  throw new Error("fail");
+}
diff --git a/tests/fixture_dev_config/routes/index.tsx b/tests/fixture_dev_config/routes/index.tsx
new file mode 100644
index 00000000000..d549f8ae630
--- /dev/null
+++ b/tests/fixture_dev_config/routes/index.tsx
@@ -0,0 +1,3 @@
+export default function Page() {
+  return <h1 class="text-red-600">check color</h1>;
+}
diff --git a/tests/fixture_dev_legacy/dev.ts b/tests/fixture_dev_legacy/dev.ts
new file mode 100644
index 00000000000..dfd26db6721
--- /dev/null
+++ b/tests/fixture_dev_legacy/dev.ts
@@ -0,0 +1,3 @@
+import { dev } from "$fresh/src/dev/dev_command.ts";
+
+await dev(import.meta.url, "./main.ts");
diff --git a/tests/fixture_dev_legacy/fresh.gen.ts b/tests/fixture_dev_legacy/fresh.gen.ts
new file mode 100644
index 00000000000..386fd9bd17f
--- /dev/null
+++ b/tests/fixture_dev_legacy/fresh.gen.ts
@@ -0,0 +1,17 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/codeframe.tsx";
+import * as $1 from "./routes/index.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/codeframe.tsx": $0,
+    "./routes/index.tsx": $1,
+  },
+  islands: {},
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_dev_legacy/main.ts b/tests/fixture_dev_legacy/main.ts
new file mode 100644
index 00000000000..5638b1c2241
--- /dev/null
+++ b/tests/fixture_dev_legacy/main.ts
@@ -0,0 +1,11 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import manifest from "./fresh.gen.ts";
+import twind from "$fresh/plugins/twind.ts";
+
+await start(manifest, { plugins: [twind({ selfURL: import.meta.url })] });
diff --git a/tests/fixture_dev_legacy/routes/codeframe.tsx b/tests/fixture_dev_legacy/routes/codeframe.tsx
new file mode 100644
index 00000000000..d9aa8fce0d2
--- /dev/null
+++ b/tests/fixture_dev_legacy/routes/codeframe.tsx
@@ -0,0 +1,4 @@
+// deno-lint-ignore no-explicit-any
+export default function Page(): any {
+  throw new Error("fail");
+}
diff --git a/tests/fixture_dev_legacy/routes/index.tsx b/tests/fixture_dev_legacy/routes/index.tsx
new file mode 100644
index 00000000000..d549f8ae630
--- /dev/null
+++ b/tests/fixture_dev_legacy/routes/index.tsx
@@ -0,0 +1,3 @@
+export default function Page() {
+  return <h1 class="text-red-600">check color</h1>;
+}
diff --git a/tests/fixture_explicit_app/routes/_app.tsx b/tests/fixture_explicit_app/routes/_app.tsx
index 295434f2e18..fc06dc705ca 100644
--- a/tests/fixture_explicit_app/routes/_app.tsx
+++ b/tests/fixture_explicit_app/routes/_app.tsx
@@ -11,7 +11,7 @@ export default function App(
   return (
     <html lang={state.lang} class="html">
       <head class="head">
-        <meta charSet="utf-8" />
+        <meta charset="utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>fresh title</title>
       </head>
diff --git a/tests/fixture_island_nesting/fresh.gen.ts b/tests/fixture_island_nesting/fresh.gen.ts
index ca11ebed1f8..aace6688c63 100644
--- a/tests/fixture_island_nesting/fresh.gen.ts
+++ b/tests/fixture_island_nesting/fresh.gen.ts
@@ -2,65 +2,71 @@
 // This file SHOULD be checked into source version control.
 // This file is automatically updated during development when running `dev.ts`.
 
-import * as $0 from "./routes/index.tsx";
-import * as $1 from "./routes/island_conditional.tsx";
-import * as $2 from "./routes/island_conditional_lazy.tsx";
-import * as $3 from "./routes/island_conditional_lazy_island.tsx";
-import * as $4 from "./routes/island_fn_child.tsx";
-import * as $5 from "./routes/island_in_island.tsx";
-import * as $6 from "./routes/island_in_island_definition.tsx";
-import * as $7 from "./routes/island_invalid_children.tsx";
-import * as $8 from "./routes/island_invalid_children_fn.tsx";
-import * as $9 from "./routes/island_jsx_child.tsx";
-import * as $10 from "./routes/island_jsx_children.tsx";
-import * as $11 from "./routes/island_jsx_island_jsx.tsx";
-import * as $12 from "./routes/island_jsx_text.tsx";
-import * as $13 from "./routes/island_nested_props.tsx";
-import * as $14 from "./routes/island_order.tsx";
-import * as $15 from "./routes/island_siblings.tsx";
-import * as $16 from "./routes/island_valid_children.tsx";
+import * as $0 from "./routes/dropdown.tsx";
+import * as $1 from "./routes/index.tsx";
+import * as $2 from "./routes/island_conditional.tsx";
+import * as $3 from "./routes/island_conditional_lazy.tsx";
+import * as $4 from "./routes/island_conditional_lazy_island.tsx";
+import * as $5 from "./routes/island_fn_child.tsx";
+import * as $6 from "./routes/island_in_island.tsx";
+import * as $7 from "./routes/island_in_island_definition.tsx";
+import * as $8 from "./routes/island_invalid_children.tsx";
+import * as $9 from "./routes/island_invalid_children_fn.tsx";
+import * as $10 from "./routes/island_jsx_child.tsx";
+import * as $11 from "./routes/island_jsx_children.tsx";
+import * as $12 from "./routes/island_jsx_island_jsx.tsx";
+import * as $13 from "./routes/island_jsx_text.tsx";
+import * as $14 from "./routes/island_nested_props.tsx";
+import * as $15 from "./routes/island_order.tsx";
+import * as $16 from "./routes/island_siblings.tsx";
+import * as $17 from "./routes/island_valid_children.tsx";
 import * as $$0 from "./islands/BooleanButton.tsx";
 import * as $$1 from "./islands/Counter.tsx";
-import * as $$2 from "./islands/FragmentIsland.tsx";
-import * as $$3 from "./islands/Island.tsx";
-import * as $$4 from "./islands/IslandCenter.tsx";
-import * as $$5 from "./islands/IslandConditional.tsx";
-import * as $$6 from "./islands/IslandFn.tsx";
-import * as $$7 from "./islands/IslandInsideIsland.tsx";
-import * as $$8 from "./islands/IslandWithProps.tsx";
-import * as $$9 from "./islands/PassThrough.tsx";
+import * as $$2 from "./islands/Dropdown.tsx";
+import * as $$3 from "./islands/FragmentIsland.tsx";
+import * as $$4 from "./islands/Island.tsx";
+import * as $$5 from "./islands/IslandCenter.tsx";
+import * as $$6 from "./islands/IslandConditional.tsx";
+import * as $$7 from "./islands/IslandFn.tsx";
+import * as $$8 from "./islands/IslandInsideIsland.tsx";
+import * as $$9 from "./islands/IslandWithProps.tsx";
+import * as $$10 from "./islands/PassThrough.tsx";
+import * as $$11 from "./islands/ReadyMarker.tsx";
 
 const manifest = {
   routes: {
-    "./routes/index.tsx": $0,
-    "./routes/island_conditional.tsx": $1,
-    "./routes/island_conditional_lazy.tsx": $2,
-    "./routes/island_conditional_lazy_island.tsx": $3,
-    "./routes/island_fn_child.tsx": $4,
-    "./routes/island_in_island.tsx": $5,
-    "./routes/island_in_island_definition.tsx": $6,
-    "./routes/island_invalid_children.tsx": $7,
-    "./routes/island_invalid_children_fn.tsx": $8,
-    "./routes/island_jsx_child.tsx": $9,
-    "./routes/island_jsx_children.tsx": $10,
-    "./routes/island_jsx_island_jsx.tsx": $11,
-    "./routes/island_jsx_text.tsx": $12,
-    "./routes/island_nested_props.tsx": $13,
-    "./routes/island_order.tsx": $14,
-    "./routes/island_siblings.tsx": $15,
-    "./routes/island_valid_children.tsx": $16,
+    "./routes/dropdown.tsx": $0,
+    "./routes/index.tsx": $1,
+    "./routes/island_conditional.tsx": $2,
+    "./routes/island_conditional_lazy.tsx": $3,
+    "./routes/island_conditional_lazy_island.tsx": $4,
+    "./routes/island_fn_child.tsx": $5,
+    "./routes/island_in_island.tsx": $6,
+    "./routes/island_in_island_definition.tsx": $7,
+    "./routes/island_invalid_children.tsx": $8,
+    "./routes/island_invalid_children_fn.tsx": $9,
+    "./routes/island_jsx_child.tsx": $10,
+    "./routes/island_jsx_children.tsx": $11,
+    "./routes/island_jsx_island_jsx.tsx": $12,
+    "./routes/island_jsx_text.tsx": $13,
+    "./routes/island_nested_props.tsx": $14,
+    "./routes/island_order.tsx": $15,
+    "./routes/island_siblings.tsx": $16,
+    "./routes/island_valid_children.tsx": $17,
   },
   islands: {
     "./islands/BooleanButton.tsx": $$0,
     "./islands/Counter.tsx": $$1,
-    "./islands/FragmentIsland.tsx": $$2,
-    "./islands/Island.tsx": $$3,
-    "./islands/IslandCenter.tsx": $$4,
-    "./islands/IslandConditional.tsx": $$5,
-    "./islands/IslandFn.tsx": $$6,
-    "./islands/IslandInsideIsland.tsx": $$7,
-    "./islands/IslandWithProps.tsx": $$8,
-    "./islands/PassThrough.tsx": $$9,
+    "./islands/Dropdown.tsx": $$2,
+    "./islands/FragmentIsland.tsx": $$3,
+    "./islands/Island.tsx": $$4,
+    "./islands/IslandCenter.tsx": $$5,
+    "./islands/IslandConditional.tsx": $$6,
+    "./islands/IslandFn.tsx": $$7,
+    "./islands/IslandInsideIsland.tsx": $$8,
+    "./islands/IslandWithProps.tsx": $$9,
+    "./islands/PassThrough.tsx": $$10,
+    "./islands/ReadyMarker.tsx": $$11,
   },
   baseUrl: import.meta.url,
 };
diff --git a/tests/fixture_island_nesting/islands/Dropdown.tsx b/tests/fixture_island_nesting/islands/Dropdown.tsx
new file mode 100644
index 00000000000..aed55ddc6ee
--- /dev/null
+++ b/tests/fixture_island_nesting/islands/Dropdown.tsx
@@ -0,0 +1,50 @@
+// islands/Dropdown.tsx
+import { ComponentChildren, createContext } from "preact";
+import { StateUpdater, useState } from "preact/hooks";
+
+const DropdownContext = createContext<[boolean, StateUpdater<boolean>]>(
+  [false, () => {}],
+);
+
+export default function Dropdown(
+  { children }: { children: ComponentChildren },
+) {
+  return (
+    <DropdownContext.Provider value={useState(false)}>
+      {children}
+    </DropdownContext.Provider>
+  );
+}
+
+export function DropdownHandle(
+  { children }: { children: ComponentChildren },
+) {
+  return (
+    <DropdownContext.Consumer>
+      {([isMenuOpen, setIsMenuOpen]) => {
+        return (
+          <button
+            onClick={() => {
+              setIsMenuOpen(!isMenuOpen);
+            }}
+          >
+            {children}
+          </button>
+        );
+      }}
+    </DropdownContext.Consumer>
+  );
+}
+
+export function DropdownMenu({ children }: { children: ComponentChildren }) {
+  return (
+    <DropdownContext.Consumer>
+      {([isMenuOpen]) => {
+        if (isMenuOpen) {
+          return children;
+        }
+        return null;
+      }}
+    </DropdownContext.Consumer>
+  );
+}
diff --git a/tests/fixture_island_nesting/islands/ReadyMarker.tsx b/tests/fixture_island_nesting/islands/ReadyMarker.tsx
new file mode 100644
index 00000000000..d3ef969c299
--- /dev/null
+++ b/tests/fixture_island_nesting/islands/ReadyMarker.tsx
@@ -0,0 +1,15 @@
+import { useSignal } from "@preact/signals";
+import { useEffect } from "preact/hooks";
+
+export function ReadyMarker() {
+  const sig = useSignal(false);
+  useEffect(() => {
+    sig.value = true;
+  }, []);
+
+  return (
+    <p class={sig.value ? "mounted" : "pending"}>
+      {sig.value ? "mounted" : "pending"}
+    </p>
+  );
+}
diff --git a/tests/fixture_island_nesting/routes/dropdown.tsx b/tests/fixture_island_nesting/routes/dropdown.tsx
new file mode 100644
index 00000000000..a11b4716336
--- /dev/null
+++ b/tests/fixture_island_nesting/routes/dropdown.tsx
@@ -0,0 +1,18 @@
+import Dropdown, {
+  DropdownHandle,
+  DropdownMenu,
+} from "../islands/Dropdown.tsx";
+
+export default function Page() {
+  return (
+    <div>
+      <h1>Dropdown</h1>
+      <Dropdown>
+        <DropdownHandle>Click me!</DropdownHandle>
+        <DropdownMenu>
+          <p class="result">Hello Menu!</p>
+        </DropdownMenu>
+      </Dropdown>
+    </div>
+  );
+}
diff --git a/tests/fixture_island_nesting/routes/island_conditional_lazy_island.tsx b/tests/fixture_island_nesting/routes/island_conditional_lazy_island.tsx
index 54ae4bdaebc..fae9ce6a92d 100644
--- a/tests/fixture_island_nesting/routes/island_conditional_lazy_island.tsx
+++ b/tests/fixture_island_nesting/routes/island_conditional_lazy_island.tsx
@@ -2,6 +2,7 @@ import IslandConditional from "../islands/IslandConditional.tsx";
 import BooleanButton from "../islands/BooleanButton.tsx";
 import { useSignal } from "@preact/signals";
 import Counter from "../islands/Counter.tsx";
+import { ReadyMarker } from "../islands/ReadyMarker.tsx";
 
 export default function Page() {
   const show = useSignal(true);
@@ -16,6 +17,7 @@ export default function Page() {
         </div>
       </IslandConditional>
       <BooleanButton signal={show} />
+      <ReadyMarker />
     </div>
   );
 }
diff --git a/tests/fixture_layouts_2/dev.ts b/tests/fixture_layouts_2/dev.ts
new file mode 100644
index 00000000000..2d85d6c183c
--- /dev/null
+++ b/tests/fixture_layouts_2/dev.ts
@@ -0,0 +1,5 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+
+await dev(import.meta.url, "./main.ts");
diff --git a/tests/fixture_layouts_2/fresh.gen.ts b/tests/fixture_layouts_2/fresh.gen.ts
new file mode 100644
index 00000000000..e956af3ce18
--- /dev/null
+++ b/tests/fixture_layouts_2/fresh.gen.ts
@@ -0,0 +1,19 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/_app.tsx";
+import * as $1 from "./routes/_layout.tsx";
+import * as $2 from "./routes/index.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/_app.tsx": $0,
+    "./routes/_layout.tsx": $1,
+    "./routes/index.tsx": $2,
+  },
+  islands: {},
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_layouts_2/main.ts b/tests/fixture_layouts_2/main.ts
new file mode 100644
index 00000000000..0f15e8defa4
--- /dev/null
+++ b/tests/fixture_layouts_2/main.ts
@@ -0,0 +1,10 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+/// <reference lib="deno.unstable" />
+
+import { start } from "$fresh/server.ts";
+import manifest from "./fresh.gen.ts";
+
+await start(manifest);
diff --git a/tests/fixture_layouts_2/routes/_app.tsx b/tests/fixture_layouts_2/routes/_app.tsx
new file mode 100644
index 00000000000..e749edd6061
--- /dev/null
+++ b/tests/fixture_layouts_2/routes/_app.tsx
@@ -0,0 +1,9 @@
+import { defineApp } from "$fresh/server.ts";
+
+export default defineApp((req, { Component }) => {
+  return (
+    <div class="app">
+      <Component />
+    </div>
+  );
+});
diff --git a/tests/fixture_layouts_2/routes/_layout.tsx b/tests/fixture_layouts_2/routes/_layout.tsx
new file mode 100644
index 00000000000..3fdf973385c
--- /dev/null
+++ b/tests/fixture_layouts_2/routes/_layout.tsx
@@ -0,0 +1,11 @@
+import { LayoutProps } from "$fresh/server.ts";
+
+export default function RootLayout(
+  { Component }: LayoutProps<unknown>,
+) {
+  return (
+    <div class="root-layout">
+      <Component />
+    </div>
+  );
+}
diff --git a/tests/fixture_layouts_2/routes/index.tsx b/tests/fixture_layouts_2/routes/index.tsx
new file mode 100644
index 00000000000..13e0de19c47
--- /dev/null
+++ b/tests/fixture_layouts_2/routes/index.tsx
@@ -0,0 +1,7 @@
+export default function Home() {
+  return (
+    <div class="home-page">
+      Home
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/components/Keyed.tsx b/tests/fixture_partials/components/Keyed.tsx
new file mode 100644
index 00000000000..4b20d8aefca
--- /dev/null
+++ b/tests/fixture_partials/components/Keyed.tsx
@@ -0,0 +1,5 @@
+import { ComponentChildren } from "preact";
+
+export function Keyed(props: { children?: ComponentChildren }) {
+  return <>{props.children}</>;
+}
diff --git a/tests/fixture_partials/deno.json b/tests/fixture_partials/deno.json
new file mode 100644
index 00000000000..c4df017779e
--- /dev/null
+++ b/tests/fixture_partials/deno.json
@@ -0,0 +1,20 @@
+{
+  "lock": false,
+  "tasks": {
+    "start": "deno run -A --watch=static/,routes/ dev.ts"
+  },
+  "imports": {
+    "$fresh/": "../../",
+    "twind": "https://esm.sh/twind@0.16.19",
+    "twind/": "https://esm.sh/twind@0.16.19/",
+    "preact": "https://esm.sh/preact@10.15.1",
+    "preact/": "https://esm.sh/preact@10.15.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.1.0",
+    "@preact/signals": "https://esm.sh/*@preact/signals@1.1.3",
+    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.2.3"
+  },
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "jsxImportSource": "preact"
+  }
+}
diff --git a/tests/fixture_partials/dev.ts b/tests/fixture_partials/dev.ts
new file mode 100755
index 00000000000..2d85d6c183c
--- /dev/null
+++ b/tests/fixture_partials/dev.ts
@@ -0,0 +1,5 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+
+await dev(import.meta.url, "./main.ts");
diff --git a/tests/fixture_partials/fresh.gen.ts b/tests/fixture_partials/fresh.gen.ts
new file mode 100644
index 00000000000..a5c60b922ae
--- /dev/null
+++ b/tests/fixture_partials/fresh.gen.ts
@@ -0,0 +1,216 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/_app.tsx";
+import * as $1 from "./routes/active_nav/foo/bar.tsx";
+import * as $2 from "./routes/active_nav/foo/index.tsx";
+import * as $3 from "./routes/active_nav/index.tsx";
+import * as $4 from "./routes/active_nav/island.tsx";
+import * as $5 from "./routes/active_nav_partial/_layout.tsx";
+import * as $6 from "./routes/active_nav_partial/foo/bar.tsx";
+import * as $7 from "./routes/active_nav_partial/foo/index.tsx";
+import * as $8 from "./routes/active_nav_partial/index.tsx";
+import * as $9 from "./routes/active_nav_partial/island.tsx";
+import * as $10 from "./routes/button/index.tsx";
+import * as $11 from "./routes/button/update.tsx";
+import * as $12 from "./routes/client_nav/_layout.tsx";
+import * as $13 from "./routes/client_nav/index.tsx";
+import * as $14 from "./routes/client_nav/injected.tsx";
+import * as $15 from "./routes/client_nav/page-a.tsx";
+import * as $16 from "./routes/client_nav/page-b.tsx";
+import * as $17 from "./routes/client_nav/page-c.tsx";
+import * as $18 from "./routes/client_nav_opt_out/_layout.tsx";
+import * as $19 from "./routes/client_nav_opt_out/index.tsx";
+import * as $20 from "./routes/client_nav_opt_out/injected.tsx";
+import * as $21 from "./routes/client_nav_opt_out/page-a.tsx";
+import * as $22 from "./routes/client_nav_opt_out/page-b.tsx";
+import * as $23 from "./routes/client_nav_opt_out/page-c.tsx";
+import * as $24 from "./routes/deep_partial/index.tsx";
+import * as $25 from "./routes/deep_partial/injected.tsx";
+import * as $26 from "./routes/deep_partial/update.tsx";
+import * as $27 from "./routes/form/index.tsx";
+import * as $28 from "./routes/form/injected.tsx";
+import * as $29 from "./routes/form/update.tsx";
+import * as $30 from "./routes/fragment_nav.tsx";
+import * as $31 from "./routes/head_merge/duplicate.tsx";
+import * as $32 from "./routes/head_merge/index.tsx";
+import * as $33 from "./routes/head_merge/injected.tsx";
+import * as $34 from "./routes/head_merge/update.tsx";
+import * as $35 from "./routes/index.tsx";
+import * as $36 from "./routes/island_instance/index.tsx";
+import * as $37 from "./routes/island_instance/injected.tsx";
+import * as $38 from "./routes/island_instance/partial.tsx";
+import * as $39 from "./routes/island_instance/partial_remove.tsx";
+import * as $40 from "./routes/island_instance/partial_replace.tsx";
+import * as $41 from "./routes/island_instance_multiple/index.tsx";
+import * as $42 from "./routes/island_instance_multiple/injected.tsx";
+import * as $43 from "./routes/island_instance_multiple/partial.tsx";
+import * as $44 from "./routes/island_instance_multiple/partial_both.tsx";
+import * as $45 from "./routes/island_instance_nested/index.tsx";
+import * as $46 from "./routes/island_instance_nested/injected.tsx";
+import * as $47 from "./routes/island_instance_nested/partial.tsx";
+import * as $48 from "./routes/island_instance_nested/replace.tsx";
+import * as $49 from "./routes/island_props/index.tsx";
+import * as $50 from "./routes/island_props/injected.tsx";
+import * as $51 from "./routes/island_props/partial.tsx";
+import * as $52 from "./routes/island_props_signals/index.tsx";
+import * as $53 from "./routes/island_props_signals/injected.tsx";
+import * as $54 from "./routes/island_props_signals/partial.tsx";
+import * as $55 from "./routes/keys/index.tsx";
+import * as $56 from "./routes/keys/injected.tsx";
+import * as $57 from "./routes/keys/swap.tsx";
+import * as $58 from "./routes/keys_components/index.tsx";
+import * as $59 from "./routes/keys_components/injected.tsx";
+import * as $60 from "./routes/keys_components/swap.tsx";
+import * as $61 from "./routes/keys_dom/index.tsx";
+import * as $62 from "./routes/keys_dom/injected.tsx";
+import * as $63 from "./routes/keys_dom/swap.tsx";
+import * as $64 from "./routes/keys_outside/index.tsx";
+import * as $65 from "./routes/loading/index.tsx";
+import * as $66 from "./routes/loading/injected.tsx";
+import * as $67 from "./routes/loading/update.tsx";
+import * as $68 from "./routes/missing_partial/index.tsx";
+import * as $69 from "./routes/missing_partial/injected.tsx";
+import * as $70 from "./routes/missing_partial/update.tsx";
+import * as $71 from "./routes/mode/append.tsx";
+import * as $72 from "./routes/mode/index.tsx";
+import * as $73 from "./routes/mode/injected.tsx";
+import * as $74 from "./routes/mode/prepend.tsx";
+import * as $75 from "./routes/mode/replace.tsx";
+import * as $76 from "./routes/no_islands/index.tsx";
+import * as $77 from "./routes/no_islands/injected.tsx";
+import * as $78 from "./routes/no_islands/update.tsx";
+import * as $79 from "./routes/no_partial_response/index.tsx";
+import * as $80 from "./routes/no_partial_response/injected.tsx";
+import * as $81 from "./routes/no_partial_response/update.tsx";
+import * as $82 from "./routes/partial_slot_inside_island.tsx";
+import * as $83 from "./routes/relative_link/index.tsx";
+import * as $84 from "./routes/scroll_restoration/index.tsx";
+import * as $85 from "./routes/scroll_restoration/injected.tsx";
+import * as $86 from "./routes/scroll_restoration/update.tsx";
+import * as $$0 from "./islands/Counter.tsx";
+import * as $$1 from "./islands/CounterA.tsx";
+import * as $$2 from "./islands/CounterB.tsx";
+import * as $$3 from "./islands/Fader.tsx";
+import * as $$4 from "./islands/InvalidSlot.tsx";
+import * as $$5 from "./islands/LazyLink.tsx";
+import * as $$6 from "./islands/Logger.tsx";
+import * as $$7 from "./islands/Other.tsx";
+import * as $$8 from "./islands/PartialTrigger.tsx";
+import * as $$9 from "./islands/PassThrough.tsx";
+import * as $$10 from "./islands/PropIsland.tsx";
+import * as $$11 from "./islands/SignalProp.tsx";
+import * as $$12 from "./islands/Spinner.tsx";
+import * as $$13 from "./islands/Stateful.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/_app.tsx": $0,
+    "./routes/active_nav/foo/bar.tsx": $1,
+    "./routes/active_nav/foo/index.tsx": $2,
+    "./routes/active_nav/index.tsx": $3,
+    "./routes/active_nav/island.tsx": $4,
+    "./routes/active_nav_partial/_layout.tsx": $5,
+    "./routes/active_nav_partial/foo/bar.tsx": $6,
+    "./routes/active_nav_partial/foo/index.tsx": $7,
+    "./routes/active_nav_partial/index.tsx": $8,
+    "./routes/active_nav_partial/island.tsx": $9,
+    "./routes/button/index.tsx": $10,
+    "./routes/button/update.tsx": $11,
+    "./routes/client_nav/_layout.tsx": $12,
+    "./routes/client_nav/index.tsx": $13,
+    "./routes/client_nav/injected.tsx": $14,
+    "./routes/client_nav/page-a.tsx": $15,
+    "./routes/client_nav/page-b.tsx": $16,
+    "./routes/client_nav/page-c.tsx": $17,
+    "./routes/client_nav_opt_out/_layout.tsx": $18,
+    "./routes/client_nav_opt_out/index.tsx": $19,
+    "./routes/client_nav_opt_out/injected.tsx": $20,
+    "./routes/client_nav_opt_out/page-a.tsx": $21,
+    "./routes/client_nav_opt_out/page-b.tsx": $22,
+    "./routes/client_nav_opt_out/page-c.tsx": $23,
+    "./routes/deep_partial/index.tsx": $24,
+    "./routes/deep_partial/injected.tsx": $25,
+    "./routes/deep_partial/update.tsx": $26,
+    "./routes/form/index.tsx": $27,
+    "./routes/form/injected.tsx": $28,
+    "./routes/form/update.tsx": $29,
+    "./routes/fragment_nav.tsx": $30,
+    "./routes/head_merge/duplicate.tsx": $31,
+    "./routes/head_merge/index.tsx": $32,
+    "./routes/head_merge/injected.tsx": $33,
+    "./routes/head_merge/update.tsx": $34,
+    "./routes/index.tsx": $35,
+    "./routes/island_instance/index.tsx": $36,
+    "./routes/island_instance/injected.tsx": $37,
+    "./routes/island_instance/partial.tsx": $38,
+    "./routes/island_instance/partial_remove.tsx": $39,
+    "./routes/island_instance/partial_replace.tsx": $40,
+    "./routes/island_instance_multiple/index.tsx": $41,
+    "./routes/island_instance_multiple/injected.tsx": $42,
+    "./routes/island_instance_multiple/partial.tsx": $43,
+    "./routes/island_instance_multiple/partial_both.tsx": $44,
+    "./routes/island_instance_nested/index.tsx": $45,
+    "./routes/island_instance_nested/injected.tsx": $46,
+    "./routes/island_instance_nested/partial.tsx": $47,
+    "./routes/island_instance_nested/replace.tsx": $48,
+    "./routes/island_props/index.tsx": $49,
+    "./routes/island_props/injected.tsx": $50,
+    "./routes/island_props/partial.tsx": $51,
+    "./routes/island_props_signals/index.tsx": $52,
+    "./routes/island_props_signals/injected.tsx": $53,
+    "./routes/island_props_signals/partial.tsx": $54,
+    "./routes/keys/index.tsx": $55,
+    "./routes/keys/injected.tsx": $56,
+    "./routes/keys/swap.tsx": $57,
+    "./routes/keys_components/index.tsx": $58,
+    "./routes/keys_components/injected.tsx": $59,
+    "./routes/keys_components/swap.tsx": $60,
+    "./routes/keys_dom/index.tsx": $61,
+    "./routes/keys_dom/injected.tsx": $62,
+    "./routes/keys_dom/swap.tsx": $63,
+    "./routes/keys_outside/index.tsx": $64,
+    "./routes/loading/index.tsx": $65,
+    "./routes/loading/injected.tsx": $66,
+    "./routes/loading/update.tsx": $67,
+    "./routes/missing_partial/index.tsx": $68,
+    "./routes/missing_partial/injected.tsx": $69,
+    "./routes/missing_partial/update.tsx": $70,
+    "./routes/mode/append.tsx": $71,
+    "./routes/mode/index.tsx": $72,
+    "./routes/mode/injected.tsx": $73,
+    "./routes/mode/prepend.tsx": $74,
+    "./routes/mode/replace.tsx": $75,
+    "./routes/no_islands/index.tsx": $76,
+    "./routes/no_islands/injected.tsx": $77,
+    "./routes/no_islands/update.tsx": $78,
+    "./routes/no_partial_response/index.tsx": $79,
+    "./routes/no_partial_response/injected.tsx": $80,
+    "./routes/no_partial_response/update.tsx": $81,
+    "./routes/partial_slot_inside_island.tsx": $82,
+    "./routes/relative_link/index.tsx": $83,
+    "./routes/scroll_restoration/index.tsx": $84,
+    "./routes/scroll_restoration/injected.tsx": $85,
+    "./routes/scroll_restoration/update.tsx": $86,
+  },
+  islands: {
+    "./islands/Counter.tsx": $$0,
+    "./islands/CounterA.tsx": $$1,
+    "./islands/CounterB.tsx": $$2,
+    "./islands/Fader.tsx": $$3,
+    "./islands/InvalidSlot.tsx": $$4,
+    "./islands/LazyLink.tsx": $$5,
+    "./islands/Logger.tsx": $$6,
+    "./islands/Other.tsx": $$7,
+    "./islands/PartialTrigger.tsx": $$8,
+    "./islands/PassThrough.tsx": $$9,
+    "./islands/PropIsland.tsx": $$10,
+    "./islands/SignalProp.tsx": $$11,
+    "./islands/Spinner.tsx": $$12,
+    "./islands/Stateful.tsx": $$13,
+  },
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_partials/islands/Counter.tsx b/tests/fixture_partials/islands/Counter.tsx
new file mode 100644
index 00000000000..463560fb39c
--- /dev/null
+++ b/tests/fixture_partials/islands/Counter.tsx
@@ -0,0 +1,16 @@
+import { useSignal } from "@preact/signals";
+import { Logger } from "./Logger.tsx";
+
+export default function Counter(props: { id: string }) {
+  const sig = useSignal(0);
+  return (
+    <Logger name={`Counter ${props.id}`}>
+      <div class="island">
+        <p class={`output-${props.id}`}>{sig.value}</p>
+        <button onClick={() => sig.value += 1}>
+          update
+        </button>
+      </div>
+    </Logger>
+  );
+}
diff --git a/tests/fixture_partials/islands/CounterA.tsx b/tests/fixture_partials/islands/CounterA.tsx
new file mode 100644
index 00000000000..b4d905687cc
--- /dev/null
+++ b/tests/fixture_partials/islands/CounterA.tsx
@@ -0,0 +1,16 @@
+import { useSignal } from "@preact/signals";
+import { Logger } from "./Logger.tsx";
+
+export default function CounterA() {
+  const sig = useSignal(0);
+  return (
+    <Logger name="Counter A">
+      <div class="island island-a">
+        <p class="output-a">{sig.value}</p>
+        <button onClick={() => sig.value += 1}>
+          update
+        </button>
+      </div>
+    </Logger>
+  );
+}
diff --git a/tests/fixture_partials/islands/CounterB.tsx b/tests/fixture_partials/islands/CounterB.tsx
new file mode 100644
index 00000000000..f41df0212fb
--- /dev/null
+++ b/tests/fixture_partials/islands/CounterB.tsx
@@ -0,0 +1,16 @@
+import { useSignal } from "@preact/signals";
+import { Logger } from "./Logger.tsx";
+
+export default function CounterB() {
+  const sig = useSignal(0);
+  return (
+    <Logger name="Counter B">
+      <div class="island island-b">
+        <p class="output-b">{sig.value}</p>
+        <button onClick={() => sig.value += 1}>
+          update
+        </button>
+      </div>
+    </Logger>
+  );
+}
diff --git a/tests/fixture_partials/islands/Fader.tsx b/tests/fixture_partials/islands/Fader.tsx
new file mode 100644
index 00000000000..bbdfb69ae66
--- /dev/null
+++ b/tests/fixture_partials/islands/Fader.tsx
@@ -0,0 +1,26 @@
+import { useEffect, useRef } from "preact/hooks";
+import { ComponentChildren } from "preact";
+
+export function Fader(props: { children?: ComponentChildren }) {
+  const ref = useRef<HTMLDivElement>(null);
+  const mounted = useRef(false);
+
+  useEffect(() => {
+    if (!mounted.current) {
+      mounted.current = true;
+      return;
+    }
+    if (ref.current) {
+      ref.current.animate([
+        { backgroundColor: "white" },
+        { backgroundColor: "peachpuff" },
+      ], {
+        fill: "backwards",
+        easing: "ease-out",
+        duration: 600,
+      });
+    }
+  });
+
+  return <div ref={ref}>{props.children}</div>;
+}
diff --git a/tests/fixture_partials/islands/InvalidSlot.tsx b/tests/fixture_partials/islands/InvalidSlot.tsx
new file mode 100644
index 00000000000..15215497fbd
--- /dev/null
+++ b/tests/fixture_partials/islands/InvalidSlot.tsx
@@ -0,0 +1,11 @@
+import { Partial } from "$fresh/runtime.ts";
+
+export default function InvalidSlot() {
+  return (
+    <div class="island">
+      <Partial name="invalid">
+        <h1>it doesn't work</h1>
+      </Partial>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/islands/LazyLink.tsx b/tests/fixture_partials/islands/LazyLink.tsx
new file mode 100644
index 00000000000..9e3d234d277
--- /dev/null
+++ b/tests/fixture_partials/islands/LazyLink.tsx
@@ -0,0 +1,28 @@
+import { useSignal } from "@preact/signals";
+import { useEffect } from "preact/hooks";
+
+export default function LazyLink(props: { links: string[] }) {
+  const sig = useSignal(false);
+
+  useEffect(() => {
+    sig.value = true;
+  }, []);
+
+  return (
+    <div class="island">
+      {sig.value
+        ? (
+          <ul class="revived">
+            {props.links.map((link) => {
+              return (
+                <li key={link}>
+                  <a href={link}>{link}</a>
+                </li>
+              );
+            })}
+          </ul>
+        )
+        : null}
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/islands/Logger.tsx b/tests/fixture_partials/islands/Logger.tsx
new file mode 100644
index 00000000000..a0b1c36a4cf
--- /dev/null
+++ b/tests/fixture_partials/islands/Logger.tsx
@@ -0,0 +1,30 @@
+import { ComponentChildren } from "preact";
+import { useEffect, useRef } from "preact/hooks";
+
+export function Logger(props: { children?: ComponentChildren; name?: string }) {
+  const mounted = useRef(false);
+
+  useEffect(() => {
+    mounted.current = true;
+    const logs = document.querySelector("#logs");
+    if (logs) {
+      logs.textContent += `mount ${props.name}\n`;
+    }
+
+    return () => {
+      if (logs) {
+        logs.textContent += `unmount ${props.name}\n`;
+      }
+    };
+  }, []);
+
+  if (mounted.current && typeof document !== "undefined") {
+    const logs = document.querySelector("#logs");
+    if (logs) {
+      logs.textContent += `update ${props.name}\n`;
+    }
+  }
+
+  // deno-lint-ignore no-explicit-any
+  return props.children as any;
+}
diff --git a/tests/fixture_partials/islands/Other.tsx b/tests/fixture_partials/islands/Other.tsx
new file mode 100644
index 00000000000..501078f6170
--- /dev/null
+++ b/tests/fixture_partials/islands/Other.tsx
@@ -0,0 +1,16 @@
+import { useSignal } from "@preact/signals";
+import { Logger } from "./Logger.tsx";
+
+export default function Other() {
+  const sig = useSignal(0);
+  return (
+    <Logger name="Other">
+      <div class="island island-other">
+        <p class="output-other">{sig.value}</p>
+        <button onClick={() => sig.value += 1}>
+          update
+        </button>
+      </div>
+    </Logger>
+  );
+}
diff --git a/tests/fixture_partials/islands/PartialTrigger.tsx b/tests/fixture_partials/islands/PartialTrigger.tsx
new file mode 100644
index 00000000000..1ab50a25867
--- /dev/null
+++ b/tests/fixture_partials/islands/PartialTrigger.tsx
@@ -0,0 +1,23 @@
+import { Signal } from "@preact/signals";
+import { ComponentChildren } from "preact";
+
+export default function PartialTrigger(
+  props: {
+    class: string;
+    href: string;
+    partial?: string;
+    loading?: Signal<boolean>;
+    children?: ComponentChildren;
+  },
+) {
+  return (
+    <a
+      class={props.class}
+      href={props.href}
+      f-partial={props.partial}
+      f-loading={props.loading}
+    >
+      {props.children}
+    </a>
+  );
+}
diff --git a/tests/fixture_partials/islands/PassThrough.tsx b/tests/fixture_partials/islands/PassThrough.tsx
new file mode 100644
index 00000000000..fc9012fb304
--- /dev/null
+++ b/tests/fixture_partials/islands/PassThrough.tsx
@@ -0,0 +1,15 @@
+import { Fader } from "$fresh/tests/fixture_partials/islands/Fader.tsx";
+import { Logger } from "./Logger.tsx";
+import { ComponentChildren } from "preact";
+
+export default function PassThrough(props: { children?: ComponentChildren }) {
+  return (
+    <Fader>
+      <Logger name="PassThrough">
+        <div class="island">
+          {props.children}
+        </div>
+      </Logger>
+    </Fader>
+  );
+}
diff --git a/tests/fixture_partials/islands/PropIsland.tsx b/tests/fixture_partials/islands/PropIsland.tsx
new file mode 100644
index 00000000000..89cb89023a9
--- /dev/null
+++ b/tests/fixture_partials/islands/PropIsland.tsx
@@ -0,0 +1,22 @@
+export default function PropIsland(
+  props: {
+    number: number;
+    string: string;
+    boolean: boolean;
+    strArr: string[];
+    obj: { foo: number };
+  },
+) {
+  return (
+    <pre class="pre-props">
+      {JSON.stringify({
+        number: props.number,
+        string: props.string,
+        null: null,
+        boolean: props.boolean,
+        object: props.obj,
+        strArr: props.strArr,
+      },null,2)}
+    </pre>
+  );
+}
diff --git a/tests/fixture_partials/islands/SignalProp.tsx b/tests/fixture_partials/islands/SignalProp.tsx
new file mode 100644
index 00000000000..263593db194
--- /dev/null
+++ b/tests/fixture_partials/islands/SignalProp.tsx
@@ -0,0 +1,12 @@
+import { Signal } from "@preact/signals";
+
+export default function SignalProp(props: { sig: Signal<number> }) {
+  return (
+    <div class="island">
+      <p class="output">{props.sig.value}</p>
+      <button onClick={() => props.sig.value += 1}>
+        update
+      </button>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/islands/Spinner.tsx b/tests/fixture_partials/islands/Spinner.tsx
new file mode 100644
index 00000000000..d2c08981377
--- /dev/null
+++ b/tests/fixture_partials/islands/Spinner.tsx
@@ -0,0 +1,7 @@
+import { Signal } from "@preact/signals";
+
+export default function Spinner(props: { id: string; show: Signal<boolean> }) {
+  return props.show.value
+    ? <p class={`spinner spinner-${props.id}`}>loading...</p>
+    : null;
+}
diff --git a/tests/fixture_partials/islands/Stateful.tsx b/tests/fixture_partials/islands/Stateful.tsx
new file mode 100644
index 00000000000..d2579baf2a0
--- /dev/null
+++ b/tests/fixture_partials/islands/Stateful.tsx
@@ -0,0 +1,13 @@
+import { useState } from "preact/hooks";
+
+export default function Stateful(props: { id: string }) {
+  const [v, set] = useState(0);
+  return (
+    <div class="island">
+      <p class={`output-${props.id}`}>{v}</p>
+      <button class={`btn-${props.id}`} onClick={() => set((v) => v + 1)}>
+        update
+      </button>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/main.ts b/tests/fixture_partials/main.ts
new file mode 100644
index 00000000000..552ac27df71
--- /dev/null
+++ b/tests/fixture_partials/main.ts
@@ -0,0 +1,9 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import manifest from "./fresh.gen.ts";
+
+await start(manifest);
diff --git a/tests/fixture_partials/routes/_app.tsx b/tests/fixture_partials/routes/_app.tsx
new file mode 100644
index 00000000000..1e55e7d35bd
--- /dev/null
+++ b/tests/fixture_partials/routes/_app.tsx
@@ -0,0 +1,16 @@
+import { defineApp } from "$fresh/src/server/defines.ts";
+
+export default defineApp((res, ctx) => {
+  return (
+    <html>
+      <head>
+        <meta charset="utf-8" />
+        <title>test</title>
+        <link rel="stylesheet" href="/style.css" />
+      </head>
+      <body f-client-nav>
+        <ctx.Component />
+      </body>
+    </html>
+  );
+});
diff --git a/tests/fixture_partials/routes/active_nav/foo/bar.tsx b/tests/fixture_partials/routes/active_nav/foo/bar.tsx
new file mode 100644
index 00000000000..3c0e69be626
--- /dev/null
+++ b/tests/fixture_partials/routes/active_nav/foo/bar.tsx
@@ -0,0 +1,19 @@
+export default function Page() {
+  return (
+    <div>
+      <h1>nav</h1>
+      <p>
+        <a href="/active_nav/foo/bar">/active_nav/foo/bar</a>
+      </p>
+      <p>
+        <a href="/active_nav/foo">/active_nav/foo</a>
+      </p>
+      <p>
+        <a href="/active_nav">/active_nav</a>
+      </p>
+      <p>
+        <a href="/">/</a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/active_nav/foo/index.tsx b/tests/fixture_partials/routes/active_nav/foo/index.tsx
new file mode 100644
index 00000000000..3c0e69be626
--- /dev/null
+++ b/tests/fixture_partials/routes/active_nav/foo/index.tsx
@@ -0,0 +1,19 @@
+export default function Page() {
+  return (
+    <div>
+      <h1>nav</h1>
+      <p>
+        <a href="/active_nav/foo/bar">/active_nav/foo/bar</a>
+      </p>
+      <p>
+        <a href="/active_nav/foo">/active_nav/foo</a>
+      </p>
+      <p>
+        <a href="/active_nav">/active_nav</a>
+      </p>
+      <p>
+        <a href="/">/</a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/active_nav/index.tsx b/tests/fixture_partials/routes/active_nav/index.tsx
new file mode 100644
index 00000000000..3c0e69be626
--- /dev/null
+++ b/tests/fixture_partials/routes/active_nav/index.tsx
@@ -0,0 +1,19 @@
+export default function Page() {
+  return (
+    <div>
+      <h1>nav</h1>
+      <p>
+        <a href="/active_nav/foo/bar">/active_nav/foo/bar</a>
+      </p>
+      <p>
+        <a href="/active_nav/foo">/active_nav/foo</a>
+      </p>
+      <p>
+        <a href="/active_nav">/active_nav</a>
+      </p>
+      <p>
+        <a href="/">/</a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/active_nav/island.tsx b/tests/fixture_partials/routes/active_nav/island.tsx
new file mode 100644
index 00000000000..cba29742484
--- /dev/null
+++ b/tests/fixture_partials/routes/active_nav/island.tsx
@@ -0,0 +1,12 @@
+import LazyLink from "../../islands/LazyLink.tsx";
+
+export default function Page() {
+  return (
+    <div>
+      <h1>active nav island</h1>
+      <LazyLink
+        links={["/", "/active_nav", "/active_nav/foo", "/active_nav/island/"]}
+      />
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/active_nav_partial/_layout.tsx b/tests/fixture_partials/routes/active_nav_partial/_layout.tsx
new file mode 100644
index 00000000000..e31f709eaaf
--- /dev/null
+++ b/tests/fixture_partials/routes/active_nav_partial/_layout.tsx
@@ -0,0 +1,9 @@
+import { LayoutProps } from "$fresh/server.ts";
+
+export default function Layout({ Component }: LayoutProps) {
+  return (
+    <div f-client-nav>
+      <Component />
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/active_nav_partial/foo/bar.tsx b/tests/fixture_partials/routes/active_nav_partial/foo/bar.tsx
new file mode 100644
index 00000000000..91a39463abc
--- /dev/null
+++ b/tests/fixture_partials/routes/active_nav_partial/foo/bar.tsx
@@ -0,0 +1,23 @@
+import { Partial } from "$fresh/runtime.ts";
+
+export default function Page() {
+  return (
+    <div>
+      <Partial name="content">
+        <h1>/active_nav_partial/foo/bar</h1>
+      </Partial>
+      <p>
+        <a href="/active_nav_partial/foo/bar">/active_nav_partial/foo/bar</a>
+      </p>
+      <p>
+        <a href="/active_nav_partial/foo">/active_nav_partial/foo</a>
+      </p>
+      <p>
+        <a href="/active_nav_partial">/active_nav_partial</a>
+      </p>
+      <p>
+        <a href="/">/</a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/active_nav_partial/foo/index.tsx b/tests/fixture_partials/routes/active_nav_partial/foo/index.tsx
new file mode 100644
index 00000000000..b0f9ab7ede9
--- /dev/null
+++ b/tests/fixture_partials/routes/active_nav_partial/foo/index.tsx
@@ -0,0 +1,23 @@
+import { Partial } from "$fresh/runtime.ts";
+
+export default function Page() {
+  return (
+    <div>
+      <Partial name="content">
+        <h1>/active_nav_partial/foo</h1>
+      </Partial>
+      <p>
+        <a href="/active_nav_partial/foo/bar">/active_nav_partial/foo/bar</a>
+      </p>
+      <p>
+        <a href="/active_nav_partial/foo">/active_nav_partial/foo</a>
+      </p>
+      <p>
+        <a href="/active_nav_partial">/active_nav_partial</a>
+      </p>
+      <p>
+        <a href="/">/</a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/active_nav_partial/index.tsx b/tests/fixture_partials/routes/active_nav_partial/index.tsx
new file mode 100644
index 00000000000..467fa73db61
--- /dev/null
+++ b/tests/fixture_partials/routes/active_nav_partial/index.tsx
@@ -0,0 +1,23 @@
+import { Partial } from "$fresh/runtime.ts";
+
+export default function Page() {
+  return (
+    <div>
+      <Partial name="content">
+        <h1>/active_nav_partial</h1>
+      </Partial>
+      <p>
+        <a href="/active_nav_partial/foo/bar">/active_nav_partial/foo/bar</a>
+      </p>
+      <p>
+        <a href="/active_nav_partial/foo">/active_nav_partial/foo</a>
+      </p>
+      <p>
+        <a href="/active_nav_partial">/active_nav_partial</a>
+      </p>
+      <p>
+        <a href="/">/</a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/active_nav_partial/island.tsx b/tests/fixture_partials/routes/active_nav_partial/island.tsx
new file mode 100644
index 00000000000..52506c92ebe
--- /dev/null
+++ b/tests/fixture_partials/routes/active_nav_partial/island.tsx
@@ -0,0 +1,17 @@
+import LazyLink from "../../islands/LazyLink.tsx";
+
+export default function Page() {
+  return (
+    <div>
+      <h1>active nav island</h1>
+      <LazyLink
+        links={[
+          "/",
+          "/active_nav_partial",
+          "/active_nav_partial/foo",
+          "/active_nav_partial/island/",
+        ]}
+      />
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/button/index.tsx b/tests/fixture_partials/routes/button/index.tsx
new file mode 100644
index 00000000000..667bcc1be2f
--- /dev/null
+++ b/tests/fixture_partials/routes/button/index.tsx
@@ -0,0 +1,19 @@
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default function ModeDemo() {
+  return (
+    <div f-client-nav>
+      <Partial name="body">
+        <Fader>
+          <p class="status-initial">Initial content</p>
+        </Fader>
+      </Partial>
+      <p>
+        <button f-partial="/button/update">
+          update
+        </button>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/button/update.tsx b/tests/fixture_partials/routes/button/update.tsx
new file mode 100644
index 00000000000..34540680f92
--- /dev/null
+++ b/tests/fixture_partials/routes/button/update.tsx
@@ -0,0 +1,19 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="body">
+      <Fader>
+        <p class="status-updated">update</p>
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/client_nav/_layout.tsx b/tests/fixture_partials/routes/client_nav/_layout.tsx
new file mode 100644
index 00000000000..baf923d3cfe
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav/_layout.tsx
@@ -0,0 +1,48 @@
+import { AppProps } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default function AppLayout({ Component }: AppProps) {
+  return (
+    <html>
+      <head>
+        <meta charset="utf-8" />
+        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+        <title>fresh title</title>
+      </head>
+      <body f-client-nav>
+        <Partial name="body">
+          <Fader>
+            <Component />
+          </Fader>
+        </Partial>
+        <p>
+          <a
+            class="page-a-link"
+            href="/client_nav/page-a"
+          >
+            Page A
+          </a>
+        </p>
+        <p>
+          <a
+            class="page-b-link"
+            href="/client_nav/page-b"
+          >
+            Page B
+          </a>
+        </p>
+        <p>
+          <a
+            class="page-c-link"
+            href="/client_nav/page-c"
+          >
+            Page C
+          </a>
+        </p>
+
+        <pre id="logs" />
+      </body>
+    </html>
+  );
+}
diff --git a/tests/fixture_partials/routes/client_nav/index.tsx b/tests/fixture_partials/routes/client_nav/index.tsx
new file mode 100644
index 00000000000..bf717a6a55d
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav/index.tsx
@@ -0,0 +1,21 @@
+import { Partial } from "$fresh/runtime.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+};
+
+export default function ModeDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Fader>
+          <p class="status-initial">Initial content</p>
+          <CounterA />
+        </Fader>
+      </Partial>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/client_nav/injected.tsx b/tests/fixture_partials/routes/client_nav/injected.tsx
new file mode 100644
index 00000000000..3b9b5a2901f
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/client_nav",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/client_nav/page-a.tsx b/tests/fixture_partials/routes/client_nav/page-a.tsx
new file mode 100644
index 00000000000..94fcfa0bb51
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav/page-a.tsx
@@ -0,0 +1,17 @@
+import { RouteConfig } from "$fresh/server.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+};
+
+export default function PageA() {
+  return (
+    <Fader>
+      <h1>Page A</h1>
+      <p>asdfasdf asdf asdf</p>
+      <CounterA />
+    </Fader>
+  );
+}
diff --git a/tests/fixture_partials/routes/client_nav/page-b.tsx b/tests/fixture_partials/routes/client_nav/page-b.tsx
new file mode 100644
index 00000000000..70468dc22d3
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav/page-b.tsx
@@ -0,0 +1,20 @@
+import { RouteConfig } from "$fresh/server.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import CounterB from "../../islands/CounterB.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+};
+
+export default function PageB() {
+  return (
+    <Fader>
+      <i>something before</i>
+      <div>
+        <h1>Page B</h1>
+      </div>
+      <CounterB />
+      <p>asdfasdf asdf asdf</p>
+    </Fader>
+  );
+}
diff --git a/tests/fixture_partials/routes/client_nav/page-c.tsx b/tests/fixture_partials/routes/client_nav/page-c.tsx
new file mode 100644
index 00000000000..577849e70a6
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav/page-c.tsx
@@ -0,0 +1,17 @@
+import { RouteConfig } from "$fresh/server.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+};
+
+export default function PageB() {
+  return (
+    <Fader>
+      <h1>Page C</h1>
+      <span class="page-c-text">
+        <p>asdfasdf asdf asdf</p>
+      </span>
+    </Fader>
+  );
+}
diff --git a/tests/fixture_partials/routes/client_nav_opt_out/_layout.tsx b/tests/fixture_partials/routes/client_nav_opt_out/_layout.tsx
new file mode 100644
index 00000000000..550bcab903c
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav_opt_out/_layout.tsx
@@ -0,0 +1,48 @@
+import { AppProps } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default function AppLayout({ Component }: AppProps) {
+  return (
+    <html>
+      <head>
+        <meta charset="utf-8" />
+        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+        <title>fresh title</title>
+      </head>
+      <body f-client-nav={false}>
+        <Partial name="body">
+          <Fader>
+            <Component />
+          </Fader>
+        </Partial>
+        <p>
+          <a
+            class="page-a-link"
+            href="/client_nav_opt_out/page-a"
+          >
+            Page A
+          </a>
+        </p>
+        <p>
+          <a
+            class="page-b-link"
+            href="/client_nav_opt_out/page-b"
+          >
+            Page B
+          </a>
+        </p>
+        <p>
+          <a
+            class="page-c-link"
+            href="/client_nav_opt_out/page-c"
+          >
+            Page C
+          </a>
+        </p>
+
+        <pre id="logs" />
+      </body>
+    </html>
+  );
+}
diff --git a/tests/fixture_partials/routes/client_nav_opt_out/index.tsx b/tests/fixture_partials/routes/client_nav_opt_out/index.tsx
new file mode 100644
index 00000000000..bf717a6a55d
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav_opt_out/index.tsx
@@ -0,0 +1,21 @@
+import { Partial } from "$fresh/runtime.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+};
+
+export default function ModeDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Fader>
+          <p class="status-initial">Initial content</p>
+          <CounterA />
+        </Fader>
+      </Partial>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/client_nav_opt_out/injected.tsx b/tests/fixture_partials/routes/client_nav_opt_out/injected.tsx
new file mode 100644
index 00000000000..52fc8fffb8b
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav_opt_out/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/client_nav_opt_out",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/client_nav_opt_out/page-a.tsx b/tests/fixture_partials/routes/client_nav_opt_out/page-a.tsx
new file mode 100644
index 00000000000..94fcfa0bb51
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav_opt_out/page-a.tsx
@@ -0,0 +1,17 @@
+import { RouteConfig } from "$fresh/server.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+};
+
+export default function PageA() {
+  return (
+    <Fader>
+      <h1>Page A</h1>
+      <p>asdfasdf asdf asdf</p>
+      <CounterA />
+    </Fader>
+  );
+}
diff --git a/tests/fixture_partials/routes/client_nav_opt_out/page-b.tsx b/tests/fixture_partials/routes/client_nav_opt_out/page-b.tsx
new file mode 100644
index 00000000000..70468dc22d3
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav_opt_out/page-b.tsx
@@ -0,0 +1,20 @@
+import { RouteConfig } from "$fresh/server.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import CounterB from "../../islands/CounterB.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+};
+
+export default function PageB() {
+  return (
+    <Fader>
+      <i>something before</i>
+      <div>
+        <h1>Page B</h1>
+      </div>
+      <CounterB />
+      <p>asdfasdf asdf asdf</p>
+    </Fader>
+  );
+}
diff --git a/tests/fixture_partials/routes/client_nav_opt_out/page-c.tsx b/tests/fixture_partials/routes/client_nav_opt_out/page-c.tsx
new file mode 100644
index 00000000000..577849e70a6
--- /dev/null
+++ b/tests/fixture_partials/routes/client_nav_opt_out/page-c.tsx
@@ -0,0 +1,17 @@
+import { RouteConfig } from "$fresh/server.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+};
+
+export default function PageB() {
+  return (
+    <Fader>
+      <h1>Page C</h1>
+      <span class="page-c-text">
+        <p>asdfasdf asdf asdf</p>
+      </span>
+    </Fader>
+  );
+}
diff --git a/tests/fixture_partials/routes/deep_partial/index.tsx b/tests/fixture_partials/routes/deep_partial/index.tsx
new file mode 100644
index 00000000000..756672062b2
--- /dev/null
+++ b/tests/fixture_partials/routes/deep_partial/index.tsx
@@ -0,0 +1,27 @@
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import { Logger } from "../../islands/Logger.tsx";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Logger name="slot-1">
+          <Fader>
+            <p class="status">initial</p>
+          </Fader>
+        </Logger>
+      </Partial>
+      <p>
+        <a
+          class="update-link"
+          href="/deep_partial/injected"
+          f-partial="/deep_partial/update"
+        >
+          update
+        </a>
+      </p>
+      <pre id="logs" />
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/deep_partial/injected.tsx b/tests/fixture_partials/routes/deep_partial/injected.tsx
new file mode 100644
index 00000000000..f1fd4145f54
--- /dev/null
+++ b/tests/fixture_partials/routes/deep_partial/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/deep_partial",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/deep_partial/update.tsx b/tests/fixture_partials/routes/deep_partial/update.tsx
new file mode 100644
index 00000000000..2dd2665c9e1
--- /dev/null
+++ b/tests/fixture_partials/routes/deep_partial/update.tsx
@@ -0,0 +1,26 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import { Logger } from "../../islands/Logger.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <div>
+      <div>
+        <Partial name="slot-1">
+          <Logger name="slot-1">
+            <Fader>
+              <p class="status-updated">updated</p>
+            </Fader>
+          </Logger>
+        </Partial>
+      </div>
+    </div>
+  );
+});
diff --git a/tests/fixture_partials/routes/form/index.tsx b/tests/fixture_partials/routes/form/index.tsx
new file mode 100644
index 00000000000..7e911445fb3
--- /dev/null
+++ b/tests/fixture_partials/routes/form/index.tsx
@@ -0,0 +1,19 @@
+import { Partial } from "$fresh/runtime.ts";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <form f-partial="/form/update">
+        <Partial name="slot-1">
+          <p class="status">Default content</p>
+          <p>
+            <input type="text" value="foo" />
+          </p>
+        </Partial>
+        <button type="submit" class="submit">
+          submit
+        </button>
+      </form>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/form/injected.tsx b/tests/fixture_partials/routes/form/injected.tsx
new file mode 100644
index 00000000000..c26cf8ac72e
--- /dev/null
+++ b/tests/fixture_partials/routes/form/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/form",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/form/update.tsx b/tests/fixture_partials/routes/form/update.tsx
new file mode 100644
index 00000000000..61b9d82204a
--- /dev/null
+++ b/tests/fixture_partials/routes/form/update.tsx
@@ -0,0 +1,19 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <p class="status-updated">it works</p>
+      <p>
+        <input type="text" />
+      </p>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/fragment_nav.tsx b/tests/fixture_partials/routes/fragment_nav.tsx
new file mode 100644
index 00000000000..88eecfe40a6
--- /dev/null
+++ b/tests/fixture_partials/routes/fragment_nav.tsx
@@ -0,0 +1,15 @@
+import { Partial } from "$fresh/runtime.ts";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <h1 id="foo">Same nav</h1>
+      <a href="#foo">#foo</a>
+      <Partial name="foo">
+        <p class="partial-text">
+          foo partial
+        </p>
+      </Partial>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/head_merge/duplicate.tsx b/tests/fixture_partials/routes/head_merge/duplicate.tsx
new file mode 100644
index 00000000000..6cec460957c
--- /dev/null
+++ b/tests/fixture_partials/routes/head_merge/duplicate.tsx
@@ -0,0 +1,27 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Head, Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <>
+      <Head>
+        <title>Head merge duplicated</title>
+        <link rel="stylesheet" href="/style.css" />
+        <style id="style-foo">{`p { color: green }`}</style>
+      </Head>
+      <Partial name="slot-1">
+        <Fader>
+          <h1>duplicated</h1>
+          <p class="status-duplicated">duplicated content</p>
+        </Fader>
+      </Partial>
+    </>
+  );
+});
diff --git a/tests/fixture_partials/routes/head_merge/index.tsx b/tests/fixture_partials/routes/head_merge/index.tsx
new file mode 100644
index 00000000000..9261a37dc70
--- /dev/null
+++ b/tests/fixture_partials/routes/head_merge/index.tsx
@@ -0,0 +1,38 @@
+import { Head, Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <Head>
+        <title>Head merge</title>
+        <meta name="foo" content="bar" />
+        <meta property="og:foo" content="og value foo" />
+        <style id="style-foo"></style>
+      </Head>
+      <Partial name="slot-1">
+        <Fader>
+          <p class="status-initial">Initial content</p>
+        </Fader>
+      </Partial>
+      <p>
+        <a
+          class="update-link"
+          href="/head_merge/injected"
+          f-partial="/head_merge/update"
+        >
+          update
+        </a>
+      </p>
+      <p>
+        <a
+          class="duplicate-link"
+          href="/head_merge/injected"
+          f-partial="/head_merge/duplicate"
+        >
+          duplicate
+        </a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/head_merge/injected.tsx b/tests/fixture_partials/routes/head_merge/injected.tsx
new file mode 100644
index 00000000000..a3fdc9c3d15
--- /dev/null
+++ b/tests/fixture_partials/routes/head_merge/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/head_merge",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/head_merge/update.tsx b/tests/fixture_partials/routes/head_merge/update.tsx
new file mode 100644
index 00000000000..fe7cf772992
--- /dev/null
+++ b/tests/fixture_partials/routes/head_merge/update.tsx
@@ -0,0 +1,30 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Head, Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <>
+      <Head>
+        <title>Head merge updated</title>
+        <meta name="foo" content="bar baz" />
+        <meta property="og:foo" content="og value foo" />
+        <meta property="og:bar" content="og value bar" />
+        <link rel="stylesheet" href="/other.css" />
+        <style>{`p { color: green }`}</style>
+      </Head>
+      <Partial name="slot-1">
+        <Fader>
+          <h1>updated</h1>
+          <p class="status-updated">updated content</p>
+        </Fader>
+      </Partial>
+    </>
+  );
+});
diff --git a/tests/fixture_partials/routes/index.tsx b/tests/fixture_partials/routes/index.tsx
new file mode 100644
index 00000000000..9c4322894a0
--- /dev/null
+++ b/tests/fixture_partials/routes/index.tsx
@@ -0,0 +1,27 @@
+import * as path from "https://deno.land/std@0.192.0/path/mod.ts";
+
+const __dirname = path.dirname(path.fromFileUrl(import.meta.url));
+
+const links: string[] = [];
+for (const file of Deno.readDirSync(__dirname)) {
+  if (file.name.startsWith("index")) continue;
+  const name = path.basename(file.name, path.extname(file.name));
+  links.push(name);
+}
+
+export default function Home() {
+  return (
+    <div>
+      <h1>Tests</h1>
+      <ul>
+        {links.sort().map((link) => {
+          return (
+            <li key={link}>
+              <a href={`/${link}`}>{link}</a>
+            </li>
+          );
+        })}
+      </ul>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/island_instance/index.tsx b/tests/fixture_partials/routes/island_instance/index.tsx
new file mode 100644
index 00000000000..7b40fba012c
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance/index.tsx
@@ -0,0 +1,44 @@
+import { Partial } from "$fresh/runtime.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Fader>
+          <p>Initial content</p>
+          <CounterA />
+        </Fader>
+      </Partial>
+      <p>
+        <a
+          class="update-link"
+          href="/island_instance/injected"
+          f-partial="/island_instance/partial"
+        >
+          Update
+        </a>
+      </p>
+      <p>
+        <a
+          class="remove-link"
+          href="/island_instance/injected"
+          f-partial="/island_instance/partial_remove"
+        >
+          Remove
+        </a>
+      </p>
+      <p>
+        <a
+          class="replace-link"
+          href="/island_instance/injected"
+          f-partial="/island_instance/partial_replace"
+        >
+          Replace
+        </a>
+      </p>
+      <pre id="logs" />
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/island_instance/injected.tsx b/tests/fixture_partials/routes/island_instance/injected.tsx
new file mode 100644
index 00000000000..cb6b2285c5d
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/island_instance",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/island_instance/partial.tsx b/tests/fixture_partials/routes/island_instance/partial.tsx
new file mode 100644
index 00000000000..ba517449af6
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance/partial.tsx
@@ -0,0 +1,22 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <Fader>
+        <h1>Another page</h1>
+        <p class="status">updated content</p>
+        <CounterA />
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/island_instance/partial_remove.tsx b/tests/fixture_partials/routes/island_instance/partial_remove.tsx
new file mode 100644
index 00000000000..1490c7c7da9
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance/partial_remove.tsx
@@ -0,0 +1,19 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <Fader>
+        <p class="status">no islands</p>
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/island_instance/partial_replace.tsx b/tests/fixture_partials/routes/island_instance/partial_replace.tsx
new file mode 100644
index 00000000000..d1d83b36315
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance/partial_replace.tsx
@@ -0,0 +1,21 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import Other from "../../islands/Other.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <Fader>
+        <p class="status-replaced">replaced content</p>
+        <Other />
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/island_instance_multiple/index.tsx b/tests/fixture_partials/routes/island_instance_multiple/index.tsx
new file mode 100644
index 00000000000..38315fe96a9
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance_multiple/index.tsx
@@ -0,0 +1,46 @@
+import { Partial } from "$fresh/runtime.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import CounterB from "../../islands/CounterB.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <div id="output">
+        <Partial name="slot-1">
+          <Fader>
+            <p>Initial content slot 1</p>
+            <CounterA />
+          </Fader>
+        </Partial>
+        <hr />
+        <Partial name="slot-2">
+          <Fader>
+            <p>Initial content slot 2</p>
+            <CounterB />
+          </Fader>
+        </Partial>
+        <hr />
+      </div>
+      <p>
+        <a
+          class="update-second-link"
+          href="/island_instance_multiple/injected"
+          f-partial="/island_instance_multiple/partial"
+        >
+          update second
+        </a>
+      </p>
+      <p>
+        <a
+          class="update-both-link"
+          href="/island_instance_multiple/injected"
+          f-partial="/island_instance_multiple/partial_both"
+        >
+          update both
+        </a>
+      </p>
+      <pre id="logs" />
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/island_instance_multiple/injected.tsx b/tests/fixture_partials/routes/island_instance_multiple/injected.tsx
new file mode 100644
index 00000000000..7c596212e97
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance_multiple/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/island_instance_multiple",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/island_instance_multiple/partial.tsx b/tests/fixture_partials/routes/island_instance_multiple/partial.tsx
new file mode 100644
index 00000000000..36fbcebbe08
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance_multiple/partial.tsx
@@ -0,0 +1,22 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import CounterB from "../../islands/CounterB.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-2">
+      <Fader>
+        <h1>Another page</h1>
+        <p class="status-2">updated content {Math.random()}</p>
+        <CounterB />
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/island_instance_multiple/partial_both.tsx b/tests/fixture_partials/routes/island_instance_multiple/partial_both.tsx
new file mode 100644
index 00000000000..b2d962c1768
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance_multiple/partial_both.tsx
@@ -0,0 +1,31 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import CounterB from "../../islands/CounterB.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <>
+      <Partial name="slot-1">
+        <Fader>
+          <p class="status-1">updated content {Math.random()}</p>
+          <CounterA />
+        </Fader>
+      </Partial>
+      <Partial name="slot-2">
+        <Fader>
+          <h1>Another page</h1>
+          <p class="status-2">updated content {Math.random()}</p>
+          <CounterB />
+        </Fader>
+      </Partial>
+    </>
+  );
+});
diff --git a/tests/fixture_partials/routes/island_instance_nested/index.tsx b/tests/fixture_partials/routes/island_instance_nested/index.tsx
new file mode 100644
index 00000000000..4a3d3c4735a
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance_nested/index.tsx
@@ -0,0 +1,44 @@
+import { Partial } from "$fresh/runtime.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import CounterB from "../../islands/CounterB.tsx";
+import PassThrough from "../../islands/PassThrough.tsx";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <PassThrough>
+          <div class="inner">
+            <p>server content</p>
+            <CounterA />
+          </div>
+          <hr />
+          <PassThrough>
+            <p>another pass through</p>
+            <CounterB />
+          </PassThrough>
+        </PassThrough>
+      </Partial>
+      <hr />
+      <p>
+        <a
+          class="update-link"
+          href="/island_instance_nested/injected"
+          f-partial="/island_instance_nested/partial"
+        >
+          update
+        </a>
+      </p>
+      <p>
+        <a
+          class="replace-link"
+          href="/island_instance_nested/injected"
+          f-partial="/island_instance_nested/replace"
+        >
+          replace
+        </a>
+      </p>
+      <pre id="logs" />
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/island_instance_nested/injected.tsx b/tests/fixture_partials/routes/island_instance_nested/injected.tsx
new file mode 100644
index 00000000000..28047c46643
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance_nested/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/island_instance_nested",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/island_instance_nested/partial.tsx b/tests/fixture_partials/routes/island_instance_nested/partial.tsx
new file mode 100644
index 00000000000..68ef0be9b43
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance_nested/partial.tsx
@@ -0,0 +1,29 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import CounterB from "../../islands/CounterB.tsx";
+import PassThrough from "../../islands/PassThrough.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <PassThrough>
+        <div class="inner">
+          <p class="status-a">updated server content</p>
+          <CounterA />
+        </div>
+        <hr />
+        <PassThrough>
+          <p class="status-b">another pass through</p>
+          <CounterB />
+        </PassThrough>
+      </PassThrough>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/island_instance_nested/replace.tsx b/tests/fixture_partials/routes/island_instance_nested/replace.tsx
new file mode 100644
index 00000000000..cca21480585
--- /dev/null
+++ b/tests/fixture_partials/routes/island_instance_nested/replace.tsx
@@ -0,0 +1,17 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import CounterA from "../../islands/CounterA.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <CounterA />
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/island_props/index.tsx b/tests/fixture_partials/routes/island_props/index.tsx
new file mode 100644
index 00000000000..8e124660d99
--- /dev/null
+++ b/tests/fixture_partials/routes/island_props/index.tsx
@@ -0,0 +1,29 @@
+import { Partial } from "$fresh/runtime.ts";
+import PropIsland from "../../islands/PropIsland.tsx";
+
+export default function PropsDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <p class="status-initial">initial</p>
+        <PropIsland
+          boolean={true}
+          number={1}
+          obj={{ foo: 123 }}
+          strArr={["foo"]}
+          string="foo"
+        />
+      </Partial>
+      <p>
+        <a
+          class="update-link"
+          href="/island_props/injected"
+          f-partial="/island_props/partial"
+        >
+          Update
+        </a>
+      </p>
+      <pre id="logs" />
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/island_props/injected.tsx b/tests/fixture_partials/routes/island_props/injected.tsx
new file mode 100644
index 00000000000..354492a8989
--- /dev/null
+++ b/tests/fixture_partials/routes/island_props/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/island_props",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/island_props/partial.tsx b/tests/fixture_partials/routes/island_props/partial.tsx
new file mode 100644
index 00000000000..77871ee8ecd
--- /dev/null
+++ b/tests/fixture_partials/routes/island_props/partial.tsx
@@ -0,0 +1,25 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import PropIsland from "../../islands/PropIsland.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <p class="status-updated">updated</p>
+      <PropIsland
+        boolean={false}
+        number={42}
+        obj={{ foo: 123456 }}
+        strArr={["foo", "bar"]}
+        string="foobar"
+      />
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/island_props_signals/index.tsx b/tests/fixture_partials/routes/island_props_signals/index.tsx
new file mode 100644
index 00000000000..a6fff773faf
--- /dev/null
+++ b/tests/fixture_partials/routes/island_props_signals/index.tsx
@@ -0,0 +1,30 @@
+import { Partial } from "$fresh/runtime.ts";
+import { useSignal } from "@preact/signals";
+import { Fader } from "../../islands/Fader.tsx";
+import SignalProp from "../../islands/SignalProp.tsx";
+
+export default function PropsDemo() {
+  const sig = useSignal(0);
+
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Fader>
+          <p class="status-initial">initial</p>
+          <SignalProp
+            sig={sig}
+          />
+        </Fader>
+      </Partial>
+      <p>
+        <a
+          class="update-link"
+          href="/island_props_signals/injected"
+          f-partial="/island_props_signals/partial"
+        >
+          Update
+        </a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/island_props_signals/injected.tsx b/tests/fixture_partials/routes/island_props_signals/injected.tsx
new file mode 100644
index 00000000000..3ebbce74784
--- /dev/null
+++ b/tests/fixture_partials/routes/island_props_signals/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/island_props_signals",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/island_props_signals/partial.tsx b/tests/fixture_partials/routes/island_props_signals/partial.tsx
new file mode 100644
index 00000000000..80761842545
--- /dev/null
+++ b/tests/fixture_partials/routes/island_props_signals/partial.tsx
@@ -0,0 +1,23 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import SignalProp from "../../islands/SignalProp.tsx";
+import { signal } from "@preact/signals";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  const sig = signal(0);
+  return (
+    <Partial name="slot-1">
+      <Fader>
+        <p class="status-update">update</p>
+        <SignalProp sig={sig} />
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/keys/index.tsx b/tests/fixture_partials/routes/keys/index.tsx
new file mode 100644
index 00000000000..85e4d6d3528
--- /dev/null
+++ b/tests/fixture_partials/routes/keys/index.tsx
@@ -0,0 +1,29 @@
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import Stateful from "../../islands/Stateful.tsx";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Fader>
+          <p>Initial content</p>
+          {[
+            <Stateful key="A" id="A" />,
+            <Stateful key="B" id="B" />,
+            <Stateful key="C" id="C" />,
+          ]}
+        </Fader>
+      </Partial>
+      <p>
+        <a
+          class="swap-link"
+          href="/keys/injected"
+          f-partial="/keys/swap"
+        >
+          swap
+        </a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/keys/injected.tsx b/tests/fixture_partials/routes/keys/injected.tsx
new file mode 100644
index 00000000000..a3de161fd67
--- /dev/null
+++ b/tests/fixture_partials/routes/keys/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/keys",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/keys/swap.tsx b/tests/fixture_partials/routes/keys/swap.tsx
new file mode 100644
index 00000000000..b1c179e2f2e
--- /dev/null
+++ b/tests/fixture_partials/routes/keys/swap.tsx
@@ -0,0 +1,25 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import Stateful from "../../islands/Stateful.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <Fader>
+        <p class="status-swap">swapped content</p>
+        {[
+          <Stateful key="C" id="C" />,
+          <Stateful key="B" id="B" />,
+          <Stateful key="A" id="A" />,
+        ]}
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/keys_components/index.tsx b/tests/fixture_partials/routes/keys_components/index.tsx
new file mode 100644
index 00000000000..af0a7c7616e
--- /dev/null
+++ b/tests/fixture_partials/routes/keys_components/index.tsx
@@ -0,0 +1,36 @@
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import Stateful from "../../islands/Stateful.tsx";
+import { Keyed } from "../../components/Keyed.tsx";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Fader>
+          <p>Initial content</p>
+          {[
+            <Keyed key="A">
+              <Stateful id="A" />
+            </Keyed>,
+            <Keyed key="B">
+              <Stateful id="B" />
+            </Keyed>,
+            <Keyed key="C">
+              <Stateful id="C" />
+            </Keyed>,
+          ]}
+        </Fader>
+      </Partial>
+      <p>
+        <a
+          class="swap-link"
+          href="/keys_components/injected"
+          f-partial="/keys_components/swap"
+        >
+          swap
+        </a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/keys_components/injected.tsx b/tests/fixture_partials/routes/keys_components/injected.tsx
new file mode 100644
index 00000000000..fd804e21933
--- /dev/null
+++ b/tests/fixture_partials/routes/keys_components/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/keys_components",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/keys_components/swap.tsx b/tests/fixture_partials/routes/keys_components/swap.tsx
new file mode 100644
index 00000000000..6fe2892e028
--- /dev/null
+++ b/tests/fixture_partials/routes/keys_components/swap.tsx
@@ -0,0 +1,32 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import Stateful from "../../islands/Stateful.tsx";
+import { Keyed } from "../../components/Keyed.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <Fader>
+        <p class="status-swap">swapped content</p>
+        {[
+          <Keyed key="C">
+            <Stateful id="C" />
+          </Keyed>,
+          <Keyed key="B">
+            <Stateful id="B" />
+          </Keyed>,
+          <Keyed key="A">
+            <Stateful id="A" />
+          </Keyed>,
+        ]}
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/keys_dom/index.tsx b/tests/fixture_partials/routes/keys_dom/index.tsx
new file mode 100644
index 00000000000..5cb5b2bf19c
--- /dev/null
+++ b/tests/fixture_partials/routes/keys_dom/index.tsx
@@ -0,0 +1,37 @@
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import Stateful from "../../islands/Stateful.tsx";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Fader>
+          <p>Initial content</p>
+          <ul>
+            {[
+              <li key="A" class="list-A">
+                <Stateful id="A" />
+              </li>,
+              <li key="B" class="list-B">
+                <Stateful id="B" />
+              </li>,
+              <li key="C" class="list-C">
+                <Stateful id="C" />
+              </li>,
+            ]}
+          </ul>
+        </Fader>
+      </Partial>
+      <p>
+        <a
+          class="swap-link"
+          href="/keys_dom/injected"
+          f-partial="/keys_dom/swap"
+        >
+          swap
+        </a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/keys_dom/injected.tsx b/tests/fixture_partials/routes/keys_dom/injected.tsx
new file mode 100644
index 00000000000..400eb666290
--- /dev/null
+++ b/tests/fixture_partials/routes/keys_dom/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/keys_dom",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/keys_dom/swap.tsx b/tests/fixture_partials/routes/keys_dom/swap.tsx
new file mode 100644
index 00000000000..61ea19c6048
--- /dev/null
+++ b/tests/fixture_partials/routes/keys_dom/swap.tsx
@@ -0,0 +1,33 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import Stateful from "../../islands/Stateful.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <Fader>
+        <p class="status-swap">swapped content</p>
+        <ul>
+          {[
+            <li key="C" class="list-C">
+              <Stateful id="C" />
+            </li>,
+            <li key="B" class="list-B">
+              <Stateful id="B" />
+            </li>,
+            <li key="A" class="list-A">
+              <Stateful id="A" />
+            </li>,
+          ]}
+        </ul>
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/keys_outside/index.tsx b/tests/fixture_partials/routes/keys_outside/index.tsx
new file mode 100644
index 00000000000..24565b3038b
--- /dev/null
+++ b/tests/fixture_partials/routes/keys_outside/index.tsx
@@ -0,0 +1,15 @@
+import { ComponentChildren } from "preact";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <Foo key="A">A</Foo>
+      <Foo key="B">B</Foo>
+      <Foo key="C">C</Foo>
+    </div>
+  );
+}
+
+function Foo(props: { children?: ComponentChildren }) {
+  return <p>{props.children}</p>;
+}
diff --git a/tests/fixture_partials/routes/loading/index.tsx b/tests/fixture_partials/routes/loading/index.tsx
new file mode 100644
index 00000000000..b5ea8afea0d
--- /dev/null
+++ b/tests/fixture_partials/routes/loading/index.tsx
@@ -0,0 +1,36 @@
+import { Partial } from "$fresh/runtime.ts";
+import { useSignal } from "@preact/signals";
+import Spinner from "../../islands/Spinner.tsx";
+import PartialTrigger from "../../islands/PartialTrigger.tsx";
+
+export default function SlotDemo() {
+  const sig = useSignal(false);
+  return (
+    <div>
+      <div class="output">
+        <Partial name="slot-1">
+          <p class="status">Default content</p>
+          <Spinner id="inner" show={sig} />
+        </Partial>
+      </div>
+      <Spinner id="outer" show={sig} />
+      <a
+        class="update-link"
+        href="/loading/injected"
+        f-partial="/loading/update"
+        f-loading={sig}
+      >
+        update
+      </a>
+      <br />
+      <PartialTrigger
+        class="trigger"
+        href="/loading/injected"
+        partial="/loading/update"
+        loading={sig}
+      >
+        partial trigger
+      </PartialTrigger>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/loading/injected.tsx b/tests/fixture_partials/routes/loading/injected.tsx
new file mode 100644
index 00000000000..366b3bf7135
--- /dev/null
+++ b/tests/fixture_partials/routes/loading/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/loading",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/loading/update.tsx b/tests/fixture_partials/routes/loading/update.tsx
new file mode 100644
index 00000000000..78e74f52877
--- /dev/null
+++ b/tests/fixture_partials/routes/loading/update.tsx
@@ -0,0 +1,20 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { delay } from "../../../deps.ts";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute(async (req, ctx) => {
+  // A bit of artificial delay to show the loader
+  await delay(200);
+
+  return (
+    <Partial name="slot-1">
+      <p class="status-updated">it works</p>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/missing_partial/index.tsx b/tests/fixture_partials/routes/missing_partial/index.tsx
new file mode 100644
index 00000000000..beed883dc9c
--- /dev/null
+++ b/tests/fixture_partials/routes/missing_partial/index.tsx
@@ -0,0 +1,25 @@
+import { Partial } from "$fresh/runtime.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default function WarnDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Fader>
+          <p class="status-initial">Initial content</p>
+          <CounterA />
+        </Fader>
+      </Partial>
+      <p>
+        <a
+          class="update-link"
+          href="/missing_partial/injected"
+          f-partial="/missing_partial/update"
+        >
+          update
+        </a>
+      </p>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/missing_partial/injected.tsx b/tests/fixture_partials/routes/missing_partial/injected.tsx
new file mode 100644
index 00000000000..e8cee1f6a7a
--- /dev/null
+++ b/tests/fixture_partials/routes/missing_partial/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/missing_partial",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/missing_partial/update.tsx b/tests/fixture_partials/routes/missing_partial/update.tsx
new file mode 100644
index 00000000000..6b8e1f171b0
--- /dev/null
+++ b/tests/fixture_partials/routes/missing_partial/update.tsx
@@ -0,0 +1,16 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="unknown-name">
+      <p class="status-append">append content</p>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/mode/append.tsx b/tests/fixture_partials/routes/mode/append.tsx
new file mode 100644
index 00000000000..8f8e023f514
--- /dev/null
+++ b/tests/fixture_partials/routes/mode/append.tsx
@@ -0,0 +1,21 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+import Other from "../../islands/Other.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1" mode="append">
+      <Fader>
+        <p class="status-append">append content</p>
+        <Other />
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/mode/index.tsx b/tests/fixture_partials/routes/mode/index.tsx
new file mode 100644
index 00000000000..951ce9a7af0
--- /dev/null
+++ b/tests/fixture_partials/routes/mode/index.tsx
@@ -0,0 +1,45 @@
+import { Partial } from "$fresh/runtime.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default function ModeDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Fader>
+          <p class="status-initial">Initial content</p>
+          <CounterA />
+        </Fader>
+      </Partial>
+      <p>
+        <a
+          class="replace-link"
+          href="/mode/injected"
+          f-partial="/mode/replace"
+        >
+          replace
+        </a>
+      </p>
+      <p>
+        <a
+          class="append-link"
+          href="/mode/injected"
+          f-partial="/mode/append"
+        >
+          append
+        </a>
+      </p>
+      <p>
+        <a
+          class="prepend-link"
+          href="/mode/injected"
+          f-partial="/mode/prepend"
+        >
+          prepend
+        </a>
+      </p>
+
+      <pre id="logs" />
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/mode/injected.tsx b/tests/fixture_partials/routes/mode/injected.tsx
new file mode 100644
index 00000000000..860ef429f7f
--- /dev/null
+++ b/tests/fixture_partials/routes/mode/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/mode",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/mode/prepend.tsx b/tests/fixture_partials/routes/mode/prepend.tsx
new file mode 100644
index 00000000000..5596a943fce
--- /dev/null
+++ b/tests/fixture_partials/routes/mode/prepend.tsx
@@ -0,0 +1,20 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1" mode="prepend">
+      <Fader>
+        <h1>prepend</h1>
+        <p class="status-prepend">prepend content</p>
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/mode/replace.tsx b/tests/fixture_partials/routes/mode/replace.tsx
new file mode 100644
index 00000000000..55a7ddc8856
--- /dev/null
+++ b/tests/fixture_partials/routes/mode/replace.tsx
@@ -0,0 +1,19 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <Fader>
+        <p class="status-replace">replace</p>
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/no_islands/index.tsx b/tests/fixture_partials/routes/no_islands/index.tsx
new file mode 100644
index 00000000000..05832034a38
--- /dev/null
+++ b/tests/fixture_partials/routes/no_islands/index.tsx
@@ -0,0 +1,20 @@
+import { Partial } from "$fresh/runtime.ts";
+
+export default function SlotDemo() {
+  return (
+    <div>
+      <div class="output">
+        <Partial name="slot-1">
+          <p>Default content</p>
+        </Partial>
+      </div>
+      <a
+        class="update-link"
+        href="/no_islands/injected"
+        f-partial="/no_islands/update"
+      >
+        update
+      </a>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/no_islands/injected.tsx b/tests/fixture_partials/routes/no_islands/injected.tsx
new file mode 100644
index 00000000000..ef04413dd33
--- /dev/null
+++ b/tests/fixture_partials/routes/no_islands/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/no_islands",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/no_islands/update.tsx b/tests/fixture_partials/routes/no_islands/update.tsx
new file mode 100644
index 00000000000..e8a01eb596b
--- /dev/null
+++ b/tests/fixture_partials/routes/no_islands/update.tsx
@@ -0,0 +1,16 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="slot-1">
+      <p class="status">it works</p>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/routes/no_partial_response/index.tsx b/tests/fixture_partials/routes/no_partial_response/index.tsx
new file mode 100644
index 00000000000..7d76e8b5252
--- /dev/null
+++ b/tests/fixture_partials/routes/no_partial_response/index.tsx
@@ -0,0 +1,26 @@
+import { Partial } from "$fresh/runtime.ts";
+import CounterA from "../../islands/CounterA.tsx";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default function WarnDemo() {
+  return (
+    <div>
+      <Partial name="slot-1">
+        <Fader>
+          <p class="status-initial">Initial content</p>
+          <CounterA />
+        </Fader>
+      </Partial>
+      <p>
+        <a
+          class="update-link"
+          href="/no_partial_response/injected"
+          f-partial="/no_partial_response/update"
+        >
+          update
+        </a>
+      </p>
+      <pre id="logs"></pre>
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/no_partial_response/injected.tsx b/tests/fixture_partials/routes/no_partial_response/injected.tsx
new file mode 100644
index 00000000000..7606f2f69c3
--- /dev/null
+++ b/tests/fixture_partials/routes/no_partial_response/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/no_partial_response",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/no_partial_response/update.tsx b/tests/fixture_partials/routes/no_partial_response/update.tsx
new file mode 100644
index 00000000000..48077539bbf
--- /dev/null
+++ b/tests/fixture_partials/routes/no_partial_response/update.tsx
@@ -0,0 +1,11 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return <p class="status-append">append content</p>;
+});
diff --git a/tests/fixture_partials/routes/partial_slot_inside_island.tsx b/tests/fixture_partials/routes/partial_slot_inside_island.tsx
new file mode 100644
index 00000000000..17f5b3fc4ca
--- /dev/null
+++ b/tests/fixture_partials/routes/partial_slot_inside_island.tsx
@@ -0,0 +1,5 @@
+import InvalidSlot from "../islands/InvalidSlot.tsx";
+
+export default function SlotDemo() {
+  return <InvalidSlot />;
+}
diff --git a/tests/fixture_partials/routes/relative_link/index.tsx b/tests/fixture_partials/routes/relative_link/index.tsx
new file mode 100644
index 00000000000..81a428b92aa
--- /dev/null
+++ b/tests/fixture_partials/routes/relative_link/index.tsx
@@ -0,0 +1,30 @@
+import { Partial } from "$fresh/runtime.ts";
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default defineRoute((req) => {
+  const url = new URL(req.url);
+
+  return (
+    <div f-client-nav>
+      <Partial name="body">
+        <Fader>
+          <p
+            class={url.searchParams.has("refresh")
+              ? "status-refreshed"
+              : "status-initial"}
+          >
+            {url.searchParams.has("refresh")
+              ? "Refreshed content"
+              : "Initial content"}
+          </p>
+        </Fader>
+      </Partial>
+      <p>
+        <button f-partial="?refresh">
+          refresh
+        </button>
+      </p>
+    </div>
+  );
+});
diff --git a/tests/fixture_partials/routes/scroll_restoration/index.tsx b/tests/fixture_partials/routes/scroll_restoration/index.tsx
new file mode 100644
index 00000000000..d46fc6d21f8
--- /dev/null
+++ b/tests/fixture_partials/routes/scroll_restoration/index.tsx
@@ -0,0 +1,300 @@
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export default function ModeDemo() {
+  return (
+    <div f-client-nav>
+      <Partial name="body">
+        <Fader>
+          <p class="status-initial">Initial content</p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+          <p>
+            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean
+            commodo ligula eget dolor. Aenean massa. Cum sociis natoque
+            penatibus et magnis dis parturient montes, nascetur ridiculus mus.
+            Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem.
+            Nulla consequat massa quis enim. Donec pede justo, fringilla vel,
+            aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut,
+            imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede
+            mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum
+            semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula,
+            porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem
+            ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra
+            nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet.
+            Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies
+            nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget
+            condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem
+            neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar,
+            hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus.
+            Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante.
+            Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed
+            fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed
+            consequat, leo eget bibendum sodales, augue velit cursus nunc,
+          </p>
+        </Fader>
+      </Partial>
+      <p>
+        <a
+          class="update-link"
+          href="/scroll_restoration/update"
+        >
+          update
+        </a>
+      </p>
+
+      <pre id="logs" />
+    </div>
+  );
+}
diff --git a/tests/fixture_partials/routes/scroll_restoration/injected.tsx b/tests/fixture_partials/routes/scroll_restoration/injected.tsx
new file mode 100644
index 00000000000..793c730061e
--- /dev/null
+++ b/tests/fixture_partials/routes/scroll_restoration/injected.tsx
@@ -0,0 +1,10 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+
+export default defineRoute(() => {
+  return new Response("", {
+    status: 302,
+    headers: {
+      Location: "/scroll_restoration",
+    },
+  });
+});
diff --git a/tests/fixture_partials/routes/scroll_restoration/update.tsx b/tests/fixture_partials/routes/scroll_restoration/update.tsx
new file mode 100644
index 00000000000..34540680f92
--- /dev/null
+++ b/tests/fixture_partials/routes/scroll_restoration/update.tsx
@@ -0,0 +1,19 @@
+import { defineRoute } from "$fresh/src/server/defines.ts";
+import { RouteConfig } from "$fresh/server.ts";
+import { Partial } from "$fresh/runtime.ts";
+import { Fader } from "../../islands/Fader.tsx";
+
+export const config: RouteConfig = {
+  skipAppWrapper: true,
+  skipInheritedLayouts: true,
+};
+
+export default defineRoute((req, ctx) => {
+  return (
+    <Partial name="body">
+      <Fader>
+        <p class="status-updated">update</p>
+      </Fader>
+    </Partial>
+  );
+});
diff --git a/tests/fixture_partials/static/other.css b/tests/fixture_partials/static/other.css
new file mode 100644
index 00000000000..adc68fa6a4d
--- /dev/null
+++ b/tests/fixture_partials/static/other.css
@@ -0,0 +1,3 @@
+h1 {
+  color: red;
+}
diff --git a/tests/fixture_partials/static/style.css b/tests/fixture_partials/static/style.css
new file mode 100644
index 00000000000..f60ef4f5b70
--- /dev/null
+++ b/tests/fixture_partials/static/style.css
@@ -0,0 +1,8 @@
+@keyframes fade {
+  0% {
+    background: white;
+  }
+  100% {
+    background: peachpuff;
+  }
+}
diff --git a/tests/fixture_plugin_error/deno.json b/tests/fixture_plugin_error/deno.json
new file mode 100644
index 00000000000..3c18115db76
--- /dev/null
+++ b/tests/fixture_plugin_error/deno.json
@@ -0,0 +1,17 @@
+{
+  "lock": false,
+  "imports": {
+    "$fresh/": "../../",
+    "preact": "https://esm.sh/preact@10.15.1",
+    "preact/": "https://esm.sh/preact@10.15.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.1",
+    "@preact/signals": "https://esm.sh/*@preact/signals@1.1.3",
+    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.2.3",
+    "@preact/signals-core@1.2.3": "https://esm.sh/@preact/signals-core@1.2.3",
+    "@preact/signals-core@1.3.0": "https://esm.sh/@preact/signals-core@1.3.0"
+  },
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "jsxImportSource": "preact"
+  }
+}
diff --git a/tests/fixture_plugin_error/dev.ts b/tests/fixture_plugin_error/dev.ts
new file mode 100755
index 00000000000..2d85d6c183c
--- /dev/null
+++ b/tests/fixture_plugin_error/dev.ts
@@ -0,0 +1,5 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+
+await dev(import.meta.url, "./main.ts");
diff --git a/tests/fixture_plugin_error/fresh.gen.ts b/tests/fixture_plugin_error/fresh.gen.ts
new file mode 100644
index 00000000000..b3d1d79171c
--- /dev/null
+++ b/tests/fixture_plugin_error/fresh.gen.ts
@@ -0,0 +1,18 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/index.tsx";
+import * as $$0 from "./islands/Island.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/index.tsx": $0,
+  },
+  islands: {
+    "./islands/Island.tsx": $$0,
+  },
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_plugin_error/islands/Island.tsx b/tests/fixture_plugin_error/islands/Island.tsx
new file mode 100644
index 00000000000..ced6810fcd2
--- /dev/null
+++ b/tests/fixture_plugin_error/islands/Island.tsx
@@ -0,0 +1,17 @@
+import { useEffect } from "preact/hooks";
+import { useSignal } from "@preact/signals";
+
+export default function Island() {
+  const sig = useSignal(false);
+  const count = useSignal(0);
+  useEffect(() => {
+    sig.value = true;
+  }, []);
+
+  return (
+    <div id={sig.value ? "ready" : "not-ready"}>
+      <p>{count}</p>
+      <button onClick={() => count.value++}>click me</button>
+    </div>
+  );
+}
diff --git a/tests/fixture_plugin_error/main.ts b/tests/fixture_plugin_error/main.ts
new file mode 100644
index 00000000000..b1b0d543da9
--- /dev/null
+++ b/tests/fixture_plugin_error/main.ts
@@ -0,0 +1,27 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import manifest from "./fresh.gen.ts";
+
+function throwErr() {
+  throw new Error("Error thrown");
+}
+
+await start(manifest, {
+  plugins: [
+    {
+      name: "thrower",
+      entrypoints: {
+        main: `data:application/javascript,export default ${throwErr}`,
+      },
+      render(ctx) {
+        ctx.render();
+        return { scripts: [{ entrypoint: "main", state: {} }] };
+      },
+    },
+  ],
+});
diff --git a/tests/fixture_plugin_error/routes/index.tsx b/tests/fixture_plugin_error/routes/index.tsx
new file mode 100644
index 00000000000..e0673948d1b
--- /dev/null
+++ b/tests/fixture_plugin_error/routes/index.tsx
@@ -0,0 +1,5 @@
+import Island from "../islands/Island.tsx";
+
+export default function Home() {
+  return <Island />;
+}
diff --git a/tests/fixture_plugin_lifecycle/deno.json b/tests/fixture_plugin_lifecycle/deno.json
new file mode 100644
index 00000000000..2b2fa78e147
--- /dev/null
+++ b/tests/fixture_plugin_lifecycle/deno.json
@@ -0,0 +1,13 @@
+{
+  "lock": false,
+  "imports": {
+    "$fresh/": "../../",
+    "preact": "https://esm.sh/preact@10.15.1",
+    "preact/": "https://esm.sh/preact@10.15.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.1"
+  },
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "jsxImportSource": "preact"
+  }
+}
diff --git a/tests/fixture_plugin_lifecycle/dev.ts b/tests/fixture_plugin_lifecycle/dev.ts
new file mode 100755
index 00000000000..1fe3e340282
--- /dev/null
+++ b/tests/fixture_plugin_lifecycle/dev.ts
@@ -0,0 +1,6 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+import config from "./fresh.config.ts";
+
+await dev(import.meta.url, "./main.ts", config);
diff --git a/tests/fixture_plugin_lifecycle/fresh.config.ts b/tests/fixture_plugin_lifecycle/fresh.config.ts
new file mode 100644
index 00000000000..1a9b40d0e97
--- /dev/null
+++ b/tests/fixture_plugin_lifecycle/fresh.config.ts
@@ -0,0 +1,24 @@
+import { defineConfig } from "$fresh/src/server/defines.ts";
+
+export default defineConfig({
+  plugins: [
+    {
+      name: "a",
+      buildEnd() {
+        console.log("Plugin a: buildEnd");
+      },
+      buildStart() {
+        console.log("Plugin a: buildStart");
+      },
+    },
+    {
+      name: "b",
+      buildEnd() {
+        console.log("Plugin b: buildEnd");
+      },
+      buildStart() {
+        console.log("Plugin b: buildStart");
+      },
+    },
+  ],
+});
diff --git a/tests/fixture_plugin_lifecycle/fresh.gen.ts b/tests/fixture_plugin_lifecycle/fresh.gen.ts
new file mode 100644
index 00000000000..b321c0e078e
--- /dev/null
+++ b/tests/fixture_plugin_lifecycle/fresh.gen.ts
@@ -0,0 +1,15 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/index.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/index.tsx": $0,
+  },
+  islands: {},
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_plugin_lifecycle/main.ts b/tests/fixture_plugin_lifecycle/main.ts
new file mode 100644
index 00000000000..fc9359215e3
--- /dev/null
+++ b/tests/fixture_plugin_lifecycle/main.ts
@@ -0,0 +1,11 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import manifest from "./fresh.gen.ts";
+import config from "./fresh.config.ts";
+
+await start(manifest, config);
diff --git a/tests/fixture_plugin_lifecycle/routes/index.tsx b/tests/fixture_plugin_lifecycle/routes/index.tsx
new file mode 100644
index 00000000000..b42a1f58d01
--- /dev/null
+++ b/tests/fixture_plugin_lifecycle/routes/index.tsx
@@ -0,0 +1,7 @@
+export default function Home() {
+  return (
+    <div>
+      <h1>Hello World</h1>
+    </div>
+  );
+}
diff --git a/tests/fixture_router_ignore_files/deno.json b/tests/fixture_router_ignore_files/deno.json
new file mode 100644
index 00000000000..2b73c6793f3
--- /dev/null
+++ b/tests/fixture_router_ignore_files/deno.json
@@ -0,0 +1,15 @@
+{
+  "lock": false,
+  "imports": {
+    "$fresh/": "../../",
+    "preact": "https://esm.sh/preact@10.15.1",
+    "preact/": "https://esm.sh/preact@10.15.1/",
+    "preact-render-to-string": "https://esm.sh/*preact-render-to-string@6.2.1",
+    "@preact/signals": "https://esm.sh/*@preact/signals@1.1.5",
+    "@preact/signals-core": "https://esm.sh/@preact/signals-core@1.3.1"
+  },
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "jsxImportSource": "preact"
+  }
+}
diff --git a/tests/fixture_router_ignore_files/dev.ts b/tests/fixture_router_ignore_files/dev.ts
new file mode 100755
index 00000000000..3908da70ce0
--- /dev/null
+++ b/tests/fixture_router_ignore_files/dev.ts
@@ -0,0 +1,6 @@
+#!/usr/bin/env -S deno run -A --watch=static/,routes/
+
+import dev from "$fresh/dev.ts";
+import options from "./options.ts";
+
+await dev(import.meta.url, "./main.ts", options);
diff --git a/tests/fixture_router_ignore_files/fresh.gen.ts b/tests/fixture_router_ignore_files/fresh.gen.ts
new file mode 100644
index 00000000000..b321c0e078e
--- /dev/null
+++ b/tests/fixture_router_ignore_files/fresh.gen.ts
@@ -0,0 +1,15 @@
+// DO NOT EDIT. This file is generated by Fresh.
+// This file SHOULD be checked into source version control.
+// This file is automatically updated during development when running `dev.ts`.
+
+import * as $0 from "./routes/index.tsx";
+
+const manifest = {
+  routes: {
+    "./routes/index.tsx": $0,
+  },
+  islands: {},
+  baseUrl: import.meta.url,
+};
+
+export default manifest;
diff --git a/tests/fixture_router_ignore_files/main.ts b/tests/fixture_router_ignore_files/main.ts
new file mode 100644
index 00000000000..1409a21d698
--- /dev/null
+++ b/tests/fixture_router_ignore_files/main.ts
@@ -0,0 +1,11 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="dom" />
+/// <reference lib="dom.iterable" />
+/// <reference lib="dom.asynciterable" />
+/// <reference lib="deno.ns" />
+
+import { start } from "$fresh/server.ts";
+import routes from "./fresh.gen.ts";
+import options from "./options.ts";
+
+await start(routes, options);
diff --git a/tests/fixture_router_ignore_files/options.ts b/tests/fixture_router_ignore_files/options.ts
new file mode 100644
index 00000000000..3bba27a2a57
--- /dev/null
+++ b/tests/fixture_router_ignore_files/options.ts
@@ -0,0 +1,7 @@
+import { FreshOptions } from "$fresh/server.ts";
+
+export default {
+  router: {
+    ignoreFilePattern: /[\.|_]cy\.[t|j]s(x)?$/,
+  },
+} as FreshOptions;
diff --git a/tests/fixture_router_ignore_files/routes/index.cy.ts b/tests/fixture_router_ignore_files/routes/index.cy.ts
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/tests/fixture_router_ignore_files/routes/index.tsx b/tests/fixture_router_ignore_files/routes/index.tsx
new file mode 100644
index 00000000000..7d94ac5aa2d
--- /dev/null
+++ b/tests/fixture_router_ignore_files/routes/index.tsx
@@ -0,0 +1,9 @@
+import { IS_BROWSER } from "$fresh/runtime.ts";
+
+export default function Home() {
+  return (
+    <div>
+      <p>{IS_BROWSER ? "Viewing browser render." : "Viewing JIT render."}</p>
+    </div>
+  );
+}
diff --git a/tests/fixture_twind_app/routes/_app.tsx b/tests/fixture_twind_app/routes/_app.tsx
index 5183eaa798d..9e889f936ce 100644
--- a/tests/fixture_twind_app/routes/_app.tsx
+++ b/tests/fixture_twind_app/routes/_app.tsx
@@ -4,7 +4,7 @@ export default function App({ Component }: AppProps) {
   return (
     <html className="bg-slate-800">
       <head className="bg-slate-800">
-        <meta charSet="utf-8" />
+        <meta charset="utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>fresh-foo</title>
       </head>
diff --git a/tests/cli_test.ts b/tests/init_test.ts
similarity index 53%
rename from tests/cli_test.ts
rename to tests/init_test.ts
index 0d34eb7f77c..7076933f7e5 100644
--- a/tests/cli_test.ts
+++ b/tests/init_test.ts
@@ -1,10 +1,8 @@
 import * as path from "$std/path/mod.ts";
-import { DenoConfig } from "$fresh/server.ts";
-import { JSONC, Status } from "../src/server/deps.ts";
+import { Status } from "../src/server/deps.ts";
 import {
   assert,
   assertEquals,
-  assertMatch,
   assertNotMatch,
   assertStringIncludes,
   delay,
@@ -94,11 +92,10 @@ Deno.test({
       assert(json.tasks.preview, "Missing 'preview' task");
 
       // Check lint settings
-      assertEquals(json.lint.exclude, ["_fresh"]);
       assertEquals(json.lint.rules.tags, ["fresh", "recommended"]);
 
-      // Check fmt settings
-      assertEquals(json.fmt.exclude, ["_fresh"]);
+      // Check exclude settings
+      assertEquals(json.exclude, ["**/_fresh/*"]);
     });
 
     await t.step("start up the server and access the root page", async () => {
@@ -136,14 +133,15 @@ Deno.test({
       await page.close();
       await browser.close();
 
-      await lines.cancel();
       serverProcess.kill("SIGTERM");
       await serverProcess.status;
+
+      // Drain the lines stream
+      for await (const _ of lines) { /* noop */ }
     });
 
     await retry(() => Deno.remove(tmpDirName, { recursive: true }));
   },
-  sanitizeResources: false,
 });
 
 Deno.test({
@@ -229,14 +227,15 @@ Deno.test({
       await page.close();
       await browser.close();
 
-      await lines.cancel();
       serverProcess.kill("SIGTERM");
       await serverProcess.status;
+
+      // Drain the lines stream
+      for await (const _ of lines) { /* noop */ }
     });
 
     await retry(() => Deno.remove(tmpDirName, { recursive: true }));
   },
-  sanitizeResources: false,
 });
 
 Deno.test("fresh-init error(help)", async function (t) {
@@ -359,14 +358,15 @@ Deno.test({
 
       await delay(100);
 
-      await lines.cancel();
       serverProcess.kill("SIGTERM");
       await serverProcess.status;
+
+      // Drain the lines stream
+      for await (const _ of lines) { /* noop */ }
     });
 
     await retry(() => Deno.remove(tmpDirName, { recursive: true }));
   },
-  sanitizeResources: false,
 });
 
 Deno.test({
@@ -407,9 +407,11 @@ Deno.test({
       const doc = await fetchHtml(`${address}/env`);
       assertTextMany(doc, "h1", ["true"]);
 
-      await lines.cancel();
       serverProcess.kill("SIGTERM");
       await serverProcess.status;
+
+      // Drain the lines stream
+      for await (const _ of lines) { /* noop */ }
     });
 
     await t.step("build code and start server again", async () => {
@@ -437,380 +439,13 @@ Deno.test({
       const doc = await fetchHtml(`${address}/env`);
       assertTextMany(doc, "h1", ["true"]);
 
-      await lines.cancel();
       serverProcess.kill("SIGTERM");
       await serverProcess.status;
+
+      // Drain the lines stream
+      for await (const _ of lines) { /* noop */ }
     });
 
     await retry(() => Deno.remove(tmpDirName, { recursive: true }));
   },
-  sanitizeResources: false,
 });
-
-Deno.test("fresh-update", async function fn(t) {
-  // Preparation
-  const tmpDirName = await Deno.makeTempDir();
-
-  const cliProcess = new Deno.Command(Deno.execPath(), {
-    args: [
-      "run",
-      "-A",
-      path.join(Deno.cwd(), "init.ts"),
-      ".",
-    ],
-    cwd: tmpDirName,
-    stdin: "null",
-    stdout: "null",
-  });
-
-  await cliProcess.output();
-
-  await t.step("execute update command", async () => {
-    await updateAndVerify(
-      /The manifest has been generated for \d+ routes and \d+ islands./,
-    );
-  });
-
-  await t.step("check deno.json", async () => {
-    const configPath = path.join(tmpDirName, "deno.json");
-    const json = JSONC.parse(await Deno.readTextFile(configPath)) as DenoConfig;
-
-    assert(json.tasks?.start, "Missing 'start' task");
-    assert(json.tasks?.build, "Missing 'build' task");
-    assert(json.tasks?.preview, "Missing 'preview' task");
-
-    assertEquals(json.lint?.rules?.tags, ["fresh", "recommended"]);
-    assertEquals(json.lint?.exclude, ["_fresh"]);
-    assertEquals(json.fmt?.exclude, ["_fresh"]);
-  });
-
-  const comment = "// This is a test comment";
-  const regex = /("preact": "https:\/\/esm.sh\/preact@[\d.]+",\n)/;
-  const originalName = `${tmpDirName}/deno.json`;
-  const updatedName = `${originalName}c`;
-
-  await t.step("execute update command deno.jsonc support", async () => {
-    try {
-      Deno.renameSync(originalName, updatedName);
-      let denoJsonText = await Deno.readTextFile(updatedName);
-      denoJsonText = denoJsonText.replace(regex, `$1${comment}\n`);
-      await Deno.writeTextFile(updatedName, denoJsonText);
-      await updateAndVerify(
-        /The manifest has been generated for \d+ routes and \d+ islands./,
-      );
-    } finally {
-      let denoJsonText = await Deno.readTextFile(updatedName);
-      denoJsonText = denoJsonText.replace(new RegExp(`\n${comment}\n`), "\n");
-      await Deno.writeTextFile(updatedName, denoJsonText);
-      Deno.renameSync(updatedName, originalName);
-    }
-  });
-
-  await t.step("execute update command src dir", async () => {
-    const names = [
-      "components",
-      "islands",
-      "routes",
-      "static",
-      "dev.ts",
-      "main.ts",
-      "fresh.gen.ts",
-    ];
-    try {
-      Deno.mkdirSync(tmpDirName + "/src");
-      names.forEach((x) => {
-        Deno.renameSync(
-          path.join(tmpDirName, x),
-          path.join(tmpDirName, "src", x),
-        );
-      });
-      await updateAndVerify(
-        /The manifest has been generated for (?!0 routes and 0 islands)\d+ routes and \d+ islands./,
-      );
-    } finally {
-      names.forEach((x) => {
-        Deno.renameSync(
-          path.join(tmpDirName, "src", x),
-          path.join(tmpDirName, x),
-        );
-      });
-      Deno.removeSync(tmpDirName + "/src", { recursive: true });
-    }
-  });
-
-  await t.step("execute update command (no islands directory)", async () => {
-    await retry(() =>
-      Deno.remove(path.join(tmpDirName, "islands"), { recursive: true })
-    );
-    await updateAndVerify(
-      /The manifest has been generated for \d+ routes and 0 islands./,
-    );
-  });
-
-  await retry(() => Deno.remove(tmpDirName, { recursive: true }));
-
-  async function updateAndVerify(expected: RegExp) {
-    const cliProcess = new Deno.Command(Deno.execPath(), {
-      args: [
-        "run",
-        "-A",
-        path.join(Deno.cwd(), "update.ts"),
-        ".",
-      ],
-      cwd: tmpDirName,
-      stdin: "null",
-      stdout: "piped",
-    });
-
-    const { code, stdout } = await cliProcess.output();
-    const output = new TextDecoder().decode(stdout);
-
-    assertMatch(
-      output,
-      expected,
-    );
-    assertEquals(code, 0);
-  }
-});
-
-Deno.test("fresh-update add _app.tsx if not present", async function fn(t) {
-  // Preparation
-  const tmpDirName = await Deno.makeTempDir();
-
-  const cliProcess = new Deno.Command(Deno.execPath(), {
-    args: [
-      "run",
-      "-A",
-      path.join(Deno.cwd(), "init.ts"),
-      ".",
-    ],
-    cwd: tmpDirName,
-    stdin: "null",
-    stdout: "null",
-  });
-
-  await cliProcess.output();
-
-  const appTsx = path.join(tmpDirName, "routes", "_app.tsx");
-  await Deno.remove(appTsx);
-
-  await t.step("execute update command", async () => {
-    await updateAndVerify(
-      /The manifest has been generated for \d+ routes and \d+ islands./,
-    );
-  });
-
-  await t.step("add _app.tsx", async () => {
-    const raw = await Deno.readTextFile(appTsx);
-    assert(raw.includes("<html>"), `<html>-tag not found in _app.tsx`);
-  });
-
-  async function updateAndVerify(expected: RegExp) {
-    const cliProcess = new Deno.Command(Deno.execPath(), {
-      args: [
-        "run",
-        "-A",
-        path.join(Deno.cwd(), "update.ts"),
-        ".",
-      ],
-      cwd: tmpDirName,
-      stdin: "null",
-      stdout: "piped",
-    });
-
-    const { code, stdout } = await cliProcess.output();
-    const output = new TextDecoder().decode(stdout);
-
-    assertMatch(
-      output,
-      expected,
-    );
-    assertEquals(code, 0);
-  }
-});
-
-Deno.test(
-  "fresh-update add _fresh to .gitignore if not present",
-  async function fn(t) {
-    // Preparation
-    const tmpDirName = await Deno.makeTempDir();
-
-    const cliProcess = new Deno.Command(Deno.execPath(), {
-      args: [
-        "run",
-        "-A",
-        path.join(Deno.cwd(), "init.ts"),
-        ".",
-      ],
-      cwd: tmpDirName,
-      stdin: "null",
-      stdout: "null",
-    });
-
-    await cliProcess.output();
-
-    const gitignore = path.join(tmpDirName, ".gitignore");
-    await Deno.writeTextFile(gitignore, ""); // clear .gitignore
-
-    await t.step("execute update command", async () => {
-      await updateAndVerify(
-        /The manifest has been generated for \d+ routes and \d+ islands./,
-      );
-    });
-
-    await t.step("append _fresh to .gitignore", async () => {
-      const raw = await Deno.readTextFile(gitignore);
-      assertStringIncludes(raw, "_fresh", "_fresh not found in .gitignore");
-    });
-
-    async function updateAndVerify(expected: RegExp) {
-      const cliProcess = new Deno.Command(Deno.execPath(), {
-        args: [
-          "run",
-          "-A",
-          path.join(Deno.cwd(), "update.ts"),
-          ".",
-        ],
-        cwd: tmpDirName,
-        stdin: "null",
-        stdout: "piped",
-      });
-
-      const { code, stdout } = await cliProcess.output();
-      const output = new TextDecoder().decode(stdout);
-
-      assertMatch(
-        output,
-        expected,
-      );
-      assertEquals(code, 0);
-    }
-  },
-);
-
-Deno.test(
-  "fresh-update do not add _fresh to .gitignore if already present",
-  async function fn(t) {
-    // Preparation
-    const tmpDirName = await Deno.makeTempDir();
-
-    const cliProcess = new Deno.Command(Deno.execPath(), {
-      args: [
-        "run",
-        "-A",
-        path.join(Deno.cwd(), "init.ts"),
-        ".",
-      ],
-      cwd: tmpDirName,
-      stdin: "null",
-      stdout: "null",
-    });
-
-    await cliProcess.output();
-
-    const gitignore = path.join(tmpDirName, ".gitignore");
-    await Deno.writeTextFile(gitignore, "_fresh");
-
-    await t.step("execute update command", async () => {
-      await updateAndVerify(
-        /The manifest has been generated for \d+ routes and \d+ islands./,
-      );
-    });
-
-    await t.step("do not append _fresh to .gitignore", async () => {
-      const raw = await Deno.readTextFile(gitignore);
-      // Count the number of times "_fresh" appears in .gitignore
-      const count = (raw.match(/_fresh/g) ?? []).length;
-      assertEquals(count, 1, "_fresh found in .gitignore");
-    });
-
-    async function updateAndVerify(expected: RegExp) {
-      const cliProcess = new Deno.Command(Deno.execPath(), {
-        args: [
-          "run",
-          "-A",
-          path.join(Deno.cwd(), "update.ts"),
-          ".",
-        ],
-        cwd: tmpDirName,
-        stdin: "null",
-        stdout: "piped",
-      });
-
-      const { code, stdout } = await cliProcess.output();
-      const output = new TextDecoder().decode(stdout);
-
-      assertMatch(
-        output,
-        expected,
-      );
-      assertEquals(code, 0);
-    }
-  },
-);
-
-Deno.test(
-  "fresh-update do not create a .gitignore if none exist",
-  async function fn(t) {
-    // Preparation
-    const tmpDirName = await Deno.makeTempDir();
-
-    const cliProcess = new Deno.Command(Deno.execPath(), {
-      args: [
-        "run",
-        "-A",
-        path.join(Deno.cwd(), "init.ts"),
-        ".",
-      ],
-      cwd: tmpDirName,
-      stdin: "null",
-      stdout: "null",
-    });
-
-    await cliProcess.output();
-
-    const gitignore = path.join(tmpDirName, ".gitignore");
-    await Deno.remove(gitignore);
-
-    await t.step("execute update command", async () => {
-      await updateAndVerify(
-        /The manifest has been generated for \d+ routes and \d+ islands./,
-      );
-    });
-
-    await t.step("do not create a .gitignore", async () => {
-      let exists = true;
-      try {
-        await Deno.open(gitignore);
-      } catch (error) {
-        if (error instanceof Deno.errors.NotFound) {
-          exists = false;
-        }
-      }
-      assert(!exists, "found .gitignore");
-    });
-
-    async function updateAndVerify(expected: RegExp) {
-      const cliProcess = new Deno.Command(Deno.execPath(), {
-        args: [
-          "run",
-          "-A",
-          path.join(Deno.cwd(), "update.ts"),
-          ".",
-        ],
-        cwd: tmpDirName,
-        stdin: "null",
-        stdout: "piped",
-      });
-
-      const { code, stdout } = await cliProcess.output();
-      const output = new TextDecoder().decode(stdout);
-
-      assertMatch(
-        output,
-        expected,
-      );
-      assertEquals(code, 0);
-    }
-  },
-);
diff --git a/tests/islands_test.ts b/tests/islands_test.ts
index 72c3727c936..514cafe5e1f 100644
--- a/tests/islands_test.ts
+++ b/tests/islands_test.ts
@@ -1,166 +1,125 @@
+import { assert, assertEquals, assertStringIncludes, Page } from "./deps.ts";
 import {
-  assert,
-  assertEquals,
-  assertStringIncludes,
-  delay,
-  Page,
-} from "./deps.ts";
-import {
+  assertNoPageComments,
   assertNotSelector,
   assertSelector,
   assertTextMatch,
   clickWhenListenerReady,
-  fetchHtml,
+  parseHtml,
   waitForText,
-  withFresh,
+  withFakeServe,
   withPageName,
 } from "./test_utils.ts";
 
-Deno.test({
-  name: "island tests",
-  async fn(t) {
-    await withPage(async (page, address) => {
-      async function counterTest(counterId: string, originalValue: number) {
-        const pElem = await page.waitForSelector(`#${counterId} > p`);
+Deno.test("island tests", async (t) => {
+  await withPage(async (page, address) => {
+    async function counterTest(counterId: string, originalValue: number) {
+      const pElem = await page.waitForSelector(`#${counterId} > p`);
 
-        const value = await pElem?.evaluate((el) => el.textContent);
-        assert(value === `${originalValue}`, `${counterId} first value`);
+      const value = await pElem?.evaluate((el) => el.textContent);
+      assert(value === `${originalValue}`, `${counterId} first value`);
 
-        await clickWhenListenerReady(page, `#b-${counterId}`);
-        await waitForText(page, `#${counterId} > p`, String(originalValue + 1));
-      }
+      await clickWhenListenerReady(page, `#b-${counterId}`);
+      await waitForText(page, `#${counterId} > p`, String(originalValue + 1));
+    }
 
-      await page.goto(`${address}/islands`, {
-        waitUntil: "networkidle2",
-      });
+    await page.goto(`${address}/islands`);
 
-      await t.step("Ensure 5 islands on 1 page are revived", async () => {
-        await counterTest("counter1", 3);
-        await counterTest("counter2", 10);
-        await counterTest("folder-counter", 3);
-        await counterTest("subfolder-counter", 3);
-        await counterTest("kebab-case-file-counter", 5);
-      });
+    await t.step("Ensure 5 islands on 1 page are revived", async () => {
+      await counterTest("counter1", 3);
+      await counterTest("counter2", 10);
+      await counterTest("folder-counter", 3);
+      await counterTest("subfolder-counter", 3);
+      await counterTest("kebab-case-file-counter", 5);
+    });
 
-      await t.step("Ensure an island revive an img 'hash' path", async () => {
-        // Ensure src path has __frsh_c=
-        const pElem = await page.waitForSelector(`#img-in-island`);
-        const srcString = (await pElem?.getProperty("src"))?.toString()!;
-        assertStringIncludes(srcString, "image.png?__frsh_c=");
+    await t.step("Ensure an island revive an img 'hash' path", async () => {
+      // Ensure src path has __frsh_c=
+      const pElem = await page.waitForSelector(`#img-in-island`);
+      const srcString = (await pElem?.getProperty("src"))?.toString()!;
+      assertStringIncludes(srcString, "image.png?__frsh_c=");
 
-        // Ensure src path is the same as server rendered
-        const resp = await fetch(new Request(`${address}/islands`));
-        const body = await resp.text();
+      // Ensure src path is the same as server rendered
+      const resp = await fetch(new Request(`${address}/islands`));
+      const body = await resp.text();
 
-        const imgFilePath = body.match(/img id="img-in-island" src="(.*?)"/)
-          ?.[1]!;
-        assertStringIncludes(srcString, imgFilePath);
-      });
+      const imgFilePath = body.match(/img id="img-in-island" src="(.*?)"/)
+        ?.[1]!;
+      assertStringIncludes(srcString, imgFilePath);
     });
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+  });
 });
 
-Deno.test({
-  name: "multiple islands exported from one file",
-  async fn(t) {
-    await withPage(async (page, address) => {
-      async function counterTest(counterId: string, originalValue: number) {
-        const pElem = await page.waitForSelector(`#${counterId} > p`);
+Deno.test("multiple islands exported from one file", async (t) => {
+  await withPage(async (page, address) => {
+    async function counterTest(counterId: string, originalValue: number) {
+      const pElem = await page.waitForSelector(`#${counterId} > p`);
 
-        const value = await pElem?.evaluate((el) => el.textContent);
-        assert(value === `${originalValue}`, `${counterId} first value`);
+      const value = await pElem?.evaluate((el) => el.textContent);
+      assert(value === `${originalValue}`, `${counterId} first value`);
 
-        await clickWhenListenerReady(page, `#b-${counterId}`);
-        await waitForText(page, `#${counterId} > p`, String(originalValue + 1));
-      }
+      await clickWhenListenerReady(page, `#b-${counterId}`);
+      await waitForText(page, `#${counterId} > p`, String(originalValue + 1));
+    }
 
-      await page.goto(`${address}/islands/multiple_island_exports`, {
-        waitUntil: "networkidle2",
-      });
+    await page.goto(`${address}/islands/multiple_island_exports`);
 
-      await t.step("Ensure 3 islands on 1 page are revived", async () => {
-        await counterTest("counter0", 4);
-        await counterTest("counter1", 3);
-        await counterTest("counter2", 10);
-      });
+    await t.step("Ensure 3 islands on 1 page are revived", async () => {
+      await counterTest("counter0", 4);
+      await counterTest("counter1", 3);
+      await counterTest("counter2", 10);
     });
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+  });
 });
 
 function withPage(fn: (page: Page, address: string) => Promise<void>) {
   return withPageName("./tests/fixture/main.ts", fn);
 }
 
-Deno.test({
-  name: "island tests with </script>",
-
-  async fn(t) {
-    await withPage(async (page, address) => {
-      page.on("dialog", () => {
-        assert(false, "There is XSS");
-      });
+Deno.test("island tests with </script>", async (t) => {
+  await withPage(async (page, address) => {
+    page.on("dialog", () => {
+      assert(false, "There is XSS");
+    });
 
-      await page.goto(`${address}/evil`, {
-        waitUntil: "networkidle2",
-      });
+    await page.goto(`${address}/evil`, {
+      waitUntil: "networkidle2",
+    });
 
-      await t.step("prevent XSS on Island", async () => {
-        const bodyElem = await page.waitForSelector(`body`);
-        const value = await bodyElem?.evaluate((el) => el.getInnerHTML());
+    await t.step("prevent XSS on Island", async () => {
+      const bodyElem = await page.waitForSelector(`body`);
+      const value = await bodyElem?.evaluate((el) => el.getInnerHTML());
 
-        assertStringIncludes(
-          value,
-          `{"message":"\\u003c/script\\u003e\\u003cscript\\u003ealert('test')\\u003c/script\\u003e"}`,
-          `XSS is not escaped`,
-        );
-      });
+      assertStringIncludes(
+        value,
+        `{"message":"\\u003c/script\\u003e\\u003cscript\\u003ealert('test')\\u003c/script\\u003e"}`,
+        `XSS is not escaped`,
+      );
     });
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+  });
 });
 
-Deno.test({
-  name: "island with fragment as root",
+Deno.test("island with fragment as root", async () => {
+  await withPage(async (page, address) => {
+    await page.goto(`${address}/islands/root_fragment`);
 
-  async fn(_t) {
-    await withPage(async (page, address) => {
-      await page.goto(`${address}/islands/root_fragment`, {
-        waitUntil: "networkidle2",
-      });
+    const clickableSelector = "#root-fragment-click-me";
 
-      const clickableSelector = "#root-fragment-click-me";
+    await page.waitForSelector(clickableSelector);
 
-      await page.waitForSelector(clickableSelector);
-
-      await waitForText(page, `#island-parent`, "HelloWorld");
-
-      await clickWhenListenerReady(page, clickableSelector);
-      await waitForText(page, `#island-parent`, "HelloWorldI'm rendered now");
-    });
-  },
+    await waitForText(page, `#island-parent`, "HelloWorld");
 
-  sanitizeOps: false,
-  sanitizeResources: false,
+    await clickWhenListenerReady(page, clickableSelector);
+    await waitForText(page, `#island-parent`, "HelloWorldI'm rendered now");
+  });
 });
 
-Deno.test({
-  name: "island with fragment as root and conditional child first",
-
-  async fn(_t) {
+Deno.test(
+  "island with fragment as root and conditional child first",
+  async () => {
     await withPage(async (page, address) => {
       await page.goto(
         `${address}/islands/root_fragment_conditional_first`,
-        {
-          waitUntil: "networkidle2",
-        },
       );
 
       const clickableSelector = "#root-fragment-conditional-first-click-me";
@@ -176,189 +135,131 @@ Deno.test({
       );
     });
   },
+);
 
-  sanitizeOps: false,
-  sanitizeResources: false,
+Deno.test("island that returns `null`", async () => {
+  await withPage(async (page, address) => {
+    await page.goto(`${address}/islands/returning_null`);
+    await page.waitForSelector(".added-by-use-effect");
+  });
 });
 
-Deno.test({
-  name: "island that returns `null`",
+Deno.test("island using `npm:` specifiers", async () => {
+  await withPageName("./tests/fixture_npm/main.ts", async (page, address) => {
+    await page.setJavaScriptEnabled(false);
+    await page.goto(address);
+    await page.waitForSelector("#server-true");
 
-  async fn(_t) {
-    await withPage(async (page, address) => {
-      await page.goto(`${address}/islands/returning_null`, {
-        waitUntil: "networkidle2",
-      });
-
-      await page.waitForSelector(".added-by-use-effect");
-    });
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+    await page.setJavaScriptEnabled(true);
+    await page.reload();
+    await page.waitForSelector("#browser-true");
+  });
 });
 
-Deno.test({
-  name: "island using `npm:` specifiers",
-
-  async fn(_t) {
-    await withPageName("./tests/fixture_npm/main.ts", async (page, address) => {
-      await page.setJavaScriptEnabled(false);
-      await page.goto(address, { waitUntil: "networkidle2" });
-      assert(await page.waitForSelector("#server-true"));
-
-      await page.setJavaScriptEnabled(true);
-      await page.reload({ waitUntil: "networkidle2" });
-      assert(await page.waitForSelector("#browser-true"));
-    });
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+Deno.test("works with older preact-render-to-string v5", async () => {
+  await withPageName(
+    "./tests/fixture_preact_rts_v5/main.ts",
+    async (page, address) => {
+      await page.goto(address);
+      await page.waitForSelector("#foo");
+      await waitForText(page, "#foo", "it works");
+      +await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name: "works with older preact-render-to-string v5",
-
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_preact_rts_v5/main.ts",
-      async (page, address) => {
-        await page.goto(address, {
-          waitUntil: "networkidle2",
-        });
-        await page.waitForSelector("#foo");
-        await waitForText(page, "#foo", "it works");
-      },
-    );
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+Deno.test("pass single JSX child to island", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_jsx_child`);
+      await page.waitForSelector(".island");
+      await waitForText(page, ".island", "it works");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name: "pass single JSX child to island",
+Deno.test("pass multiple JSX children to island", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_jsx_children`);
+      await page.waitForSelector(".island");
 
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_island_nesting/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/island_jsx_child`, {
-          waitUntil: "networkidle2",
-        });
-        await page.waitForSelector(".island");
-        await waitForText(page, ".island", "it works");
-      },
-    );
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+      await waitForText(page, ".island", "it works");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name: "pass multiple JSX children to island",
-
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_island_nesting/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/island_jsx_children`, {
-          waitUntil: "networkidle2",
-        });
-        await page.waitForSelector(".island");
-
-        await delay(100);
-        const text = await page.$eval(".island", (el) => el.textContent);
-        assertEquals(text, "it works");
-      },
-    );
-  },
+Deno.test("pass multiple text JSX children to island", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_jsx_text`);
+      await page.waitForSelector(".island");
 
-  sanitizeOps: false,
-  sanitizeResources: false,
+      await waitForText(page, ".island", "it works");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name: "pass multiple text JSX children to island",
-
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_island_nesting/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/island_jsx_text`, {
-          waitUntil: "networkidle2",
-        });
-        await page.waitForSelector(".island");
-
-        await delay(100);
-        const text = await page.$eval(".island", (el) => el.textContent);
-        assertEquals(text, "it works");
-      },
-    );
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+Deno.test("render island in island", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_in_island`);
+      await page.waitForSelector(".island");
+      await waitForText(page, ".island .island p", "it works");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name: "render island in island",
+Deno.test("render island inside island definition", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_in_island_definition`);
+      await page.waitForSelector(".island");
 
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_island_nesting/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/island_in_island`, {
-          waitUntil: "networkidle2",
-        });
-        await page.waitForSelector(".island");
-        await waitForText(page, ".island .island p", "it works");
-      },
-    );
-  },
+      await waitForText(page, ".island .island p", "it works");
 
-  sanitizeOps: false,
-  sanitizeResources: false,
+      // Check that there is no duplicated content which could happen
+      // when islands aren't initialized correctly
+      await waitForText(page, "#page", "it works");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name: "render island inside island definition",
-
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_island_nesting/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/island_in_island_definition`, {
-          waitUntil: "networkidle2",
-        });
-        await page.waitForSelector(".island");
-
-        await waitForText(page, ".island .island p", "it works");
+Deno.test("render island inside island with conditional children", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/dropdown`);
+      await page.waitForSelector("button");
+      await assertNoPageComments(page);
 
-        // Check that there is no duplicated content which could happen
-        // when islands aren't initialized correctly
-        await waitForText(page, "#page", "it works");
-      },
-    );
-  },
+      const doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".result");
 
-  sanitizeOps: false,
-  sanitizeResources: false,
+      await page.click("button");
+      await page.waitForSelector(".result");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name:
-    "render island with JSX children that render another island with JSX children",
-
-  async fn(_t) {
+Deno.test(
+  "render island with JSX children that render another island with JSX children",
+  async () => {
     await withPageName(
       "./tests/fixture_island_nesting/main.ts",
       async (page, address) => {
-        await page.goto(`${address}/island_jsx_island_jsx`, {
-          waitUntil: "networkidle2",
-        });
+        await page.goto(`${address}/island_jsx_island_jsx`);
         await page.waitForSelector(".island");
 
         await waitForText(
@@ -366,118 +267,81 @@ Deno.test({
           ".island .server .island .server p",
           "it works",
         );
-      },
-    );
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
-});
-
-Deno.test({
-  name: "render sibling islands",
-
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_island_nesting/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/island_siblings`, {
-          waitUntil: "networkidle2",
-        });
-        await page.waitForSelector(".island");
 
-        await waitForText(page, ".island .a", "it works");
-        await waitForText(page, ".island + .island .b", "it works");
+        await assertNoPageComments(page);
       },
     );
   },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+);
+
+Deno.test("render sibling islands", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_siblings`);
+      await page.waitForSelector(".island");
+
+      await waitForText(page, ".island .a", "it works");
+      await waitForText(page, ".island + .island .b", "it works");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name: "render sibling islands that render nothing initially",
-
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_island_nesting/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/island_conditional`, {
-          waitUntil: "networkidle2",
-        });
-        await page.waitForSelector("button");
-
-        await delay(100);
-        await page.click("button");
-
-        // Button text is matched too, but this allows us
-        // to assert correct ordering. The "island content" should
-        // be left of "Toggle"
-        await waitForText(page, "#page", "island contentToggle");
-      },
-    );
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+Deno.test("render sibling islands that render nothing initially", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_conditional`);
+      await page.waitForSelector(".island");
+      await assertNoPageComments(page);
+
+      await page.click("button");
+
+      // Button text is matched too, but this allows us
+      // to assert correct ordering. The "island content" should
+      // be left of "Toggle"
+      await waitForText(page, "#page", "island contentToggle");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name: "serialize inner island props",
-
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_island_nesting/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/island_nested_props`, {
-          waitUntil: "networkidle2",
-        });
-        await page.waitForSelector(".island");
-
-        await waitForText(page, ".island .island p", "it works");
-      },
-    );
-  },
+Deno.test("serialize inner island props", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_nested_props`);
+      await page.waitForSelector(".island");
 
-  sanitizeOps: false,
-  sanitizeResources: false,
+      await waitForText(page, ".island .island p", "it works");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name: "render island inside island when passed as fn child",
-
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_island_nesting/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/island_fn_child`);
-        await page.waitForSelector(".island");
-        await waitForText(page, "#page", "it works");
-      },
-    );
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+Deno.test("render island inside island when passed as fn child", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_fn_child`);
+      await page.waitForSelector(".island");
+      await waitForText(page, "#page", "it works");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
-Deno.test({
-  name: "render nested islands in correct order",
-
-  async fn(_t) {
-    await withPageName(
-      "./tests/fixture_island_nesting/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/island_order`);
-        await page.waitForSelector(".island");
-        await waitForText(page, "#page", "leftcenterright");
-      },
-    );
-  },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
+Deno.test("render nested islands in correct order", async () => {
+  await withPageName(
+    "./tests/fixture_island_nesting/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_order`);
+      await page.waitForSelector(".island");
+      await waitForText(page, "#page", "leftcenterright");
+      await assertNoPageComments(page);
+    },
+  );
 });
 
 Deno.test({
@@ -489,98 +353,94 @@ Deno.test({
       async (page, address) => {
         await page.goto(`${address}/island_conditional_lazy`);
         await waitForText(page, ".island p", "island content");
+        await assertNoPageComments(page);
 
         await page.click("button");
         await waitForText(page, ".island p", "server rendered");
+        await assertNoPageComments(page);
       },
     );
   },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
 
-Deno.test({
-  name: "revive island in lazy server rendered children conditionally",
-
-  async fn() {
+Deno.test(
+  "revive island in lazy server rendered children conditionally",
+  async () => {
     await withPageName(
       "./tests/fixture_island_nesting/main.ts",
       async (page, address) => {
         await page.goto(`${address}/island_conditional_lazy_island`);
         await waitForText(page, ".island p", "island content");
+        await page.waitForSelector(".mounted");
+        await assertNoPageComments(page);
 
         await page.click("button");
         await waitForText(page, ".island .server", "server rendered");
+        await assertNoPageComments(page);
 
         await page.click("button.counter");
         await waitForText(page, ".island .count", "1");
+        await assertNoPageComments(page);
       },
     );
   },
-});
-
-Deno.test({
-  name: "revive boolean attributes",
-
-  async fn() {
-    await withPageName(
-      "./tests/fixture/main.ts",
-      async (page, address) => {
-        await page.goto(`${address}/preact/boolean_attrs`);
-        await waitForText(page, ".form-revived", "Revived: true");
-
-        const checked = await page.$eval(
-          "input[type=checkbox]",
-          (el) => el.checked,
-        );
-        assertEquals(checked, true, "Checkbox is not checked");
-
-        const required = await page.$eval(
-          "input[type=text]",
-          (el) => el.required,
-        );
-        assertEquals(required, true, "Text input is not marked as required");
+);
+
+Deno.test("revive boolean attributes", async () => {
+  await withPageName(
+    "./tests/fixture/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/preact/boolean_attrs`);
+      await waitForText(page, ".form-revived", "Revived: true");
+      await assertNoPageComments(page);
+
+      const checked = await page.$eval(
+        "input[type=checkbox]",
+        (el) => el.checked,
+      );
+      assertEquals(checked, true, "Checkbox is not checked");
 
-        const radioChecked = await page.$eval(
-          "input[type=radio][value='2']",
-          (el) => el.checked,
-        );
-        assertEquals(
-          radioChecked,
-          true,
-          "Text input is not marked as required",
-        );
+      const required = await page.$eval(
+        "input[type=text]",
+        (el) => el.required,
+      );
+      assertEquals(required, true, "Text input is not marked as required");
 
-        const selected = await page.$eval(
-          "select",
-          (el) => el.options[el.selectedIndex].text,
-        );
-        assertEquals(selected, "bar", "'bar' value is not selected");
-      },
-    );
-  },
+      const radioChecked = await page.$eval(
+        "input[type=radio][value='2']",
+        (el) => el.checked,
+      );
+      assertEquals(
+        radioChecked,
+        true,
+        "Text input is not marked as required",
+      );
 
-  sanitizeOps: false,
-  sanitizeResources: false,
+      const selected = await page.$eval(
+        "select",
+        (el) => el.options[el.selectedIndex].text,
+      );
+      assertEquals(selected, "bar", "'bar' value is not selected");
+    },
+  );
 });
 
 Deno.test("throws when passing non-jsx children to an island", async (t) => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_island_nesting/dev.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/island_invalid_children`);
+    async (server) => {
+      const doc = await server.getHtml(`/island_invalid_children`);
 
       assertSelector(doc, ".frsh-error-page");
       assertTextMatch(doc, "pre", /Invalid JSX child passed to island/);
 
-      const doc2 = await fetchHtml(`${address}/island_invalid_children_fn`);
+      const doc2 = await server.getHtml(`/island_invalid_children_fn`);
 
       assertSelector(doc2, ".frsh-error-page");
       assertTextMatch(doc2, "pre", /Invalid JSX child passed to island/);
 
       await t.step("should not throw on valid children", async () => {
-        const doc2 = await fetchHtml(`${address}/island_valid_children`);
+        const doc2 = await server.getHtml(`/island_valid_children`);
 
         assertNotSelector(doc2, ".frsh-error-page");
       });
diff --git a/tests/islands_wasm_test.ts b/tests/islands_wasm_test.ts
index 0204e886e6a..6e129d69532 100644
--- a/tests/islands_wasm_test.ts
+++ b/tests/islands_wasm_test.ts
@@ -1,47 +1,35 @@
-import { assert, delay, puppeteer } from "./deps.ts";
-import { startFreshServer } from "./test_utils.ts";
+import { assert, delay } from "./deps.ts";
+import { withPageName } from "./test_utils.ts";
 
 Deno.test({
   name: "wasm island tests",
   ignore: Deno.build.os === "windows",
   async fn(t) {
-    // Preparation
-    const { lines, serverProcess, address } = await startFreshServer({
-      args: ["run", "-A", "./tests/fixture/main_wasm.ts"],
-    });
-
-    await delay(100);
-
-    const browser = await puppeteer.launch({ args: ["--no-sandbox"] });
-    const page = await browser.newPage();
-
-    async function counterTest(counterId: string, originalValue: number) {
-      const pElem = await page.waitForSelector(`#${counterId} > p`);
-      let value = await pElem?.evaluate((el) => el.textContent);
-      assert(value === `${originalValue}`, `${counterId} first value`);
-
-      const buttonPlus = await page.$(`#b-${counterId}`);
-      await buttonPlus?.click();
-      await delay(100);
-      value = await pElem?.evaluate((el) => el.textContent);
-      assert(value === `${originalValue + 1}`, `${counterId} click`);
-    }
-
-    await page.goto(`${address}/islands`, {
-      waitUntil: "networkidle2",
-    });
-
-    await t.step("Ensure 3 islands on 1 page are revived", async () => {
-      await counterTest("counter1", 3);
-      await counterTest("counter2", 10);
-      await counterTest("kebab-case-file-counter", 5);
-    });
-
-    await browser.close();
-
-    await lines.cancel();
-    serverProcess.kill("SIGTERM");
+    await withPageName(
+      "./tests/fixture/main_wasm.ts",
+      async (page, address) => {
+        async function counterTest(counterId: string, originalValue: number) {
+          const pElem = await page.waitForSelector(`#${counterId} > p`);
+          let value = await pElem?.evaluate((el) => el.textContent);
+          assert(value === `${originalValue}`, `${counterId} first value`);
+
+          const buttonPlus = await page.$(`#b-${counterId}`);
+          await buttonPlus?.click();
+          await delay(100);
+          value = await pElem?.evaluate((el) => el.textContent);
+          assert(value === `${originalValue + 1}`, `${counterId} click`);
+        }
+
+        await page.goto(`${address}/islands`, {
+          waitUntil: "networkidle2",
+        });
+
+        await t.step("Ensure 3 islands on 1 page are revived", async () => {
+          await counterTest("counter1", 3);
+          await counterTest("counter2", 10);
+          await counterTest("kebab-case-file-counter", 5);
+        });
+      },
+    );
   },
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
diff --git a/tests/layouts_test.ts b/tests/layouts_test.ts
index e7a6f4b34a9..838241ba931 100644
--- a/tests/layouts_test.ts
+++ b/tests/layouts_test.ts
@@ -3,70 +3,69 @@ import {
   assertNotSelector,
   assertSelector,
   clickWhenListenerReady,
-  fetchHtml,
   waitForText,
-  withFresh,
+  withFakeServe,
   withPageName,
 } from "./test_utils.ts";
 
 Deno.test("apply root _layout and _app", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(address);
+    async (server) => {
+      const doc = await server.getHtml("/");
       assert(doc.body.textContent?.includes("it works"));
       assertSelector(doc, ".app .root-layout .home-page");
 
-      const doc2 = await fetchHtml(`${address}/other`);
+      const doc2 = await server.getHtml("/other");
       assertSelector(doc2, ".app .root-layout .other-page");
     },
   );
 });
 
 Deno.test("apply sub layouts", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/foo`);
+    async (server) => {
+      const doc = await server.getHtml("/foo");
       assertSelector(doc, ".app .root-layout .foo-layout .foo-page");
 
-      const doc2 = await fetchHtml(`${address}/foo/bar`);
+      const doc2 = await server.getHtml("/foo/bar");
       assertSelector(doc2, ".app .root-layout .foo-layout .bar-page");
     },
   );
 });
 
 Deno.test("skip layouts if not present", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/skip/sub`);
+    async (server) => {
+      const doc = await server.getHtml(`/skip/sub`);
       assertSelector(doc, ".app .root-layout .sub-layout .sub-page");
     },
   );
 });
 
 Deno.test("check file types", async (t) => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
+    async (server) => {
       await t.step(".js", async () => {
-        const doc = await fetchHtml(`${address}/files/js`);
+        const doc = await server.getHtml(`/files/js`);
         assertSelector(doc, ".app .root-layout .js-layout .js-page");
       });
 
       await t.step(".jsx", async () => {
-        const doc = await fetchHtml(`${address}/files/jsx`);
+        const doc = await server.getHtml(`/files/jsx`);
         assertSelector(doc, ".app .root-layout .jsx-layout .jsx-page");
       });
 
       await t.step(".ts", async () => {
-        const doc = await fetchHtml(`${address}/files/ts`);
+        const doc = await server.getHtml(`/files/ts`);
         assertSelector(doc, ".app .root-layout .ts-layout .ts-page");
       });
 
       await t.step(".tsx", async () => {
-        const doc = await fetchHtml(`${address}/files/tsx`);
+        const doc = await server.getHtml(`/files/tsx`);
         assertSelector(doc, ".app .root-layout .tsx-layout .tsx-page");
       });
     },
@@ -74,20 +73,20 @@ Deno.test("check file types", async (t) => {
 });
 
 Deno.test("render async layout", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/async`);
+    async (server) => {
+      const doc = await server.getHtml(`/async`);
       assertSelector(doc, ".app .root-layout .async-layout .async-page");
     },
   );
 });
 
 Deno.test("render nested async layout", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/async/sub`);
+    async (server) => {
+      const doc = await server.getHtml(`/async/sub`);
       assertSelector(
         doc,
         ".app .root-layout .async-layout .async-sub-layout .async-sub-page",
@@ -96,27 +95,24 @@ Deno.test("render nested async layout", async () => {
   );
 });
 
-Deno.test({
-  name: "can return Response from async layout",
-  fn: async () => {
-    await withFresh(
-      "./tests/fixture_layouts/main.ts",
-      async (address) => {
-        const doc = await fetchHtml(`${address}/async/redirect`);
-        assertSelector(
-          doc,
-          ".app .root-layout .async-layout .async-sub-layout .async-sub-page",
-        );
-      },
-    );
-  },
+Deno.test("can return Response from async layout", async () => {
+  await withFakeServe(
+    "./tests/fixture_layouts/main.ts",
+    async (server) => {
+      const doc = await server.getHtml(`/async/redirect`);
+      assertSelector(
+        doc,
+        ".app .root-layout .async-layout .async-sub-layout .async-sub-page",
+      );
+    },
+  );
 });
 
 Deno.test("disable _app layout", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/override/no_app`);
+    async (server) => {
+      const doc = await server.getHtml(`/override/no_app`);
       assertNotSelector(doc, "body body");
       assertSelector(doc, "body > .override-layout >.no-app");
     },
@@ -124,10 +120,10 @@ Deno.test("disable _app layout", async () => {
 });
 
 Deno.test("disable _app in _layout", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/override/layout_no_app`);
+    async (server) => {
+      const doc = await server.getHtml(`/override/layout_no_app`);
       assertNotSelector(doc, "body body");
       assertSelector(doc, "body > .override-layout > .no-app-layout > .page");
     },
@@ -135,30 +131,30 @@ Deno.test("disable _app in _layout", async () => {
 });
 
 Deno.test("override layouts", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/override`);
+    async (server) => {
+      const doc = await server.getHtml(`/override`);
       assertSelector(doc, "body > .app > .override-layout > .override-page");
     },
   );
 });
 
 Deno.test("route overrides layout", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/override/no_layout`);
+    async (server) => {
+      const doc = await server.getHtml(`/override/no_layout`);
       assertSelector(doc, "body > .app > .no-layouts");
     },
   );
 });
 
 Deno.test("route overrides layout and app", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_layouts/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/override/no_layout_no_app`);
+    async (server) => {
+      const doc = await server.getHtml(`/override/no_layout_no_app`);
       assertSelector(doc, "body > .no-app-no-layouts");
     },
   );
@@ -194,7 +190,14 @@ Deno.test({
       },
     );
   },
+});
 
-  sanitizeOps: false,
-  sanitizeResources: false,
+Deno.test("mix async app and layouts", async () => {
+  await withFakeServe(
+    "./tests/fixture_layouts_2/main.ts",
+    async (server) => {
+      const doc = await server.getHtml(`/`);
+      assertSelector(doc, ".app > .root-layout > .home-page");
+    },
+  );
 });
diff --git a/tests/main_test.ts b/tests/main_test.ts
index 7d561f32198..21fc8464ff9 100644
--- a/tests/main_test.ts
+++ b/tests/main_test.ts
@@ -5,6 +5,7 @@ import {
   assertMatch,
   assertStringIncludes,
   delay,
+  join,
   puppeteer,
   retry,
 } from "./deps.ts";
@@ -14,11 +15,10 @@ import { BUILD_ID } from "../src/server/build_id.ts";
 import {
   assertSelector,
   assertTextMany,
-  fetchHtml,
   parseHtml,
   startFreshServer,
   waitForText,
-  withFresh,
+  withFakeServe,
   withPageName,
 } from "./test_utils.ts";
 
@@ -59,7 +59,7 @@ Deno.test("/props/123 page prerender", async () => {
   assertEquals(resp.headers.get("content-type"), "text/html; charset=utf-8");
   const body = await resp.text();
   const doc = parseHtml(body);
-  const data = JSON.parse(doc.querySelector("body > div").textContent);
+  const data = JSON.parse(doc.querySelector("body > div")!.textContent!);
 
   assertEquals(data, {
     "params": { "id": "123" },
@@ -217,6 +217,26 @@ Deno.test("/books/:id page - /books/abc", async () => {
   assertEquals(resp.status, Status.NotFound);
 });
 
+Deno.test("/i18n{/:lang}?/lang page - /i18n/lang", async () => {
+  const resp = await handler(new Request("https://fresh.deno.dev/i18n/lang"));
+  assert(resp);
+  assertEquals(resp.status, Status.OK);
+  assertEquals(resp.headers.get("content-type"), "text/html; charset=utf-8");
+  const body = await resp.text();
+  assertStringIncludes(body, "<div>Hello</div>");
+});
+
+Deno.test("/i18n{/:lang}?/lang page - /i18n/en/lang", async () => {
+  const resp = await handler(
+    new Request("https://fresh.deno.dev/i18n/en/lang"),
+  );
+  assert(resp);
+  assertEquals(resp.status, Status.OK);
+  assertEquals(resp.headers.get("content-type"), "text/html; charset=utf-8");
+  const body = await resp.text();
+  assertStringIncludes(body, "<div>Hello en</div>");
+});
+
 Deno.test("redirect /pages/fresh/ to /pages/fresh", async () => {
   const resp = await handler(
     new Request("https://fresh.deno.dev/pages/fresh/"),
@@ -593,7 +613,7 @@ Deno.test({
 
     const body = await resp.text();
     const doc = parseHtml(body);
-    assertEquals(JSON.parse(doc.querySelector("pre").textContent), {
+    assertEquals(JSON.parse(doc.querySelector("pre")!.textContent!), {
       handler1: "it works",
       handler2: "it works",
       handler3: "it works",
@@ -655,15 +675,6 @@ Deno.test({
 });
 
 Deno.test("middleware destination", async (t) => {
-  await t.step("internal", async () => {
-    const resp = await handler(
-      new Request("https://fresh.deno.dev/_frsh/refresh.js"),
-    );
-    assert(resp);
-    assertEquals(resp.headers.get("destination"), "internal");
-    await resp.body?.cancel();
-  });
-
   await t.step("static", async () => {
     const resp = await handler(new Request("https://fresh.deno.dev/foo.txt"));
     assert(resp);
@@ -704,10 +715,7 @@ Deno.test({
   },
 });
 
-Deno.test("jsx pragma works", {
-  sanitizeOps: false,
-  sanitizeResources: false,
-}, async (t) => {
+Deno.test("jsx pragma works", async (t) => {
   // Preparation
   const { serverProcess, lines, address } = await startFreshServer({
     args: ["run", "-A", "./tests/fixture_jsx_pragma/main.ts"],
@@ -736,51 +744,14 @@ Deno.test("jsx pragma works", {
 
   await browser.close();
 
-  await lines.cancel();
   serverProcess.kill("SIGTERM");
-});
-
-Deno.test("preact/debug is active in dev mode", {
-  sanitizeOps: false,
-  sanitizeResources: false,
-}, async (t) => {
-  // Preparation
-  const { serverProcess, lines, address } = await startFreshServer({
-    args: ["run", "-A", "./tests/fixture_render_error/main.ts"],
-  });
-
-  await delay(100);
-
-  await t.step("SSR error is shown", async () => {
-    const resp = await fetch(address);
-    assertEquals(resp.status, Status.InternalServerError);
-    const text = await resp.text();
-    assertStringIncludes(text, "Objects are not valid as a child");
-  });
-
-  const browser = await puppeteer.launch({ args: ["--no-sandbox"] });
-  const page = await browser.newPage();
-
-  await page.goto(address, {
-    waitUntil: "networkidle2",
-  });
-
-  await t.step("error page is shown with error message", async () => {
-    const el = await page.waitForSelector(".frsh-error-page");
-    const text = await page.evaluate((el) => el.textContent, el);
-    assertStringIncludes(text, "Objects are not valid as a child");
-  });
-
-  await browser.close();
+  await serverProcess.status;
 
-  await lines.cancel();
-  serverProcess.kill("SIGTERM");
+  // Drain the lines stream
+  for await (const _ of lines) { /* noop */ }
 });
 
-Deno.test("preloading javascript files", {
-  sanitizeOps: false,
-  sanitizeResources: false,
-}, async () => {
+Deno.test("preloading javascript files", async () => {
   // Preparation
   const { serverProcess, lines, address } = await startFreshServer({
     args: ["run", "-A", "./tests/fixture/main.ts"],
@@ -821,15 +792,15 @@ Deno.test("preloading javascript files", {
   } finally {
     await browser.close();
 
-    await lines.cancel();
     serverProcess.kill("SIGTERM");
+    await serverProcess.status;
+
+    // Drain the lines stream
+    for await (const _ of lines) { /* noop */ }
   }
 });
 
-Deno.test("PORT environment variable", {
-  sanitizeOps: false,
-  sanitizeResources: false,
-}, async () => {
+Deno.test("PORT environment variable", async () => {
   const PORT = "8765";
   // Preparation
   const { serverProcess, lines } = await startFreshServer({
@@ -840,61 +811,63 @@ Deno.test("PORT environment variable", {
   await delay(100);
 
   const resp = await fetch("http://localhost:" + PORT);
+  await resp.body?.cancel();
   assert(resp);
   assertEquals(resp.status, Status.OK);
+  await resp.body!.cancel();
 
-  await lines.cancel();
   serverProcess.kill("SIGTERM");
+  await serverProcess.status;
+
+  // Drain the lines stream
+  for await (const _ of lines) { /* noop */ }
 });
 
-Deno.test("throw on route export 'handlers' instead of 'handler'", {
-  sanitizeOps: false,
-  sanitizeResources: false,
-}, async () => {
-  const result = await new Deno.Command(Deno.execPath(), {
-    args: ["run", "-A", "./tests/fixture_invalid_handlers/main.ts"],
-    stderr: "piped",
-    stdout: "piped",
-  }).output();
+Deno.test(
+  "throw on route export 'handlers' instead of 'handler'",
+  async () => {
+    const result = await new Deno.Command(Deno.execPath(), {
+      args: ["run", "-A", "./tests/fixture_invalid_handlers/main.ts"],
+      stderr: "piped",
+      stdout: "piped",
+    }).output();
 
-  assertEquals(result.code, 1);
+    assertEquals(result.code, 1);
 
-  const text = new TextDecoder().decode(result.stderr);
-  assertMatch(text, /Did you mean "handler"\?/);
-});
+    const text = new TextDecoder().decode(result.stderr);
+    assertMatch(text, /Did you mean "handler"\?/);
+  },
+);
 
 Deno.test("rendering custom _500.tsx page for default handlers", async (t) => {
-  await withFresh("./tests/fixture_custom_500/main.ts", async (address) => {
+  await withFakeServe("./tests/fixture_custom_500/main.ts", async (server) => {
     await t.step("SSR error is shown", async () => {
-      const resp = await fetch(address);
+      const resp = await server.get("/");
       assertEquals(resp.status, Status.InternalServerError);
       const text = await resp.text();
       assertStringIncludes(text, "Custom 500: Pickle Rick!");
     });
 
     await t.step("error page is shown with error message", async () => {
-      const doc = await fetchHtml(address);
+      const doc = await server.getHtml("/");
       const text = doc.querySelector(".custom-500")?.textContent!;
       assertStringIncludes(text, "Custom 500: Pickle Rick!");
     });
   });
 });
 
-Deno.test("renders error boundary", {
-  sanitizeOps: false,
-  sanitizeResources: false,
-}, async () => {
+Deno.test("renders error boundary", async () => {
   await withPageName("./tests/fixture/main.ts", async (page, address) => {
     await page.goto(`${address}/error_boundary`);
-    const text = await page.$eval("body", (el) => el.textContent);
+    const text = await page.$eval("p", (el) => el.textContent);
     assertEquals(text, "it works");
   });
 });
 
 Deno.test("Resolves routes with non-latin characters", async () => {
-  await withFresh("./tests/fixture/main.ts", async (address) => {
+  await withFakeServe("./tests/fixture/main.ts", async (server) => {
     // Check that we can navigate to the page
-    const doc = await fetchHtml(`${address}/umlaut-äöüß`);
+    const doc = await server.getHtml(`/umlaut-äöüß`);
     assertSelector(doc, "h1");
     assertTextMany(doc, "h1", ["it works"]);
 
@@ -909,8 +882,8 @@ Deno.test("Resolves routes with non-latin characters", async () => {
 });
 
 Deno.test("Generate a single nonce value per page", async () => {
-  await withFresh("./tests/fixture/main.ts", async (address) => {
-    const doc = await fetchHtml(address);
+  await withFakeServe("./tests/fixture/main.ts", async (server) => {
+    const doc = await server.getHtml("/");
 
     const nonceValues = Array.from(
       new Set(
@@ -928,6 +901,20 @@ Deno.test("Generate a single nonce value per page", async () => {
   });
 });
 
+Deno.test("Adds nonce to inline scripts", async () => {
+  await withFakeServe("./tests/fixture/main.ts", async (server) => {
+    const doc = await server.getHtml(`/nonce_inline`);
+
+    const stateScript = doc.querySelector("#__FRSH_STATE")!;
+    const nonce = stateScript.getAttribute("nonce")!;
+
+    const el = doc.querySelector("#inline-script")!;
+    const inlineNonce = el.getAttribute("nonce")!;
+
+    assertEquals(inlineNonce, nonce);
+  });
+});
+
 Deno.test({
   name: "support string based event handlers during SSR",
   async fn() {
@@ -939,9 +926,6 @@ Deno.test({
       await waitForText(page, "p", "it works");
     });
   },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
 
 Deno.test({
@@ -971,14 +955,114 @@ Deno.test({
       });
     });
   },
+});
+
+Deno.test("De-duplicates <Head /> nodes by key", async () => {
+  await withFakeServe("./tests/fixture/main.ts", async (server) => {
+    const res = await server.get(`/head_deduplicate`);
+    const html = await res.text();
+
+    assertEquals(Array.from(html.matchAll(/<title>/g)).length, 1);
+    assert(/<title>bar<\/title>/.test(html));
+
+    assertEquals(
+      Array.from(html.matchAll(/<meta property="og:title"/g)).length,
+      1,
+    );
+    assert(/<meta property="og:title" content="Other title"\/>/.test(html));
+  });
+});
 
-  sanitizeOps: false,
-  sanitizeResources: false,
+Deno.test("pass options in config", async (t) => {
+  const fixture = join(Deno.cwd(), "tests", "fixture_config");
+
+  await t.step("config.onListen", async () => {
+    const { lines, serverProcess, output } = await startFreshServer({
+      args: [
+        "run",
+        "-A",
+        join(fixture, "main.ts"),
+      ],
+    });
+
+    try {
+      assert(output.find((line) => line === "it works"));
+    } finally {
+      serverProcess.kill("SIGTERM");
+      await serverProcess.status;
+
+      // Drain the lines stream
+      for await (const _ of lines) { /* noop */ }
+    }
+  });
+
+  await t.step("config.server.onListen", async () => {
+    const { lines, serverProcess, output } = await startFreshServer({
+      args: [
+        "run",
+        "-A",
+        join(fixture, "main.ts"),
+      ],
+      env: {
+        TEST_CONFIG_SERVER: "true",
+      },
+    });
+
+    try {
+      assert(output.find((line) => line === "it works #2"));
+    } finally {
+      serverProcess.kill("SIGTERM");
+      await serverProcess.status;
+
+      // Drain the lines stream
+      for await (const _ of lines) { /* noop */ }
+    }
+  });
 });
 
-Deno.test("adds refresh script to html", async () => {
-  await withFresh("./tests/fixture/main.ts", async (address) => {
-    const doc = await fetchHtml(address);
-    assertSelector(doc, `script[src="/_frsh/refresh.js"]`);
+Deno.test("pass options in config dev.ts", async (t) => {
+  const fixture = join(Deno.cwd(), "tests", "fixture_config");
+
+  await t.step("config.onListen", async () => {
+    const { lines, serverProcess, output } = await startFreshServer({
+      args: [
+        "run",
+        "-A",
+        join(fixture, "dev.ts"),
+      ],
+    });
+
+    try {
+      assert(output.find((line) => line === "it works"));
+    } finally {
+      serverProcess.kill("SIGTERM");
+      await serverProcess.status;
+
+      // Drain the lines stream
+      for await (const _ of lines) { /* noop */ }
+    }
+  });
+
+  await t.step("config.server.onListen", async () => {
+    const { lines, serverProcess, output } = await startFreshServer({
+      args: [
+        "run",
+        "-A",
+        join(fixture, "dev.ts"),
+      ],
+      env: {
+        TEST_CONFIG_SERVER: "true",
+      },
+    });
+
+    try {
+      assert(output.find((line) => line === "it works #2"));
+    } finally {
+      serverProcess.kill("SIGTERM");
+      await serverProcess.status;
+
+      // Drain the lines stream
+      for await (const _ of lines) { /* noop */ }
+    }
   });
 });
diff --git a/tests/partials_test.ts b/tests/partials_test.ts
new file mode 100644
index 00000000000..d42d3d5129d
--- /dev/null
+++ b/tests/partials_test.ts
@@ -0,0 +1,1116 @@
+import { assert, assertEquals, assertMatch } from "$std/testing/asserts.ts";
+import { Page } from "./deps.ts";
+import {
+  assertMetaContent,
+  assertNoComments,
+  assertNoPageComments,
+  assertNotSelector,
+  assertSelector,
+  assertTextMany,
+  parseHtml,
+  waitFor,
+  waitForText,
+  withFakeServe,
+  withPageName,
+} from "./test_utils.ts";
+
+async function assertLogs(page: Page, expected: string[]) {
+  await waitForText(page, "#logs", expected.join("\n") + "\n");
+}
+
+Deno.test("injects server content with no islands present", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/no_islands`);
+      await page.waitForSelector(".output");
+
+      const href = await page.$eval(".update-link", (el) => el.href);
+      await page.click(".update-link");
+      await waitForText(page, "p", "it works");
+
+      assertEquals(href, await page.url());
+      await assertNoPageComments(page);
+    },
+  );
+});
+
+Deno.test(
+  "throws when Partial is instantiated inside an island",
+  async () => {
+    await withFakeServe(
+      "./tests/fixture_partials/main.ts",
+      async (server) => {
+        const html = await server.getHtml("/partial_slot_inside_island");
+        assertMatch(
+          html.querySelector("h1")!.textContent!,
+          /<Partial> components cannot be used inside islands/,
+        );
+      },
+    );
+  },
+);
+
+Deno.test("warns on missing partial", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const logs: string[] = [];
+      page.on("console", (msg) => logs.push(msg.text()));
+
+      const initialUrl = `${address}/missing_partial`;
+      await page.goto(initialUrl);
+      await page.waitForSelector(".status-initial");
+
+      await page.click(".update-link");
+
+      await waitFor(() =>
+        logs.find((line) => /^Partial.*not found/.test(line))
+      );
+    },
+  );
+});
+
+Deno.test("does not include revive() when no island present", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const logs: string[] = [];
+      page.on("pageerror", (msg) => logs.push(msg.message));
+
+      const initialUrl = `${address}`;
+      await page.goto(initialUrl, {
+        waitUntil: "networkidle2",
+      });
+
+      // Should not error
+      assertEquals(logs, []);
+    },
+  );
+});
+
+Deno.test("injects content with island and keeps island instance alive", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_instance`);
+      await page.waitForSelector(".output-a");
+
+      // Update island state
+      await page.click(".island button");
+      await waitForText(page, ".output-a", "1");
+      await assertLogs(page, ["mount Counter A", "update Counter A"]);
+      await assertNoPageComments(page);
+
+      const href = await page.$eval(".update-link", (el) => el.href);
+      await page.click(".update-link");
+      await waitForText(page, ".status", "updated content");
+      await assertLogs(page, ["mount Counter A", "update Counter A"]);
+
+      assertEquals(href, await page.url());
+
+      // Check that island value didn't change
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+    },
+  );
+});
+
+Deno.test("finds partial nested in response", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/deep_partial`);
+      await page.waitForSelector(".status");
+
+      await page.click(".update-link");
+      await waitForText(page, ".status-updated", "updated");
+    },
+  );
+});
+
+Deno.test("unmounts island", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_instance`);
+      await page.waitForSelector(".output-a");
+
+      const href = await page.$eval(".remove-link", (el) => el.href);
+      await page.click(".remove-link");
+      await waitForText(page, ".status", "no islands");
+      await assertNoPageComments(page);
+
+      assertEquals(href, await page.url());
+      await assertLogs(page, ["mount Counter A", "unmount Counter A"]);
+
+      await page.click(".update-link");
+      await waitForText(page, ".status", "updated content");
+      await assertNoPageComments(page);
+
+      await assertLogs(page, [
+        "mount Counter A",
+        "unmount Counter A",
+        "mount Counter A",
+      ]);
+    },
+  );
+});
+
+Deno.test("unmounts island on replace", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_instance`);
+      await page.waitForSelector(".output-a");
+
+      // Update island state
+      await page.click(".island-a button");
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+
+      const href = await page.$eval(".replace-link", (el) => el.href);
+      await page.click(".replace-link");
+      await waitForText(page, ".status-replaced", "replaced content");
+      await assertNoPageComments(page);
+
+      assertEquals(href, await page.url());
+      await assertLogs(page, [
+        "mount Counter A",
+        "update Counter A",
+        "unmount Counter A",
+        "mount Other",
+      ]);
+
+      await page.click(".island-other button");
+      await waitForText(page, ".output-other", "1");
+      await assertNoPageComments(page);
+
+      await assertLogs(page, [
+        "mount Counter A",
+        "update Counter A",
+        "unmount Counter A",
+        "mount Other",
+        "update Other",
+      ]);
+    },
+  );
+});
+
+Deno.test("updates only one partial of many", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_instance_multiple`);
+      await page.waitForSelector(".output-a");
+
+      // Update island state
+      await page.click(".island-a button");
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+
+      await page.click(".island-b button");
+      await waitForText(page, ".output-b", "1");
+      await assertNoPageComments(page);
+
+      await assertLogs(page, [
+        "mount Counter A",
+        "mount Counter B",
+        "update Counter A",
+        "update Counter B",
+      ]);
+
+      const href = await page.$eval(".update-second-link", (el) => el.href);
+      await page.click(".update-second-link");
+      await page.waitForSelector(".status-2");
+      await assertNoPageComments(page);
+
+      assertEquals(href, await page.url());
+
+      // Check that island value didn't change
+      await waitForText(page, ".output-a", "1");
+      await waitForText(page, ".output-b", "1");
+    },
+  );
+});
+
+Deno.test("updates many partials at once", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_instance_multiple`);
+      await page.waitForSelector(".output-a");
+
+      // Update island state
+      await page.click(".island-a button");
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+
+      await page.click(".island-b button");
+      await waitForText(page, ".output-b", "1");
+      await assertNoPageComments(page);
+
+      await assertLogs(page, [
+        "mount Counter A",
+        "mount Counter B",
+        "update Counter A",
+        "update Counter B",
+      ]);
+
+      const href = await page.$eval(".update-both-link", (el) => el.href);
+      await page.click(".update-both-link");
+      await page.waitForSelector(".status-1");
+      await page.waitForSelector(".status-2");
+      await assertNoPageComments(page);
+
+      assertEquals(href, await page.url());
+
+      // Check that island value didn't change
+      await waitForText(page, ".output-a", "1");
+      await waitForText(page, ".output-b", "1");
+    },
+  );
+});
+
+Deno.test("keeps nested island state", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_instance_nested`);
+      await page.waitForSelector(".output-a");
+
+      // Update island state
+      await page.click(".island-a button");
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+
+      await page.click(".island-b button");
+      await waitForText(page, ".output-b", "1");
+      await assertNoPageComments(page);
+
+      await assertLogs(page, [
+        "mount Counter A",
+        "mount Counter B",
+        "mount PassThrough",
+        "mount PassThrough",
+        "update Counter A",
+        "update Counter B",
+      ]);
+
+      const href = await page.$eval(".update-link", (el) => el.href);
+      await page.click(".update-link");
+      await page.waitForSelector(".status-a");
+      await page.waitForSelector(".status-b");
+      await assertNoPageComments(page);
+
+      assertEquals(href, await page.url());
+
+      // Check that island value didn't change
+      await waitForText(page, ".output-a", "1");
+      await waitForText(page, ".output-b", "1");
+    },
+  );
+});
+
+Deno.test("replace island if parent type changes", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_instance_nested`);
+      await page.waitForSelector(".output-a");
+
+      // Update island state
+      await page.click(".island-a button");
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+
+      await page.click(".island-b button");
+      await waitForText(page, ".output-b", "1");
+      await assertNoPageComments(page);
+
+      await assertLogs(page, [
+        "mount Counter A",
+        "mount Counter B",
+        "mount PassThrough",
+        "mount PassThrough",
+        "update Counter A",
+        "update Counter B",
+      ]);
+
+      const href = await page.$eval(".replace-link", (el) => el.href);
+      await page.click(".replace-link");
+      await page.waitForSelector(".output-a");
+
+      assertEquals(href, await page.url());
+
+      // Check that island value was destroyed since we replaced it
+      await waitForText(page, ".output-a", "0");
+
+      await assertLogs(page, [
+        "mount Counter A",
+        "mount Counter B",
+        "mount PassThrough",
+        "mount PassThrough",
+        "update Counter A",
+        "update Counter B",
+        "unmount PassThrough",
+        "unmount Counter A",
+        "unmount PassThrough",
+        "unmount Counter B",
+        "mount Counter A",
+      ]);
+    },
+  );
+});
+
+Deno.test("serializes props", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_props`);
+      await page.waitForSelector(".pre-props");
+
+      let text = JSON.parse(
+        await page.$eval(".pre-props", (el) => el.textContent!),
+      );
+      assertEquals(
+        text,
+        {
+          number: 1,
+          string: "foo",
+          boolean: true,
+          null: null,
+          object: { foo: 123 },
+          strArr: ["foo"],
+        },
+      );
+
+      await page.click(".update-link");
+      await page.waitForSelector(".status-updated");
+      text = JSON.parse(
+        await page.$eval(".pre-props", (el) => el.textContent!),
+      );
+
+      assertEquals(
+        text,
+        {
+          number: 42,
+          string: "foobar",
+          boolean: false,
+          null: null,
+          object: { foo: 123456 },
+          strArr: ["foo", "bar"],
+        },
+      );
+
+      await assertNoPageComments(page);
+    },
+  );
+});
+
+Deno.test("serializes signals", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/island_props_signals`);
+      await page.waitForSelector(".island");
+
+      await page.click("button");
+      await waitForText(page, ".output", "1");
+      await assertNoPageComments(page);
+
+      await page.click(".update-link");
+      await page.waitForSelector(".status-update");
+      await assertNoPageComments(page);
+
+      // Currently, signal props are reset. This may change in
+      // the future
+      await waitForText(page, ".output", "0");
+    },
+  );
+});
+
+Deno.test("reconciles keyed islands", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/keys`);
+      await page.waitForSelector(".island");
+
+      await page.click(".btn-A");
+      await waitForText(page, ".output-A", "1");
+      await assertNoPageComments(page);
+
+      await page.click(".btn-B");
+      await waitForText(page, ".output-B", "1");
+      await page.click(".btn-B");
+      await waitForText(page, ".output-B", "2");
+      await assertNoPageComments(page);
+
+      await page.click(".btn-C");
+      await waitForText(page, ".output-C", "1");
+      await page.click(".btn-C");
+      await waitForText(page, ".output-C", "2");
+      await page.click(".btn-C");
+      await waitForText(page, ".output-C", "3");
+      await assertNoPageComments(page);
+
+      await page.click(".swap-link");
+      await page.waitForSelector(".status-swap");
+      await assertNoPageComments(page);
+
+      // Check that result is stable
+      await waitForText(page, ".output-A", "1");
+      await waitForText(page, ".output-B", "2");
+      await waitForText(page, ".output-C", "3");
+    },
+  );
+});
+
+Deno.test("reconciles keyed DOM nodes", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/keys_dom`);
+      await page.waitForSelector(".island");
+
+      await page.click(".btn-A");
+      await waitForText(page, ".output-A", "1");
+      await assertNoPageComments(page);
+
+      await page.click(".btn-B");
+      await waitForText(page, ".output-B", "1");
+      await page.click(".btn-B");
+      await waitForText(page, ".output-B", "2");
+      await assertNoPageComments(page);
+
+      await page.click(".btn-C");
+      await waitForText(page, ".output-C", "1");
+      await page.click(".btn-C");
+      await waitForText(page, ".output-C", "2");
+      await page.click(".btn-C");
+      await waitForText(page, ".output-C", "3");
+      await assertNoPageComments(page);
+
+      await page.click(".swap-link");
+      await page.waitForSelector(".status-swap");
+      await assertNoPageComments(page);
+
+      // Check that result is stable
+      await waitForText(page, ".output-A", "1");
+      await waitForText(page, ".output-B", "2");
+      await waitForText(page, ".output-C", "3");
+
+      // Check that no element has `data-fresh-key` attribute
+      const doc = parseHtml(await page.content());
+      assertNotSelector(doc, "[data-fresh-key]");
+    },
+  );
+});
+
+Deno.test("reconciles keyed non island components", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/keys_components`);
+      await page.waitForSelector(".island");
+
+      await page.click(".btn-A");
+      await waitForText(page, ".output-A", "1");
+      await assertNoPageComments(page);
+
+      await page.click(".btn-B");
+      await waitForText(page, ".output-B", "1");
+      await page.click(".btn-B");
+      await waitForText(page, ".output-B", "2");
+      await assertNoPageComments(page);
+
+      await page.click(".btn-C");
+      await waitForText(page, ".output-C", "1");
+      await page.click(".btn-C");
+      await waitForText(page, ".output-C", "2");
+      await page.click(".btn-C");
+      await waitForText(page, ".output-C", "3");
+      await assertNoPageComments(page);
+
+      await page.click(".swap-link");
+      await page.waitForSelector(".status-swap");
+      await assertNoPageComments(page);
+
+      // Check that result is stable
+      await waitForText(page, ".output-A", "1");
+      await waitForText(page, ".output-B", "2");
+      await waitForText(page, ".output-C", "3");
+
+      // Check that no element has `data-fresh-key` attribute
+      const doc = parseHtml(await page.content());
+      assertNotSelector(doc, "[data-fresh-key]");
+    },
+  );
+});
+
+Deno.test("don't serialize keys for nodes outside islands or partials", async () => {
+  await withFakeServe("./tests/fixture_partials/main.ts", async (server) => {
+    const doc = await server.getHtml("/keys_outside");
+    assertNoComments(doc);
+  });
+});
+
+Deno.test("partial injection mode", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/mode`);
+      await page.waitForSelector(".island");
+
+      await page.click("button");
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+
+      // Append
+      await page.click(".append-link");
+      await page.waitForSelector(".status-append");
+      // Check that old content is still there
+      await page.waitForSelector(".status-initial");
+      await assertNoPageComments(page);
+
+      // Check that newly inserted island is interactive
+      await page.click(".island-other button");
+      await waitForText(page, ".output-other", "1");
+      await assertNoPageComments(page);
+
+      // Prepend
+      await page.click(".prepend-link");
+      await page.waitForSelector(".status-prepend");
+      // Check that old content is still there
+      await page.waitForSelector(".status-append");
+      await page.waitForSelector(".status-initial");
+      await assertNoPageComments(page);
+
+      // Replace
+      await page.click(".replace-link");
+      await page.waitForSelector(".status-replace");
+      await assertNoPageComments(page);
+
+      const doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".status-append");
+      assertNotSelector(doc, ".status-prepend");
+    },
+  );
+});
+
+Deno.test("partial navigation", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const initialUrl = `${address}/mode`;
+      await page.goto(initialUrl);
+      await page.waitForSelector(".island");
+
+      await page.click(".append-link");
+      await page.waitForSelector(".status-append");
+      await assertNoPageComments(page);
+
+      await page.click(".island-other button");
+      await waitForText(page, ".output-other", "1");
+      await assertNoPageComments(page);
+
+      const url = page.url();
+
+      // Click link again
+      await page.click(".append-link");
+      await page.waitForFunction(() =>
+        document.querySelectorAll(".status-append").length > 1
+      );
+      assertEquals(page.url(), url);
+      await assertNoPageComments(page);
+
+      // Go back
+      await page.goBack();
+      await page.waitForFunction(() =>
+        document.querySelectorAll(".island").length === 1
+      );
+      assertEquals(page.url(), initialUrl);
+      await waitFor(async () => {
+        const doc = parseHtml(await page.content());
+        return /mount Counter A/.test(doc.querySelector("pre")!.textContent!);
+      });
+      await assertNoPageComments(page);
+    },
+  );
+});
+
+Deno.test("non-partial client navigation", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const initialUrl = `${address}/client_nav`;
+      await page.goto(initialUrl);
+      await page.waitForSelector(".island");
+
+      // Add marker to check if the page reloaded or not
+      await page.evaluate(() => {
+        const marker = document.createElement("fresh-nav-marker");
+        document.body.appendChild(marker);
+      });
+
+      await page.click(".island-a button");
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+
+      // Go to page B
+      await page.click(".page-b-link");
+      await page.waitForSelector(".island-b");
+
+      let doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".island-a");
+      assertSelector(doc, "fresh-nav-marker");
+      assertEquals(page.url(), `${address}/client_nav/page-b`);
+
+      await page.click(".island-b button");
+      await waitForText(page, ".output-b", "1");
+      await assertNoPageComments(page);
+
+      // Go to page C
+      await page.click(".page-c-link");
+      await page.waitForSelector(".page-c-text");
+
+      doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".island-a");
+      assertNotSelector(doc, ".island-b");
+      assertSelector(doc, "fresh-nav-marker");
+      assertEquals(page.url(), `${address}/client_nav/page-c`);
+
+      // Go back to B
+      await page.goBack();
+      await page.waitForSelector(".island-b");
+
+      doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".island-a");
+      assertSelector(doc, "fresh-nav-marker");
+      assertNotSelector(doc, ".page-c-text");
+
+      // Non-shared state is reset
+      assertTextMany(doc, ".output-b", ["0"]);
+
+      // Check that island is interactive
+      await page.click(".island-b button");
+      await waitForText(page, ".output-b", "1");
+      await assertNoPageComments(page);
+
+      // Go back to A
+      await page.goBack();
+      await page.waitForSelector(".island-a");
+
+      doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".island-b");
+      assertNotSelector(doc, ".page-c-text");
+      assertSelector(doc, "fresh-nav-marker");
+
+      // Non-shared state is reset
+      assertTextMany(doc, ".output-a", ["0"]);
+
+      // Check that island is interactive
+      await page.click(".island-a button");
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+
+      // Go forward to B
+      await page.goForward();
+      await page.waitForSelector(".island-b");
+
+      doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".island-a");
+      assertNotSelector(doc, ".page-c-text");
+      assertSelector(doc, "fresh-nav-marker");
+
+      // Non-shared state is reset
+      assertTextMany(doc, ".output-b", ["0"]);
+
+      // Check that island is interactive
+      await page.click(".island-b button");
+      await waitForText(page, ".output-b", "1");
+      await assertNoPageComments(page);
+    },
+  );
+});
+
+Deno.test("allow opting out of client navigation", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const initialUrl = `${address}/client_nav_opt_out`;
+      await page.goto(initialUrl);
+      await page.waitForSelector(".island");
+
+      async function addMarker() {
+        await page.evaluate(() => {
+          const marker = document.createElement("fresh-nav-marker");
+          document.body.appendChild(marker);
+        });
+      }
+
+      // Add marker to check if the page reloaded or not
+      await addMarker();
+
+      await page.click(".island-a button");
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+
+      // Go to page B
+      await page.click(".page-b-link");
+      await page.waitForSelector(".island-b");
+
+      let doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".island-a");
+      assertNotSelector(doc, "fresh-nav-marker");
+      assertEquals(page.url(), `${address}/client_nav_opt_out/page-b`);
+
+      await page.click(".island-b button");
+      await waitForText(page, ".output-b", "1");
+      await assertNoPageComments(page);
+
+      // Add marker to check if the page reloaded or not
+      await addMarker();
+
+      // Go to page C
+      await page.click(".page-c-link");
+      await page.waitForSelector(".page-c-text");
+
+      doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".island-a");
+      assertNotSelector(doc, ".island-b");
+      assertNotSelector(doc, "fresh-nav-marker");
+      assertEquals(page.url(), `${address}/client_nav_opt_out/page-c`);
+
+      // Add marker to check if the page reloaded or not
+      await addMarker();
+
+      // Go back to B
+      await page.goBack();
+      await page.waitForSelector(".island-b");
+
+      doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".island-a");
+      assertNotSelector(doc, "fresh-nav-marker");
+      assertNotSelector(doc, ".page-c-text");
+
+      // Non-shared state is reset
+      assertTextMany(doc, ".output-b", ["0"]);
+
+      // Check that island is interactive
+      await page.click(".island-b button");
+      await waitForText(page, ".output-b", "1");
+      await assertNoPageComments(page);
+
+      // Go back to A
+      await page.goBack();
+      await page.waitForSelector(".island-a");
+
+      doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".island-b");
+      assertNotSelector(doc, ".page-c-text");
+      assertNotSelector(doc, "fresh-nav-marker");
+
+      // Non-shared state is reset
+      assertTextMany(doc, ".output-a", ["0"]);
+
+      // Check that island is interactive
+      await page.click(".island-a button");
+      await waitForText(page, ".output-a", "1");
+      await assertNoPageComments(page);
+
+      // Go forward to B
+      await page.goForward();
+      await page.waitForSelector(".island-b");
+
+      doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".island-a");
+      assertNotSelector(doc, ".page-c-text");
+      assertNotSelector(doc, "fresh-nav-marker");
+
+      // Non-shared state is reset
+      assertTextMany(doc, ".output-b", ["0"]);
+
+      // Check that island is interactive
+      await page.click(".island-b button");
+      await waitForText(page, ".output-b", "1");
+    },
+  );
+});
+
+Deno.test("restore scroll position", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const initialUrl = `${address}/scroll_restoration`;
+      await page.goto(initialUrl);
+      await page.waitForSelector(".status-initial");
+
+      await page.evaluate(() => {
+        document.querySelector(".update-link")?.scrollIntoView({
+          behavior: "instant",
+        });
+      });
+
+      await page.click(".update-link");
+      await page.waitForSelector(".status-updated");
+
+      await page.goBack();
+      await page.waitForSelector(".status-initial");
+      const scroll = await page.evaluate(() => ({ scrollX, scrollY }));
+
+      assert(scroll.scrollY > 100, `Page did not scroll ${scroll.scrollY}`);
+    },
+  );
+});
+
+Deno.test("shows loading indicator if trigger outside island", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const initialUrl = `${address}/loading`;
+      await page.goto(initialUrl);
+      await page.waitForSelector(".status");
+
+      let doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".spinner");
+
+      await Promise.all([
+        page.waitForSelector(".spinner-inner"),
+        page.waitForSelector(".spinner-outer"),
+        page.click(".update-link"),
+      ]);
+
+      await page.waitForSelector(".status-updated");
+      await assertNoPageComments(page);
+
+      doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".spinner");
+    },
+  );
+});
+
+Deno.test("shows loading indicator if trigger inside island", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const initialUrl = `${address}/loading`;
+      await page.goto(initialUrl);
+      await page.waitForSelector(".status");
+
+      let doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".spinner");
+
+      await Promise.all([
+        page.waitForSelector(".spinner-inner"),
+        page.waitForSelector(".spinner-outer"),
+        page.click(".trigger"),
+      ]);
+
+      await page.waitForSelector(".status-updated");
+      await assertNoPageComments(page);
+
+      doc = parseHtml(await page.content());
+      assertNotSelector(doc, ".spinner");
+    },
+  );
+});
+
+Deno.test("submit form", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const initialUrl = `${address}/form`;
+      await page.goto(initialUrl);
+      await page.waitForSelector(".status");
+
+      await page.click(".submit");
+      await page.waitForSelector(".status-updated");
+      await assertNoPageComments(page);
+    },
+  );
+});
+
+Deno.test("fragment navigation should not cause loop", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const logs: string[] = [];
+      page.on("console", (msg) => logs.push(msg.text()));
+
+      const initialUrl = `${address}/fragment_nav`;
+      await page.goto(initialUrl);
+      await page.waitForSelector(".partial-text");
+
+      await page.click("a");
+
+      await page.waitForFunction(() => location.hash === "#foo");
+      assertEquals(logs, []);
+    },
+  );
+});
+
+Deno.test("active links without client nav", async () => {
+  await withFakeServe(
+    "./tests/fixture_partials/main.ts",
+    async (server) => {
+      let doc = await server.getHtml(`/active_nav`);
+      assertSelector(doc, "a[href='/'][data-ancestor]");
+
+      // Current
+      assertNotSelector(doc, "a[href='/active_nav'][data-ancestor]");
+      assertSelector(doc, "a[href='/active_nav'][data-current]");
+
+      // Unrelated links
+      assertNotSelector(doc, "a[href='/active_nav/foo'][data-ancestor]");
+      assertNotSelector(doc, "a[href='/active_nav/foo/bar'][data-ancestor]");
+
+      doc = await server.getHtml(`/active_nav/foo`);
+      assertSelector(doc, "a[href='/active_nav/foo'][data-current]");
+      assertSelector(doc, "a[href='/active_nav'][data-ancestor]");
+      assertSelector(doc, "a[href='/'][data-ancestor]");
+    },
+  );
+});
+
+Deno.test("Updates active links outside of vdom", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/active_nav_partial`);
+
+      let doc = parseHtml(await page.content());
+      assertSelector(doc, "a[href='/'][data-ancestor]");
+
+      // Current
+      assertNotSelector(doc, "a[href='/active_nav_partial'][data-ancestor]");
+      assertSelector(doc, "a[href='/active_nav_partial'][data-current]");
+
+      // Unrelated links
+      assertNotSelector(
+        doc,
+        "a[href='/active_nav_partial/foo'][data-ancestor]",
+      );
+      assertNotSelector(
+        doc,
+        "a[href='/active_nav_partial/foo/bar'][data-ancestor]",
+      );
+
+      await page.goto(`${address}/active_nav_partial/foo`);
+      doc = parseHtml(await page.content());
+      assertSelector(doc, "a[href='/active_nav_partial/foo'][data-current]");
+      assertSelector(doc, "a[href='/active_nav_partial'][data-ancestor]");
+      assertSelector(doc, "a[href='/'][data-ancestor]");
+    },
+  );
+});
+
+Deno.test("throws an error when response contains no partials", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      const logs: string[] = [];
+      page.on("pageerror", (msg) => logs.push(msg.message));
+
+      await page.goto(`${address}/no_partial_response`);
+      await waitFor(async () => {
+        const logEl = await page.$eval("#logs", (el) => el.textContent);
+        return /mount Counter/.test(logEl);
+      });
+
+      await page.click(".update-link");
+
+      await waitFor(() => logs.length > 0);
+      assertMatch(logs[0], /Found no partials/);
+    },
+  );
+});
+
+Deno.test("merges <head> content", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/head_merge`);
+      await page.waitForSelector(".status-initial");
+
+      await page.click(".update-link");
+      await page.waitForSelector(".status-updated");
+
+      await waitFor(async () => {
+        return (await page.title()) === "Head merge updated";
+      });
+
+      const doc = parseHtml(await page.content());
+      assertEquals(doc.title, "Head merge updated");
+
+      assertMetaContent(doc, "foo", "bar baz");
+      assertMetaContent(doc, "og:foo", "og value foo");
+      assertMetaContent(doc, "og:bar", "og value bar");
+
+      const color = await page.$eval("h1", (el) => {
+        return window.getComputedStyle(el).color;
+      });
+      assertEquals(color, "rgb(255, 0, 0)");
+
+      const textColor = await page.$eval("p", (el) => {
+        return window.getComputedStyle(el).color;
+      });
+      assertEquals(textColor, "rgb(0, 128, 0)");
+    },
+  );
+});
+
+Deno.test("does not merge duplicate <head> content", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/head_merge`);
+      await page.waitForSelector(".status-initial");
+
+      await page.click(".duplicate-link");
+      await page.waitForSelector(".status-duplicated");
+
+      await waitFor(async () => {
+        return (await page.title()) === "Head merge duplicated";
+      });
+
+      const html = await page.content();
+      assert(
+        Array.from(html.matchAll(/id="style-foo"/g)).length === 1,
+        `Duplicate style tag found`,
+      );
+
+      assert(
+        Array.from(html.matchAll(/style\.css/g)).length === 1,
+        `Duplicate link stylesheet found`,
+      );
+    },
+  );
+});
+
+Deno.test("applies f-partial on <button>", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/button`);
+      await page.waitForSelector(".status-initial");
+
+      await page.click("button");
+      await page.waitForSelector(".status-updated");
+    },
+  );
+});
+
+Deno.test("supports relative links", async () => {
+  await withPageName(
+    "./tests/fixture_partials/main.ts",
+    async (page, address) => {
+      await page.goto(`${address}/relative_link`);
+      await page.waitForSelector(".status-initial");
+
+      await page.click("button");
+      await page.waitForSelector(".status-refreshed");
+    },
+  );
+});
diff --git a/tests/plugin_test.ts b/tests/plugin_test.ts
index 999215bf7fc..300ec70d39e 100644
--- a/tests/plugin_test.ts
+++ b/tests/plugin_test.ts
@@ -1,3 +1,4 @@
+import { assertMatch } from "$std/testing/asserts.ts";
 import { ServerContext, Status } from "../server.ts";
 import {
   assert,
@@ -8,7 +9,12 @@ import {
 } from "./deps.ts";
 import manifest from "./fixture_plugin/fresh.gen.ts";
 import options from "./fixture_plugin/options.ts";
-import { startFreshServer } from "./test_utils.ts";
+import {
+  clickWhenListenerReady,
+  runBuild,
+  startFreshServer,
+  withPageName,
+} from "./test_utils.ts";
 
 const ctx = await ServerContext.fromManifest(manifest, options);
 const handler = ctx.handler();
@@ -122,9 +128,49 @@ Deno.test({
 
     await browser.close();
 
-    await lines.cancel();
     serverProcess.kill("SIGTERM");
+    await serverProcess.status;
+
+    // Drain the lines stream
+    for await (const _ of lines) { /* noop */ }
   },
-  sanitizeOps: false,
-  sanitizeResources: false,
+});
+
+Deno.test("calls buildStart() and buildEnd()", async () => {
+  const result = await runBuild("./tests/fixture_plugin_lifecycle/dev.ts");
+
+  const out = result.stdout.split("\n").filter((line) =>
+    line.startsWith("Plugin")
+  );
+
+  assertEquals(out, [
+    "Plugin a: buildStart",
+    "Plugin b: buildStart",
+    "Plugin a: buildEnd",
+    "Plugin b: buildEnd",
+  ]);
+});
+
+Deno.test("plugin script doesn't halt island execution", async () => {
+  await withPageName(
+    "./tests/fixture_plugin_error/main.ts",
+    async (page, address) => {
+      let error;
+      page.on("pageerror", (err) => {
+        error = err;
+      });
+      await page.goto(address);
+      await page.waitForSelector("#ready");
+
+      let text = await page.$eval("p", (el) => el.textContent!);
+      assertEquals(text, "0");
+
+      await clickWhenListenerReady(page, "button");
+
+      text = await page.$eval("p", (el) => el.textContent!);
+      assertEquals(text, "1");
+
+      assertMatch(String(error), /Error thrown/);
+    },
+  );
 });
diff --git a/tests/route_groups_test.ts b/tests/route_groups_test.ts
index b2b29a1e479..6153b984eed 100644
--- a/tests/route_groups_test.ts
+++ b/tests/route_groups_test.ts
@@ -1,18 +1,17 @@
 import { assertEquals } from "$std/testing/asserts.ts";
 import {
   assertTextMany,
-  fetchHtml,
   parseHtml,
   waitForText,
-  withFresh,
+  withFakeServe,
   withPageName,
 } from "./test_utils.ts";
 
 Deno.test("applies only _layout file of one group", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/route-groups`);
+    async (server) => {
+      const doc = await server.getHtml(`/route-groups`);
 
       assertTextMany(doc, "p", ["Foo layout", "Foo page"]);
     },
@@ -20,20 +19,20 @@ Deno.test("applies only _layout file of one group", async () => {
 });
 
 Deno.test("applies only _layout files in parent groups", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/route-groups/baz`);
+    async (server) => {
+      const doc = await server.getHtml(`/route-groups/baz`);
       assertTextMany(doc, "p", ["Bar layout", "Baz layout", "Baz page"]);
     },
   );
 });
 
 Deno.test("applies only _layout files in parent groups #2", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}/route-groups/boof`);
+    async (server) => {
+      const doc = await server.getHtml(`/route-groups/boof`);
       assertTextMany(doc, "p", ["Bar layout", "Boof Page"]);
     },
   );
@@ -52,32 +51,32 @@ Deno.test("can co-locate islands inside routes folder", async () => {
 });
 
 Deno.test("does not treat files in (_islands) as routes", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture/main.ts",
-    async (address) => {
-      const res = await fetch(`${address}/route-groups-islands/invalid`);
+    async (server) => {
+      const res = await server.get(`/route-groups-islands/invalid`);
       assertEquals(res.status, 404);
-      res.body?.cancel();
+      await res.body?.cancel();
     },
   );
 });
 
 Deno.test("does not treat files in (_...) as routes", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture/main.ts",
-    async (address) => {
-      const res = await fetch(`${address}/route-groups-islands/sub`);
+    async (server) => {
+      const res = await server.get(`/route-groups-islands/sub`);
       assertEquals(res.status, 404);
-      res.body?.cancel();
+      await res.body?.cancel();
     },
   );
 });
 
 Deno.test("resolve index route in group /(group)/index.tsx", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_group_index/main.ts",
-    async (address) => {
-      const res = await fetch(`${address}`);
+    async (server) => {
+      const res = await server.get(`/`);
       assertEquals(res.status, 200);
       const doc = parseHtml(await res.text());
       assertEquals(doc.querySelector("h1")?.textContent, "it works");
diff --git a/tests/server_components_test.ts b/tests/server_components_test.ts
index 1ee3fc5ac42..6984971070d 100644
--- a/tests/server_components_test.ts
+++ b/tests/server_components_test.ts
@@ -2,7 +2,7 @@ import { assertEquals } from "./deps.ts";
 import {
   assertSelector,
   assertTextMany,
-  fetchHtml,
+  withFakeServe,
   withFresh,
   withPageName,
 } from "./test_utils.ts";
@@ -12,35 +12,29 @@ Deno.test({
   name: "render async server component",
 
   async fn() {
-    await withFresh(
+    await withFakeServe(
       "./tests/fixture_server_components/main.ts",
-      async (address) => {
-        const doc = await fetchHtml(`${address}/basic`);
+      async (server) => {
+        const doc = await server.getHtml(`/basic`);
         assertTextMany(doc, "h1", ["it works"]);
       },
     );
   },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
 
 Deno.test({
   name: "uses returned response",
 
   async fn() {
-    await withFresh(
+    await withFakeServe(
       "./tests/fixture_server_components/main.ts",
-      async (address) => {
-        const res = await fetch(`${address}/response`);
+      async (server) => {
+        const res = await server.get(`/response`);
         const text = await res.text();
         assertEquals(text, "it works");
       },
     );
   },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
 
 Deno.test({
@@ -62,9 +56,6 @@ Deno.test({
       },
     );
   },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
 
 Deno.test({
@@ -91,7 +82,7 @@ Deno.test({
               transport: "tcp",
             },
             remoteAddr: {
-              hostname: "localhost",
+              hostname: "127.0.0.1",
               port: 8000,
               transport: "tcp",
             },
@@ -107,19 +98,16 @@ Deno.test({
       },
     );
   },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
 
 Deno.test({
   name: "can call context.renderNotFound()",
 
   async fn() {
-    await withFresh(
+    await withFakeServe(
       "./tests/fixture_server_components/main.ts",
-      async (address) => {
-        const res = await fetch(`${address}/fail`);
+      async (server) => {
+        const res = await server.get(`/fail`);
 
         assertEquals(res.status, Status.NotFound);
         const html = await res.text();
@@ -127,9 +115,6 @@ Deno.test({
       },
     );
   },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
 
 Deno.test({
@@ -142,7 +127,7 @@ Deno.test({
         await page.goto(`${address}/twind`);
         await page.waitForSelector("h1");
 
-        const text = await page.$eval("body", (el) => el.textContent);
+        const text = await page.$eval("h1", (el) => el.textContent);
         assertEquals(text, "it works");
 
         // Check that CSS was applied accordingly
@@ -153,19 +138,16 @@ Deno.test({
       },
     );
   },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
 
 Deno.test({
   name: "renders async app template",
 
   async fn() {
-    await withFresh(
+    await withFakeServe(
       "./tests/fixture_async_app/main.ts",
-      async (address) => {
-        const doc = await fetchHtml(`${address}`);
+      async (server) => {
+        const doc = await server.getHtml(``);
         assertSelector(doc, "html > body > .app > .layout > .page");
       },
     );
@@ -173,10 +155,10 @@ Deno.test({
 });
 
 Deno.test("define helpers", async () => {
-  await withFresh(
+  await withFakeServe(
     "./tests/fixture_define_helpers/main.ts",
-    async (address) => {
-      const doc = await fetchHtml(`${address}`);
+    async (server) => {
+      const doc = await server.getHtml(``);
       assertSelector(doc, "html > body > .app > .layout > .page");
       assertTextMany(doc, "p", ["Layout: it works", "Page: it works"]);
     },
diff --git a/tests/signal_test.ts b/tests/signal_test.ts
index 31e7f49aa85..46aa3402d2d 100644
--- a/tests/signal_test.ts
+++ b/tests/signal_test.ts
@@ -16,7 +16,4 @@ Deno.test({
       await waitForText(page, "#counter-2 p", "3");
     });
   },
-
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
diff --git a/tests/test_utils.ts b/tests/test_utils.ts
index 1e25bcee579..62f14b893d5 100644
--- a/tests/test_utils.ts
+++ b/tests/test_utils.ts
@@ -1,17 +1,38 @@
-import { colors } from "$fresh/src/server/deps.ts";
+import { colors, toFileUrl } from "$fresh/src/server/deps.ts";
+import { assert } from "$std/_util/asserts.ts";
+import * as path from "$std/path/mod.ts";
+import {
+  FromManifestOptions,
+  Manifest,
+  ServeHandlerInfo,
+  ServerContext,
+} from "$fresh/server.ts";
 import {
   assertEquals,
+  basename,
   delay,
+  dirname,
   DOMParser,
   HTMLElement,
   HTMLMetaElement,
+  join,
   Page,
   puppeteer,
   TextLineStream,
 } from "./deps.ts";
 
-export function parseHtml(input: string) {
-  return new DOMParser().parseFromString(input, "text/html");
+export interface TestDocument extends Document {
+  debug(): void;
+}
+
+export function parseHtml(input: string): TestDocument {
+  // deno-lint-ignore no-explicit-any
+  const doc = new DOMParser().parseFromString(input, "text/html") as any;
+  Object.defineProperty(doc, "debug", {
+    value: () => console.log(prettyDom(doc)),
+    enumerable: false,
+  });
+  return doc;
 }
 
 export async function startFreshServer(options: Deno.CommandOptions) {
@@ -87,7 +108,6 @@ export const VOID_ELEMENTS =
   /^(?:area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/;
 function prettyDom(doc: Document) {
   let out = colors.dim(`<!DOCTYPE ${doc.doctype?.name ?? ""}>\n`);
-  console.log(out);
 
   const node = doc.documentElement;
   out += _printDomNode(node, 0);
@@ -103,6 +123,8 @@ function _printDomNode(
 
   if (node.nodeType === 3) {
     return space + colors.dim(node.textContent ?? "") + "\n";
+  } else if (node.nodeType === 8) {
+    return space + colors.dim(`<--${(node as Text).data}-->`) + "\n";
   }
 
   let out = space;
@@ -166,12 +188,13 @@ export async function withFresh(
   try {
     await fn(address);
   } finally {
-    await lines.cancel();
-
     serverProcess.kill("SIGTERM");
 
     // Wait until the process exits
     await serverProcess.status;
+
+    // Drain the lines stream
+    for await (const _ of lines) { /* noop */ }
   }
 }
 
@@ -194,19 +217,90 @@ export async function withPageName(
       await browser.close();
     }
   } finally {
-    await lines.cancel();
-
     serverProcess.kill("SIGTERM");
 
     // Wait until the process exits
     await serverProcess.status;
+
+    // Drain the lines stream
+    for await (const _ of lines) { /* noop */ }
+  }
+}
+
+export interface FakeServer {
+  request(req: Request): Promise<Response>;
+  getHtml(pathname: string): Promise<TestDocument>;
+  get(pathname: string): Promise<Response>;
+}
+
+async function handleRequest(
+  handler: ReturnType<ServerContext["handler"]>,
+  conn: ServeHandlerInfo,
+  req: Request,
+) {
+  let res = await handler(req, conn);
+
+  // Follow redirects
+  while (res.headers.has("location")) {
+    const loc = res.headers.get("location");
+    const hostname = conn.remoteAddr.hostname;
+    res = await handler(new Request(`https://${hostname}${loc}`), conn);
   }
+
+  return res;
+}
+
+export async function fakeServe(
+  manifest: Manifest,
+  options: FromManifestOptions,
+): Promise<FakeServer> {
+  const ctx = await ServerContext.fromManifest(manifest, options);
+  const handler = ctx.handler();
+
+  const conn: ServeHandlerInfo = {
+    remoteAddr: {
+      transport: "tcp",
+      hostname: "127.0.0.1",
+      port: 80,
+    },
+  };
+
+  const origin = `https://127.0.0.1`;
+
+  return {
+    request(req) {
+      return handler(req, conn);
+    },
+    async getHtml(pathname) {
+      const req = new Request(`${origin}${pathname}`);
+      const res = await handleRequest(handler, conn, req);
+      return parseHtml(await res.text());
+    },
+    get(pathname: string) {
+      const req = new Request(`${origin}${pathname}`);
+      return handleRequest(handler, conn, req);
+    },
+  };
+}
+
+export async function withFakeServe(
+  name: string,
+  cb: (server: FakeServer) => Promise<void> | void,
+) {
+  const fixture = join(Deno.cwd(), name);
+  const dev = basename(name) === "dev.ts";
+
+  const manifestPath = toFileUrl(join(dirname(fixture), "fresh.gen.ts")).href;
+  const manifestMod = await import(manifestPath);
+
+  const server = await fakeServe(manifestMod.default, { dev });
+  await cb(server);
 }
 
 export async function startFreshServerExpectErrors(
   options: Deno.CommandOptions,
 ) {
-  const { serverProcess, address } = await spawnServer(options, true);
+  const { serverProcess, lines, address } = await spawnServer(options, true);
 
   if (address) {
     throw Error("Server started correctly");
@@ -222,6 +316,16 @@ export async function startFreshServerExpectErrors(
   for await (const line of errorLines) {
     output += line + "\n";
   }
+
+  try {
+    serverProcess.kill("SIGTERM");
+  } catch {
+    // ignore the error, this may throw on windows if the process has already
+    // exited
+  }
+  await serverProcess.status;
+  for await (const _ of lines) { /* noop */ }
+
   return output;
 }
 
@@ -259,14 +363,60 @@ export async function waitForText(
   text: string,
 ) {
   await page.waitForSelector(selector);
-  await page.waitForFunction(
-    (sel, value) => {
-      return document.querySelector(sel)!.textContent === value;
-    },
-    { timeout: 2000 },
-    selector,
-    String(text),
-  );
+  try {
+    await page.waitForFunction(
+      (sel, value) => {
+        return document.querySelector(sel)!.textContent === value;
+      },
+      { timeout: 2000 },
+      selector,
+      String(text),
+    );
+  } catch (err) {
+    const body = await page.content();
+    // deno-lint-ignore no-explicit-any
+    const pretty = prettyDom(parseHtml(body) as any);
+
+    console.log(
+      `Text "${text}" not found on selector "${selector}" in html:\n\n${pretty}`,
+    );
+    throw err;
+  }
+}
+
+export async function waitForStyle(
+  page: Page,
+  selector: string,
+  name: keyof CSSStyleDeclaration,
+  value: string,
+) {
+  await page.waitForSelector(selector);
+
+  const start = Date.now();
+  let now = start;
+  let found = false;
+  while (now < start + 2000) {
+    found = await page.evaluate(
+      (s, n, v) => {
+        const el = document.querySelector(s);
+        if (!el) return false;
+        return window.getComputedStyle(el)[n] === v;
+      },
+      selector,
+      name,
+      value,
+    );
+
+    if (found) break;
+
+    await delay(200);
+    now = Date.now();
+  }
+
+  if (!found) {
+    console.log(prettyDom(parseHtml(await page.content())));
+    throw new Error(`Could not find style ${String(name)}: ${value}`);
+  }
 }
 
 async function spawnServer(
@@ -280,16 +430,14 @@ async function spawnServer(
     stderr: expectErrors ? "piped" : "inherit",
   }).spawn();
 
-  const decoder = new TextDecoderStream();
   const lines: ReadableStream<string> = serverProcess.stdout
-    .pipeThrough(decoder)
-    .pipeThrough(new TextLineStream(), {
-      preventCancel: true,
-    });
+    .pipeThrough(new TextDecoderStream())
+    .pipeThrough(new TextLineStream());
 
   const output: string[] = [];
   let address = "";
-  for await (const line of lines) {
+  // @ts-ignore yes it does
+  for await (const line of lines.values({ preventCancel: true })) {
     output.push(line);
     const match = line.match(/https?:\/\/localhost:\d+/g);
     if (match) {
@@ -300,3 +448,141 @@ async function spawnServer(
 
   return { serverProcess, lines, address, output };
 }
+
+export async function runBuild(fixture: string) {
+  const outDir = path.join(path.dirname(fixture), "_fresh");
+  try {
+    await Deno.remove(outDir, { recursive: true });
+  } catch {
+    // Ignore
+  }
+
+  assert(
+    fixture.endsWith("dev.ts"),
+    `Build command only works with "dev.ts", but got "${fixture}" instead`,
+  );
+  const res = await new Deno.Command(Deno.execPath(), {
+    args: [
+      "run",
+      "-A",
+      fixture,
+      "build",
+    ],
+    env: {
+      GITHUB_SHA: "__BUILD_ID__",
+      DENO_DEPLOYMENT_ID: "__BUILD_ID__",
+    },
+    stdin: "null",
+    stdout: "piped",
+    stderr: "piped",
+  }).output();
+
+  const output = getStdOutput(res);
+  return {
+    code: res.code,
+    stderr: output.stderr,
+    stdout: output.stdout,
+  };
+}
+
+export function getStdOutput(
+  out: Deno.CommandOutput,
+): { stdout: string; stderr: string } {
+  const decoder = new TextDecoder();
+  const stdout = colors.stripColor(decoder.decode(out.stdout));
+
+  const decoderErr = new TextDecoder();
+  const stderr = colors.stripColor(decoderErr.decode(out.stderr));
+
+  return { stdout, stderr };
+}
+
+export async function waitFor(
+  fn: () => Promise<unknown> | unknown,
+): Promise<void> {
+  let now = Date.now();
+  const limit = now + 2000;
+
+  while (now < limit) {
+    try {
+      if (await fn()) return;
+    } catch (err) {
+      if (now > limit) {
+        throw err;
+      }
+    } finally {
+      await delay(100);
+      now = Date.now();
+    }
+  }
+
+  throw new Error(`Timed out`);
+}
+
+function walk(doc: Document, node: HTMLElement): string | null {
+  for (let i = 0; i < node.childNodes.length; i++) {
+    const child = node.childNodes[i];
+
+    if (child.nodeType === doc.COMMENT_NODE) {
+      return child.data;
+    } else if (child.nodeType === doc.TEXT_NODE) {
+      continue;
+    } else if (
+      child.nodeType === doc.ELEMENT_NODE && node.localName !== "template"
+    ) {
+      const res = walk(doc, child);
+      if (res !== null) return res;
+    }
+  }
+  return null;
+}
+
+export async function assertNoPageComments(page: Page) {
+  const doc = parseHtml(await page.content());
+
+  // deno-lint-ignore no-explicit-any
+  const result = walk(doc, doc.body as any);
+
+  if (result !== null) {
+    console.log(prettyDom(doc));
+    throw new Error(
+      `Expected no HTML comments to be present, but found comment "${result}"`,
+    );
+  }
+}
+
+export function assertNoComments(doc: Document) {
+  // deno-lint-ignore no-explicit-any
+  const result = walk(doc, doc.body as any);
+
+  if (result !== null) {
+    console.log(prettyDom(doc));
+    throw new Error(
+      `Expected no HTML comments to be present, but found comment "${result}"`,
+    );
+  }
+}
+
+export function assertMetaContent(
+  doc: Document,
+  nameOrProperty: string,
+  expected: string,
+) {
+  let el = doc.querySelector(`meta[name="${nameOrProperty}"]`) as
+    | HTMLMetaElement
+    | null;
+
+  if (el === null) {
+    el = doc.querySelector(`meta[property="${nameOrProperty}"]`) as
+      | HTMLMetaElement
+      | null;
+  }
+
+  if (el === null) {
+    console.log(prettyDom(doc));
+    throw new Error(
+      `No <meta>-tag found with content "${expected}"`,
+    );
+  }
+  assertEquals(el.content, expected);
+}
diff --git a/tests/twind_test.ts b/tests/twind_test.ts
index 5db357af6af..9235859d950 100644
--- a/tests/twind_test.ts
+++ b/tests/twind_test.ts
@@ -1,7 +1,12 @@
 import { assert, assertEquals, assertMatch, delay, puppeteer } from "./deps.ts";
 
 import { cmpStringArray } from "./fixture_twind_hydrate/utils/utils.ts";
-import { startFreshServer, withFresh, withPageName } from "./test_utils.ts";
+import {
+  startFreshServer,
+  withFakeServe,
+  withFresh,
+  withPageName,
+} from "./test_utils.ts";
 
 /**
  * Start the server with the main file.
@@ -22,25 +27,16 @@ async function setUpServer(path: string) {
    * terminate server
    */
   const terminate = async () => {
-    await lines.cancel();
     await browser.close();
 
     serverProcess.kill("SIGKILL");
     await serverProcess.status;
 
-    // TextDecoder leaks, so close it manually.
-    const denoResourcesMap = new Map(
-      Object.entries(Deno.resources()).map(([rid, representation]) => {
-        return [representation, parseInt(rid)];
-      }),
-    );
-    const textDecoderRid = denoResourcesMap.get("textDecoder");
-    if (textDecoderRid != null) {
-      Deno.close(textDecoderRid);
-    }
+    // Drain the lines stream
+    for await (const _ of lines) { /* noop */ }
   };
 
-  return { page: page, terminate: terminate, address };
+  return { page: page, terminate, address };
 }
 
 /**
@@ -312,8 +308,6 @@ Deno.test({
       },
     );
   },
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
 
 Deno.test({
@@ -347,32 +341,26 @@ Deno.test({
       },
     );
   },
-  sanitizeOps: false,
-  sanitizeResources: false,
 });
 
 // Test for: https://github.com/denoland/fresh/issues/1655
-Deno.test({
-  name: "don't duplicate css class",
-  async fn() {
-    await withFresh(
-      "./tests/fixture_twind_app/main.ts",
-      async (address) => {
-        const res = await fetch(`${address}/app_class`);
-        assertEquals(res.status, 200);
-
-        // Don't use an HTML parser here which would de-duplicate the
-        // class names automatically
-        const html = await res.text();
-        assertMatch(html, /html class="bg-slate-800">/);
-        assertMatch(html, /head class="bg-slate-800">/);
-        assertMatch(html, /body class="bg-slate-800">/);
-      },
-    );
-  },
-  sanitizeOps: false,
-  sanitizeResources: false,
+Deno.test("don't duplicate css class", async () => {
+  await withFakeServe(
+    "./tests/fixture_twind_app/main.ts",
+    async (server) => {
+      const res = await server.get(`/app_class`);
+      assertEquals(res.status, 200);
+
+      // Don't use an HTML parser here which would de-duplicate the
+      // class names automatically
+      const html = await res.text();
+      assertMatch(html, /html class="bg-slate-800">/);
+      assertMatch(html, /head class="bg-slate-800">/);
+      assertMatch(html, /body class="bg-slate-800">/);
+    },
+  );
 });
+
 // Test for: https://github.com/denoland/fresh/issues/1655
 Deno.test("don't duplicate css class with twindV1", async () => {
   await withFresh(
diff --git a/tests/update_test.ts b/tests/update_test.ts
new file mode 100644
index 00000000000..b38aaa4813c
--- /dev/null
+++ b/tests/update_test.ts
@@ -0,0 +1,249 @@
+import * as path from "$std/path/mod.ts";
+import { DenoConfig } from "$fresh/server.ts";
+import { JSONC } from "../src/server/deps.ts";
+import {
+  assertEquals,
+  assertExists,
+  assertMatch,
+  assertRejects,
+  assertStringIncludes,
+  retry,
+} from "./deps.ts";
+
+async function updateAndVerify(cwd: string | URL, expected: RegExp) {
+  const cliProcess = new Deno.Command(Deno.execPath(), {
+    args: [
+      "run",
+      "-A",
+      path.join(Deno.cwd(), "update.ts"),
+      ".",
+    ],
+    cwd,
+    stdin: "null",
+    stdout: "piped",
+  });
+
+  const { code, stdout } = await cliProcess.output();
+  const output = new TextDecoder().decode(stdout);
+
+  assertMatch(
+    output,
+    expected,
+  );
+  assertEquals(code, 0);
+}
+
+async function initProject() {
+  const tmpDirName = await Deno.makeTempDir();
+
+  const cliProcess = new Deno.Command(Deno.execPath(), {
+    args: [
+      "run",
+      "-A",
+      path.join(Deno.cwd(), "init.ts"),
+      ".",
+    ],
+    cwd: tmpDirName,
+    stdin: "null",
+    stdout: "null",
+  });
+
+  await cliProcess.output();
+
+  return tmpDirName;
+}
+
+async function executeUpdateCommand(t: Deno.TestContext, tmpDirName: string) {
+  await t.step("execute update command", async () => {
+    await updateAndVerify(
+      tmpDirName,
+      /The manifest has been generated for \d+ routes and \d+ islands./,
+    );
+  });
+}
+
+Deno.test("fresh-update", async function fn(t) {
+  // Preparation
+  const tmpDirName = await initProject();
+  await executeUpdateCommand(t, tmpDirName);
+
+  await t.step("check deno.json", async () => {
+    const configPath = path.join(tmpDirName, "deno.json");
+    const json = JSONC.parse(await Deno.readTextFile(configPath)) as DenoConfig;
+
+    assertExists(json.tasks?.start, "Missing 'start' task");
+    assertExists(json.tasks?.build, "Missing 'build' task");
+    assertExists(json.tasks?.preview, "Missing 'preview' task");
+
+    assertEquals(json.lint?.rules?.tags, ["fresh", "recommended"]);
+    assertEquals(json.exclude, ["**/_fresh/*"]);
+  });
+
+  const comment = "// This is a test comment";
+  const regex = /("preact": "https:\/\/esm.sh\/preact@[\d.]+",\n)/;
+  const originalName = `${tmpDirName}/deno.json`;
+  const updatedName = `${originalName}c`;
+
+  await t.step("execute update command deno.jsonc support", async () => {
+    try {
+      Deno.renameSync(originalName, updatedName);
+      let denoJsonText = await Deno.readTextFile(updatedName);
+      denoJsonText = denoJsonText.replace(regex, `$1${comment}\n`);
+      await Deno.writeTextFile(updatedName, denoJsonText);
+      await updateAndVerify(
+        tmpDirName,
+        /The manifest has been generated for \d+ routes and \d+ islands./,
+      );
+    } finally {
+      let denoJsonText = await Deno.readTextFile(updatedName);
+      denoJsonText = denoJsonText.replace(new RegExp(`\n${comment}\n`), "\n");
+      await Deno.writeTextFile(updatedName, denoJsonText);
+      Deno.renameSync(updatedName, originalName);
+    }
+  });
+
+  await t.step("execute update command src dir", async () => {
+    const names = [
+      "components",
+      "islands",
+      "routes",
+      "static",
+      "dev.ts",
+      "main.ts",
+      "fresh.gen.ts",
+    ];
+    try {
+      Deno.mkdirSync(tmpDirName + "/src");
+      names.forEach((x) => {
+        Deno.renameSync(
+          path.join(tmpDirName, x),
+          path.join(tmpDirName, "src", x),
+        );
+      });
+      await updateAndVerify(
+        tmpDirName,
+        /The manifest has been generated for (?!0 routes and 0 islands)\d+ routes and \d+ islands./,
+      );
+    } finally {
+      names.forEach((x) => {
+        Deno.renameSync(
+          path.join(tmpDirName, "src", x),
+          path.join(tmpDirName, x),
+        );
+      });
+      Deno.removeSync(tmpDirName + "/src", { recursive: true });
+    }
+  });
+
+  await t.step("execute update command (no islands directory)", async () => {
+    await retry(() =>
+      Deno.remove(path.join(tmpDirName, "islands"), { recursive: true })
+    );
+    await updateAndVerify(
+      tmpDirName,
+      /The manifest has been generated for \d+ routes and 0 islands./,
+    );
+  });
+
+  await retry(() => Deno.remove(tmpDirName, { recursive: true }));
+});
+
+Deno.test("fresh-update add _app.tsx if not present", async function fn(t) {
+  // Preparation
+  const tmpDirName = await initProject();
+
+  const appTsx = path.join(tmpDirName, "routes", "_app.tsx");
+  await Deno.remove(appTsx);
+
+  await executeUpdateCommand(t, tmpDirName);
+
+  await t.step("add _app.tsx", async () => {
+    const raw = await Deno.readTextFile(appTsx);
+    assertStringIncludes(raw, "<html>", `<html>-tag not found in _app.tsx`);
+  });
+});
+
+Deno.test(
+  "fresh-update add _fresh to .gitignore if not present",
+  async function fn(t) {
+    // Preparation
+    const tmpDirName = await initProject();
+
+    const gitignore = path.join(tmpDirName, ".gitignore");
+    await Deno.writeTextFile(gitignore, ""); // clear .gitignore
+
+    await executeUpdateCommand(t, tmpDirName);
+
+    await t.step("append _fresh to .gitignore", async () => {
+      const raw = await Deno.readTextFile(gitignore);
+      assertStringIncludes(raw, "_fresh", "_fresh not found in .gitignore");
+    });
+  },
+);
+
+Deno.test(
+  "fresh-update do not add _fresh to .gitignore if already present",
+  async function fn(t) {
+    // Preparation
+    const tmpDirName = await initProject();
+
+    const gitignore = path.join(tmpDirName, ".gitignore");
+    await Deno.writeTextFile(gitignore, "_fresh");
+
+    await executeUpdateCommand(t, tmpDirName);
+
+    await t.step("do not append _fresh to .gitignore", async () => {
+      const raw = await Deno.readTextFile(gitignore);
+      // Count the number of times "_fresh" appears in .gitignore
+      const count = (raw.match(/_fresh/g) ?? []).length;
+      assertEquals(count, 1, "extra _fresh found in .gitignore");
+    });
+  },
+);
+
+Deno.test(
+  "fresh-update do not create a .gitignore if none exist",
+  async function fn(t) {
+    // Preparation
+    const tmpDirName = await initProject();
+
+    const gitignore = path.join(tmpDirName, ".gitignore");
+    await Deno.remove(gitignore);
+
+    await executeUpdateCommand(t, tmpDirName);
+
+    await t.step("do not create a .gitignore", async () => {
+      await assertRejects(
+        () => Deno.open(gitignore),
+        Deno.errors.NotFound,
+        undefined,
+        "found .gitignore",
+      );
+    });
+  },
+);
+
+Deno.test(
+  "fresh-update migrates old exclude to top level exclude",
+  async (t) => {
+    // Preparation
+    const tmpDirName = await initProject();
+    const denoJsonFile = path.join(tmpDirName, "deno.json");
+    const denoJson = JSON.parse(await Deno.readTextFile(denoJsonFile));
+    delete denoJson.exclude;
+    if (!denoJson.fmt) denoJson.fmt = {};
+    if (!denoJson.lint) denoJson.lint = {};
+    denoJson.fmt.exclude = ["_fresh"];
+    denoJson.lint.exclude = ["_fresh"];
+    await Deno.writeTextFile(denoJsonFile, JSON.stringify(denoJson, null, 2));
+
+    await executeUpdateCommand(t, tmpDirName);
+
+    const denoJsonAfter = JSON.parse(Deno.readTextFileSync(denoJsonFile));
+    assertEquals(denoJsonAfter.exclude, ["**/_fresh/*"]);
+    assertEquals(denoJsonAfter.lint, {
+      rules: { tags: ["fresh", "recommended"] },
+    });
+    assertEquals(denoJsonAfter.fmt, undefined);
+  },
+);
diff --git a/update.ts b/update.ts
index 6701c0f0a7f..a611d335a90 100644
--- a/update.ts
+++ b/update.ts
@@ -26,16 +26,21 @@ To upgrade a project in the current directory, run:
   fresh-update .
 
 USAGE:
-    fresh-update <DIRECTORY>
+    fresh-update [DIRECTORY]
 `;
 
 const flags = parse(Deno.args, {});
 
+let unresolvedDirectory = Deno.args[0];
 if (flags._.length !== 1) {
-  error(help);
+  const userInput = prompt("Project Directory", ".");
+  if (!userInput) {
+    error(help);
+  }
+
+  unresolvedDirectory = userInput;
 }
 
-const unresolvedDirectory = Deno.args[0];
 const resolvedDirectory = resolve(unresolvedDirectory);
 const srcDirectory = await findSrcDirectory("main.ts", resolvedDirectory);
 
@@ -51,7 +56,7 @@ if (!DENO_JSON_PATH) {
     `Neither deno.json nor deno.jsonc could be found in ${resolvedDirectory}`,
   );
 }
-let denoJsonText = await Deno.readTextFile(DENO_JSON_PATH);
+const denoJsonText = await Deno.readTextFile(DENO_JSON_PATH);
 const ext = extname(DENO_JSON_PATH);
 let denoJson;
 if (ext === ".json") {
@@ -87,22 +92,37 @@ if (!denoJson.lint.rules.tags.includes("fresh")) {
 if (!denoJson.lint.rules.tags.includes("recommended")) {
   denoJson.lint.rules.tags.push("recommended");
 }
-if (!denoJson.lint.exclude) {
-  denoJson.lint.exclude = [];
-}
-if (!denoJson.lint.exclude.includes("_fresh")) {
-  denoJson.lint.exclude.push("_fresh");
+
+// Remove old _fresh exclude where we added it separately to
+// "lint" and "fmt"
+const fmtExcludeIdx = denoJson?.fmt?.exclude?.indexOf("_fresh");
+if (fmtExcludeIdx > -1) {
+  denoJson.fmt.exclude.splice(fmtExcludeIdx, 1);
+  if (denoJson.fmt.exclude.length === 0) {
+    delete denoJson.fmt.exclude;
+  }
+  if (Object.keys(denoJson.fmt).length === 0) {
+    delete denoJson.fmt;
+  }
 }
 
-// Exclude _fresh dir from linting
-if (!denoJson.fmt) {
-  denoJson.fmt = {};
+const lintExcludeIdx = denoJson?.lint?.exclude?.indexOf("_fresh");
+if (lintExcludeIdx > -1) {
+  denoJson.lint.exclude.splice(lintExcludeIdx, 1);
+  if (denoJson.lint.exclude.length === 0) {
+    delete denoJson.lint.exclude;
+  }
+  if (Object.keys(denoJson.lint).length === 0) {
+    delete denoJson.lint;
+  }
 }
-if (!denoJson.fmt.exclude) {
-  denoJson.fmt.exclude = [];
+
+// Exclude _fresh dir from everything
+if (!denoJson.exclude) {
+  denoJson.exclude = [];
 }
-if (!denoJson.fmt.exclude.includes("_fresh")) {
-  denoJson.fmt.exclude.push("_fresh");
+if (!denoJson.exclude.includes("**/_fresh/*")) {
+  denoJson.exclude.push("**/_fresh/*");
 }
 
 if (!denoJson.tasks) {
@@ -119,8 +139,7 @@ freshImports(denoJson.imports);
 if (denoJson.imports["twind"]) {
   twindImports(denoJson.imports);
 }
-denoJsonText = JSON.stringify(denoJson, null, 2);
-await Deno.writeTextFile(DENO_JSON_PATH, denoJsonText);
+await writeFormattedJson(DENO_JSON_PATH, denoJson);
 
 // Code mod for classic JSX -> automatic JSX.
 const JSX_CODEMOD =
@@ -132,8 +151,7 @@ if (denoJson.compilerOptions?.jsx !== "react-jsx" && confirm(JSX_CODEMOD)) {
   denoJson.compilerOptions = denoJson.compilerOptions || {};
   denoJson.compilerOptions.jsx = "react-jsx";
   denoJson.compilerOptions.jsxImportSource = "preact";
-  denoJsonText = JSON.stringify(denoJson, null, 2);
-  await Deno.writeTextFile(DENO_JSON_PATH, denoJsonText);
+  await writeFormattedJson(DENO_JSON_PATH, denoJson);
 
   const project = new Project();
   const sfs = project.addSourceFilesAtPaths(
@@ -174,8 +192,7 @@ if (denoJson.imports["@twind"] && confirm(TWIND_CODEMOD)) {
   await Deno.remove(join(resolvedDirectory, denoJson.imports["@twind"]));
 
   delete denoJson.imports["@twind"];
-  denoJson = JSON.stringify(denoJson, null, 2);
-  await Deno.writeTextFile(DENO_JSON_PATH, denoJson);
+  await writeFormattedJson(DENO_JSON_PATH, denoJson);
 
   const MAIN_TS = `/// <reference no-default-lib="true" />
 /// <reference lib="dom" />
@@ -267,7 +284,7 @@ export default function App({ Component }: AppProps) {
   return (
     <html>
       <head>
-        <meta charSet="utf-8" />
+        <meta charset="utf-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>${basename(resolvedDirectory)}</title>
       </head>
@@ -310,3 +327,19 @@ async function findSrcDirectory(
   }
   return resolvedDirectory;
 }
+
+async function writeFormattedJson(
+  denoJsonPath: string,
+  // deno-lint-ignore no-explicit-any
+  denoJson: any,
+): Promise<void> {
+  const denoJsonText = JSON.stringify(denoJson);
+  await Deno.writeTextFile(denoJsonPath, denoJsonText);
+  const command = new Deno.Command(Deno.execPath(), {
+    args: [
+      "fmt",
+      denoJsonPath,
+    ],
+  });
+  await command.output();
+}
diff --git a/versions.json b/versions.json
index 681663d4002..a54152b88b7 100644
--- a/versions.json
+++ b/versions.json
@@ -1,4 +1,5 @@
 [
+  "1.5.0",
   "1.4.3",
   "1.4.2",
   "1.4.1",
diff --git a/www/components/DocsSidebar.tsx b/www/components/DocsSidebar.tsx
index 4583496d17d..b167ff20d05 100644
--- a/www/components/DocsSidebar.tsx
+++ b/www/components/DocsSidebar.tsx
@@ -9,7 +9,6 @@ import { type VersionLink } from "../routes/docs/[...slug].tsx";
 
 export default function DocsSidebar(
   props: {
-    path: string;
     mobile?: boolean;
     versionLinks: VersionLink[];
     selectedVersion: string;
@@ -63,33 +62,30 @@ export default function DocsSidebar(
 
       <ul class="list-inside font-semibold nested ml-2.5">
         {CATEGORIES[props.selectedVersion].map((category) => (
-          <SidebarCategory path={props.path} category={category} />
+          <SidebarCategory key={category.href} category={category} />
         ))}
       </ul>
     </>
   );
 }
 
-const link = "text(gray-900 hover:gray-600)";
-const linkActive = "text-green-700 hover:underline font-bold";
-
 export function SidebarCategory(props: {
-  path: string;
   category: TableOfContentsCategory;
 }) {
   const { title, href, entries } = props.category;
 
-  const outerLink = `${href == props.path ? linkActive : link} font-bold`;
-
   return (
     <li class="my-2 block">
-      <a href={href} class={outerLink}>
+      <a
+        href={href}
+        class="text(gray-900 hover:gray-600) [data-current]:text-green-700 [data-current]:hover:underline font-bold"
+      >
         {title}
       </a>
       {entries.length > 0 && (
-        <ul class="py-2 pl-4 nested list-outside">
+        <ul class="py-2 nested list-outside">
           {entries.map((entry) => (
-            <SidebarEntry path={props.path} entry={entry} />
+            <SidebarEntry key={entry.href} entry={entry} />
           ))}
         </ul>
       )}
@@ -98,18 +94,18 @@ export function SidebarCategory(props: {
 }
 
 export function SidebarEntry(props: {
-  path: string;
   entry: TableOfContentsCategoryEntry;
 }) {
   const { title, href } = props.entry;
 
-  const innerLink = `${
-    href == props.path ? linkActive : link
-  } transition-colors hover:text-green-500 font-normal`;
-
   return (
-    <li class="py-0.5">
-      <a href={href} class={innerLink}>{title}</a>
+    <li class="py-[1px]">
+      <a
+        href={href}
+        class="[data-current]:text-green-700 [data-current]:border-green-600 [data-current]:bg-green-50 border-l-4 border-transparent px-4 py-0.5 transition-colors hover:text-green-500 font-normal block"
+      >
+        {title}
+      </a>
     </li>
   );
 }
diff --git a/www/components/NavigationBar.tsx b/www/components/NavigationBar.tsx
index 8104684c531..9567dcf5f7e 100644
--- a/www/components/NavigationBar.tsx
+++ b/www/components/NavigationBar.tsx
@@ -24,16 +24,14 @@ export default function NavigationBar(
   const isHome = props.active == "/";
   return (
     <nav class={"flex " + props.class ?? ""}>
-      <ul class="flex justify-center items-center gap-4 mx-4 my-6 flex-wrap">
+      <ul class="flex justify-center items-center gap-2 sm:gap-4 mx-4 my-2 sm:my-6 flex-wrap">
         {items.map((item) => (
           <li>
             <a
               href={item.href}
-              class={`p-2 ${
+              class={`p-1 sm:p-2 ${
                 isHome ? "text-green-900" : "text-gray-600"
-              } hover:underline ${
-                props.active == item.href ? "font-bold" : ""
-              }`}
+              } hover:underline [data-current]:font-bold [data-ancestor]:font-bold`}
             >
               {item.name}
             </a>
diff --git a/www/components/gallery/Header.tsx b/www/components/gallery/Header.tsx
index b9927d805bb..efb35f816eb 100644
--- a/www/components/gallery/Header.tsx
+++ b/www/components/gallery/Header.tsx
@@ -15,7 +15,7 @@ export default function Header({ active }: Props) {
     <div class="bg-white w-full max-w-screen-lg py-6 px-8 flex flex-col md:flex-row gap-4">
       <div class="flex items-center flex-1">
         <LemonIcon aria-hidden="true" />
-        <div class="text-2xl  ml-1 font-bold">
+        <div class="text-2xl ml-1 font-bold">
           Fresh
         </div>
       </div>
diff --git a/www/data/showcase.json b/www/data/showcase.json
index 382f43dbe8c..a2443f77d96 100644
--- a/www/data/showcase.json
+++ b/www/data/showcase.json
@@ -37,7 +37,7 @@
   },
   {
     "title": "Video Poker Academy",
-    "link": "https://videopoker.academy/",
+    "link": "https://videopoker-academy.deno.dev/",
     "github": "hyprtxt/videopoker.academy",
     "image": "videopoker-academy"
   },
@@ -362,6 +362,29 @@
     "link": "https://over-ip.dragon-vi.be",
     "image": "over-ip"
   },
+  {
+    "title": "Miguel Rangel Site",
+    "link": "https://crawford.ml",
+    "github": "denyncrawford/new-portfolio",
+    "image": "miguel-rangel-site"
+  },
+  {
+    "title": "Deno Artwork",
+    "link": "https://artwork.deno.dev/",
+    "github": "jasonjgardner/deno-artwork",
+    "image": "deno-artwork"
+  },
+  {
+    "title": "FilterHN",
+    "link": "https://filterhn.com/",
+    "image": "filter-hn"
+  },
+  {
+    "title": "AquaVibes",
+    "link": "https://aquavibes.earth/",
+    "github": "arturolume/aquavibes",
+    "image": "aquavibes"
+  },
   {
     "title": "Do not remove this, it’s for preventing conflicts by trailing comma",
     "link": "",
diff --git a/www/deno.json b/www/deno.json
index 42dd6070c05..9ccf6686304 100644
--- a/www/deno.json
+++ b/www/deno.json
@@ -1,7 +1,7 @@
 {
   "lock": false,
   "tasks": {
-    "start": "deno run -A --watch=static/,routes/ dev.ts",
+    "start": "deno run -A --watch=static/,routes/,../src dev.ts",
     "build": "deno run -A dev.ts build",
     "preview": "deno run -A main.ts"
   },
diff --git a/www/fresh.config.ts b/www/fresh.config.ts
index 4b076dd4af3..67aa3598fdf 100644
--- a/www/fresh.config.ts
+++ b/www/fresh.config.ts
@@ -3,5 +3,8 @@ import twindConfig from "./twind.config.ts";
 import { defineConfig } from "$fresh/server.ts";
 
 export default defineConfig({
+  build: {
+    target: "safari12",
+  },
   plugins: [twindPlugin(twindConfig)],
 });
diff --git a/www/main_test.ts b/www/main_test.ts
index c4f87b9c549..dac566d2412 100644
--- a/www/main_test.ts
+++ b/www/main_test.ts
@@ -1,32 +1,23 @@
 import { assertArrayIncludes, assertEquals } from "$std/testing/asserts.ts";
-import { delay } from "$std/async/delay.ts";
-import { startFreshServer, withPageName } from "../tests/test_utils.ts";
+import { withPageName } from "../tests/test_utils.ts";
 import { dirname, join } from "$std/path/mod.ts";
 import VERSIONS from "../versions.json" assert { type: "json" };
+import { createHandler } from "../server.ts";
+import manifest from "./fresh.gen.ts";
+import config from "./fresh.config.ts";
 
 const dir = dirname(import.meta.url);
+const handler = await createHandler(manifest, config);
 
-Deno.test("CORS should not set on GET /fresh-badge.svg", {
-  sanitizeResources: false,
-}, async () => {
-  const { serverProcess, lines, address } = await startFreshServer({
-    args: ["run", "-A", join(dir, "./main.ts")],
-  });
-
-  const res = await fetch(`${address}/fresh-badge.svg`);
-  await res.body?.cancel();
-
-  assertEquals(res.headers.get("cross-origin-resource-policy"), null);
+Deno.test("CORS should not set on GET /fresh-badge.svg", async () => {
+  const req = new Request("http://localhost/fresh-badge.svg");
+  const resp = await handler(req);
+  await resp?.body?.cancel();
 
-  await lines.cancel();
-  serverProcess.kill("SIGTERM");
-  // await for the server to close
-  await delay(100);
+  assertEquals(resp.headers.get("cross-origin-resource-policy"), null);
 });
 
-Deno.test("shows version selector", {
-  sanitizeResources: false,
-}, async () => {
+Deno.test("shows version selector", async () => {
   await withPageName(join(dir, "./main.ts"), async (page, address) => {
     await page.goto(`${address}/docs`);
     await page.waitForSelector("#version");
diff --git a/www/routes/docs/[...slug].tsx b/www/routes/docs/[...slug].tsx
index d70ffad9a4f..9432618b4c6 100644
--- a/www/routes/docs/[...slug].tsx
+++ b/www/routes/docs/[...slug].tsx
@@ -1,5 +1,5 @@
 import { Handlers, PageProps } from "$fresh/server.ts";
-import { asset, Head } from "$fresh/runtime.ts";
+import { asset, Head, Partial } from "$fresh/runtime.ts";
 import DocsSidebar from "../../components/DocsSidebar.tsx";
 import DocsTitle from "../../components/DocsTitle.tsx";
 import Footer from "../../components/Footer.tsx";
@@ -155,23 +155,23 @@ export default function DocsPage(props: PageProps<Data>) {
         <meta property="og:image" content={ogImageUrl} />
         <meta name="view-transition" content="same-origin" />
       </Head>
-      <div class="flex flex-col min-h-screen">
+      <div class="flex flex-col min-h-screen" f-client-nav>
         <Header title="docs" active="/docs" />
-        <Main path={props.url.pathname} page={props.data.page} />
+        <Main page={props.data.page} />
         <Footer />
       </div>
     </>
   );
 }
 
-function Main(props: { path: string; page: Page }) {
+function Main(props: { page: Page }) {
   return (
     <div class="flex-1">
-      <MobileSidebar path={props.path} page={props.page} />
-      <div class="flex mx-auto max-w-screen-xl px-4 md:px-0 py-5 md:py-0 justify-end">
+      <MobileSidebar page={props.page} />
+      <div class="flex mx-auto max-w-screen-xl px-4 md:px-0 md:py-0 justify-end bg-gray-100">
         <label
           for="docs_sidebar"
-          class="px-4 py-3 md:hidden flex items-center hover:bg-gray-100 rounded gap-2"
+          class="px-4 py-3 md:hidden flex items-center hover:bg-gray-100 rounded gap-2 cursor-pointer"
         >
           <svg
             class="h-6 w-6"
@@ -187,18 +187,20 @@ function Main(props: { path: string; page: Page }) {
             >
             </path>
           </svg>
-          <div>Menu</div>
+          <div>Table of Contents</div>
         </label>
       </div>
-      <div class="mx-auto max-w-screen-xl px-4 flex gap-6 md:gap-8">
-        <DesktopSidebar path={props.path} page={props.page} />
-        <Content page={props.page} />
+      <div class="mx-auto max-w-screen-xl flex gap-6 md:gap-8">
+        <DesktopSidebar page={props.page} />
+        <Partial name="docs-main">
+          <Content page={props.page} />
+        </Partial>
       </div>
     </div>
   );
 }
 
-function MobileSidebar(props: { path: string; page: Page }) {
+function MobileSidebar(props: { page: Page }) {
   return (
     <>
       <input
@@ -220,7 +222,6 @@ function MobileSidebar(props: { path: string; page: Page }) {
           <nav class="pt-6 pb-16 px-4 overflow-x-auto">
             <DocsSidebar
               mobile
-              path={props.path}
               versionLinks={props.page.versionLinks}
               selectedVersion={props.page.version}
             />
@@ -231,11 +232,10 @@ function MobileSidebar(props: { path: string; page: Page }) {
   );
 }
 
-function DesktopSidebar(props: { path: string; page: Page }) {
+function DesktopSidebar(props: { page: Page }) {
   return (
-    <nav class="w-[18rem] flex-shrink-0 hidden md:block py-7 pr-8">
+    <nav class="w-[18rem] flex-shrink-0 hidden md:block py-7 px-4">
       <DocsSidebar
-        path={props.path}
         versionLinks={props.page.versionLinks}
         selectedVersion={props.page.version}
       />
@@ -246,8 +246,8 @@ function DesktopSidebar(props: { path: string; page: Page }) {
 function Content(props: { page: Page }) {
   const html = renderMarkdown(props.page.markdown);
   return (
-    <main class="py-6 overflow-hidden md:mr-4 lg:mr-32">
-      <h1 class="text(4xl gray-900) tracking-tight font-extrabold mt-6 md:mt-0">
+    <main class="py-6 md:mr-4 lg:mr-32 min-w-0">
+      <h1 class="text(4xl gray-900) tracking-tight font-extrabold md:mt-0 px-4">
         {props.page.title}
       </h1>
       <div
@@ -278,7 +278,7 @@ function ForwardBackButtons(props: {
   const lower = "text-gray-900 font-medium";
 
   return (
-    <div class="mt-8 flex flex(col md:row) gap-4">
+    <div class="px-4 mt-8 flex flex(col md:row) gap-4">
       {prev && (
         <a href={prev.href} class={`${button} text-left`}>
           <span class={upper}>{"←"} Previous</span>
diff --git a/www/routes/gfm.css.ts b/www/routes/gfm.css.ts
index 18555fa6c9c..e35e4a6568e 100644
--- a/www/routes/gfm.css.ts
+++ b/www/routes/gfm.css.ts
@@ -18,6 +18,92 @@ function css(template: TemplateStringsArray, ...params: string[]) {
 
 const CSS = css`${gfm.CSS}
 
+.markdown-body h1,
+.markdown-body h2,
+.markdown-body h3,
+.markdown-body h4,
+.markdown-body h5,
+.markdown-body h6,
+.markdown-body ul,
+.markdown-body ol,
+.markdown-body p,
+.markdown-body details,
+.markdown-body blockquote {
+  margin-left: 1rem;
+  margin-right: 1rem;
+}
+
+.markdown-body blockquote p {
+  margin-left: 0
+}
+
+.markdown-body .admonition {
+  padding: 1rem;
+}
+.markdown-body .admonition-header {
+  font-weight: bold;
+  display: flex;
+  align-items: center;
+  font-size: 1rem;
+  padding-bottom: .5rem;
+}
+.markdown-body .admonition .icon {
+  display: inline-flex;
+  margin-right: .25rem;
+  width: 1.2em;
+  height: 1.2em;
+}
+.markdown-body blockquote.warn {
+  border-color: #ff9100;
+  background: #F0900525;
+}
+
+.markdown-body .admonition .fenced-code {
+  margin-left: 0;
+  margin-right: 0;
+  border: 1px solid #d9d2d2;
+  border-radius: .5rem .5rem .25rem .25rem;
+}
+
+.markdown-body .admonition .highlight {
+  margin-bottom: 0;
+}
+
+.markdown-body .admonition.tip .admonition-header {
+  color: rgb(0, 148, 0);
+}
+.markdown-body .admonition.tip {
+  background-color: rgb(230, 246, 230);
+  border-color: rgb(0, 148, 0);
+}
+.markdown-body .admonition.info .admonition-header {
+  color: rgb(25 146 184);
+}
+.markdown-body .admonition.info {
+  background-color: rgb(238, 249, 253);
+  border-color: rgb(25 146 184);
+}
+.markdown-body .admonition.warn .admonition-header {
+  color: #dd6f04;
+}
+.markdown-body .admonition.warn {
+  background-color: #F0900525;
+  border-color: #ff9100;
+}
+
+@media screen and (min-width: 768px) {
+  .markdown-body .fenced-code,
+  .markdown-body table {
+    margin-left: 1rem;
+    margin-right: 1rem;
+  }
+
+  .markdown-body details .fenced-code {
+    margin-left: 0;
+    margin-right: 0;
+  }
+}
+
 ol.nested {
 	counter-reset: item;
 }
@@ -43,6 +129,22 @@ ol.nested li:before {
   list-style: numeric;
 }
 
+.markdown-body .md-anchor {
+  color: inherit;
+  text-decoration: none !important;
+}
+.markdown-body .md-anchor span {
+  color: var(--color-accent-fg);
+  display: inline-block;
+  margin-left: .25rem;
+  opacity: 0;
+  visibility: hidden;
+}
+.markdown-body .md-anchor:hover span {
+  opacity: 1;
+  visibility: visible;
+}
+
 .markdown-body .highlight {
   border: 1px solid #eaeef1;
   border-radius: .5rem;
@@ -53,7 +155,7 @@ ol.nested li:before {
 }
 
 .fenced-code {
-  margin-bottom: 1rem;
+  margin-bottom: 1rem; 
 }
 .fenced-code pre {
   margin-bottom: 0;
diff --git a/www/static/docs/fresh-partial-docs.png b/www/static/docs/fresh-partial-docs.png
new file mode 100644
index 00000000000..5d0fe941cc2
Binary files /dev/null and b/www/static/docs/fresh-partial-docs.png differ
diff --git a/www/static/icons.svg b/www/static/icons.svg
new file mode 100644
index 00000000000..18a2e474a71
--- /dev/null
+++ b/www/static/icons.svg
@@ -0,0 +1,26 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <symbol id="tip" viewBox="0 0 24 24">
+    <g stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
+      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
+      <path d="M3 12h1m8 -9v1m8 8h1m-15.4 -6.4l.7 .7m12.1 -.7l-.7 .7" />
+      <path d="M9 16a5 5 0 1 1 6 0a3.5 3.5 0 0 0 -1 3a2 2 0 0 1 -4 0a3.5 3.5 0 0 0 -1 -3" />
+      <path d="M9.7 17l4.6 0" />
+    </g>
+  </symbol>
+
+  <symbol id="info" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
+    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
+    <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" />
+    <path d="M12 9h.01" />
+    <path d="M11 12h1v4h1" />
+  </symbol>
+
+  <symbol id="warn" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
+    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
+    <path d="M12 9v4" />
+    <path d="M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z" />
+    <path d="M12 16h.01" />
+  </symbol>
+</svg>
+
+
diff --git a/www/static/showcase/deno-artwork1x.jpg b/www/static/showcase/deno-artwork1x.jpg
new file mode 100644
index 00000000000..14b0d963250
Binary files /dev/null and b/www/static/showcase/deno-artwork1x.jpg differ
diff --git a/www/static/showcase/deno-artwork2x.jpg b/www/static/showcase/deno-artwork2x.jpg
new file mode 100644
index 00000000000..fea991f8979
Binary files /dev/null and b/www/static/showcase/deno-artwork2x.jpg differ
diff --git a/www/static/showcase/miguel-rangel-site1x.jpg b/www/static/showcase/miguel-rangel-site1x.jpg
new file mode 100644
index 00000000000..eda7b75f7d5
Binary files /dev/null and b/www/static/showcase/miguel-rangel-site1x.jpg differ
diff --git a/www/static/showcase/miguel-rangel-site2x.jpg b/www/static/showcase/miguel-rangel-site2x.jpg
new file mode 100644
index 00000000000..07a2a914c08
Binary files /dev/null and b/www/static/showcase/miguel-rangel-site2x.jpg differ
diff --git a/www/utils/markdown.ts b/www/utils/markdown.ts
index 215b239f256..64f587049c6 100644
--- a/www/utils/markdown.ts
+++ b/www/utils/markdown.ts
@@ -16,6 +16,8 @@ import { mangle } from "$marked-mangle";
 
 Marked.marked.use(mangle());
 
+const ADMISSION_REG = /^<p>\[(info|warn|tip)\]:\s/;
+
 class DefaultRenderer extends Marked.Renderer {
   text(text: string): string {
     // Smartypants typography enhancement
@@ -38,7 +40,7 @@ class DefaultRenderer extends Marked.Renderer {
     slugger: Marked.Slugger,
   ): string {
     const slug = slugger.slug(raw);
-    return `<h${level} id="${slug}"><a class="anchor" aria-hidden="true" tabindex="-1" href="#${slug}">#</a>${text}</h${level}>`;
+    return `<h${level} id="${slug}"><a class="md-anchor" tabindex="-1" href="#${slug}">${text}<span aria-hidden="true">#</span></a></h${level}>`;
   }
 
   link(href: string, title: string | null, text: string) {
@@ -91,12 +93,30 @@ class DefaultRenderer extends Marked.Renderer {
     } else {
       const html = Prism.highlight(code, grammar, lang);
       out +=
-        `<pre class="highlight highlight-source-${lang} notranslate lang-${lang}">${html}</pre>`;
+        `<pre class="highlight highlight-source-${lang} notranslate lang-${lang}"><code>${html}</code></pre>`;
     }
 
     out += `</div>`;
     return out;
   }
+
+  blockquote(quote: string): string {
+    const match = quote.match(ADMISSION_REG);
+    if (match) {
+      const label: Record<string, string> = {
+        tip: "Tip",
+        warn: "Warning",
+        info: "Info",
+      };
+      const type = match[1];
+      quote = quote.slice(match[0].length);
+      const icon = `<svg class="icon"><use href="/icons.svg#${type}" /></svg>`;
+      return `<blockquote class="admonition ${type}">\n<span class="admonition-header">${icon}${
+        label[type]
+      }</span>${quote}</blockquote>\n`;
+    }
+    return `<blockquote>\n${quote}</blockquote>\n`;
+  }
 }
 
 export interface MarkdownOptions {
