diff --git a/Dockerfile b/Dockerfile
index 7e2a164c..c8bdcc24 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,4 +1,4 @@
-FROM hayd/alpine-deno:1.9.0
+FROM denoland/deno:alpine-1.11.0
 WORKDIR /app
 
 # Install wait utility
@@ -6,16 +6,20 @@ USER root
 ADD https://github.com/ufoscout/docker-compose-wait/releases/download/2.8.0/wait /wait
 RUN chmod +x /wait
 
-# Cache external libraries
 USER deno
-ADD . .
+
+# Cache external libraries
 # Test deps caches all main dependencies as well
+COPY tests/test_deps.ts tests/test_deps.ts
+COPY deps.ts deps.ts
 RUN deno cache tests/test_deps.ts
 
+ADD . .
+RUN deno cache mod.ts
+
 # Code health checks
-RUN deno lint --unstable
+RUN deno lint
 RUN deno fmt --check
 
 # Run tests
 CMD /wait && deno test --unstable -A
-
diff --git a/README.md b/README.md
index 0a09ea33..1ef8cee9 100644
--- a/README.md
+++ b/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 [![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)](https://deno-postgres.com)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.11.3/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.12.0/mod.ts)
 [![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)](LICENSE)
 
 A lightweight PostgreSQL driver for Deno focused on user experience
@@ -56,7 +56,7 @@ For more examples visit the documentation available at
 
 ## Why do I need unstable to connect using TLS?
 
-Sadly, stablishing a TLS connection in the way Postgres requires it isn't
+Sadly, establishing a TLS connection in the way Postgres requires it isn't
 possible without the `Deno.startTls` API, which is currently marked as unstable.
 This is a situation that will be solved once this API is stabilized, however I
 don't have an estimated time of when that might happen.
@@ -105,7 +105,7 @@ It is recommended that you don't rely on any previously initialized data for
 your tests, instead of that create all the data you need at the moment of
 running the tests
 
-For example, the following test will create a temporal table that will dissapear
+For example, the following test will create a temporal table that will disappear
 once the test has been completed
 
 ```ts
@@ -124,6 +124,23 @@ Deno.test("INSERT works correctly", async () => {
 });
 ```
 
+### Setting up an advanced development environment
+
+More advanced features such as the Deno inspector, test filtering, database
+inspection and permission filtering can be achieved by setting up a local
+testing environment, as shown in the following steps:
+
+1. Start the development databases using the Docker service with the command\
+   `docker-compose up postgres postgres_scram postgres_invalid_tls`\
+   Though using the detach (`-d`) option is recommended, this will make the
+   databases run in the background unless you use docker itself to stop them.
+   You can find more info about this
+   [here](https://docs.docker.com/compose/reference/up)
+2. Run the tests manually by using the command\
+   `DEVELOPMENT=true deno test --unstable -A`\
+   The `DEVELOPMENT` variable will tell the testing pipeline to use the local
+   testing settings specified in `tests/config.json`
+
 ## Deno compatibility
 
 Due to a not intended breaking change in Deno 1.9.0, two versions of
@@ -135,7 +152,8 @@ above indicating possible compatibility problems
 | ------------ | ------------------ | ------------------ |
 | 1.8.x        | 0.5.0              | 0.10.0             |
 | 1.9.0        | 0.11.0             | 0.11.1             |
-| 1.9.1 and up | 0.11.2             |                    |
+| 1.9.1 and up | 0.11.2             | 0.11.3             |
+| 1.11.x       | 0.12.0             |                    |
 
 ## Contributing guidelines
 
@@ -146,7 +164,7 @@ When contributing to repository make sure to:
    explaining their usage
 3. All code must pass the format and lint checks enforced by `deno fmt` and
    `deno lint --unstable` respectively. The build will not pass the tests if
-   this conditions are not met. Ignore rules will be accepted in the code base
+   these conditions are not met. Ignore rules will be accepted in the code base
    when their respective justification is given in a comment
 4. All features and fixes must have a corresponding test added in order to be
    accepted
@@ -156,7 +174,7 @@ When contributing to repository make sure to:
 There are substantial parts of this library based on other libraries. They have
 preserved their individual licenses and copyrights.
 
-Eveything is licensed under the MIT License.
+Everything is licensed under the MIT License.
 
 All additional work is copyright 2018 - 2021 — Bartłomiej Iwańczuk and Steven
 Guerrero — All rights reserved.
diff --git a/client.ts b/client.ts
index e3c7ce59..8bb53a74 100644
--- a/client.ts
+++ b/client.ts
@@ -1,6 +1,8 @@
+// deno-lint-ignore-file camelcase
 import { Connection } from "./connection/connection.ts";
 import {
-  ConnectionOptions,
+  ClientConfiguration,
+  ClientOptions,
   ConnectionString,
   createParams,
 } from "./connection/connection_params.ts";
@@ -16,49 +18,76 @@ import {
   templateStringToQuery,
 } from "./query/query.ts";
 import { Transaction, TransactionOptions } from "./query/transaction.ts";
-import { isTemplateString } from "./utils.ts";
+import { isTemplateString } from "./utils/utils.ts";
+
+export interface Session {
+  /**
+   * This is the code for the transaction currently locking the connection.
+   * If there is no transaction ongoing, the transaction code will be null
+   */
+  current_transaction: string | null;
+  /**
+   * This is the process id of the current session as assigned by the database
+   * on connection. This id will undefined when there is no connection stablished
+   */
+  pid: number | undefined;
+}
 
 export abstract class QueryClient {
-  protected connection: Connection;
-  protected transaction: string | null = null;
+  #connection: Connection;
+  #terminated = false;
+  #transaction: string | null = null;
 
   constructor(connection: Connection) {
-    this.connection = connection;
+    this.#connection = connection;
   }
 
-  get current_transaction(): string | null {
-    return this.transaction;
+  // TODO
+  // Add comment about reconnection attempts
+  get connected() {
+    return this.#connection.connected;
   }
 
-  protected executeQuery<T extends Array<unknown>>(
-    query: Query<ResultType.ARRAY>,
-  ): Promise<QueryArrayResult<T>>;
-  protected executeQuery<T>(
-    query: Query<ResultType.OBJECT>,
-  ): Promise<QueryObjectResult<T>>;
-  protected executeQuery(
-    query: Query<ResultType>,
-  ): Promise<QueryResult> {
-    return this.connection.query(query);
+  get session(): Session {
+    return {
+      current_transaction: this.#transaction,
+      pid: this.#connection.pid,
+    };
+  }
+
+  #assertOpenConnection() {
+    if (this.#terminated) {
+      throw new Error(
+        "Connection to the database has been terminated",
+      );
+    }
+  }
+
+  protected async closeConnection() {
+    if (this.connected) {
+      await this.#connection.end();
+    }
+
+    this.resetSessionMetadata();
   }
 
   /**
    * Transactions are a powerful feature that guarantees safe operations by allowing you to control
    * the outcome of a series of statements and undo, reset, and step back said operations to
    * your liking
-   * 
+   *
    * In order to create a transaction, use the `createTransaction` method in your client as follows:
-   * 
+   *
    * ```ts
    * const transaction = client.createTransaction("my_transaction_name");
    * await transaction.begin();
    * // All statements between begin and commit will happen inside the transaction
    * await transaction.commit(); // All changes are saved
    * ```
-   * 
+   *
    * All statements that fail in query execution will cause the current transaction to abort and release
    * the client without applying any of the changes that took place inside it
-   * 
+   *
    * ```ts
    * await transaction.begin();
    * await transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES ${"some_value"}`;
@@ -68,10 +97,10 @@ export abstract class QueryClient {
    *   await transaction.commit(); // Will throw, current transaction has already finished
    * }
    * ```
-   * 
+   *
    * This however, only happens if the error is of execution in nature, validation errors won't abort
    * the transaction
-   * 
+   *
    * ```ts
    * await transaction.begin();
    * await transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES ${"some_value"}`;
@@ -81,86 +110,121 @@ export abstract class QueryClient {
    *   await transaction.commit(); // Transaction will end, changes will be saved
    * }
    * ```
-   * 
+   *
    * A transaction has many options to ensure modifications made to the database are safe and
    * have the expected outcome, which is a hard thing to accomplish in a database with many concurrent users,
    * and it does so by allowing you to set local levels of isolation to the transaction you are about to begin
-   * 
+   *
    * Each transaction can execute with the following levels of isolation:
-   * 
+   *
    * - Read committed: This is the normal behavior of a transaction. External changes to the database
    *   will be visible inside the transaction once they are committed.
-   * 
+   *
    * - Repeatable read: This isolates the transaction in a way that any external changes to the data we are reading
    *   won't be visible inside the transaction until it has finished
    *   ```ts
    *   const transaction = await client.createTransaction("my_transaction", { isolation_level: "repeatable_read" });
    *   ```
-   * 
+   *
    * - Serializable: This isolation level prevents the current transaction from making persistent changes
    *   if the data they were reading at the beginning of the transaction has been modified (recommended)
    *   ```ts
    *   const transaction = await client.createTransaction("my_transaction", { isolation_level: "serializable" });
    *   ```
-   * 
+   *
    * Additionally, each transaction allows you to set two levels of access to the data:
-   * 
+   *
    * - Read write: This is the default mode, it allows you to execute all commands you have access to normally
-   * 
+   *
    * - Read only: Disables all commands that can make changes to the database. Main use for the read only mode
    *   is to in conjuction with the repeatable read isolation, ensuring the data you are reading does not change
    *   during the transaction, specially useful for data extraction
    *   ```ts
    *   const transaction = await client.createTransaction("my_transaction", { read_only: true });
    *   ```
-   * 
+   *
    * Last but not least, transactions allow you to share starting point snapshots between them.
    * For example, if you initialized a repeatable read transaction before a particularly sensible change
    * in the database, and you would like to start several transactions with that same before the change state
    * you can do the following:
-   * 
+   *
    * ```ts
    * const snapshot = await transaction_1.getSnapshot();
    * const transaction_2 = client_2.createTransaction("new_transaction", { isolation_level: "repeatable_read", snapshot });
    * // transaction_2 now shares the same starting state that transaction_1 had
    * ```
-   * 
+   *
    * https://www.postgresql.org/docs/13/tutorial-transactions.html
    * https://www.postgresql.org/docs/13/sql-set-transaction.html
    */
-
   createTransaction(name: string, options?: TransactionOptions): Transaction {
+    this.#assertOpenConnection();
+
     return new Transaction(
       name,
       options,
       this,
       // Bind context so function can be passed as is
-      this.executeQuery.bind(this),
+      this.#executeQuery.bind(this),
       (name: string | null) => {
-        this.transaction = name;
+        this.#transaction = name;
       },
     );
   }
 
+  /**
+   * Every client must initialize their connection previously to the
+   * execution of any statement
+   */
+  async connect(): Promise<void> {
+    if (!this.connected) {
+      await this.#connection.startup(false);
+      this.#terminated = false;
+    }
+  }
+
+  /**
+   * Closing your PostgreSQL connection will delete all non-persistent data
+   * that may have been created in the course of the session and will require
+   * you to reconnect in order to execute further queries
+   */
+  async end(): Promise<void> {
+    await this.closeConnection();
+
+    this.#terminated = true;
+  }
+
+  #executeQuery<T extends Array<unknown>>(
+    _query: Query<ResultType.ARRAY>,
+  ): Promise<QueryArrayResult<T>>;
+  #executeQuery<T>(
+    _query: Query<ResultType.OBJECT>,
+  ): Promise<QueryObjectResult<T>>;
+  #executeQuery(
+    query: Query<ResultType>,
+  ): Promise<QueryResult> {
+    return this.#connection.query(query);
+  }
+
   /**
    * This method allows executed queries to be retrieved as array entries.
    * It supports a generic interface in order to type the entries retrieved by the query
-   * 
+   *
    * ```ts
    * const {rows} = await my_client.queryArray(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<unknown[]>
    * ```
-   * 
+   *
    * You can pass type arguments to the query in order to hint TypeScript what the return value will be
    * ```ts
    * const {rows} = await my_client.queryArray<[number, string]>(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<[number, string]>
    * ```
-   * 
-   * It also allows you to execute prepared stamements with template strings
-   * 
+   *
+   * It also allows you to execute prepared statements with template strings
+   *
    * ```ts
    * const id = 12;
    * // Array<[number, string]>
@@ -179,13 +243,14 @@ export abstract class QueryClient {
     ...args: QueryArguments
   ): Promise<QueryArrayResult<T>>;
   queryArray<T extends Array<unknown> = Array<unknown>>(
-    // deno-lint-ignore camelcase
     query_template_or_config: TemplateStringsArray | string | QueryConfig,
     ...args: QueryArguments
   ): Promise<QueryArrayResult<T>> {
-    if (this.current_transaction !== null) {
+    this.#assertOpenConnection();
+
+    if (this.#transaction !== null) {
       throw new Error(
-        `This connection is currently locked by the "${this.current_transaction}" transaction`,
+        `This connection is currently locked by the "${this.#transaction}" transaction`,
       );
     }
 
@@ -202,43 +267,43 @@ export abstract class QueryClient {
       query = new Query(query_template_or_config, ResultType.ARRAY);
     }
 
-    return this.executeQuery(query);
+    return this.#executeQuery(query);
   }
 
   /**
    * This method allows executed queries to be retrieved as object entries.
    * It supports a generic interface in order to type the entries retrieved by the query
-   * 
+   *
    * ```ts
    * const {rows} = await my_client.queryObject(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Record<string, unknown>
-   * 
+   *
    * const {rows} = await my_client.queryObject<{id: number, name: string}>(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<{id: number, name: string}>
    * ```
-   * 
+   *
    * You can also map the expected results to object fields using the configuration interface.
    * This will be assigned in the order they were provided
-   * 
+   *
    * ```ts
    * const {rows} = await my_client.queryObject(
    *  "SELECT ID, NAME FROM CLIENTS"
    * );
-   * 
+   *
    * console.log(rows); // [{id: 78, name: "Frank"}, {id: 15, name: "Sarah"}]
-   * 
+   *
    * const {rows} = await my_client.queryObject({
    *  text: "SELECT ID, NAME FROM CLIENTS",
    *  fields: ["personal_id", "complete_name"],
    * });
-   * 
+   *
    * console.log(rows); // [{personal_id: 78, complete_name: "Frank"}, {personal_id: 15, complete_name: "Sarah"}]
    * ```
-   * 
-   * It also allows you to execute prepared stamements with template strings
-   * 
+   *
+   * It also allows you to execute prepared statements with template strings
+   *
    * ```ts
    * const id = 12;
    * // Array<{id: number, name: string}>
@@ -259,16 +324,17 @@ export abstract class QueryClient {
   queryObject<
     T = Record<string, unknown>,
   >(
-    // deno-lint-ignore camelcase
     query_template_or_config:
       | string
       | QueryObjectConfig
       | TemplateStringsArray,
     ...args: QueryArguments
   ): Promise<QueryObjectResult<T>> {
-    if (this.current_transaction !== null) {
+    this.#assertOpenConnection();
+
+    if (this.#transaction !== null) {
       throw new Error(
-        `This connection is currently locked by the "${this.current_transaction}" transaction`,
+        `This connection is currently locked by the "${this.#transaction}" transaction`,
       );
     }
 
@@ -288,7 +354,11 @@ export abstract class QueryClient {
       );
     }
 
-    return this.executeQuery<T>(query);
+    return this.#executeQuery<T>(query);
+  }
+
+  protected resetSessionMetadata() {
+    this.#transaction = null;
   }
 }
 
@@ -297,17 +367,17 @@ export abstract class QueryClient {
 /**
  * Clients allow you to communicate with your PostgreSQL database and execute SQL
  * statements asynchronously
- * 
+ *
  * ```ts
  * const client = new Client(connection_parameters);
  * await client.connect();
  * await client.queryArray`UPDATE MY_TABLE SET MY_FIELD = 0`;
  * await client.end();
  * ```
- * 
+ *
  * A client will execute all their queries in a sequencial fashion,
  * for concurrency capabilities check out connection pools
- * 
+ *
  * ```ts
  * const client_1 = new Client(connection_parameters);
  * await client_1.connect();
@@ -315,50 +385,42 @@ export abstract class QueryClient {
  * // scheduled
  * client_1.queryArray`UPDATE MY_TABLE SET MY_FIELD = 0`;
  * client_1.queryArray`DELETE FROM MY_TABLE`;
- * 
+ *
  * const client_2 = new Client(connection_parameters);
  * await client_2.connect();
  * // `client_2` will execute it's queries in parallel to `client_1`
  * const {rows: result} = await client_2.queryArray`SELECT * FROM MY_TABLE`;
- * 
+ *
  * await client_1.end();
  * await client_2.end();
  * ```
  */
 export class Client extends QueryClient {
-  constructor(config?: ConnectionOptions | ConnectionString) {
-    super(new Connection(createParams(config)));
-  }
-
-  /**
-   * Every client must initialize their connection previously to the
-   * execution of any statement
-   */
-  async connect(): Promise<void> {
-    await this.connection.startup();
-  }
-
-  /**
-   * Ending a connection will close your PostgreSQL connection, and delete
-   * all non-persistent data that may have been created in the course of the
-   * session
-   */
-  async end(): Promise<void> {
-    await this.connection.end();
-    this.transaction = null;
+  constructor(config?: ClientOptions | ConnectionString) {
+    super(
+      new Connection(createParams(config), async () => {
+        await this.closeConnection();
+      }),
+    );
   }
 }
 
 export class PoolClient extends QueryClient {
   #release: () => void;
 
-  constructor(connection: Connection, releaseCallback: () => void) {
-    super(connection);
+  constructor(config: ClientConfiguration, releaseCallback: () => void) {
+    super(
+      new Connection(config, async () => {
+        await this.closeConnection();
+      }),
+    );
     this.#release = releaseCallback;
   }
 
-  async release(): Promise<void> {
-    await this.#release();
-    this.transaction = null;
+  release() {
+    this.#release();
+
+    // Cleanup all session related metadata
+    this.resetSessionMetadata();
   }
 }
diff --git a/connection/connection.ts b/connection/connection.ts
index 1d599013..dd3b4002 100644
--- a/connection/connection.ts
+++ b/connection/connection.ts
@@ -1,3 +1,5 @@
+// deno-lint-ignore-file camelcase
+
 /*!
  * Substantial parts adapted from https://github.com/brianc/node-postgres
  * which is licensed as follows:
@@ -27,25 +29,22 @@
  */
 
 import { bold, BufReader, BufWriter, yellow } from "../deps.ts";
-import { DeferredStack } from "./deferred.ts";
-import { hashMd5Password, readUInt32BE } from "../utils.ts";
-import { PacketReader } from "./packet_reader.ts";
+import { DeferredStack } from "../utils/deferred.ts";
+import { hashMd5Password, readUInt32BE } from "../utils/utils.ts";
 import { PacketWriter } from "./packet_writer.ts";
-import { parseError, parseNotice } from "./warning.ts";
+import { Message, parseError, parseNotice } from "./warning.ts";
 import {
   Query,
   QueryArrayResult,
   QueryObjectResult,
   QueryResult,
   ResultType,
+  RowDescription,
 } from "../query/query.ts";
-import type { ConnectionParams } from "./connection_params.ts";
+import { Column } from "../query/decode.ts";
+import type { ClientConfiguration } from "./connection_params.ts";
 import * as scram from "./scram.ts";
-
-export enum Format {
-  TEXT = 0,
-  BINARY = 1,
-}
+import { ConnectionError } from "./warning.ts";
 
 enum TransactionStatus {
   Idle = "I",
@@ -77,7 +76,6 @@ function assertSuccessfulStartup(msg: Message) {
   }
 }
 
-// deno-lint-ignore camelcase
 function assertSuccessfulAuthentication(auth_message: Message) {
   if (auth_message.type === "E") {
     throw parseError(auth_message);
@@ -109,51 +107,25 @@ function assertQueryResponse(msg: Message) {
   }
 }
 
-export class Message {
-  public reader: PacketReader;
-
-  constructor(
-    public type: string,
-    public byteCount: number,
-    public body: Uint8Array,
-  ) {
-    this.reader = new PacketReader(body);
-  }
-}
-
-export class Column {
-  constructor(
-    public name: string,
-    public tableOid: number,
-    public index: number,
-    public typeOid: number,
-    public columnLength: number,
-    public typeModifier: number,
-    public format: Format,
-  ) {}
-}
-
-export class RowDescription {
-  constructor(public columnCount: number, public columns: Column[]) {}
-}
-
 const decoder = new TextDecoder();
 const encoder = new TextEncoder();
 
-//TODO
-//Refactor properties to not be lazily initialized
-//or to handle their undefined value
+// TODO
+// - Refactor properties to not be lazily initialized
+//   or to handle their undefined value
+// - Expose connection PID as a method
+// - Cleanup properties on startup to guarantee safe reconnection
 export class Connection {
   #bufReader!: BufReader;
   #bufWriter!: BufWriter;
   #conn!: Deno.Conn;
   connected = false;
+  #connection_params: ClientConfiguration;
+  #onDisconnection: () => Promise<void>;
   #packetWriter = new PacketWriter();
   // TODO
   // Find out what parameters are for
   #parameters: { [key: string]: string } = {};
-  // TODO
-  // Find out what the pid is for
   #pid?: number;
   #queryLock: DeferredStack<undefined> = new DeferredStack(
     1,
@@ -161,19 +133,49 @@ export class Connection {
   );
   // TODO
   // Find out what the secret key is for
+  // Clean on startup
   #secretKey?: number;
+  #tls = false;
   // TODO
   // Find out what the transaction status is used for
+  // Clean on startup
   #transactionStatus?: TransactionStatus;
 
-  constructor(private connParams: ConnectionParams) {}
+  get pid() {
+    return this.#pid;
+  }
+
+  /** Indicates if the connection is carried over TLS */
+  get tls() {
+    return this.#tls;
+  }
+
+  constructor(
+    connection_params: ClientConfiguration,
+    disconnection_callback: () => Promise<void>,
+  ) {
+    this.#connection_params = connection_params;
+    this.#onDisconnection = disconnection_callback;
+  }
 
   /** Read single message sent by backend */
-  private async readMessage(): Promise<Message> {
+  async #readMessage(): Promise<Message> {
     // TODO: reuse buffer instead of allocating new ones each for each read
     const header = new Uint8Array(5);
     await this.#bufReader.readFull(header);
     const msgType = decoder.decode(header.slice(0, 1));
+    // TODO
+    // Investigate if the ascii terminator is the best way to check for a broken
+    // session
+    if (msgType === "\x00") {
+      // This error means that the database terminated the session without notifying
+      // the library
+      // TODO
+      // This will be removed once we move to async handling of messages by the frontend
+      // However, unnotified disconnection will remain a possibility, that will likely
+      // be handled in another place
+      throw new ConnectionError("The session was terminated by the database");
+    }
     const msgLength = readUInt32BE(header, 1) - 4;
     const msgBody = new Uint8Array(msgLength);
     await this.#bufReader.readFull(msgBody);
@@ -181,7 +183,7 @@ export class Connection {
     return new Message(msgType, msgLength, msgBody);
   }
 
-  private async serverAcceptsTLS(): Promise<boolean> {
+  async #serverAcceptsTLS(): Promise<boolean> {
     const writer = this.#packetWriter;
     writer.clear();
     writer
@@ -207,12 +209,12 @@ export class Connection {
     }
   }
 
-  private async sendStartupMessage(): Promise<Message> {
+  async #sendStartupMessage(): Promise<Message> {
     const writer = this.#packetWriter;
     writer.clear();
     // protocol version - 3.0, written as
     writer.addInt16(3).addInt16(0);
-    const connParams = this.connParams;
+    const connParams = this.#connection_params;
     // TODO: recognize other parameters
     writer.addCString("user").addCString(connParams.user);
     writer.addCString("database").addCString(connParams.database);
@@ -238,37 +240,78 @@ export class Connection {
     await this.#bufWriter.write(finalBuffer);
     await this.#bufWriter.flush();
 
-    return await this.readMessage();
+    return await this.#readMessage();
   }
 
-  /**
-   * https://www.postgresql.org/docs/13/protocol-flow.html#id-1.10.5.7.3
-   * */
-  async startup() {
+  async #createNonTlsConnection(options: Deno.ConnectOptions) {
+    this.#conn = await Deno.connect(options);
+    this.#bufWriter = new BufWriter(this.#conn);
+    this.#bufReader = new BufReader(this.#conn);
+  }
+
+  async #createTlsConnection(
+    connection: Deno.Conn,
+    options: Deno.ConnectOptions,
+  ) {
+    if ("startTls" in Deno) {
+      // @ts-ignore This API should be available on unstable
+      this.#conn = await Deno.startTls(connection, options);
+      this.#bufWriter = new BufWriter(this.#conn);
+      this.#bufReader = new BufReader(this.#conn);
+    } else {
+      throw new Error(
+        "You need to execute Deno with the `--unstable` argument in order to stablish a TLS connection",
+      );
+    }
+  }
+
+  #resetConnectionMetadata() {
+    this.connected = false;
+    this.#packetWriter = new PacketWriter();
+    this.#parameters = {};
+    this.#pid = undefined;
+    this.#queryLock = new DeferredStack(
+      1,
+      [undefined],
+    );
+    this.#secretKey = undefined;
+    this.#tls = false;
+    this.#transactionStatus = undefined;
+  }
+
+  async #startup() {
+    try {
+      this.#conn.close();
+    } catch (_e) {
+      // Swallow error
+    }
+    this.#resetConnectionMetadata();
+
     const {
       hostname,
       port,
       tls: {
         enforce: enforceTLS,
       },
-    } = this.connParams;
+    } = this.#connection_params;
 
-    this.#conn = await Deno.connect({ port, hostname });
-    this.#bufWriter = new BufWriter(this.#conn);
+    // A BufWriter needs to be available in order to check if the server accepts TLS connections
+    await this.#createNonTlsConnection({ hostname, port });
+
+    const accepts_tls = await this.#serverAcceptsTLS()
+      .catch((e) => {
+        // Make sure to close the connection if the TLS validation throws
+        this.#conn.close();
+        throw e;
+      });
 
     /**
      * https://www.postgresql.org/docs/13/protocol-flow.html#id-1.10.5.7.11
      * */
-    if (await this.serverAcceptsTLS()) {
+    if (accepts_tls) {
       try {
-        if ("startTls" in Deno) {
-          // @ts-ignore This API should be available on unstable
-          this.#conn = await Deno.startTls(this.#conn, { hostname });
-        } else {
-          throw new Error(
-            "You need to execute Deno with the `--unstable` argument in order to stablish a TLS connection",
-          );
-        }
+        await this.#createTlsConnection(this.#conn, { hostname, port });
+        this.#tls = true;
       } catch (e) {
         if (!enforceTLS) {
           console.error(
@@ -277,48 +320,70 @@ export class Connection {
               "\n" +
               bold("Defaulting to non-encrypted connection"),
           );
-          this.#conn = await Deno.connect({ port, hostname });
+          await this.#createNonTlsConnection({ hostname, port });
+          this.#tls = false;
         } else {
           throw e;
         }
       }
-      this.#bufWriter = new BufWriter(this.#conn);
     } else if (enforceTLS) {
+      // Make sure to close the connection before erroring
+      this.#conn.close();
       throw new Error(
         "The server isn't accepting TLS connections. Change the client configuration so TLS configuration isn't required to connect",
       );
     }
 
-    this.#bufReader = new BufReader(this.#conn);
-
     try {
-      // deno-lint-ignore camelcase
-      const startup_response = await this.sendStartupMessage();
+      let startup_response;
+      try {
+        startup_response = await this.#sendStartupMessage();
+      } catch (e) {
+        if (e instanceof Deno.errors.InvalidData) {
+          if (enforceTLS) {
+            throw new Error(
+              "The certificate used to secure the TLS connection is invalid",
+            );
+          } else {
+            console.error(
+              bold(yellow("TLS connection failed with message: ")) +
+                e.message +
+                "\n" +
+                bold("Defaulting to non-encrypted connection"),
+            );
+            await this.#createNonTlsConnection({ hostname, port });
+            this.#tls = false;
+            startup_response = await this.#sendStartupMessage();
+          }
+        } else {
+          throw e;
+        }
+      }
       assertSuccessfulStartup(startup_response);
-      await this.authenticate(startup_response);
+      await this.#authenticate(startup_response);
 
       // Handle connection status
       // (connected but not ready)
       let msg;
       connection_status:
       while (true) {
-        msg = await this.readMessage();
+        msg = await this.#readMessage();
         switch (msg.type) {
           // Connection error (wrong database or user)
           case "E":
-            await this.processError(msg, false);
+            await this.#processError(msg, false);
             break;
           // backend key data
           case "K":
-            this._processBackendKeyData(msg);
+            this.#processBackendKeyData(msg);
             break;
           // parameter status
           case "S":
-            this._processParameterStatus(msg);
+            this.#processParameterStatus(msg);
             break;
           // ready for query
           case "Z": {
-            this._processReadyForQuery(msg);
+            this.#processReadyForQuery(msg);
             break connection_status;
           }
           default:
@@ -333,13 +398,65 @@ export class Connection {
     }
   }
 
+  /**
+   * Calling startup on a connection twice will create a new session and overwrite the previous one
+   *
+   * @param is_reconnection This indicates whether the startup should behave as if there was
+   * a connection previously established, or if it should attempt to create a connection first
+   *
+   * https://www.postgresql.org/docs/13/protocol-flow.html#id-1.10.5.7.3
+   * */
+  async startup(is_reconnection: boolean) {
+    if (is_reconnection && this.#connection_params.connection.attempts === 0) {
+      throw new Error(
+        "The client has been disconnected from the database. Enable reconnection in the client to attempt reconnection after failure",
+      );
+    }
+
+    let reconnection_attempts = 0;
+    const max_reconnections = this.#connection_params.connection.attempts;
+
+    let error: Error | undefined;
+    // If no connection has been established and the reconnection attempts are
+    // set to zero, attempt to connect at least once
+    if (!is_reconnection && this.#connection_params.connection.attempts === 0) {
+      try {
+        await this.#startup();
+      } catch (e) {
+        error = e;
+      }
+    } else {
+      // If the reconnection attempts are set to zero the client won't attempt to
+      // reconnect, but it won't error either, this "no reconnections" behavior
+      // should be handled wherever the reconnection is requested
+      while (reconnection_attempts < max_reconnections) {
+        try {
+          await this.#startup();
+          break;
+        } catch (e) {
+          // TODO
+          // Eventually distinguish between connection errors and normal errors
+          reconnection_attempts++;
+          if (reconnection_attempts === max_reconnections) {
+            error = e;
+          }
+        }
+      }
+    }
+
+    if (error) {
+      await this.end();
+      throw error;
+    }
+  }
+
   // TODO
   // Why is this handling the startup message response?
   /**
-   * Will attempt to authenticate with the database using the provided
+   * Will attempt to #authenticate with the database using the provided
    * password credentials
    */
-  private async authenticate(msg: Message) {
+  async #authenticate(msg: Message) {
     const code = msg.reader.readInt32();
     switch (code) {
       // pass
@@ -348,14 +465,14 @@ export class Connection {
       // cleartext password
       case 3:
         await assertSuccessfulAuthentication(
-          await this.authenticateWithClearPassword(),
+          await this.#authenticateWithClearPassword(),
         );
         break;
       // md5 password
       case 5: {
         const salt = msg.reader.readBytes(4);
         await assertSuccessfulAuthentication(
-          await this.authenticateWithMd5(salt),
+          await this.#authenticateWithMd5(salt),
         );
         break;
       }
@@ -367,7 +484,7 @@ export class Connection {
       // scram-sha-256 password
       case 10: {
         await assertSuccessfulAuthentication(
-          await this.authenticateWithScramSha256(),
+          await this.#authenticateWithScramSha256(),
         );
         break;
       }
@@ -376,27 +493,27 @@ export class Connection {
     }
   }
 
-  private async authenticateWithClearPassword(): Promise<Message> {
+  async #authenticateWithClearPassword(): Promise<Message> {
     this.#packetWriter.clear();
-    const password = this.connParams.password || "";
+    const password = this.#connection_params.password || "";
     const buffer = this.#packetWriter.addCString(password).flush(0x70);
 
     await this.#bufWriter.write(buffer);
     await this.#bufWriter.flush();
 
-    return this.readMessage();
+    return this.#readMessage();
   }
 
-  private async authenticateWithMd5(salt: Uint8Array): Promise<Message> {
+  async #authenticateWithMd5(salt: Uint8Array): Promise<Message> {
     this.#packetWriter.clear();
 
-    if (!this.connParams.password) {
+    if (!this.#connection_params.password) {
       throw new Error("Auth Error: attempting MD5 auth with password unset");
     }
 
     const password = hashMd5Password(
-      this.connParams.password,
-      this.connParams.user,
+      this.#connection_params.password,
+      this.#connection_params.user,
       salt,
     );
     const buffer = this.#packetWriter.addCString(password).flush(0x70);
@@ -404,19 +521,19 @@ export class Connection {
     await this.#bufWriter.write(buffer);
     await this.#bufWriter.flush();
 
-    return this.readMessage();
+    return this.#readMessage();
   }
 
-  private async authenticateWithScramSha256(): Promise<Message> {
-    if (!this.connParams.password) {
+  async #authenticateWithScramSha256(): Promise<Message> {
+    if (!this.#connection_params.password) {
       throw new Error(
         "Auth Error: attempting SCRAM-SHA-256 auth with password unset",
       );
     }
 
     const client = new scram.Client(
-      this.connParams.user,
-      this.connParams.password,
+      this.#connection_params.user,
+      this.#connection_params.password,
     );
     const utf8 = new TextDecoder("utf-8");
 
@@ -430,7 +547,7 @@ export class Connection {
     this.#bufWriter.flush();
 
     // AuthenticationSASLContinue
-    const saslContinue = await this.readMessage();
+    const saslContinue = await this.#readMessage();
     switch (saslContinue.type) {
       case "R": {
         if (saslContinue.reader.readInt32() != 11) {
@@ -446,17 +563,16 @@ export class Connection {
       }
     }
     const serverFirstMessage = utf8.decode(saslContinue.reader.readAllBytes());
-    client.receiveChallenge(serverFirstMessage);
+    await client.receiveChallenge(serverFirstMessage);
 
-    // SASLResponse
-    const clientFinalMessage = client.composeResponse();
     this.#packetWriter.clear();
-    this.#packetWriter.addString(clientFinalMessage);
+    // SASLResponse
+    this.#packetWriter.addString(await client.composeResponse());
     this.#bufWriter.write(this.#packetWriter.flush(0x70));
     this.#bufWriter.flush();
 
     // AuthenticationSASLFinal
-    const saslFinal = await this.readMessage();
+    const saslFinal = await this.#readMessage();
     switch (saslFinal.type) {
       case "R": {
         if (saslFinal.reader.readInt32() !== 12) {
@@ -472,33 +588,33 @@ export class Connection {
       }
     }
     const serverFinalMessage = utf8.decode(saslFinal.reader.readAllBytes());
-    client.receiveResponse(serverFinalMessage);
+    await client.receiveResponse(serverFinalMessage);
 
     // AuthenticationOK
-    return this.readMessage();
+    return this.#readMessage();
   }
 
-  private _processBackendKeyData(msg: Message) {
+  #processBackendKeyData(msg: Message) {
     this.#pid = msg.reader.readInt32();
     this.#secretKey = msg.reader.readInt32();
   }
 
-  private _processParameterStatus(msg: Message) {
+  #processParameterStatus(msg: Message) {
     // TODO: should we save all parameters?
     const key = msg.reader.readCString();
     const value = msg.reader.readCString();
     this.#parameters[key] = value;
   }
 
-  private _processReadyForQuery(msg: Message) {
+  #processReadyForQuery(msg: Message) {
     const txStatus = msg.reader.readByte();
     this.#transactionStatus = String.fromCharCode(
       txStatus,
     ) as TransactionStatus;
   }
 
-  private async _readReadyForQuery() {
-    const msg = await this.readMessage();
+  async #readReadyForQuery() {
+    const msg = await this.#readMessage();
 
     if (msg.type !== "Z") {
       throw new Error(
@@ -506,16 +622,16 @@ export class Connection {
       );
     }
 
-    this._processReadyForQuery(msg);
+    this.#processReadyForQuery(msg);
   }
 
-  private async _simpleQuery(
-    query: Query<ResultType.ARRAY>,
+  async #simpleQuery(
+    _query: Query<ResultType.ARRAY>,
   ): Promise<QueryArrayResult>;
-  private async _simpleQuery(
-    query: Query<ResultType.OBJECT>,
+  async #simpleQuery(
+    _query: Query<ResultType.OBJECT>,
   ): Promise<QueryObjectResult>;
-  private async _simpleQuery(
+  async #simpleQuery(
     query: Query<ResultType>,
   ): Promise<QueryResult> {
     this.#packetWriter.clear();
@@ -534,29 +650,29 @@ export class Connection {
 
     let msg: Message;
 
-    msg = await this.readMessage();
+    msg = await this.#readMessage();
 
     // Query startup message, executed only once
     switch (msg.type) {
       // row description
       case "T":
-        result.loadColumnDescriptions(this.parseRowDescription(msg));
+        result.loadColumnDescriptions(this.#parseRowDescription(msg));
         break;
       // no data
       case "n":
         break;
       // error response
       case "E":
-        await this.processError(msg);
+        await this.#processError(msg);
         break;
       // notice response
       case "N":
-        result.warnings.push(await this.processNotice(msg));
+        result.warnings.push(await this.#processNotice(msg));
         break;
       // command complete
       // TODO: this is duplicated in next loop
       case "C": {
-        const commandTag = this.getCommandTag(msg);
+        const commandTag = this.#getCommandTag(msg);
         result.handleCommandComplete(commandTag);
         result.done();
         break;
@@ -567,35 +683,35 @@ export class Connection {
 
     // Handle each row returned by the query
     while (true) {
-      msg = await this.readMessage();
+      msg = await this.#readMessage();
       switch (msg.type) {
         // data row
         case "D": {
           // this is actually packet read
-          result.insertRow(this.parseRowData(msg));
+          result.insertRow(this.#parseRowData(msg));
           break;
         }
         // command complete
         case "C": {
-          const commandTag = this.getCommandTag(msg);
+          const commandTag = this.#getCommandTag(msg);
           result.handleCommandComplete(commandTag);
           result.done();
           break;
         }
         // ready for query
         case "Z":
-          this._processReadyForQuery(msg);
+          this.#processReadyForQuery(msg);
           return result;
         // error response
         case "E":
-          await this.processError(msg);
+          await this.#processError(msg);
           break;
         // notice response
         case "N":
-          result.warnings.push(await this.processNotice(msg));
+          result.warnings.push(await this.#processNotice(msg));
           break;
         case "T":
-          result.loadColumnDescriptions(this.parseRowDescription(msg));
+          result.loadColumnDescriptions(this.#parseRowDescription(msg));
           break;
         default:
           throw new Error(`Unexpected frame: ${msg.type}`);
@@ -603,7 +719,7 @@ export class Connection {
     }
   }
 
-  private async appendQueryToMessage<T extends ResultType>(query: Query<T>) {
+  async #appendQueryToMessage<T extends ResultType>(query: Query<T>) {
     this.#packetWriter.clear();
 
     const buffer = this.#packetWriter
@@ -614,7 +730,7 @@ export class Connection {
     await this.#bufWriter.write(buffer);
   }
 
-  private async appendArgumentsToMessage<T extends ResultType>(
+  async #appendArgumentsToMessage<T extends ResultType>(
     query: Query<T>,
   ) {
     this.#packetWriter.clear();
@@ -661,14 +777,14 @@ export class Connection {
    * This function appends the query type (in this case prepared statement)
    * to the message
    */
-  private async appendQueryTypeToMessage() {
+  async #appendQueryTypeToMessage() {
     this.#packetWriter.clear();
 
     const buffer = this.#packetWriter.addCString("P").flush(0x44);
     await this.#bufWriter.write(buffer);
   }
 
-  private async appendExecuteToMessage() {
+  async #appendExecuteToMessage() {
     this.#packetWriter.clear();
 
     const buffer = this.#packetWriter
@@ -678,22 +794,22 @@ export class Connection {
     await this.#bufWriter.write(buffer);
   }
 
-  private async appendSyncToMessage() {
+  async #appendSyncToMessage() {
     this.#packetWriter.clear();
 
     const buffer = this.#packetWriter.flush(0x53);
     await this.#bufWriter.write(buffer);
   }
 
-  private async processError(msg: Message, recoverable = true) {
+  async #processError(msg: Message, recoverable = true) {
     const error = parseError(msg);
     if (recoverable) {
-      await this._readReadyForQuery();
+      await this.#readReadyForQuery();
     }
     throw error;
   }
 
-  private processNotice(msg: Message) {
+  #processNotice(msg: Message) {
     const warning = parseNotice(msg);
     console.error(`${bold(yellow(warning.severity))}: ${warning.message}`);
     return warning;
@@ -704,19 +820,19 @@ export class Connection {
   /**
    * https://www.postgresql.org/docs/13/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
    */
-  private async _preparedQuery<T extends ResultType>(
+  async #preparedQuery<T extends ResultType>(
     query: Query<T>,
   ): Promise<QueryResult> {
-    await this.appendQueryToMessage(query);
-    await this.appendArgumentsToMessage(query);
-    await this.appendQueryTypeToMessage();
-    await this.appendExecuteToMessage();
-    await this.appendSyncToMessage();
+    await this.#appendQueryToMessage(query);
+    await this.#appendArgumentsToMessage(query);
+    await this.#appendQueryTypeToMessage();
+    await this.#appendExecuteToMessage();
+    await this.#appendSyncToMessage();
     // send all messages to backend
     await this.#bufWriter.flush();
 
-    await assertQueryResponse(await this.readMessage());
-    await assertArgumentsResponse(await this.readMessage());
+    await assertQueryResponse(await this.#readMessage());
+    await assertArgumentsResponse(await this.#readMessage());
 
     let result;
     if (query.result_type === ResultType.ARRAY) {
@@ -725,21 +841,25 @@ export class Connection {
       result = new QueryObjectResult(query);
     }
     let msg: Message;
-    msg = await this.readMessage();
+    msg = await this.#readMessage();
 
     switch (msg.type) {
       // row description
       case "T": {
-        const rowDescription = this.parseRowDescription(msg);
+        const rowDescription = this.#parseRowDescription(msg);
         result.loadColumnDescriptions(rowDescription);
         break;
       }
       // no data
       case "n":
         break;
+      // notice response
+      case "N":
+        result.warnings.push(await this.#processNotice(msg));
+        break;
       // error
       case "E":
-        await this.processError(msg);
+        await this.#processError(msg);
         break;
       default:
         throw new Error(`Unexpected frame: ${msg.type}`);
@@ -747,32 +867,36 @@ export class Connection {
 
     outerLoop:
     while (true) {
-      msg = await this.readMessage();
+      msg = await this.#readMessage();
       switch (msg.type) {
         // data row
         case "D": {
           // this is actually packet read
-          const rawDataRow = this.parseRowData(msg);
+          const rawDataRow = this.#parseRowData(msg);
           result.insertRow(rawDataRow);
           break;
         }
         // command complete
         case "C": {
-          const commandTag = this.getCommandTag(msg);
+          const commandTag = this.#getCommandTag(msg);
           result.handleCommandComplete(commandTag);
           result.done();
           break outerLoop;
         }
+        // notice response
+        case "N":
+          result.warnings.push(await this.#processNotice(msg));
+          break;
         // error response
         case "E":
-          await this.processError(msg);
+          await this.#processError(msg);
           break;
         default:
           throw new Error(`Unexpected frame: ${msg.type}`);
       }
     }
 
-    await this._readReadyForQuery();
+    await this.#readReadyForQuery();
 
     return result;
   }
@@ -787,21 +911,29 @@ export class Connection {
     query: Query<ResultType>,
   ): Promise<QueryResult> {
     if (!this.connected) {
-      throw new Error("The connection hasn't been initialized");
+      await this.startup(true);
     }
+
     await this.#queryLock.pop();
     try {
       if (query.args.length === 0) {
-        return await this._simpleQuery(query);
+        return await this.#simpleQuery(query);
       } else {
-        return await this._preparedQuery(query);
+        return await this.#preparedQuery(query);
       }
+    } catch (e) {
+      if (
+        e instanceof ConnectionError
+      ) {
+        await this.end();
+      }
+      throw e;
     } finally {
       this.#queryLock.push(undefined);
     }
   }
 
-  private parseRowDescription(msg: Message): RowDescription {
+  #parseRowDescription(msg: Message): RowDescription {
     const columnCount = msg.reader.readInt16();
     const columns = [];
 
@@ -824,9 +956,9 @@ export class Connection {
   }
 
   //TODO
-  //Research corner cases where parseRowData can return null values
+  //Research corner cases where #parseRowData can return null values
   // deno-lint-ignore no-explicit-any
-  private parseRowData(msg: Message): any[] {
+  #parseRowData(msg: Message): any[] {
     const fieldCount = msg.reader.readInt16();
     const row = [];
 
@@ -845,7 +977,7 @@ export class Connection {
     return row;
   }
 
-  private getCommandTag(msg: Message) {
+  #getCommandTag(msg: Message) {
     return msg.reader.readString(msg.byteCount);
   }
 
@@ -853,9 +985,15 @@ export class Connection {
     if (this.connected) {
       const terminationMessage = new Uint8Array([0x58, 0x00, 0x00, 0x00, 0x04]);
       await this.#bufWriter.write(terminationMessage);
-      await this.#bufWriter.flush();
-      this.#conn.close();
-      this.connected = false;
+      try {
+        await this.#bufWriter.flush();
+        this.#conn.close();
+      } catch (_e) {
+        // This steps can fail if the underlying connection has been closed ungracefully
+      } finally {
+        this.#resetConnectionMetadata();
+        this.#onDisconnection();
+      }
     }
   }
 }
diff --git a/connection/connection_params.ts b/connection/connection_params.ts
index 057a4cb4..2e78919e 100644
--- a/connection/connection_params.ts
+++ b/connection/connection_params.ts
@@ -1,4 +1,5 @@
-import { parseDsn } from "../utils.ts";
+// deno-lint-ignore-file camelcase
+import { parseDsn } from "../utils/utils.ts";
 
 /**
  * The connection string must match the following URI structure
@@ -17,7 +18,7 @@ export type ConnectionString = string;
  *
  * It will throw if no env permission was provided on startup
  */
-function getPgEnv(): ConnectionOptions {
+function getPgEnv(): ClientOptions {
   return {
     database: Deno.env.get("PGDATABASE"),
     hostname: Deno.env.get("PGHOST"),
@@ -35,6 +36,18 @@ export class ConnectionParamsError extends Error {
   }
 }
 
+export interface ConnectionOptions {
+  /**
+   * By default, any client will only attempt to stablish
+   * connection with your database once. Setting this parameter
+   * will cause the client to attempt reconnection as many times
+   * as requested before erroring
+   *
+   * default: `1`
+   */
+  attempts: number;
+}
+
 export interface TLSOptions {
   /**
    * This will force the connection to run over TLS
@@ -45,18 +58,20 @@ export interface TLSOptions {
   enforce: boolean;
 }
 
-export interface ConnectionOptions {
+export interface ClientOptions {
   applicationName?: string;
+  connection?: Partial<ConnectionOptions>;
   database?: string;
   hostname?: string;
   password?: string;
   port?: string | number;
-  tls?: TLSOptions;
+  tls?: Partial<TLSOptions>;
   user?: string;
 }
 
-export interface ConnectionParams {
+export interface ClientConfiguration {
   applicationName: string;
+  connection: ConnectionOptions;
   database: string;
   hostname: string;
   password?: string;
@@ -81,12 +96,11 @@ function formatMissingParams(missingParams: string[]) {
  * telling the user to pass env permissions in order to read environmental variables
  */
 function assertRequiredOptions(
-  options: ConnectionOptions,
-  requiredKeys: (keyof ConnectionOptions)[],
-  // deno-lint-ignore camelcase
+  options: Partial<ClientConfiguration>,
+  requiredKeys: (keyof ClientOptions)[],
   has_env_access: boolean,
-) {
-  const missingParams: (keyof ConnectionOptions)[] = [];
+): asserts options is ClientConfiguration {
+  const missingParams: (keyof ClientOptions)[] = [];
   for (const key of requiredKeys) {
     if (
       options[key] === "" ||
@@ -98,7 +112,6 @@ function assertRequiredOptions(
   }
 
   if (missingParams.length) {
-    // deno-lint-ignore camelcase
     let missing_params_message = formatMissingParams(missingParams);
     if (!has_env_access) {
       missing_params_message +=
@@ -109,7 +122,7 @@ function assertRequiredOptions(
   }
 }
 
-function parseOptionsFromDsn(connString: string): ConnectionOptions {
+function parseOptionsFromDsn(connString: string): ClientOptions {
   const dsn = parseDsn(connString);
 
   if (dsn.driver !== "postgres" && dsn.driver !== "postgresql") {
@@ -141,24 +154,26 @@ function parseOptionsFromDsn(connString: string): ConnectionOptions {
   };
 }
 
-const DEFAULT_OPTIONS = {
+const DEFAULT_OPTIONS: Omit<ClientConfiguration, "database" | "user"> = {
   applicationName: "deno_postgres",
+  connection: {
+    attempts: 1,
+  },
   hostname: "127.0.0.1",
-  port: "5432",
+  port: 5432,
   tls: {
     enforce: false,
   },
 };
 
 export function createParams(
-  params: string | ConnectionOptions = {},
-): ConnectionParams {
+  params: string | ClientOptions = {},
+): ClientConfiguration {
   if (typeof params === "string") {
     params = parseOptionsFromDsn(params);
   }
 
-  let pgEnv: ConnectionOptions = {};
-  // deno-lint-ignore camelcase
+  let pgEnv: ClientOptions = {};
   let has_env_access = true;
   try {
     pgEnv = getPgEnv();
@@ -170,21 +185,29 @@ export function createParams(
     }
   }
 
-  let port: string;
+  let port: number;
   if (params.port) {
-    port = String(params.port);
+    port = Number(params.port);
   } else if (pgEnv.port) {
-    port = String(pgEnv.port);
+    port = Number(pgEnv.port);
   } else {
     port = DEFAULT_OPTIONS.port;
   }
+  if (Number.isNaN(port) || port === 0) {
+    throw new ConnectionParamsError(
+      `"${params.port ?? pgEnv.port}" is not a valid port number`,
+    );
+  }
 
   // TODO
   // Perhaps username should be taken from the PC user as a default?
-  // deno-lint-ignore camelcase
   const connection_options = {
     applicationName: params.applicationName ?? pgEnv.applicationName ??
       DEFAULT_OPTIONS.applicationName,
+    connection: {
+      attempts: params?.connection?.attempts ??
+        DEFAULT_OPTIONS.connection.attempts,
+    },
     database: params.database ?? pgEnv.database,
     hostname: params.hostname ?? pgEnv.hostname ?? DEFAULT_OPTIONS.hostname,
     password: params.password ?? pgEnv.password,
@@ -197,25 +220,9 @@ export function createParams(
 
   assertRequiredOptions(
     connection_options,
-    ["database", "hostname", "port", "user", "applicationName"],
+    ["applicationName", "database", "hostname", "port", "user"],
     has_env_access,
   );
 
-  // By this point all required parameters have been checked out
-  // by the assert function
-  // deno-lint-ignore camelcase
-  const connection_parameters: ConnectionParams = {
-    ...connection_options,
-    database: connection_options.database as string,
-    port: parseInt(connection_options.port, 10),
-    user: connection_options.user as string,
-  };
-
-  if (isNaN(connection_parameters.port)) {
-    throw new ConnectionParamsError(
-      `Invalid port ${connection_parameters.port}`,
-    );
-  }
-
-  return connection_parameters;
+  return connection_options;
 }
diff --git a/connection/deferred.ts b/connection/deferred.ts
deleted file mode 100644
index fe5bcfe6..00000000
--- a/connection/deferred.ts
+++ /dev/null
@@ -1,50 +0,0 @@
-import { Deferred, deferred } from "../deps.ts";
-
-export class DeferredStack<T> {
-  #array: Array<T>;
-  #creator?: () => Promise<T>;
-  #max_size: number;
-  #queue: Array<Deferred<T>>;
-  #size: number;
-
-  constructor(
-    max?: number,
-    ls?: Iterable<T>,
-    creator?: () => Promise<T>,
-  ) {
-    this.#array = ls ? [...ls] : [];
-    this.#creator = creator;
-    this.#max_size = max || 10;
-    this.#queue = [];
-    this.#size = this.#array.length;
-  }
-
-  get available(): number {
-    return this.#array.length;
-  }
-
-  async pop(): Promise<T> {
-    if (this.#array.length > 0) {
-      return this.#array.pop()!;
-    } else if (this.#size < this.#max_size && this.#creator) {
-      this.#size++;
-      return await this.#creator();
-    }
-    const d = deferred<T>();
-    this.#queue.push(d);
-    await d;
-    return this.#array.pop()!;
-  }
-
-  push(value: T): void {
-    this.#array.push(value);
-    if (this.#queue.length > 0) {
-      const d = this.#queue.shift()!;
-      d.resolve();
-    }
-  }
-
-  get size(): number {
-    return this.#size;
-  }
-}
diff --git a/connection/packet_reader.ts b/connection/packet_reader.ts
index 7b360a9e..b69c16cd 100644
--- a/connection/packet_reader.ts
+++ b/connection/packet_reader.ts
@@ -1,20 +1,23 @@
-import { readInt16BE, readInt32BE } from "../utils.ts";
+import { readInt16BE, readInt32BE } from "../utils/utils.ts";
 
 export class PacketReader {
-  private offset = 0;
-  private decoder: TextDecoder = new TextDecoder();
+  #buffer: Uint8Array;
+  #decoder = new TextDecoder();
+  #offset = 0;
 
-  constructor(private buffer: Uint8Array) {}
+  constructor(buffer: Uint8Array) {
+    this.#buffer = buffer;
+  }
 
   readInt16(): number {
-    const value = readInt16BE(this.buffer, this.offset);
-    this.offset += 2;
+    const value = readInt16BE(this.#buffer, this.#offset);
+    this.#offset += 2;
     return value;
   }
 
   readInt32(): number {
-    const value = readInt32BE(this.buffer, this.offset);
-    this.offset += 4;
+    const value = readInt32BE(this.#buffer, this.#offset);
+    this.#offset += 4;
     return value;
   }
 
@@ -23,31 +26,31 @@ export class PacketReader {
   }
 
   readBytes(length: number): Uint8Array {
-    const start = this.offset;
+    const start = this.#offset;
     const end = start + length;
-    const slice = this.buffer.slice(start, end);
-    this.offset = end;
+    const slice = this.#buffer.slice(start, end);
+    this.#offset = end;
     return slice;
   }
 
   readAllBytes(): Uint8Array {
-    const slice = this.buffer.slice(this.offset);
-    this.offset = this.buffer.length;
+    const slice = this.#buffer.slice(this.#offset);
+    this.#offset = this.#buffer.length;
     return slice;
   }
 
   readString(length: number): string {
     const bytes = this.readBytes(length);
-    return this.decoder.decode(bytes);
+    return this.#decoder.decode(bytes);
   }
 
   readCString(): string {
-    const start = this.offset;
+    const start = this.#offset;
     // find next null byte
-    const end = this.buffer.indexOf(0, start);
-    const slice = this.buffer.slice(start, end);
+    const end = this.#buffer.indexOf(0, start);
+    const slice = this.#buffer.slice(start, end);
     // add +1 for null byte
-    this.offset = end + 1;
-    return this.decoder.decode(slice);
+    this.#offset = end + 1;
+    return this.#decoder.decode(slice);
   }
 }
diff --git a/connection/packet_writer.ts b/connection/packet_writer.ts
index 43d7b0dd..9f0a90f6 100644
--- a/connection/packet_writer.ts
+++ b/connection/packet_writer.ts
@@ -28,59 +28,59 @@
 import { copy } from "../deps.ts";
 
 export class PacketWriter {
-  private size: number;
-  private buffer: Uint8Array;
-  private offset: number;
-  private headerPosition: number;
-  private encoder = new TextEncoder();
+  #buffer: Uint8Array;
+  #encoder = new TextEncoder();
+  #headerPosition: number;
+  #offset: number;
+  #size: number;
 
   constructor(size?: number) {
-    this.size = size || 1024;
-    this.buffer = new Uint8Array(this.size + 5);
-    this.offset = 5;
-    this.headerPosition = 0;
+    this.#size = size || 1024;
+    this.#buffer = new Uint8Array(this.#size + 5);
+    this.#offset = 5;
+    this.#headerPosition = 0;
   }
 
-  _ensure(size: number) {
-    const remaining = this.buffer.length - this.offset;
+  #ensure(size: number) {
+    const remaining = this.#buffer.length - this.#offset;
     if (remaining < size) {
-      const oldBuffer = this.buffer;
+      const oldBuffer = this.#buffer;
       // exponential growth factor of around ~ 1.5
-      // https://stackoverflow.com/questions/2269063/buffer-growth-strategy
+      // https://stackoverflow.com/questions/2269063/#buffer-growth-strategy
       const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
-      this.buffer = new Uint8Array(newSize);
-      copy(oldBuffer, this.buffer);
+      this.#buffer = new Uint8Array(newSize);
+      copy(oldBuffer, this.#buffer);
     }
   }
 
   addInt32(num: number) {
-    this._ensure(4);
-    this.buffer[this.offset++] = (num >>> 24) & 0xff;
-    this.buffer[this.offset++] = (num >>> 16) & 0xff;
-    this.buffer[this.offset++] = (num >>> 8) & 0xff;
-    this.buffer[this.offset++] = (num >>> 0) & 0xff;
+    this.#ensure(4);
+    this.#buffer[this.#offset++] = (num >>> 24) & 0xff;
+    this.#buffer[this.#offset++] = (num >>> 16) & 0xff;
+    this.#buffer[this.#offset++] = (num >>> 8) & 0xff;
+    this.#buffer[this.#offset++] = (num >>> 0) & 0xff;
     return this;
   }
 
   addInt16(num: number) {
-    this._ensure(2);
-    this.buffer[this.offset++] = (num >>> 8) & 0xff;
-    this.buffer[this.offset++] = (num >>> 0) & 0xff;
+    this.#ensure(2);
+    this.#buffer[this.#offset++] = (num >>> 8) & 0xff;
+    this.#buffer[this.#offset++] = (num >>> 0) & 0xff;
     return this;
   }
 
   addCString(string?: string) {
     // just write a 0 for empty or null strings
     if (!string) {
-      this._ensure(1);
+      this.#ensure(1);
     } else {
-      const encodedStr = this.encoder.encode(string);
-      this._ensure(encodedStr.byteLength + 1); // +1 for null terminator
-      copy(encodedStr, this.buffer, this.offset);
-      this.offset += encodedStr.byteLength;
+      const encodedStr = this.#encoder.encode(string);
+      this.#ensure(encodedStr.byteLength + 1); // +1 for null terminator
+      copy(encodedStr, this.#buffer, this.#offset);
+      this.#offset += encodedStr.byteLength;
     }
 
-    this.buffer[this.offset++] = 0; // null terminator
+    this.#buffer[this.#offset++] = 0; // null terminator
     return this;
   }
 
@@ -89,48 +89,48 @@ export class PacketWriter {
       throw new Error("addChar requires single character strings");
     }
 
-    this._ensure(1);
-    copy(this.encoder.encode(c), this.buffer, this.offset);
-    this.offset++;
+    this.#ensure(1);
+    copy(this.#encoder.encode(c), this.#buffer, this.#offset);
+    this.#offset++;
     return this;
   }
 
   addString(string?: string) {
     string = string || "";
-    const encodedStr = this.encoder.encode(string);
-    this._ensure(encodedStr.byteLength);
-    copy(encodedStr, this.buffer, this.offset);
-    this.offset += encodedStr.byteLength;
+    const encodedStr = this.#encoder.encode(string);
+    this.#ensure(encodedStr.byteLength);
+    copy(encodedStr, this.#buffer, this.#offset);
+    this.#offset += encodedStr.byteLength;
     return this;
   }
 
   add(otherBuffer: Uint8Array) {
-    this._ensure(otherBuffer.length);
-    copy(otherBuffer, this.buffer, this.offset);
-    this.offset += otherBuffer.length;
+    this.#ensure(otherBuffer.length);
+    copy(otherBuffer, this.#buffer, this.#offset);
+    this.#offset += otherBuffer.length;
     return this;
   }
 
   clear() {
-    this.offset = 5;
-    this.headerPosition = 0;
+    this.#offset = 5;
+    this.#headerPosition = 0;
   }
 
   // appends a header block to all the written data since the last
   // subsequent header or to the beginning if there is only one data block
   addHeader(code: number, last?: boolean) {
-    const origOffset = this.offset;
-    this.offset = this.headerPosition;
-    this.buffer[this.offset++] = code;
+    const origOffset = this.#offset;
+    this.#offset = this.#headerPosition;
+    this.#buffer[this.#offset++] = code;
     // length is everything in this packet minus the code
-    this.addInt32(origOffset - (this.headerPosition + 1));
+    this.addInt32(origOffset - (this.#headerPosition + 1));
     // set next header position
-    this.headerPosition = origOffset;
+    this.#headerPosition = origOffset;
     // make space for next header
-    this.offset = origOffset;
+    this.#offset = origOffset;
     if (!last) {
-      this._ensure(5);
-      this.offset += 5;
+      this.#ensure(5);
+      this.#offset += 5;
     }
     return this;
   }
@@ -139,7 +139,7 @@ export class PacketWriter {
     if (code) {
       this.addHeader(code, true);
     }
-    return this.buffer.slice(code ? 0 : 5, this.offset);
+    return this.#buffer.slice(code ? 0 : 5, this.#offset);
   }
 
   flush(code?: number) {
diff --git a/connection/scram.ts b/connection/scram.ts
index da5c0de8..036e3856 100644
--- a/connection/scram.ts
+++ b/connection/scram.ts
@@ -1,4 +1,4 @@
-import { base64, HmacSha256, Sha256 } from "../deps.ts";
+import { base64, HmacSha256 } from "../deps.ts";
 
 function assert(cond: unknown): asserts cond {
   if (!cond) {
@@ -38,60 +38,60 @@ const defaultNonceSize = 16;
 
 /**
  * Client composes and verifies SCRAM authentication messages, keeping track
- * of authentication state and parameters.
+ * of authentication #state and parameters.
  * @see {@link https://tools.ietf.org/html/rfc5802}
  */
 export class Client {
-  private username: string;
-  private password: string;
-  private keys?: Keys;
-  private clientNonce: string;
-  private serverNonce?: string;
-  private authMessage: string;
-  private state: State;
+  #authMessage: string;
+  #clientNonce: string;
+  #keys?: Keys;
+  #password: string;
+  #serverNonce?: string;
+  #state: State;
+  #username: string;
 
   /** Constructor sets credentials and parameters used in an authentication. */
   constructor(username: string, password: string, nonce?: string) {
-    this.username = username;
-    this.password = password;
-    this.clientNonce = nonce ?? generateNonce(defaultNonceSize);
-    this.authMessage = "";
-    this.state = State.Init;
+    this.#username = username;
+    this.#password = password;
+    this.#clientNonce = nonce ?? generateNonce(defaultNonceSize);
+    this.#authMessage = "";
+    this.#state = State.Init;
   }
 
   /** Composes client-first-message. */
   composeChallenge(): string {
-    assert(this.state === State.Init);
+    assert(this.#state === State.Init);
 
     try {
       // "n" for no channel binding, then an empty authzid option follows.
       const header = "n,,";
 
-      const username = escape(normalize(this.username));
-      const challenge = `n=${username},r=${this.clientNonce}`;
+      const username = escape(normalize(this.#username));
+      const challenge = `n=${username},r=${this.#clientNonce}`;
       const message = header + challenge;
 
-      this.authMessage += challenge;
-      this.state = State.ClientChallenge;
+      this.#authMessage += challenge;
+      this.#state = State.ClientChallenge;
       return message;
     } catch (e) {
-      this.state = State.Failed;
+      this.#state = State.Failed;
       throw e;
     }
   }
 
   /** Processes server-first-message. */
-  receiveChallenge(challenge: string) {
-    assert(this.state === State.ClientChallenge);
+  async receiveChallenge(challenge: string) {
+    assert(this.#state === State.ClientChallenge);
 
     try {
       const attrs = parseAttributes(challenge);
 
       const nonce = attrs.r;
-      if (!attrs.r || !attrs.r.startsWith(this.clientNonce)) {
+      if (!attrs.r || !attrs.r.startsWith(this.#clientNonce)) {
         throw new AuthError(Reason.BadServerNonce);
       }
-      this.serverNonce = nonce;
+      this.#serverNonce = nonce;
 
       let salt: Uint8Array | undefined;
       if (!attrs.s) {
@@ -108,48 +108,48 @@ export class Client {
         throw new AuthError(Reason.BadIterationCount);
       }
 
-      this.keys = deriveKeys(this.password, salt, iterCount);
+      this.#keys = await deriveKeys(this.#password, salt, iterCount);
 
-      this.authMessage += "," + challenge;
-      this.state = State.ServerChallenge;
+      this.#authMessage += "," + challenge;
+      this.#state = State.ServerChallenge;
     } catch (e) {
-      this.state = State.Failed;
+      this.#state = State.Failed;
       throw e;
     }
   }
 
   /** Composes client-final-message. */
-  composeResponse(): string {
-    assert(this.state === State.ServerChallenge);
-    assert(this.keys);
-    assert(this.serverNonce);
+  async composeResponse(): Promise<string> {
+    assert(this.#state === State.ServerChallenge);
+    assert(this.#keys);
+    assert(this.#serverNonce);
 
     try {
       // "biws" is the base-64 encoded form of the gs2-header "n,,".
-      const responseWithoutProof = `c=biws,r=${this.serverNonce}`;
+      const responseWithoutProof = `c=biws,r=${this.#serverNonce}`;
 
-      this.authMessage += "," + responseWithoutProof;
+      this.#authMessage += "," + responseWithoutProof;
 
       const proof = base64.encode(
         computeProof(
-          computeSignature(this.authMessage, this.keys.stored),
-          this.keys.client,
+          await computeSignature(this.#authMessage, this.#keys.stored),
+          this.#keys.client,
         ),
       );
       const message = `${responseWithoutProof},p=${proof}`;
 
-      this.state = State.ClientResponse;
+      this.#state = State.ClientResponse;
       return message;
     } catch (e) {
-      this.state = State.Failed;
+      this.#state = State.Failed;
       throw e;
     }
   }
 
   /** Processes server-final-message. */
-  receiveResponse(response: string) {
-    assert(this.state === State.ClientResponse);
-    assert(this.keys);
+  async receiveResponse(response: string) {
+    assert(this.#state === State.ClientResponse);
+    assert(this.#keys);
 
     try {
       const attrs = parseAttributes(response);
@@ -159,15 +159,15 @@ export class Client {
       }
 
       const verifier = base64.encode(
-        computeSignature(this.authMessage, this.keys.server),
+        await computeSignature(this.#authMessage, this.#keys.server),
       );
       if (attrs.v !== verifier) {
         throw new AuthError(Reason.BadVerifier);
       }
 
-      this.state = State.ServerResponse;
+      this.#state = State.ServerResponse;
     } catch (e) {
-      this.state = State.Failed;
+      this.#state = State.Failed;
       throw e;
     }
   }
@@ -210,21 +210,26 @@ interface Keys {
 }
 
 /** Derives authentication keys from a plaintext password. */
-function deriveKeys(
+async function deriveKeys(
   password: string,
   salt: Uint8Array,
   iterCount: number,
-): Keys {
+): Promise<Keys> {
   const ikm = bytes(normalize(password));
-  const key = pbkdf2((msg: Uint8Array) => sign(msg, ikm), salt, iterCount, 1);
-  const server = sign(bytes("Server Key"), key);
-  const client = sign(bytes("Client Key"), key);
-  const stored = digest(client);
+  const key = await pbkdf2(
+    (msg: Uint8Array) => sign(msg, ikm),
+    salt,
+    iterCount,
+    1,
+  );
+  const server = await sign(bytes("Server Key"), key);
+  const client = await sign(bytes("Client Key"), key);
+  const stored = new Uint8Array(await crypto.subtle.digest("SHA-256", client));
   return { server, client, stored };
 }
 
 /** Computes SCRAM signature. */
-function computeSignature(message: string, key: Key): Digest {
+function computeSignature(message: string, key: Key): Promise<Digest> {
   return sign(bytes(message), key);
 }
 
@@ -265,15 +270,11 @@ function escape(str: string): string {
     .replace(/,/g, "=2C");
 }
 
-/** Computes message digest. */
-function digest(msg: Uint8Array): Digest {
-  const hash = new Sha256();
-  hash.update(msg);
-  return new Uint8Array(hash.arrayBuffer());
-}
-
 /** Computes HMAC of a message using given key. */
-function sign(msg: Uint8Array, key: Key): Digest {
+// TODO
+// Migrate to crypto.subtle.sign on Deno 1.11
+// deno-lint-ignore require-await
+async function sign(msg: Uint8Array, key: Key): Promise<Digest> {
   const hmac = new HmacSha256(key);
   hmac.update(msg);
   return new Uint8Array(hmac.arrayBuffer());
@@ -283,23 +284,23 @@ function sign(msg: Uint8Array, key: Key): Digest {
  * Computes a PBKDF2 key block.
  * @see {@link https://tools.ietf.org/html/rfc2898}
  */
-function pbkdf2(
-  prf: (_: Uint8Array) => Digest,
+async function pbkdf2(
+  prf: (_: Uint8Array) => Promise<Digest>,
   salt: Uint8Array,
   iterCount: number,
   index: number,
-): Key {
+): Promise<Key> {
   let block = new Uint8Array(salt.length + 4);
   block.set(salt);
   block[salt.length + 0] = (index >> 24) & 0xFF;
   block[salt.length + 1] = (index >> 16) & 0xFF;
   block[salt.length + 2] = (index >> 8) & 0xFF;
   block[salt.length + 3] = index & 0xFF;
-  block = prf(block);
+  block = await prf(block);
 
   const key = block;
   for (let r = 1; r < iterCount; r++) {
-    block = prf(block);
+    block = await prf(block);
     for (let i = 0; i < key.length; i++) {
       key[i] ^= block[i];
     }
diff --git a/connection/warning.ts b/connection/warning.ts
index bd0339ed..44be6b7b 100644
--- a/connection/warning.ts
+++ b/connection/warning.ts
@@ -1,4 +1,17 @@
-import type { Message } from "./connection.ts";
+// deno-lint-ignore-file camelcase
+import { PacketReader } from "./packet_reader.ts";
+
+export class Message {
+  public reader: PacketReader;
+
+  constructor(
+    public type: string,
+    public byteCount: number,
+    public body: Uint8Array,
+  ) {
+    this.reader = new PacketReader(body);
+  }
+}
 
 export interface WarningFields {
   severity: string;
@@ -20,6 +33,8 @@ export interface WarningFields {
   routine?: string;
 }
 
+export class ConnectionError extends Error {}
+
 export class PostgresError extends Error {
   public fields: WarningFields;
 
@@ -34,7 +49,6 @@ export class PostgresError extends Error {
 // Use error cause once it's added to JavaScript
 export class TransactionError extends Error {
   constructor(
-    // deno-lint-ignore camelcase
     transaction_name: string,
     public cause: PostgresError,
   ) {
diff --git a/deps.ts b/deps.ts
index 72ba9444..55a5b78d 100644
--- a/deps.ts
+++ b/deps.ts
@@ -1,11 +1,8 @@
-export { BufReader, BufWriter } from "https://deno.land/std@0.93.0/io/bufio.ts";
-export { copy } from "https://deno.land/std@0.93.0/bytes/mod.ts";
-export { createHash } from "https://deno.land/std@0.93.0/hash/mod.ts";
-export {
-  HmacSha256,
-  Sha256,
-} from "https://deno.land/std@0.93.0/hash/sha256.ts";
-export * as base64 from "https://deno.land/std@0.93.0/encoding/base64.ts";
-export { deferred, delay } from "https://deno.land/std@0.93.0/async/mod.ts";
-export type { Deferred } from "https://deno.land/std@0.93.0/async/mod.ts";
-export { bold, yellow } from "https://deno.land/std@0.93.0/fmt/colors.ts";
+export { BufReader, BufWriter } from "https://deno.land/std@0.98.0/io/bufio.ts";
+export { copy } from "https://deno.land/std@0.98.0/bytes/mod.ts";
+export { createHash } from "https://deno.land/std@0.98.0/hash/mod.ts";
+export { HmacSha256 } from "https://deno.land/std@0.98.0/hash/sha256.ts";
+export * as base64 from "https://deno.land/std@0.98.0/encoding/base64.ts";
+export { deferred, delay } from "https://deno.land/std@0.98.0/async/mod.ts";
+export type { Deferred } from "https://deno.land/std@0.98.0/async/mod.ts";
+export { bold, yellow } from "https://deno.land/std@0.98.0/fmt/colors.ts";
diff --git a/docker-compose.yml b/docker-compose.yml
index 3dd7a0e4..c3e25829 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -11,6 +11,8 @@ services:
     volumes:
       - ./docker/postgres/data/:/var/lib/postgresql/host/
       - ./docker/postgres/init/:/docker-entrypoint-initdb.d/
+    ports:
+      - "6001:5432"
   postgres_scram:
     image: postgres
     hostname: postgres_scram
@@ -23,13 +25,28 @@ services:
     volumes:
       - ./docker/postgres_scram/data/:/var/lib/postgresql/host/
       - ./docker/postgres_scram/init/:/docker-entrypoint-initdb.d/
+    ports:
+      - "6002:5432"
+  postgres_invalid_tls:
+    image: postgres
+    hostname: postgres_invalid_tls
+    environment:
+      - POSTGRES_DB=postgres
+      - POSTGRES_PASSWORD=postgres
+      - POSTGRES_USER=postgres
+    volumes:
+      - ./docker/postgres_invalid_tls/data/:/var/lib/postgresql/host/
+      - ./docker/postgres_invalid_tls/init/:/docker-entrypoint-initdb.d/
+    ports:
+      - "6003:5432"
   tests:
     build: .
     depends_on:
       - postgres
       - postgres_scram
+      - postgres_invalid_tls
     environment:
-      - WAIT_HOSTS=postgres:5432,postgres_scram:5432
+      - WAIT_HOSTS=postgres:5432,postgres_scram:5432,postgres_invalid_tls:5432
       # Wait thirty seconds after database goes online
       # For database metadata initialization
       - WAIT_AFTER_HOSTS=15
diff --git a/docker/postgres/data/pg_hba.conf b/docker/postgres/data/pg_hba.conf
old mode 100644
new mode 100755
index ca7efe5a..4e4c3e53
--- a/docker/postgres/data/pg_hba.conf
+++ b/docker/postgres/data/pg_hba.conf
@@ -1,3 +1,3 @@
-hostnossl  all         postgres    0.0.0.0/0  md5
-hostnossl  postgres    clear       0.0.0.0/0  password
-hostnossl  postgres    md5         0.0.0.0/0  md5
+hostnossl  all         postgres              0.0.0.0/0  md5
+hostnossl  postgres    clear                 0.0.0.0/0  password
+hostnossl  postgres    md5                   0.0.0.0/0  md5
diff --git a/docker/postgres/data/postgresql.conf b/docker/postgres/data/postgresql.conf
old mode 100644
new mode 100755
index 91f4196c..2a20969c
--- a/docker/postgres/data/postgresql.conf
+++ b/docker/postgres/data/postgresql.conf
@@ -1,3 +1 @@
 ssl = off
-# ssl_cert_file = 'server.crt'
-# ssl_key_file = 'server.key'
\ No newline at end of file
diff --git a/docker/postgres/init/initialize_test_server.sh b/docker/postgres/init/initialize_test_server.sh
index 2bba73f0..ac0e7636 100644
--- a/docker/postgres/init/initialize_test_server.sh
+++ b/docker/postgres/init/initialize_test_server.sh
@@ -1,4 +1,2 @@
 cat /var/lib/postgresql/host/postgresql.conf >> /var/lib/postgresql/data/postgresql.conf
 cp /var/lib/postgresql/host/pg_hba.conf /var/lib/postgresql/data
-# chmod 600 /var/lib/postgresql/data/server.crt
-# chmod 600 /var/lib/postgresql/data/server.key
\ No newline at end of file
diff --git a/docker/postgres_invalid_tls/data/pg_hba.conf b/docker/postgres_invalid_tls/data/pg_hba.conf
new file mode 100755
index 00000000..02c4591a
--- /dev/null
+++ b/docker/postgres_invalid_tls/data/pg_hba.conf
@@ -0,0 +1 @@
+hostssl    postgres    postgres   0.0.0.0/0  md5
diff --git a/docker/postgres_invalid_tls/data/postgresql.conf b/docker/postgres_invalid_tls/data/postgresql.conf
new file mode 100755
index 00000000..c94e3a22
--- /dev/null
+++ b/docker/postgres_invalid_tls/data/postgresql.conf
@@ -0,0 +1,3 @@
+ssl = on
+ssl_cert_file = 'server.crt'
+ssl_key_file = 'server.key'
diff --git a/docker/postgres_invalid_tls/init/initialize_test_server.sh b/docker/postgres_invalid_tls/init/initialize_test_server.sh
new file mode 100644
index 00000000..403b4cd3
--- /dev/null
+++ b/docker/postgres_invalid_tls/init/initialize_test_server.sh
@@ -0,0 +1,8 @@
+cat /var/lib/postgresql/host/postgresql.conf >> /var/lib/postgresql/data/postgresql.conf
+cp /var/lib/postgresql/host/pg_hba.conf /var/lib/postgresql/data
+openssl genrsa -out /var/lib/postgresql/data/server.key 2048
+openssl req -new -key /var/lib/postgresql/data/server.key -out /var/lib/postgresql/data/server.csr -subj "/C=CO/ST=Cundinamarca/L=Bogota/O=deno-postgres.com/CN=deno-postgres.com"
+openssl rsa -in /var/lib/postgresql/data/server.key -out /var/lib/postgresql/data/server.key
+openssl x509 -req -days 365 -in /var/lib/postgresql/data/server.csr -signkey /var/lib/postgresql/data/server.key -out /var/lib/postgresql/data/server.crt -sha256
+chmod 600 /var/lib/postgresql/data/server.crt
+chmod 600 /var/lib/postgresql/data/server.key
diff --git a/docker/postgres_invalid_tls/init/initialize_test_server.sql b/docker/postgres_invalid_tls/init/initialize_test_server.sql
new file mode 100644
index 00000000..e69de29b
diff --git a/docs/README.md b/docs/README.md
index adda3b18..af5a155b 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -3,7 +3,7 @@
 ![Build Status](https://img.shields.io/github/workflow/status/denodrivers/postgres/ci?label=Build&logo=github&style=flat-square)
 [![Discord server](https://img.shields.io/discord/768918486575480863?color=blue&label=Ask%20for%20help%20here&logo=discord&style=flat-square)](https://discord.gg/HEdTCvZUSf)
 ![Manual](https://img.shields.io/github/v/release/denodrivers/postgres?color=orange&label=Manual&logo=deno&style=flat-square)
-[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.11.3/mod.ts)
+[![Documentation](https://img.shields.io/github/v/release/denodrivers/postgres?color=yellow&label=Documentation&logo=deno&style=flat-square)](https://doc.deno.land/https/deno.land/x/postgres@v0.12.0/mod.ts)
 ![License](https://img.shields.io/github/license/denodrivers/postgres?color=yellowgreen&label=License&style=flat-square)
 
 `deno-postgres` is a lightweight PostgreSQL driver for Deno focused on user
@@ -32,7 +32,10 @@ await client.end();
 
 ## Connection Management
 
-### Connecting to DB
+### Connecting to your DB
+
+All `deno-postgres` clients provide the following options to authenticate and
+manage your connections
 
 ```ts
 import { Client } from "https://deno.land/x/postgres/mod.ts";
@@ -42,6 +45,9 @@ let config;
 // You can use the connection interface to set the connection properties
 config = {
   applicationName: "my_custom_app",
+  connection: {
+    attempts: 1,
+  },
   database: "test",
   hostname: "localhost",
   password: "password",
@@ -61,25 +67,61 @@ await client.connect();
 await client.end();
 ```
 
-The values required to connect to the database can be read directly from
-environmental variables, given the case that the user doesn't provide them while
-initializing the client. The only requirement for this variables to be read is
-for Deno to be run with `--allow-env` permissions
+#### Database reconnection
 
-The env variables that the client will recognize are taken from `libpq` to keep
-consistency with other PostgreSQL clients out there (see
-https://www.postgresql.org/docs/current/libpq-envars.html)
+It's a very common occurrence to get broken connections due to connectivity
+issues or OS related problems, however while this may be a minor inconvenience
+in development, it becomes a serious matter in a production environment if not
+handled correctly. To mitigate the impact of disconnected clients
+`deno-postgres` allows the developer to stablish a new connection with the
+database automatically before executing a query on a broken connection.
+
+To manage the number of reconnection attempts, adjust the `connection.attempts`
+parameter in your client options. Every client will default to one try before
+throwing a disconnection error.
 
 ```ts
-// PGUSER=user PGPASSWORD=admin PGDATABASE=test deno run --allow-net --allow-env --unstable database.js
-import { Client } from "https://deno.land/x/postgres/mod.ts";
+try {
+  // We will forcefully close our current connection
+  await client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`;
+} catch (e) {
+  // Manage the error
+}
 
-const client = new Client();
-await client.connect();
-await client.end();
+// The client will reconnect silently before running the query
+await client.queryArray`SELECT 1`;
+```
+
+If automatic reconnection is not desired, the developer can simply set the
+number of attempts to zero and manage connection and reconnection manually
+
+```ts
+const client = new Client({
+  connection: {
+    attempts: 0,
+  },
+});
+
+try {
+  await runQueryThatWillFailBecauseDisconnection();
+  // From here on now, the client will be marked as "disconnected"
+} catch (e) {
+  if (e instanceof ConnectionError) {
+    // Reconnect manually
+    await client.connect();
+  } else {
+    throw e;
+  }
+}
 ```
 
-### SSL/TLS connection
+Your initial connection will also be affected by this setting, in a slightly
+different manner than already active errored connections. If you fail to connect
+to your database in the first attempt, the client will keep trying to connect as
+many times as requested, meaning that if your attempt configuration is three,
+your total first-connection-attempts will ammount to four.
+
+#### SSL/TLS connection
 
 Using a database that supports TLS is quite simple. After providing your
 connection parameters, the client will check if the database accepts encrypted
@@ -102,7 +144,42 @@ possible without the `Deno.startTls` API, which is currently marked as unstable.
 This is a situation that will be solved once this API is stabilized, however I
 don't have an estimated time of when that might happen.
 
-### Clients
+##### About invalid TLS certificates
+
+There is a miriad of factors you have to take into account when using a
+certificate to encrypt your connection that, if not taken care of, can render
+your certificate invalid. Deno is specially strict when stablishing a TLS
+connection, rendering self-signed certificates unusable at the time.
+
+Work is being done in order to address the needs of those users who need to use
+said certificates, however as a personal piece of advice I recommend you to not
+use TLS at all if you are going to use a non-secure certificate, specially on a
+publicly reachable server.
+
+TLS can be disabled from your server by editing your `postgresql.conf` file and
+setting the `ssl` option to `off`.
+
+#### Env parameters
+
+The values required to connect to the database can be read directly from
+environmental variables, given the case that the user doesn't provide them while
+initializing the client. The only requirement for this variables to be read is
+for Deno to be run with `--allow-env` permissions
+
+The env variables that the client will recognize are taken from `libpq` to keep
+consistency with other PostgreSQL clients out there (see
+https://www.postgresql.org/docs/current/libpq-envars.html)
+
+```ts
+// PGUSER=user PGPASSWORD=admin PGDATABASE=test deno run --allow-net --allow-env --unstable database.js
+import { Client } from "https://deno.land/x/postgres/mod.ts";
+
+const client = new Client();
+await client.connect();
+await client.end();
+```
+
+### Clients (Single clients)
 
 Clients are the most basic block for establishing communication with your
 database. They provide abstractions over queries, transactions and connection
@@ -233,8 +310,11 @@ single function call
 ```ts
 async function runQuery(query: string) {
   const client = await pool.connect();
-  const result = await client.queryObject(query);
-  client.release();
+  try {
+    const result = await client.queryObject(query);
+  } finally {
+    client.release();
+  }
   return result;
 }
 
@@ -427,8 +507,9 @@ Other aspects to take into account when using the `fields` argument:
 
 - The fields will be matched in the order they were declared
 - The fields will override any alias in the query
-- These field properties must be unique (case insensitive), otherwise the query
-  will throw before execution
+- These field properties must be unique otherwise the query will throw before
+  execution
+- The fields must not have special characters and not start with a number
 - The fields must match the number of fields returned on the query, otherwise
   the query will throw on execution
 
diff --git a/docs/index.html b/docs/index.html
index 19accf53..066d193f 100644
--- a/docs/index.html
+++ b/docs/index.html
@@ -4,7 +4,7 @@
   <meta charset="UTF-8">
   <title>Deno Postgres</title>
   <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
-  <meta name="description" content="Description">
+  <meta name="description" content="🦕 Lightweight PostgreSQL driver for Deno focused on user experience">
   <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
   <link rel="stylesheet" href="//unpkg.com/docsify/lib/themes/vue.css">
 </head>
diff --git a/mod.ts b/mod.ts
index 9e22e5da..d921f6e3 100644
--- a/mod.ts
+++ b/mod.ts
@@ -1,15 +1,17 @@
 export { Client } from "./client.ts";
-export { PostgresError } from "./connection/warning.ts";
+export { ConnectionError, PostgresError } from "./connection/warning.ts";
 export { Pool } from "./pool.ts";
 
 // TODO
 // Remove the following reexports after https://doc.deno.land
 // supports two level depth exports
 export type {
+  ClientOptions,
   ConnectionOptions,
   ConnectionString,
   TLSOptions,
 } from "./connection/connection_params.ts";
+export type { Session } from "./client.ts";
 export { PoolClient, QueryClient } from "./client.ts";
 export type { QueryConfig, QueryObjectConfig } from "./query/query.ts";
 export { Savepoint, Transaction } from "./query/transaction.ts";
diff --git a/pool.ts b/pool.ts
index 1b989471..58659a4d 100644
--- a/pool.ts
+++ b/pool.ts
@@ -1,19 +1,19 @@
+// deno-lint-ignore-file camelcase
 import { PoolClient } from "./client.ts";
-import { Connection } from "./connection/connection.ts";
 import {
-  ConnectionOptions,
-  ConnectionParams,
+  ClientConfiguration,
+  ClientOptions,
   ConnectionString,
   createParams,
 } from "./connection/connection_params.ts";
-import { DeferredStack } from "./connection/deferred.ts";
+import { DeferredAccessStack } from "./utils/deferred.ts";
 
 /**
  * Connection pools are a powerful resource to execute parallel queries and
  * save up time in connection initialization. It is highly recommended that all
  * applications that require concurrent access use a pool to communicate
  * with their PostgreSQL database
- * 
+ *
  * ```ts
  * const pool = new Pool({
  *   database: "database",
@@ -22,31 +22,31 @@ import { DeferredStack } from "./connection/deferred.ts";
  *   port: 5432,
  *   user: "user",
  * }, 10); // Creates a pool with 10 available connections
- * 
+ *
  * const client = await pool.connect();
  * await client.queryArray`SELECT 1`;
  * await client.release();
  * ```
- * 
+ *
  * You can also opt to not initialize all your connections at once by passing the `lazy`
  * option when instantiating your pool, this is useful to reduce startup time. In
  * addition to this, the pool won't start the connection unless there isn't any already
  * available connections in the pool
- * 
+ *
  * ```ts
  * // Creates a pool with 10 max available connections
  * // Connection with the database won't be established until the user requires it
  * const pool = new Pool(connection_params, 10, true);
- * 
+ *
  * // Connection is created here, will be available from now on
  * const client_1 = await pool.connect();
  * await client_1.queryArray`SELECT 1`;
  * await client_1.release();
- * 
+ *
  * // Same connection as before, will be reused instead of starting a new one
  * const client_2 = await pool.connect();
  * await client_2.queryArray`SELECT 1`;
- * 
+ *
  * // New connection, since previous one is still in use
  * // There will be two open connections available from now on
  * const client_3 = await pool.connect();
@@ -55,47 +55,65 @@ import { DeferredStack } from "./connection/deferred.ts";
  * ```
  */
 export class Pool {
-  #available_connections: DeferredStack<Connection> | null = null;
-  #connection_params: ConnectionParams;
+  #available_connections?: DeferredAccessStack<PoolClient>;
+  #connection_params: ClientConfiguration;
   #ended = false;
   #lazy: boolean;
-  #max_size: number;
   // TODO
   // Initialization should probably have a timeout
   #ready: Promise<void>;
-
-  constructor(
-    // deno-lint-ignore camelcase
-    connection_params: ConnectionOptions | ConnectionString | undefined,
-    // deno-lint-ignore camelcase
-    max_size: number,
-    lazy: boolean = false,
-  ) {
-    this.#connection_params = createParams(connection_params);
-    this.#lazy = lazy;
-    this.#max_size = max_size;
-    this.#ready = this.#initialize();
-  }
+  #size: number;
 
   /**
    * The number of open connections available for use
-   * 
+   *
    * Lazily initialized pools won't have any open connections by default
    */
   get available(): number {
-    if (this.#available_connections == null) {
+    if (!this.#available_connections) {
       return 0;
     }
     return this.#available_connections.available;
   }
 
+  /**
+   * The number of total connections open in the pool
+   *
+   * Both available and in use connections will be counted
+   */
+  get size(): number {
+    if (!this.#available_connections) {
+      return 0;
+    }
+    return this.#available_connections.size;
+  }
+
+  constructor(
+    connection_params: ClientOptions | ConnectionString | undefined,
+    size: number,
+    lazy: boolean = false,
+  ) {
+    this.#connection_params = createParams(connection_params);
+    this.#lazy = lazy;
+    this.#size = size;
+
+    // This must ALWAYS be called the last
+    // TODO
+    // Refactor into its own initialization function
+    this.#ready = this.#initialize();
+  }
+
+  // TODO
+  // Rename to getClient or similar
+  // The connect method should initialize the connections instead of doing it
+  // in the constructor
   /**
    * This will return a new client from the available connections in
    * the pool
-   * 
+   *
    * In the case of lazy initialized pools, a new connection will be established
    * with the database if no other connections are available
-   * 
+   *
    * ```ts
    * const client = pool.connect();
    * await client.queryArray`UPDATE MY_TABLE SET X = 1`;
@@ -109,29 +127,21 @@ export class Pool {
     }
 
     await this.#ready;
-    const connection = await this.#available_connections!.pop();
-    const release = () => this.#available_connections!.push(connection);
-    return new PoolClient(connection, release);
+    return this.#available_connections!.pop();
   }
 
-  #createConnection = async (): Promise<Connection> => {
-    const connection = new Connection(this.#connection_params);
-    await connection.startup();
-    return connection;
-  };
-
   /**
    * This will close all open connections and set a terminated status in the pool
-   * 
+   *
    * ```ts
    * await pool.end();
    * assertEquals(pool.available, 0);
    * await pool.end(); // An exception will be thrown, pool doesn't have any connections to close
    * ```
-   * 
+   *
    * However, a terminated pool can be reused by using the "connect" method, which
    * will reinitialize the connections according to the original configuration of the pool
-   * 
+   *
    * ```ts
    * await pool.end();
    * const client = await pool.connect();
@@ -146,39 +156,54 @@ export class Pool {
 
     await this.#ready;
     while (this.available > 0) {
-      const conn = await this.#available_connections!.pop();
-      await conn.end();
+      const client = await this.#available_connections!.pop();
+      await client.end();
     }
 
-    this.#available_connections = null;
+    this.#available_connections = undefined;
     this.#ended = true;
   }
 
-  #initialize = async (): Promise<void> => {
-    const initSize = this.#lazy ? 0 : this.#max_size;
-    const connections = Array.from(
-      { length: initSize },
-      () => this.#createConnection(),
+  /**
+   * Initialization will create all pool clients instances by default
+   *
+   * If the pool is lazily initialized, the clients will connect when they
+   * are requested by the user, otherwise they will all connect on initialization
+   */
+  async #initialize() {
+    const initialized = this.#lazy ? 0 : this.#size;
+    const clients = Array.from(
+      { length: this.#size },
+      async (_e, index) => {
+        const client: PoolClient = new PoolClient(
+          this.#connection_params,
+          () => this.#available_connections!.push(client),
+        );
+
+        if (index < initialized) {
+          await client.connect();
+        }
+
+        return client;
+      },
     );
 
-    this.#available_connections = new DeferredStack(
-      this.#max_size,
-      await Promise.all(connections),
-      this.#createConnection.bind(this),
+    this.#available_connections = new DeferredAccessStack(
+      await Promise.all(clients),
+      (client) => client.connect(),
+      (client) => client.connected,
     );
 
     this.#ended = false;
-  };
-
-  /**
-   * The number of total connections open in the pool
-   * 
-   * Both available and in use connections will be counted
+  } /**
+   * This will return the number of initialized clients in the pool
    */
-  get size(): number {
-    if (this.#available_connections == null) {
+
+  async initialized(): Promise<number> {
+    if (!this.#available_connections) {
       return 0;
     }
-    return this.#available_connections.size;
+
+    return await this.#available_connections.initialized();
   }
 }
diff --git a/query/array_parser.ts b/query/array_parser.ts
index 0cc06bb8..66f484fa 100644
--- a/query/array_parser.ts
+++ b/query/array_parser.ts
@@ -76,7 +76,7 @@ class ArrayParser<T> {
   /**
    * Arrays can contain items separated by semicolon (such as boxes)
    * and commas
-   * 
+   *
    * This checks if there is an instance of a semicolon on the top level
    * of the array. If it were to be found, the separator will be
    * a semicolon, otherwise it will default to a comma
diff --git a/query/decode.ts b/query/decode.ts
index 2ebe9993..b33ee839 100644
--- a/query/decode.ts
+++ b/query/decode.ts
@@ -1,5 +1,4 @@
 import { Oid } from "./oid.ts";
-import { Column, Format } from "../connection/connection.ts";
 import {
   decodeBigint,
   decodeBigintArray,
@@ -34,6 +33,23 @@ import {
   decodeTidArray,
 } from "./decoders.ts";
 
+export class Column {
+  constructor(
+    public name: string,
+    public tableOid: number,
+    public index: number,
+    public typeOid: number,
+    public columnLength: number,
+    public typeModifier: number,
+    public format: Format,
+  ) {}
+}
+
+enum Format {
+  TEXT = 0,
+  BINARY = 1,
+}
+
 const decoder = new TextDecoder();
 
 function decodeBinary() {
diff --git a/query/decoders.ts b/query/decoders.ts
index 40273ff2..e5373345 100644
--- a/query/decoders.ts
+++ b/query/decoders.ts
@@ -106,11 +106,11 @@ function decodeByteaHex(byteaStr: string): Uint8Array {
 export function decodeCircle(value: string): Circle {
   const [point, radius] = value.substring(1, value.length - 1).split(
     /,(?![^(]*\))/,
-  );
+  ) as [string, Float8];
 
   return {
     point: decodePoint(point),
-    radius: radius as Float8,
+    radius: radius,
   };
 }
 
@@ -217,12 +217,16 @@ export function decodeJsonArray(value: string): unknown[] {
 }
 
 export function decodeLine(value: string): Line {
-  const [a, b, c] = value.substring(1, value.length - 1).split(",");
+  const [a, b, c] = value.substring(1, value.length - 1).split(",") as [
+    Float8,
+    Float8,
+    Float8,
+  ];
 
   return {
-    a: a as Float8,
-    b: b as Float8,
-    c: c as Float8,
+    a: a,
+    b: b,
+    c: c,
   };
 }
 
@@ -258,7 +262,10 @@ export function decodePathArray(value: string) {
 }
 
 export function decodePoint(value: string): Point {
-  const [x, y] = value.substring(1, value.length - 1).split(",");
+  const [x, y] = value.substring(1, value.length - 1).split(",") as [
+    Float8,
+    Float8,
+  ];
 
   if (Number.isNaN(parseFloat(x)) || Number.isNaN(parseFloat(y))) {
     throw new Error(
@@ -267,8 +274,8 @@ export function decodePoint(value: string): Point {
   }
 
   return {
-    x: x as Float8,
-    y: y as Float8,
+    x: x,
+    y: y,
   };
 }
 
diff --git a/query/encode.ts b/query/encode.ts
index 50e35dee..df736913 100644
--- a/query/encode.ts
+++ b/query/encode.ts
@@ -74,7 +74,7 @@ function encodeArray(array: Array<unknown>): string {
 
 function encodeBytes(value: Uint8Array): string {
   const hex = Array.from(value)
-    .map((val) => (val < 10 ? `0${val.toString(16)}` : val.toString(16)))
+    .map((val) => (val < 0x10 ? `0${val.toString(16)}` : val.toString(16)))
     .join("");
   return `\\x${hex}`;
 }
@@ -93,7 +93,6 @@ export function encode(value: unknown): EncodedArg {
   } else if (value instanceof Object) {
     return JSON.stringify(value);
   } else {
-    // deno-lint-ignore no-explicit-any
-    return (value as any).toString();
+    return String(value);
   }
 }
diff --git a/query/oid.ts b/query/oid.ts
index 06b6b657..7d56460f 100644
--- a/query/oid.ts
+++ b/query/oid.ts
@@ -1,3 +1,4 @@
+// deno-lint-ignore-file camelcase
 export const Oid = {
   bool: 16,
   bytea: 17,
@@ -7,7 +8,6 @@ export const Oid = {
   name: 19,
   int8: 20,
   int2: 21,
-  // deno-lint-ignore camelcase
   _int2vector_0: 22,
   int4: 23,
   regproc: 24,
@@ -15,31 +15,19 @@ export const Oid = {
   oid: 26,
   tid: 27,
   xid: 28,
-  // deno-lint-ignore camelcase
   _cid_0: 29,
-  // deno-lint-ignore camelcase
   _oidvector_0: 30,
-  // deno-lint-ignore camelcase
   _pg_ddl_command: 32,
-  // deno-lint-ignore camelcase
   _pg_type: 71,
-  // deno-lint-ignore camelcase
   _pg_attribute: 75,
-  // deno-lint-ignore camelcase
   _pg_proc: 81,
-  // deno-lint-ignore camelcase
   _pg_class: 83,
   json: 114,
-  // deno-lint-ignore camelcase
   _xml_0: 142,
-  // deno-lint-ignore camelcase
   _xml_1: 143,
-  // deno-lint-ignore camelcase
   _pg_node_tree: 194,
-  // deno-lint-ignore camelcase
   json_array: 199,
   _smgr: 210,
-  // deno-lint-ignore camelcase
   _index_am_handler: 325,
   point: 600,
   lseg: 601,
@@ -47,238 +35,140 @@ export const Oid = {
   box: 603,
   polygon: 604,
   line: 628,
-  // deno-lint-ignore camelcase
   line_array: 629,
   cidr: 650,
-  // deno-lint-ignore camelcase
   cidr_array: 651,
   float4: 700,
   float8: 701,
-  // deno-lint-ignore camelcase
   _abstime_0: 702,
-  // deno-lint-ignore camelcase
   _reltime_0: 703,
-  // deno-lint-ignore camelcase
   _tinterval_0: 704,
   _unknown: 705,
   circle: 718,
-  // deno-lint-ignore camelcase
   circle_array: 719,
-  // deno-lint-ignore camelcase
   _money_0: 790,
-  // deno-lint-ignore camelcase
   _money_1: 791,
   macaddr: 829,
   inet: 869,
-  // deno-lint-ignore camelcase
   bool_array: 1000,
-  // deno-lint-ignore camelcase
   byte_array: 1001,
   // TODO
   // Find out how to test char types
-  // deno-lint-ignore camelcase
   char_array: 1002,
-  // deno-lint-ignore camelcase
   name_array: 1003,
-  // deno-lint-ignore camelcase
   int2_array: 1005,
-  // deno-lint-ignore camelcase
   _int2vector_1: 1006,
-  // deno-lint-ignore camelcase
   int4_array: 1007,
-  // deno-lint-ignore camelcase
   regproc_array: 1008,
-  // deno-lint-ignore camelcase
   text_array: 1009,
-  // deno-lint-ignore camelcase
   tid_array: 1010,
-  // deno-lint-ignore camelcase
   xid_array: 1011,
-  // deno-lint-ignore camelcase
   _cid_1: 1012,
-  // deno-lint-ignore camelcase
   _oidvector_1: 1013,
-  // deno-lint-ignore camelcase
   bpchar_array: 1014,
-  // deno-lint-ignore camelcase
   varchar_array: 1015,
-  // deno-lint-ignore camelcase
   int8_array: 1016,
-  // deno-lint-ignore camelcase
   point_array: 1017,
-  // deno-lint-ignore camelcase
   lseg_array: 1018,
-  // deno-lint-ignore camelcase
   path_array: 1019,
-  // deno-lint-ignore camelcase
   box_array: 1020,
-  // deno-lint-ignore camelcase
   float4_array: 1021,
-  // deno-lint-ignore camelcase
   float8_array: 1022,
-  // deno-lint-ignore camelcase
   _abstime_1: 1023,
-  // deno-lint-ignore camelcase
   _reltime_1: 1024,
-  // deno-lint-ignore camelcase
   _tinterval_1: 1025,
-  // deno-lint-ignore camelcase
   polygon_array: 1027,
-  // deno-lint-ignore camelcase
   oid_array: 1028,
-  // deno-lint-ignore camelcase
   _aclitem_0: 1033,
-  // deno-lint-ignore camelcase
   _aclitem_1: 1034,
-  // deno-lint-ignore camelcase
   macaddr_array: 1040,
-  // deno-lint-ignore camelcase
   inet_array: 1041,
   bpchar: 1042,
   varchar: 1043,
   date: 1082,
   time: 1083,
   timestamp: 1114,
-  // deno-lint-ignore camelcase
   timestamp_array: 1115,
-  // deno-lint-ignore camelcase
   date_array: 1182,
-  // deno-lint-ignore camelcase
   time_array: 1183,
   timestamptz: 1184,
-  // deno-lint-ignore camelcase
   timestamptz_array: 1185,
-  // deno-lint-ignore camelcase
   _interval_0: 1186,
-  // deno-lint-ignore camelcase
   _interval_1: 1187,
-  // deno-lint-ignore camelcase
   numeric_array: 1231,
-  // deno-lint-ignore camelcase
   _pg_database: 1248,
-  // deno-lint-ignore camelcase
   _cstring_0: 1263,
   timetz: 1266,
-  // deno-lint-ignore camelcase
   timetz_array: 1270,
-  // deno-lint-ignore camelcase
   _bit_0: 1560,
-  // deno-lint-ignore camelcase
   _bit_1: 1561,
-  // deno-lint-ignore camelcase
   _varbit_0: 1562,
-  // deno-lint-ignore camelcase
   _varbit_1: 1563,
   numeric: 1700,
-  // deno-lint-ignore camelcase
   _refcursor_0: 1790,
-  // deno-lint-ignore camelcase
   _refcursor_1: 2201,
   regprocedure: 2202,
   regoper: 2203,
   regoperator: 2204,
   regclass: 2205,
   regtype: 2206,
-  // deno-lint-ignore camelcase
   regprocedure_array: 2207,
-  // deno-lint-ignore camelcase
   regoper_array: 2208,
-  // deno-lint-ignore camelcase
   regoperator_array: 2209,
-  // deno-lint-ignore camelcase
   regclass_array: 2210,
-  // deno-lint-ignore camelcase
   regtype_array: 2211,
-  // deno-lint-ignore camelcase
   _record_0: 2249,
-  // deno-lint-ignore camelcase
   _cstring_1: 2275,
   _any: 2276,
   _anyarray: 2277,
   void: 2278,
   _trigger: 2279,
-  // deno-lint-ignore camelcase
   _language_handler: 2280,
   _internal: 2281,
   _opaque: 2282,
   _anyelement: 2283,
-  // deno-lint-ignore camelcase
   _record_1: 2287,
   _anynonarray: 2776,
-  // deno-lint-ignore camelcase
   _pg_authid: 2842,
-  // deno-lint-ignore camelcase
   _pg_auth_members: 2843,
-  // deno-lint-ignore camelcase
   _txid_snapshot_0: 2949,
   uuid: 2950,
-  // deno-lint-ignore camelcase
   uuid_varchar: 2951,
-  // deno-lint-ignore camelcase
   _txid_snapshot_1: 2970,
-  // deno-lint-ignore camelcase
   _fdw_handler: 3115,
-  // deno-lint-ignore camelcase
   _pg_lsn_0: 3220,
-  // deno-lint-ignore camelcase
   _pg_lsn_1: 3221,
-  // deno-lint-ignore camelcase
   _tsm_handler: 3310,
   _anyenum: 3500,
-  // deno-lint-ignore camelcase
   _tsvector_0: 3614,
-  // deno-lint-ignore camelcase
   _tsquery_0: 3615,
-  // deno-lint-ignore camelcase
   _gtsvector_0: 3642,
-  // deno-lint-ignore camelcase
   _tsvector_1: 3643,
-  // deno-lint-ignore camelcase
   _gtsvector_1: 3644,
-  // deno-lint-ignore camelcase
   _tsquery_1: 3645,
   regconfig: 3734,
-  // deno-lint-ignore camelcase
   regconfig_array: 3735,
   regdictionary: 3769,
-  // deno-lint-ignore camelcase
   regdictionary_array: 3770,
   jsonb: 3802,
-  // deno-lint-ignore camelcase
   jsonb_array: 3807,
   _anyrange: 3831,
-  // deno-lint-ignore camelcase
   _event_trigger: 3838,
-  // deno-lint-ignore camelcase
   _int4range_0: 3904,
-  // deno-lint-ignore camelcase
   _int4range_1: 3905,
-  // deno-lint-ignore camelcase
   _numrange_0: 3906,
-  // deno-lint-ignore camelcase
   _numrange_1: 3907,
-  // deno-lint-ignore camelcase
   _tsrange_0: 3908,
-  // deno-lint-ignore camelcase
   _tsrange_1: 3909,
-  // deno-lint-ignore camelcase
   _tstzrange_0: 3910,
-  // deno-lint-ignore camelcase
   _tstzrange_1: 3911,
-  // deno-lint-ignore camelcase
   _daterange_0: 3912,
-  // deno-lint-ignore camelcase
   _daterange_1: 3913,
-  // deno-lint-ignore camelcase
   _int8range_0: 3926,
-  // deno-lint-ignore camelcase
   _int8range_1: 3927,
-  // deno-lint-ignore camelcase
   _pg_shseclabel: 4066,
   regnamespace: 4089,
-  // deno-lint-ignore camelcase
   regnamespace_array: 4090,
   regrole: 4096,
-  // deno-lint-ignore camelcase
   regrole_array: 4097,
 };
diff --git a/query/query.ts b/query/query.ts
index 8530bbdc..360d9611 100644
--- a/query/query.ts
+++ b/query/query.ts
@@ -1,6 +1,6 @@
-import type { RowDescription } from "../connection/connection.ts";
+// deno-lint-ignore-file camelcase
 import { encode, EncodedArg } from "./encode.ts";
-import { decode } from "./decode.ts";
+import { Column, decode } from "./decode.ts";
 import { WarningFields } from "../connection/warning.ts";
 
 const commandTagRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;
@@ -20,9 +20,13 @@ export enum ResultType {
   OBJECT,
 }
 
+export class RowDescription {
+  constructor(public columnCount: number, public columns: Column[]) {}
+}
+
 /**
  * This function transforms template string arguments into a query
- * 
+ *
  * ```ts
  * ["SELECT NAME FROM TABLE WHERE ID = ", " AND DATE < "]
  * // "SELECT NAME FROM TABLE WHERE ID = $1 AND DATE < $2"
@@ -31,7 +35,6 @@ export enum ResultType {
 export function templateStringToQuery<T extends ResultType>(
   template: TemplateStringsArray,
   args: QueryArguments,
-  // deno-lint-ignore camelcase
   result_type: T,
 ): Query<T> {
   const text = template.reduce((curr, next, index) => {
@@ -51,11 +54,13 @@ export interface QueryConfig {
 export interface QueryObjectConfig extends QueryConfig {
   /**
    * This parameter superseeds query column names
-   * 
+   *
    * When specified, this names will be asigned to the results
    * of the query in the order they were provided
-   * 
-   * Fields must be unique (case is not taken into consideration)
+   *
+   * Fields must be unique and be in the range of (a-zA-Z0-9_), otherwise the query will throw before execution
+   *
+   * A field can not start with a number, just like JavaScript variables
    */
   fields?: string[];
 }
@@ -65,12 +70,12 @@ export interface QueryObjectConfig extends QueryConfig {
 // to a query
 /**
  * https://www.postgresql.org/docs/current/sql-prepare.html
- * 
+ *
  * This arguments will be appended to the prepared statement passed
  * as query
- * 
+ *
  * They will take the position according to the order in which they were provided
- * 
+ *
  * ```ts
  * await my_client.queryArray(
  *  "SELECT ID, NAME FROM PEOPLE WHERE AGE > $1 AND AGE < $2",
@@ -128,13 +133,15 @@ export class QueryArrayResult<T extends Array<unknown> = Array<unknown>>
   extends QueryResult {
   public rows: T[] = [];
 
-  // deno-lint-ignore camelcase
   insertRow(row_data: Uint8Array[]) {
-    if (this._done) {
-      throw new Error(
-        "Tried to add a new row to the result after the result is done reading",
-      );
-    }
+    // TODO
+    // Investigate multiple query status report
+    // INSERT INTO X VALUES (1); SELECT PG_TERMINATE_BACKEND(PID) triggers an error here
+    // if (this._done) {
+    //   throw new Error(
+    //     "Tried to add a new row to the result after the result is done reading",
+    //   );
+    // }
 
     if (!this.rowDescription) {
       throw new Error(
@@ -161,13 +168,15 @@ export class QueryObjectResult<
 > extends QueryResult {
   public rows: T[] = [];
 
-  // deno-lint-ignore camelcase
   insertRow(row_data: Uint8Array[]) {
-    if (this._done) {
-      throw new Error(
-        "Tried to add a new row to the result after the result is done reading",
-      );
-    }
+    // TODO
+    // Investigate multiple query status report
+    // INSERT INTO X VALUES (1); SELECT PG_TERMINATE_BACKEND(PID) triggers an error here
+    // if (this._done) {
+    //   throw new Error(
+    //     "Tried to add a new row to the result after the result is done reading",
+    //   );
+    // }
 
     if (!this.rowDescription) {
       throw new Error(
@@ -186,23 +195,26 @@ export class QueryObjectResult<
     }
 
     // Row description won't be modified after initialization
-    const row = row_data.reduce((row, raw_value, index) => {
-      const column = this.rowDescription!.columns[index];
-
-      // Find the field name provided by the user
-      // default to database provided name
-      const name = this.query.fields?.[index] ?? column.name;
-
-      if (raw_value === null) {
-        row[name] = null;
-      } else {
-        row[name] = decode(raw_value, column);
-      }
+    const row = row_data.reduce(
+      (row: Record<string, unknown>, raw_value, index) => {
+        const column = this.rowDescription!.columns[index];
+
+        // Find the field name provided by the user
+        // default to database provided name
+        const name = this.query.fields?.[index] ?? column.name;
+
+        if (raw_value === null) {
+          row[name] = null;
+        } else {
+          row[name] = decode(raw_value, column);
+        }
 
-      return row;
-    }, {} as Record<string, unknown>) as T;
+        return row;
+      },
+      {},
+    );
 
-    this.rows.push(row);
+    this.rows.push(row as T);
   }
 }
 
@@ -212,14 +224,10 @@ export class Query<T extends ResultType> {
   public result_type: ResultType;
   public text: string;
 
-  //deno-lint-ignore camelcase
-  constructor(_config: QueryObjectConfig, _result_type: T);
-  //deno-lint-ignore camelcase
-  constructor(_text: string, _result_type: T, ..._args: unknown[]);
+  constructor(config: QueryObjectConfig, result_type: T);
+  constructor(text: string, result_type: T, ...args: unknown[]);
   constructor(
-    //deno-lint-ignore camelcase
     config_or_text: string | QueryObjectConfig,
-    //deno-lint-ignore camelcase
     result_type: T,
     ...args: unknown[]
   ) {
@@ -231,17 +239,20 @@ export class Query<T extends ResultType> {
     } else {
       const {
         fields,
-        //deno-lint-ignore camelcase
         ...query_config
       } = config_or_text;
 
       // Check that the fields passed are valid and can be used to map
       // the result of the query
       if (fields) {
-        //deno-lint-ignore camelcase
-        const clean_fields = fields.map((field) =>
-          field.toString().toLowerCase()
+        const clean_fields = fields.filter((field) =>
+          /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(field)
         );
+        if (fields.length !== clean_fields.length) {
+          throw new TypeError(
+            "The fields provided for the query must contain only letters and underscores",
+          );
+        }
 
         if ((new Set(clean_fields)).size !== clean_fields.length) {
           throw new TypeError(
@@ -255,10 +266,10 @@ export class Query<T extends ResultType> {
       config = query_config;
     }
     this.text = config.text;
-    this.args = this._prepareArgs(config);
+    this.args = this.#prepareArgs(config);
   }
 
-  private _prepareArgs(config: QueryConfig): EncodedArg[] {
+  #prepareArgs(config: QueryConfig): EncodedArg[] {
     const encodingFn = config.encoder ? config.encoder : encode;
     return (config.args || []).map(encodingFn);
   }
diff --git a/query/transaction.ts b/query/transaction.ts
index 992b98ea..95244a85 100644
--- a/query/transaction.ts
+++ b/query/transaction.ts
@@ -1,3 +1,4 @@
+// deno-lint-ignore-file camelcase
 import type { QueryClient } from "../client.ts";
 import {
   Query,
@@ -10,7 +11,7 @@ import {
   ResultType,
   templateStringToQuery,
 } from "./query.ts";
-import { isTemplateString } from "../utils.ts";
+import { isTemplateString } from "../utils/utils.ts";
 import { PostgresError, TransactionError } from "../connection/warning.ts";
 
 export class Savepoint {
@@ -23,9 +24,7 @@ export class Savepoint {
 
   constructor(
     public readonly name: string,
-    // deno-lint-ignore camelcase
     update_callback: (name: string) => Promise<void>,
-    // deno-lint-ignore camelcase
     release_callback: (name: string) => Promise<void>,
   ) {
     this.#release_callback = release_callback;
@@ -38,22 +37,22 @@ export class Savepoint {
 
   /**
    * Releasing a savepoint will remove it's last instance in the transaction
-   * 
+   *
    * ```ts
    * const savepoint = await transaction.savepoint("n1");
    * await savepoint.release();
    * transaction.rollback(savepoint); // Error, can't rollback because the savepoint was released
    * ```
-   * 
+   *
    * It will also allow you to set the savepoint to the position it had before the last update
-   * 
+   *
    * * ```ts
    * const savepoint = await transaction.savepoint("n1");
    * await savepoint.update();
    * await savepoint.release(); // This drops the update of the last statement
    * transaction.rollback(savepoint); // Will rollback to the first instance of the savepoint
    * ```
-   * 
+   *
    * This function will throw if there are no savepoint instances to drop
    */
   async release() {
@@ -67,15 +66,15 @@ export class Savepoint {
 
   /**
    * Updating a savepoint will update its position in the transaction execution
-   * 
+   *
    * ```ts
    * const savepoint = await transaction.savepoint("n1");
    * transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES (${my_value})`;
    * await savepoint.update(); // Rolling back will now return you to this point on the transaction
    * ```
-   * 
+   *
    * You can also undo a savepoint update by using the `release` method
-   * 
+   *
    * ```ts
    * const savepoint = await transaction.savepoint("n1");
    * transaction.queryArray`DELETE FROM VERY_IMPORTANT_TABLE`;
@@ -93,16 +92,14 @@ export class Savepoint {
 type IsolationLevel = "read_committed" | "repeatable_read" | "serializable";
 
 export type TransactionOptions = {
-  // deno-lint-ignore camelcase
   isolation_level?: IsolationLevel;
-  // deno-lint-ignore camelcase
   read_only?: boolean;
   snapshot?: string;
 };
 
 export class Transaction {
   #client: QueryClient;
-  #executeQuery: (_query: Query<ResultType>) => Promise<QueryResult>;
+  #executeQuery: (query: Query<ResultType>) => Promise<QueryResult>;
   #isolation_level: IsolationLevel;
   #read_only: boolean;
   #savepoints: Savepoint[] = [];
@@ -113,9 +110,7 @@ export class Transaction {
     public name: string,
     options: TransactionOptions | undefined,
     client: QueryClient,
-    // deno-lint-ignore camelcase
-    execute_query_callback: (_query: Query<ResultType>) => Promise<QueryResult>,
-    // deno-lint-ignore camelcase
+    execute_query_callback: (query: Query<ResultType>) => Promise<QueryResult>,
     update_client_lock_callback: (name: string | null) => void,
   ) {
     this.#client = client;
@@ -137,17 +132,17 @@ export class Transaction {
   /**
    * This method will throw if the transaction opened in the client doesn't match this one
    */
-  #assertTransactionOpen = () => {
-    if (this.#client.current_transaction !== this.name) {
+  #assertTransactionOpen() {
+    if (this.#client.session.current_transaction !== this.name) {
       throw new Error(
         `This transaction has not been started yet, make sure to use the "begin" method to do so`,
       );
     }
-  };
+  }
 
-  #resetTransaction = () => {
+  #resetTransaction() {
     this.#savepoints = [];
-  };
+  }
 
   /**
    * The begin method will officially begin the transaction, and it must be called before
@@ -161,19 +156,18 @@ export class Transaction {
    * https://www.postgresql.org/docs/13/sql-begin.html
    */
   async begin() {
-    if (this.#client.current_transaction !== null) {
-      if (this.#client.current_transaction === this.name) {
+    if (this.#client.session.current_transaction !== null) {
+      if (this.#client.session.current_transaction === this.name) {
         throw new Error(
           "This transaction is already open",
         );
       }
 
       throw new Error(
-        `This client already has an ongoing transaction "${this.#client.current_transaction}"`,
+        `This client already has an ongoing transaction "${this.#client.session.current_transaction}"`,
       );
     }
 
-    // deno-lint-ignore camelcase
     let isolation_level;
     switch (this.#isolation_level) {
       case "read_committed": {
@@ -224,16 +218,16 @@ export class Transaction {
   /**
    * The commit method will make permanent all changes made to the database in the
    * current transaction and end the current transaction
-   * 
+   *
    * ```ts
    * await transaction.begin();
    * // Important operations
    * await transaction.commit(); // Will terminate the transaction and save all changes
    * ```
-   * 
+   *
    * The commit method allows you to specify a "chain" option, that allows you to both commit the current changes and
    * start a new with the same transaction parameters in a single statement
-   * 
+   *
    * ```ts
    * // ...
    * // Transaction operations I want to commit
@@ -241,7 +235,7 @@ export class Transaction {
    * await transaction.query`DELETE SOMETHING FROM SOMEWHERE`; // Still inside the transaction
    * await transaction.commit(); // The transaction finishes for good
    * ```
-   * 
+   *
    * https://www.postgresql.org/docs/13/sql-commit.html
    */
   async commit(options?: { chain?: boolean }) {
@@ -285,7 +279,7 @@ export class Transaction {
   /**
    * This method returns the snapshot id of the on going transaction, allowing you to share
    * the snapshot state between two transactions
-   * 
+   *
    * ```ts
    * const snapshot = await transaction_1.getSnapshot();
    * const transaction_2 = client_2.createTransaction("new_transaction", { isolation_level: "repeatable_read", snapshot });
@@ -304,22 +298,22 @@ export class Transaction {
   /**
    * This method allows executed queries to be retrieved as array entries.
    * It supports a generic interface in order to type the entries retrieved by the query
-   * 
+   *
    * ```ts
    * const {rows} = await transaction.queryArray(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<unknown[]>
    * ```
-   * 
+   *
    * You can pass type arguments to the query in order to hint TypeScript what the return value will be
    * ```ts
    * const {rows} = await transaction.queryArray<[number, string]>(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<[number, string]>
    * ```
-   * 
+   *
    * It also allows you to execute prepared stamements with template strings
-   * 
+   *
    * ```ts
    * const id = 12;
    * // Array<[number, string]>
@@ -338,7 +332,6 @@ export class Transaction {
     ...args: QueryArguments
   ): Promise<QueryArrayResult<T>>;
   async queryArray<T extends Array<unknown> = Array<unknown>>(
-    // deno-lint-ignore camelcase
     query_template_or_config: TemplateStringsArray | string | QueryConfig,
     ...args: QueryArguments
   ): Promise<QueryArrayResult<T>> {
@@ -376,37 +369,37 @@ export class Transaction {
   /**
    * This method allows executed queries to be retrieved as object entries.
    * It supports a generic interface in order to type the entries retrieved by the query
-   * 
+   *
    * ```ts
    * const {rows} = await transaction.queryObject(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Record<string, unknown>
-   * 
+   *
    * const {rows} = await transaction.queryObject<{id: number, name: string}>(
    *  "SELECT ID, NAME FROM CLIENTS"
    * ); // Array<{id: number, name: string}>
    * ```
-   * 
+   *
    * You can also map the expected results to object fields using the configuration interface.
    * This will be assigned in the order they were provided
-   * 
+   *
    * ```ts
    * const {rows} = await transaction.queryObject(
    *  "SELECT ID, NAME FROM CLIENTS"
    * );
-   * 
+   *
    * console.log(rows); // [{id: 78, name: "Frank"}, {id: 15, name: "Sarah"}]
-   * 
+   *
    * const {rows} = await transaction.queryObject({
    *  text: "SELECT ID, NAME FROM CLIENTS",
    *  fields: ["personal_id", "complete_name"],
    * });
-   * 
+   *
    * console.log(rows); // [{personal_id: 78, complete_name: "Frank"}, {personal_id: 15, complete_name: "Sarah"}]
    * ```
-   * 
+   *
    * It also allows you to execute prepared stamements with template strings
-   * 
+   *
    * ```ts
    * const id = 12;
    * // Array<{id: number, name: string}>
@@ -427,7 +420,6 @@ export class Transaction {
   async queryObject<
     T = Record<string, unknown>,
   >(
-    // deno-lint-ignore camelcase
     query_template_or_config:
       | string
       | QueryObjectConfig
@@ -471,17 +463,17 @@ export class Transaction {
   /**
    * Rollbacks are a mechanism to undo transaction operations without compromising the data that was modified during
    * the transaction
-   * 
+   *
    * A rollback can be executed the following way
    * ```ts
    * // ...
    * // Very very important operations that went very, very wrong
    * await transaction.rollback(); // Like nothing ever happened
    * ```
-   * 
+   *
    * Calling a rollback without arguments will terminate the current transaction and undo all changes,
    * but it can be used in conjuction with the savepoint feature to rollback specific changes like the following
-   * 
+   *
    * ```ts
    * // ...
    * // Important operations I don't want to rollback
@@ -491,10 +483,10 @@ export class Transaction {
    * // Everything that happened between the savepoint and the rollback gets undone
    * await transaction.commit(); // Commits all other changes
    * ```
-   * 
+   *
    * The rollback method allows you to specify a "chain" option, that allows you to not only undo the current transaction
    * but to restart it with the same parameters in a single statement
-   * 
+   *
    * ```ts
    * // ...
    * // Transaction operations I want to undo
@@ -502,12 +494,12 @@ export class Transaction {
    * await transaction.query`DELETE SOMETHING FROM SOMEWHERE`; // Still inside the transaction
    * await transaction.commit(); // The transaction finishes for good
    * ```
-   * 
+   *
    * However, the "chain" option can't be used alongside a savepoint, even though they are similar
-   * 
+   *
    * A savepoint is meant to reset progress up to a certain point, while a chained rollback is meant to reset all progress
    * and start from scratch
-   * 
+   *
    * ```ts
    * await transaction.rollback({ chain: true, savepoint: my_savepoint }); // Error, can't both return to savepoint and reset transaction
    * ```
@@ -517,14 +509,12 @@ export class Transaction {
   async rollback(options?: { savepoint?: string | Savepoint }): Promise<void>;
   async rollback(options?: { chain?: boolean }): Promise<void>;
   async rollback(
-    // deno-lint-ignore camelcase
     savepoint_or_options?: string | Savepoint | {
       savepoint?: string | Savepoint;
     } | { chain?: boolean },
   ): Promise<void> {
     this.#assertTransactionOpen();
 
-    // deno-lint-ignore camelcase
     let savepoint_option: Savepoint | string | undefined;
     if (
       typeof savepoint_or_options === "string" ||
@@ -536,7 +526,6 @@ export class Transaction {
         (savepoint_or_options as { savepoint?: string | Savepoint })?.savepoint;
     }
 
-    // deno-lint-ignore camelcase
     let savepoint_name: string | undefined;
     if (savepoint_option instanceof Savepoint) {
       savepoint_name = savepoint_option.name;
@@ -544,7 +533,6 @@ export class Transaction {
       savepoint_name = savepoint_option.toLowerCase();
     }
 
-    // deno-lint-ignore camelcase
     let chain_option = false;
     if (typeof savepoint_or_options === "object") {
       chain_option = (savepoint_or_options as { chain?: boolean })?.chain ??
@@ -559,7 +547,6 @@ export class Transaction {
 
     // If a savepoint is provided, rollback to that savepoint, continue the transaction
     if (typeof savepoint_option !== "undefined") {
-      // deno-lint-ignore camelcase
       const ts_savepoint = this.#savepoints.find(({ name }) =>
         name === savepoint_name
       );
@@ -600,14 +587,14 @@ export class Transaction {
   /**
    * This method will generate a savepoint, which will allow you to reset transaction states
    * to a previous point of time
-   * 
+   *
    * Each savepoint has a unique name used to identify it, and it must abide the following rules
-   * 
+   *
    * - Savepoint names must start with a letter or an underscore
    * - Savepoint names are case insensitive
    * - Savepoint names can't be longer than 63 characters
    * - Savepoint names can only have alphanumeric characters
-   * 
+   *
    * A savepoint can be easily created like this
    * ```ts
    * const savepoint = await transaction.save("MY_savepoint"); // returns a `Savepoint` with name "my_savepoint"
@@ -626,7 +613,7 @@ export class Transaction {
    * await transaction.rollback(savepoint); // It rolls back before the insert
    * await savepoint.release(); // All savepoints are released
    * ```
-   * 
+   *
    * Creating a new savepoint with an already used name will return you a reference to
    * the original savepoint
    * ```ts
diff --git a/query/types.ts b/query/types.ts
index fbd22288..7d20bde8 100644
--- a/query/types.ts
+++ b/query/types.ts
@@ -16,18 +16,18 @@ export interface Circle {
 
 /**
  * Decimal-like string. Uses dot to split the decimal
- * 
+ *
  * Example: 1.89, 2, 2.1
- * 
+ *
  * https://www.postgresql.org/docs/13/datatype-numeric.html#DATATYPE-FLOAT
  * */
 export type Float4 = "string";
 
 /**
  * Decimal-like string. Uses dot to split the decimal
- * 
+ *
  * Example: 1.89, 2, 2.1
- * 
+ *
  * https://www.postgresql.org/docs/13/datatype-numeric.html#DATATYPE-FLOAT
  * */
 export type Float8 = "string";
@@ -54,7 +54,7 @@ export interface LineSegment {
  */
 export type Path = Point[];
 
-/**  
+/**
  * https://www.postgresql.org/docs/13/datatype-geometric.html#id-1.5.7.16.5
  */
 export interface Point {
@@ -75,7 +75,7 @@ export type TID = [BigInt, BigInt];
 /**
  * Additional to containing normal dates, they can contain 'Infinity'
  * values, so handle them with care
- * 
+ *
  * https://www.postgresql.org/docs/13/datatype-datetime.html
  */
 export type Timestamp = Date | number;
diff --git a/tests/config.json b/tests/config.json
index 260aae4b..a4d7b7ad 100644
--- a/tests/config.json
+++ b/tests/config.json
@@ -1,24 +1,76 @@
 {
-  "postgres": {
-    "applicationName": "deno_postgres",
-    "database": "postgres",
-    "hostname": "postgres",
-    "password": "postgres",
-    "port": 5432,
-    "users": {
-      "clear": "clear",
-      "main": "postgres",
-      "md5": "md5"
+  "ci": {
+    "postgres": {
+      "applicationName": "deno_postgres",
+      "database": "postgres",
+      "hostname": "postgres",
+      "password": "postgres",
+      "port": 5432,
+      "users": {
+        "clear": "clear",
+        "main": "postgres",
+        "md5": "md5"
+      }
+    },
+    "postgres_scram": {
+      "applicationName": "deno_postgres",
+      "database": "postgres",
+      "hostname": "postgres_scram",
+      "password": "postgres",
+      "port": 5432,
+      "users": {
+        "scram": "scram"
+      }
+    },
+    "postgres_invalid_tls": {
+      "applicationName": "deno_postgres",
+      "database": "postgres",
+      "hostname": "postgres_invalid_tls",
+      "password": "postgres",
+      "port": 5432,
+      "tls": {
+        "enforce": true
+      },
+      "users": {
+        "main": "postgres"
+      }
     }
   },
-  "postgres_scram": {
-    "applicationName": "deno_postgres",
-    "database": "postgres",
-    "hostname": "postgres_scram",
-    "password": "postgres",
-    "port": 5432,
-    "users": {
-      "scram": "scram"
+  "local": {
+    "postgres": {
+      "applicationName": "deno_postgres",
+      "database": "postgres",
+      "hostname": "localhost",
+      "password": "postgres",
+      "port": 6001,
+      "users": {
+        "clear": "clear",
+        "main": "postgres",
+        "md5": "md5"
+      }
+    },
+    "postgres_scram": {
+      "applicationName": "deno_postgres",
+      "database": "postgres",
+      "hostname": "localhost",
+      "password": "postgres",
+      "port": 6002,
+      "users": {
+        "scram": "scram"
+      }
+    },
+    "postgres_invalid_tls": {
+      "applicationName": "deno_postgres",
+      "database": "postgres",
+      "hostname": "localhost",
+      "password": "postgres",
+      "port": 6003,
+      "tls": {
+        "enforce": true
+      },
+      "users": {
+        "main": "postgres"
+      }
     }
   }
 }
diff --git a/tests/config.ts b/tests/config.ts
index b4e9c322..be472af2 100644
--- a/tests/config.ts
+++ b/tests/config.ts
@@ -1,22 +1,7 @@
-import { ConnectionOptions } from "../connection/connection_params.ts";
+// deno-lint-ignore-file camelcase
+import { ClientOptions } from "../connection/connection_params.ts";
 
-const file = "config.json";
-const path = new URL("config.json", import.meta.url);
-
-let content = "{}";
-try {
-  content = await Deno.readTextFile(path);
-} catch (e) {
-  if (e instanceof Deno.errors.NotFound) {
-    console.log(
-      `"${file}" wasn't found in the tests directory, using environmental variables`,
-    );
-  } else {
-    throw e;
-  }
-}
-
-const config: {
+interface EnvironmentConfig {
   postgres: {
     applicationName: string;
     database: string;
@@ -39,9 +24,33 @@ const config: {
       scram: string;
     };
   };
-} = JSON.parse(content);
+  postgres_invalid_tls: {
+    applicationName: string;
+    database: string;
+    hostname: string;
+    password: string;
+    port: string | number;
+    tls: {
+      enforce: boolean;
+    };
+    users: {
+      main: string;
+    };
+  };
+}
+
+const config_file: {
+  ci: EnvironmentConfig;
+  local: EnvironmentConfig;
+} = JSON.parse(
+  await Deno.readTextFile(new URL("./config.json", import.meta.url)),
+);
 
-export const getClearConfiguration = (): ConnectionOptions => {
+const config = Deno.env.get("DEVELOPMENT") === "true"
+  ? config_file.local
+  : config_file.ci;
+
+export const getClearConfiguration = (): ClientOptions => {
   return {
     applicationName: config.postgres.applicationName,
     database: config.postgres.database,
@@ -52,7 +61,7 @@ export const getClearConfiguration = (): ConnectionOptions => {
   };
 };
 
-export const getMainConfiguration = (): ConnectionOptions => {
+export const getMainConfiguration = (): ClientOptions => {
   return {
     applicationName: config.postgres.applicationName,
     database: config.postgres.database,
@@ -63,7 +72,7 @@ export const getMainConfiguration = (): ConnectionOptions => {
   };
 };
 
-export const getMd5Configuration = (): ConnectionOptions => {
+export const getMd5Configuration = (): ClientOptions => {
   return {
     applicationName: config.postgres.applicationName,
     database: config.postgres.database,
@@ -74,7 +83,7 @@ export const getMd5Configuration = (): ConnectionOptions => {
   };
 };
 
-export const getScramSha256Configuration = (): ConnectionOptions => {
+export const getScramSha256Configuration = (): ClientOptions => {
   return {
     applicationName: config.postgres_scram.applicationName,
     database: config.postgres_scram.database,
@@ -84,3 +93,17 @@ export const getScramSha256Configuration = (): ConnectionOptions => {
     user: config.postgres_scram.users.scram,
   };
 };
+
+export const getInvalidTlsConfiguration = (): ClientOptions => {
+  return {
+    applicationName: config.postgres_invalid_tls.applicationName,
+    database: config.postgres_invalid_tls.database,
+    hostname: config.postgres_invalid_tls.hostname,
+    password: config.postgres_invalid_tls.password,
+    port: config.postgres_invalid_tls.port,
+    tls: {
+      enforce: config.postgres_invalid_tls.tls.enforce,
+    },
+    user: config.postgres_invalid_tls.users.main,
+  };
+};
diff --git a/tests/connection_params_test.ts b/tests/connection_params_test.ts
index dc13d721..dd97c45f 100644
--- a/tests/connection_params_test.ts
+++ b/tests/connection_params_test.ts
@@ -1,10 +1,9 @@
-const { test } = Deno;
+// deno-lint-ignore-file camelcase
 import { assertEquals, assertThrows } from "./test_deps.ts";
 import {
   ConnectionParamsError,
   createParams,
 } from "../connection/connection_params.ts";
-// deno-lint-ignore camelcase
 import { has_env_access } from "./constants.ts";
 
 /**
@@ -57,7 +56,7 @@ function withNotAllowedEnv(fn: () => void) {
   };
 }
 
-test("dsnStyleParameters", function () {
+Deno.test("dsnStyleParameters", function () {
   const p = createParams(
     "postgres://some_user@some_host:10101/deno_postgres",
   );
@@ -68,7 +67,7 @@ test("dsnStyleParameters", function () {
   assertEquals(p.port, 10101);
 });
 
-test("dsnStyleParametersWithPostgresqlDriver", function () {
+Deno.test("dsnStyleParametersWithPostgresqlDriver", function () {
   const p = createParams(
     "postgresql://some_user@some_host:10101/deno_postgres",
   );
@@ -79,7 +78,7 @@ test("dsnStyleParametersWithPostgresqlDriver", function () {
   assertEquals(p.port, 10101);
 });
 
-test("dsnStyleParametersWithoutExplicitPort", function () {
+Deno.test("dsnStyleParametersWithoutExplicitPort", function () {
   const p = createParams(
     "postgres://some_user@some_host/deno_postgres",
   );
@@ -90,7 +89,7 @@ test("dsnStyleParametersWithoutExplicitPort", function () {
   assertEquals(p.port, 5432);
 });
 
-test("dsnStyleParametersWithApplicationName", function () {
+Deno.test("dsnStyleParametersWithApplicationName", function () {
   const p = createParams(
     "postgres://some_user@some_host:10101/deno_postgres?application_name=test_app",
   );
@@ -102,7 +101,7 @@ test("dsnStyleParametersWithApplicationName", function () {
   assertEquals(p.port, 10101);
 });
 
-test("dsnStyleParametersWithSSLModeRequire", function () {
+Deno.test("dsnStyleParametersWithSSLModeRequire", function () {
   const p = createParams(
     "postgres://some_user@some_host:10101/deno_postgres?sslmode=require",
   );
@@ -110,7 +109,7 @@ test("dsnStyleParametersWithSSLModeRequire", function () {
   assertEquals(p.tls.enforce, true);
 });
 
-test("dsnStyleParametersWithInvalidDriver", function () {
+Deno.test("dsnStyleParametersWithInvalidDriver", function () {
   assertThrows(
     () =>
       createParams(
@@ -121,7 +120,7 @@ test("dsnStyleParametersWithInvalidDriver", function () {
   );
 });
 
-test("dsnStyleParametersWithInvalidPort", function () {
+Deno.test("dsnStyleParametersWithInvalidPort", function () {
   assertThrows(
     () =>
       createParams(
@@ -132,7 +131,7 @@ test("dsnStyleParametersWithInvalidPort", function () {
   );
 });
 
-test("dsnStyleParametersWithInvalidSSLMode", function () {
+Deno.test("dsnStyleParametersWithInvalidSSLMode", function () {
   assertThrows(
     () =>
       createParams(
@@ -143,7 +142,7 @@ test("dsnStyleParametersWithInvalidSSLMode", function () {
   );
 });
 
-test("objectStyleParameters", function () {
+Deno.test("objectStyleParameters", function () {
   const p = createParams({
     user: "some_user",
     hostname: "some_host",
@@ -157,7 +156,7 @@ test("objectStyleParameters", function () {
   assertEquals(p.port, 10101);
 });
 
-test({
+Deno.test({
   name: "envParameters",
   ignore: !has_env_access,
   fn() {
@@ -176,26 +175,27 @@ test({
   },
 });
 
-test({
+Deno.test({
   name: "envParametersWithInvalidPort",
   ignore: !has_env_access,
   fn() {
+    const port = "abc";
     withEnv({
       database: "deno_postgres",
       host: "some_host",
-      port: "abc",
+      port,
       user: "some_user",
     }, () => {
       assertThrows(
         () => createParams(),
         ConnectionParamsError,
-        "Invalid port NaN",
+        `"${port}" is not a valid port number`,
       );
     });
   },
 });
 
-test(
+Deno.test(
   "envParametersWhenNotAllowed",
   withNotAllowedEnv(function () {
     const p = createParams({
@@ -210,7 +210,7 @@ test(
   }),
 );
 
-test("defaultParameters", function () {
+Deno.test("defaultParameters", function () {
   const database = "deno_postgres";
   const user = "deno_postgres";
 
@@ -232,7 +232,7 @@ test("defaultParameters", function () {
   );
 });
 
-test("requiredParameters", function () {
+Deno.test("requiredParameters", function () {
   if (has_env_access) {
     if (!(Deno.env.get("PGUSER") && Deno.env.get("PGDATABASE"))) {
       assertThrows(
diff --git a/tests/connection_test.ts b/tests/connection_test.ts
index b64297d5..a86697fe 100644
--- a/tests/connection_test.ts
+++ b/tests/connection_test.ts
@@ -1,11 +1,14 @@
-import { assertThrowsAsync } from "./test_deps.ts";
+// deno-lint-ignore-file camelcase
+import { assertEquals, assertThrowsAsync, deferred } from "./test_deps.ts";
 import {
   getClearConfiguration,
+  getInvalidTlsConfiguration,
   getMainConfiguration,
   getMd5Configuration,
   getScramSha256Configuration,
 } from "./config.ts";
 import { Client, PostgresError } from "../mod.ts";
+import { ConnectionError } from "../connection/warning.ts";
 
 function getRandomString() {
   return Math.random().toString(36).substring(7);
@@ -17,6 +20,33 @@ Deno.test("Clear password authentication (no tls)", async () => {
   await client.end();
 });
 
+Deno.test("MD5 authentication (no tls)", async () => {
+  const client = new Client(getMd5Configuration());
+  await client.connect();
+  await client.end();
+});
+
+Deno.test("SCRAM-SHA-256 authentication (no tls)", async () => {
+  const client = new Client(getScramSha256Configuration());
+  await client.connect();
+  await client.end();
+});
+
+Deno.test("Handles invalid TLS certificates correctly", async () => {
+  const client = new Client(getInvalidTlsConfiguration());
+
+  await assertThrowsAsync(
+    async (): Promise<void> => {
+      await client.connect();
+    },
+    Error,
+    "The certificate used to secure the TLS connection is invalid",
+  )
+    .finally(async () => {
+      await client.end();
+    });
+});
+
 Deno.test("Handles bad authentication correctly", async function () {
   const badConnectionData = getMainConfiguration();
   badConnectionData.password += getRandomString();
@@ -34,18 +64,6 @@ Deno.test("Handles bad authentication correctly", async function () {
     });
 });
 
-Deno.test("MD5 authentication (no tls)", async () => {
-  const client = new Client(getMd5Configuration());
-  await client.connect();
-  await client.end();
-});
-
-Deno.test("SCRAM-SHA-256 authentication (no tls)", async () => {
-  const client = new Client(getScramSha256Configuration());
-  await client.connect();
-  await client.end();
-});
-
 // This test requires current user database connection permissions
 // on "pg_hba.conf" set to "all"
 Deno.test("Startup error when database does not exist", async function () {
@@ -64,3 +82,241 @@ Deno.test("Startup error when database does not exist", async function () {
       await client.end();
     });
 });
+
+Deno.test("Exposes session PID", async () => {
+  const client = new Client(getClearConfiguration());
+  await client.connect();
+  const { rows } = await client.queryObject<{ pid: string }>(
+    "SELECT PG_BACKEND_PID() AS PID",
+  );
+  assertEquals(client.session.pid, rows[0].pid);
+
+  await client.end();
+  assertEquals(
+    client.session.pid,
+    undefined,
+    "PID is not cleared after disconnection",
+  );
+});
+
+Deno.test("Closes connection on bad TLS availability verification", async function () {
+  const server = new Worker(
+    new URL("./workers/postgres_server.ts", import.meta.url).href,
+    {
+      type: "module",
+      deno: {
+        namespace: true,
+      },
+    },
+  );
+
+  // Await for server initialization
+  const initialized = deferred();
+  server.onmessage = ({ data }) => {
+    if (data !== "initialized") {
+      initialized.reject(`Unexpected message "${data}" received from worker`);
+    }
+    initialized.resolve();
+  };
+  server.postMessage("initialize");
+  await initialized;
+
+  const client = new Client({
+    database: "none",
+    hostname: "127.0.0.1",
+    port: "8080",
+    user: "none",
+  });
+
+  // The server will try to emit a message everytime it receives a connection
+  // For this test we don't need them, so we just discard them
+  server.onmessage = () => {};
+
+  let bad_tls_availability_message = false;
+  try {
+    await client.connect();
+  } catch (e) {
+    if (
+      e instanceof Error ||
+      e.message.startsWith("Could not check if server accepts SSL connections")
+    ) {
+      bad_tls_availability_message = true;
+    } else {
+      // Early fail, if the connection fails for an unexpected error
+      server.terminate();
+      throw e;
+    }
+  } finally {
+    await client.end();
+  }
+
+  const closed = deferred();
+  server.onmessage = ({ data }) => {
+    if (data !== "closed") {
+      closed.reject(
+        `Unexpected message "${data}" received from worker`,
+      );
+    }
+    closed.resolve();
+  };
+  server.postMessage("close");
+  await closed;
+  server.terminate();
+
+  assertEquals(bad_tls_availability_message, true);
+});
+
+async function mockReconnection(attempts: number) {
+  const server = new Worker(
+    new URL("./workers/postgres_server.ts", import.meta.url).href,
+    {
+      type: "module",
+      deno: {
+        namespace: true,
+      },
+    },
+  );
+
+  // Await for server initialization
+  const initialized = deferred();
+  server.onmessage = ({ data }) => {
+    if (data !== "initialized") {
+      initialized.reject(`Unexpected message "${data}" received from worker`);
+    }
+    initialized.resolve();
+  };
+  server.postMessage("initialize");
+  await initialized;
+
+  const client = new Client({
+    connection: {
+      attempts,
+    },
+    database: "none",
+    hostname: "127.0.0.1",
+    port: "8080",
+    user: "none",
+  });
+
+  let connection_attempts = 0;
+  server.onmessage = ({ data }) => {
+    if (data !== "connection") {
+      closed.reject(
+        `Unexpected message "${data}" received from worker`,
+      );
+    }
+    connection_attempts++;
+  };
+
+  try {
+    await client.connect();
+  } catch (e) {
+    if (
+      !(e instanceof Error) ||
+      !e.message.startsWith("Could not check if server accepts SSL connections")
+    ) {
+      // Early fail, if the connection fails for an unexpected error
+      server.terminate();
+      throw e;
+    }
+  } finally {
+    await client.end();
+  }
+
+  const closed = deferred();
+  server.onmessage = ({ data }) => {
+    if (data !== "closed") {
+      closed.reject(
+        `Unexpected message "${data}" received from worker`,
+      );
+    }
+    closed.resolve();
+  };
+  server.postMessage("close");
+  await closed;
+  server.terminate();
+
+  // If reconnections are set to zero, it will attempt to connect at least once, but won't
+  // attempt to reconnect
+  assertEquals(
+    connection_attempts,
+    attempts === 0 ? 1 : attempts,
+    `Attempted "${connection_attempts}" reconnections, "${attempts}" expected`,
+  );
+}
+
+Deno.test("Attempts reconnection on connection startup", async function () {
+  await mockReconnection(5);
+  await mockReconnection(0);
+});
+
+// This test ensures a failed query that is disconnected after execution but before
+// status report is only executed one (regression test)
+Deno.test("Attempts reconnection on disconnection", async function () {
+  const client = new Client({
+    ...getMainConfiguration(),
+    connection: {
+      attempts: 1,
+    },
+  });
+  await client.connect();
+
+  const test_table = "TEST_DENO_RECONNECTION_1";
+  const test_value = 1;
+
+  await client.queryArray(`DROP TABLE IF EXISTS ${test_table}`);
+  await client.queryArray(`CREATE TABLE ${test_table} (X INT)`);
+
+  await assertThrowsAsync(
+    () =>
+      client.queryArray(
+        `INSERT INTO ${test_table} VALUES (${test_value}); COMMIT; SELECT PG_TERMINATE_BACKEND(${client.session.pid})`,
+      ),
+    ConnectionError,
+    "The session was terminated by the database",
+  );
+  assertEquals(client.connected, false);
+
+  const { rows: result_1 } = await client.queryObject<{ pid: string }>({
+    text: "SELECT PG_BACKEND_PID() AS PID",
+    fields: ["pid"],
+  });
+  assertEquals(
+    client.session.pid,
+    result_1[0].pid,
+    "The PID is not reseted after reconnection",
+  );
+
+  const { rows: result_2 } = await client.queryObject<{ x: number }>({
+    text: `SELECT X FROM ${test_table}`,
+    fields: ["x"],
+  });
+  assertEquals(
+    result_2.length,
+    1,
+  );
+  assertEquals(
+    result_2[0].x,
+    test_value,
+  );
+
+  await client.end();
+});
+
+Deno.test("Doesn't attempt reconnection when attempts are set to zero", async function () {
+  const client = new Client({
+    ...getMainConfiguration(),
+    connection: { attempts: 0 },
+  });
+  await client.connect();
+  await assertThrowsAsync(() =>
+    client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`
+  );
+  assertEquals(client.connected, false);
+
+  await assertThrowsAsync(
+    () => client.queryArray`SELECT 1`,
+    Error,
+    "The client has been disconnected from the database",
+  );
+});
diff --git a/tests/constants.ts b/tests/constants.ts
index c7de8e35..2fdd16b1 100644
--- a/tests/constants.ts
+++ b/tests/constants.ts
@@ -1,3 +1,4 @@
+// deno-lint-ignore-file camelcase
 export const DEFAULT_SETUP = [
   "DROP TABLE IF EXISTS ids;",
   "CREATE TABLE ids(id integer);",
@@ -12,7 +13,6 @@ export const DEFAULT_SETUP = [
   "CREATE OR REPLACE FUNCTION CREATE_NOTICE () RETURNS INT AS $$ BEGIN RAISE NOTICE 'NOTICED'; RETURN (SELECT 1); END; $$ LANGUAGE PLPGSQL;",
 ];
 
-// deno-lint-ignore camelcase
 let has_env_access = true;
 try {
   Deno.env.toObject();
diff --git a/tests/data_types_test.ts b/tests/data_types_test.ts
index e642188f..268544c8 100644
--- a/tests/data_types_test.ts
+++ b/tests/data_types_test.ts
@@ -1,3 +1,4 @@
+// deno-lint-ignore-file camelcase
 import { assertEquals, base64, formatDate, parseDate } from "./test_deps.ts";
 import { Client } from "../mod.ts";
 import { getMainConfiguration } from "./config.ts";
@@ -28,12 +29,10 @@ const SETUP = [
 /**
  * This will generate a random number with a precision of 2
  */
-// deno-lint-ignore camelcase
 function generateRandomNumber(max_value: number) {
   return Math.round((Math.random() * max_value + Number.EPSILON) * 100) / 100;
 }
 
-// deno-lint-ignore camelcase
 function generateRandomPoint(max_value = 100): Point {
   return {
     x: String(generateRandomNumber(max_value)) as Float8,
@@ -380,7 +379,6 @@ testClient(async function varcharNestedArray() {
 });
 
 testClient(async function uuid() {
-  // deno-lint-ignore camelcase
   const uuid_text = "c4792ecb-c00a-43a2-bd74-5b0ed551c599";
   const result = await CLIENT.queryArray(`SELECT $1::uuid`, uuid_text);
   assertEquals(result.rows[0][0], uuid_text);
@@ -444,7 +442,6 @@ testClient(async function bpcharNestedArray() {
 });
 
 testClient(async function jsonArray() {
-  // deno-lint-ignore camelcase
   const json_array = await CLIENT.queryArray(
     `SELECT ARRAY_AGG(A) FROM  (
       SELECT JSON_BUILD_OBJECT( 'X', '1' ) AS A
@@ -503,7 +500,6 @@ function randomBase64(): string {
 }
 
 testClient(async function bytea() {
-  // deno-lint-ignore camelcase
   const base64_string = randomBase64();
 
   const result = await CLIENT.queryArray(
@@ -703,7 +699,6 @@ testClient(async function tidArray() {
 });
 
 testClient(async function date() {
-  // deno-lint-ignore camelcase
   const date_text = "2020-01-01";
 
   const result = await CLIENT.queryArray<[Timestamp, Timestamp]>(
diff --git a/tests/encode_test.ts b/tests/encode_test.ts
index 717c94db..1f48d64c 100644
--- a/tests/encode_test.ts
+++ b/tests/encode_test.ts
@@ -65,9 +65,11 @@ test("encodeObject", function () {
 test("encodeUint8Array", function () {
   const buf1 = new Uint8Array([1, 2, 3]);
   const buf2 = new Uint8Array([2, 10, 500]);
+  const buf3 = new Uint8Array([11]);
 
   assertEquals("\\x010203", encode(buf1));
-  assertEquals("\\x02af4", encode(buf2));
+  assertEquals("\\x020af4", encode(buf2));
+  assertEquals("\\x0b", encode(buf3));
 });
 
 test("encodeArray", function () {
diff --git a/tests/pool_test.ts b/tests/pool_test.ts
index 659652b8..98032740 100644
--- a/tests/pool_test.ts
+++ b/tests/pool_test.ts
@@ -1,14 +1,16 @@
+// deno-lint-ignore-file camelcase
 import { assertEquals, delay } from "./test_deps.ts";
 import { Pool } from "../pool.ts";
 import { getMainConfiguration } from "./config.ts";
 
 function testPool(
   name: string,
-  t: (pool: Pool) => void | Promise<void>,
-  lazy?: boolean,
+  t: (pool: Pool, size: number, lazy: boolean) => void | Promise<void>,
+  size = 10,
+  lazy = false,
 ) {
   const fn = async () => {
-    const POOL = new Pool(getMainConfiguration(), 10, lazy);
+    const POOL = new Pool(getMainConfiguration(), size, lazy);
     // If the connection is not lazy, create a client to await
     // for initialization
     if (!lazy) {
@@ -16,7 +18,7 @@ function testPool(
       await client.release();
     }
     try {
-      await t(POOL);
+      await t(POOL, size, lazy);
     } finally {
       await POOL.end();
     }
@@ -61,24 +63,25 @@ testPool(
 
 testPool(
   "Pool initializes lazy connections on demand",
-  async function (POOL) {
-    // deno-lint-ignore camelcase
+  async function (POOL, size) {
     const client_1 = await POOL.connect();
     await client_1.queryArray("SELECT 1");
     await client_1.release();
-    assertEquals(POOL.available, 1);
+    assertEquals(await POOL.initialized(), 1);
 
-    // deno-lint-ignore camelcase
     const client_2 = await POOL.connect();
     const p = client_2.queryArray("SELECT pg_sleep(0.1) is null, -1 AS id");
     await delay(1);
-    assertEquals(POOL.available, 0);
-    assertEquals(POOL.size, 1);
+    assertEquals(POOL.size, size);
+    assertEquals(POOL.available, size - 1);
+    assertEquals(await POOL.initialized(), 0);
     await p;
     await client_2.release();
-    assertEquals(POOL.available, 1);
+    assertEquals(await POOL.initialized(), 1);
 
-    const qsThunks = [...Array(25)].map(async (_, i) => {
+    // Test stack repletion as well
+    const requested_clients = size + 5;
+    const qsThunks = Array.from({ length: requested_clients }, async (_, i) => {
       const client = await POOL.connect();
       const query = await client.queryArray(
         "SELECT pg_sleep(0.1) is null, $1::text as id",
@@ -90,14 +93,19 @@ testPool(
     const qsPromises = Promise.all(qsThunks);
     await delay(1);
     assertEquals(POOL.available, 0);
+    assertEquals(await POOL.initialized(), 0);
     const qs = await qsPromises;
-    assertEquals(POOL.available, 10);
-    assertEquals(POOL.size, 10);
+    assertEquals(POOL.available, size);
+    assertEquals(await POOL.initialized(), size);
 
     const result = qs.map((r) => r.rows[0][1]);
-    const expected = [...Array(25)].map((_, i) => i.toString());
+    const expected = Array.from(
+      { length: requested_clients },
+      (_, i) => i.toString(),
+    );
     assertEquals(result, expected);
   },
+  10,
   true,
 );
 
@@ -113,14 +121,17 @@ testPool("Pool can be reinitialized after termination", async function (POOL) {
 
 testPool(
   "Lazy pool can be reinitialized after termination",
-  async function (POOL) {
+  async function (POOL, size) {
     await POOL.end();
     assertEquals(POOL.available, 0);
+    assertEquals(await POOL.initialized(), 0);
 
     const client = await POOL.connect();
     await client.queryArray`SELECT 1`;
     await client.release();
-    assertEquals(POOL.available, 1);
+    assertEquals(await POOL.initialized(), 1);
+    assertEquals(POOL.available, size);
   },
+  10,
   true,
 );
diff --git a/tests/query_client_test.ts b/tests/query_client_test.ts
index f95543a5..981ab461 100644
--- a/tests/query_client_test.ts
+++ b/tests/query_client_test.ts
@@ -1,4 +1,5 @@
-import { Client, Pool } from "../mod.ts";
+// deno-lint-ignore-file camelcase
+import { Client, ConnectionError, Pool } from "../mod.ts";
 import { assert, assertEquals, assertThrowsAsync } from "./test_deps.ts";
 import { getMainConfiguration } from "./config.ts";
 import { PoolClient, QueryClient } from "../client.ts";
@@ -51,6 +52,16 @@ testClient("Simple query", async function (generateClient) {
   assertEquals(result.rows.length, 2);
 });
 
+testClient("Object query", async function (generateClient) {
+  const client = await generateClient();
+
+  const result = await client.queryObject(
+    "SELECT ARRAY[1, 2, 3] AS ID, 'DATA' AS TYPE",
+  );
+
+  assertEquals(result.rows, [{ id: [1, 2, 3], type: "DATA" }]);
+});
+
 testClient("Prepared statements", async function (generateClient) {
   const client = await generateClient();
 
@@ -61,65 +72,41 @@ testClient("Prepared statements", async function (generateClient) {
   assertEquals(result.rows, [{ id: 1 }]);
 });
 
-testClient("Object query", async function (generateClient) {
+testClient("Terminated connections", async function (generateClient) {
   const client = await generateClient();
+  await client.end();
 
-  const result = await client.queryObject(
-    "SELECT ARRAY[1, 2, 3] AS ID, 'DATA' AS TYPE",
+  await assertThrowsAsync(
+    async () => {
+      await client.queryArray`SELECT 1`;
+    },
+    Error,
+    "Connection to the database has been terminated",
   );
-
-  assertEquals(result.rows, [{ id: [1, 2, 3], type: "DATA" }]);
 });
 
-testClient(
-  "Object query are mapped to user provided fields",
-  async function (generateClient) {
-    const client = await generateClient();
-
-    const result = await client.queryObject({
-      text: "SELECT ARRAY[1, 2, 3], 'DATA'",
-      fields: ["ID", "type"],
-    });
-
-    assertEquals(result.rows, [{ id: [1, 2, 3], type: "DATA" }]);
-  },
-);
-
-testClient(
-  "Object query throws if user provided fields aren't unique",
-  async function (generateClient) {
-    const client = await generateClient();
-
-    await assertThrowsAsync(
-      async () => {
-        await client.queryObject({
-          text: "SELECT 1",
-          fields: ["FIELD_1", "FIELD_1"],
-        });
-      },
-      TypeError,
-      "The fields provided for the query must be unique",
-    );
-  },
-);
+// This test depends on the assumption that all clients will default to
+// one reconneciton by default
+testClient("Default reconnection", async (generateClient) => {
+  const client = await generateClient();
 
-testClient(
-  "Object query throws if result columns don't match the user provided fields",
-  async function (generateClient) {
-    const client = await generateClient();
+  await assertThrowsAsync(
+    () => client.queryArray`SELECT PG_TERMINATE_BACKEND(${client.session.pid})`,
+    ConnectionError,
+    "The session was terminated by the database",
+  );
+  assertEquals(client.connected, false);
 
-    await assertThrowsAsync(
-      async () => {
-        await client.queryObject({
-          text: "SELECT 1",
-          fields: ["FIELD_1", "FIELD_2"],
-        });
-      },
-      RangeError,
-      "The fields provided for the query don't match the ones returned as a result (1 expected, 2 received)",
-    );
-  },
-);
+  const { rows: result } = await client.queryObject<{ res: number }>({
+    text: `SELECT 1`,
+    fields: ["res"],
+  });
+  assertEquals(
+    result[0].res,
+    1,
+  );
+  assertEquals(client.connected, true);
+});
 
 testClient("Handling of debug notices", async function (generateClient) {
   const client = await generateClient();
@@ -165,7 +152,6 @@ testClient("nativeType", async function (generateClient) {
 testClient("Binary data is parsed correctly", async function (generateClient) {
   const client = await generateClient();
 
-  // deno-lint-ignore camelcase
   const { rows: result_1 } = await client.queryArray
     `SELECT E'foo\\\\000\\\\200\\\\\\\\\\\\377'::BYTEA`;
 
@@ -173,7 +159,6 @@ testClient("Binary data is parsed correctly", async function (generateClient) {
 
   assertEquals(result_1[0][0], expectedBytes);
 
-  // deno-lint-ignore camelcase
   const { rows: result_2 } = await client.queryArray(
     "SELECT $1::BYTEA",
     expectedBytes,
@@ -262,7 +247,6 @@ testClient("Long column alias is truncated", async function (generateClient) {
 testClient("Query array with template string", async function (generateClient) {
   const client = await generateClient();
 
-  // deno-lint-ignore camelcase
   const [value_1, value_2] = ["A", "B"];
 
   const { rows } = await client.queryArray<[string, string]>
@@ -271,6 +255,125 @@ testClient("Query array with template string", async function (generateClient) {
   assertEquals(rows[0], [value_1, value_2]);
 });
 
+testClient(
+  "Object query are mapped to user provided fields",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    const result = await client.queryObject({
+      text: "SELECT ARRAY[1, 2, 3], 'DATA'",
+      fields: ["ID", "type"],
+    });
+
+    assertEquals(result.rows, [{ ID: [1, 2, 3], type: "DATA" }]);
+  },
+);
+
+testClient(
+  "Object query throws if user provided fields aren't unique",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    await assertThrowsAsync(
+      async () => {
+        await client.queryObject({
+          text: "SELECT 1",
+          fields: ["FIELD_1", "FIELD_1"],
+        });
+      },
+      TypeError,
+      "The fields provided for the query must be unique",
+    );
+  },
+);
+
+// Regression test
+testClient(
+  "Object query doesn't throw provided fields only have one letter",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    const { rows: result_1 } = await client.queryObject<{ a: number }>({
+      text: "SELECT 1",
+      fields: ["a"],
+    });
+
+    assertEquals(
+      result_1[0].a,
+      1,
+    );
+
+    await assertThrowsAsync(
+      async () => {
+        await client.queryObject({
+          text: "SELECT 1",
+          fields: ["1"],
+        });
+      },
+      TypeError,
+      "The fields provided for the query must contain only letters and underscores",
+    );
+  },
+);
+
+testClient(
+  "Object query throws if user provided fields aren't valid",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    await assertThrowsAsync(
+      async () => {
+        await client.queryObject({
+          text: "SELECT 1",
+          fields: ["123_"],
+        });
+      },
+      TypeError,
+      "The fields provided for the query must contain only letters and underscores",
+    );
+
+    await assertThrowsAsync(
+      async () => {
+        await client.queryObject({
+          text: "SELECT 1",
+          fields: ["1A"],
+        });
+      },
+      TypeError,
+      "The fields provided for the query must contain only letters and underscores",
+    );
+
+    await assertThrowsAsync(
+      async () => {
+        await client.queryObject({
+          text: "SELECT 1",
+          fields: ["A$"],
+        });
+      },
+      TypeError,
+      "The fields provided for the query must contain only letters and underscores",
+    );
+  },
+);
+
+testClient(
+  "Object query throws if result columns don't match the user provided fields",
+  async function (generateClient) {
+    const client = await generateClient();
+
+    await assertThrowsAsync(
+      async () => {
+        await client.queryObject({
+          text: "SELECT 1",
+          fields: ["FIELD_1", "FIELD_2"],
+        });
+      },
+      RangeError,
+      "The fields provided for the query don't match the ones returned as a result (1 expected, 2 received)",
+    );
+  },
+);
+
 testClient(
   "Query object with template string",
   async function (generateClient) {
@@ -279,7 +382,7 @@ testClient(
     const value = { x: "A", y: "B" };
 
     const { rows } = await client.queryObject<{ x: string; y: string }>
-      `SELECT ${value.x} AS X, ${value.y} AS Y`;
+      `SELECT ${value.x} AS x, ${value.y} AS y`;
 
     assertEquals(rows[0], value);
   },
@@ -288,20 +391,18 @@ testClient(
 testClient("Transaction", async function (generateClient) {
   const client = await generateClient();
 
-  // deno-lint-ignore camelcase
   const transaction_name = "x";
   const transaction = client.createTransaction(transaction_name);
 
   await transaction.begin();
   assertEquals(
-    client.current_transaction,
+    client.session.current_transaction,
     transaction_name,
     "Client is locked out during transaction",
   );
   await transaction.queryArray`CREATE TEMP TABLE TEST (X INTEGER)`;
   const savepoint = await transaction.savepoint("table_creation");
   await transaction.queryArray`INSERT INTO TEST (X) VALUES (1)`;
-  // deno-lint-ignore camelcase
   const query_1 = await transaction.queryObject<{ x: number }>
     `SELECT X FROM TEST`;
   assertEquals(
@@ -310,7 +411,6 @@ testClient("Transaction", async function (generateClient) {
     "Operation was not executed inside transaction",
   );
   await transaction.rollback(savepoint);
-  // deno-lint-ignore camelcase
   const query_2 = await transaction.queryObject<{ x: number }>
     `SELECT X FROM TEST`;
   assertEquals(
@@ -320,7 +420,7 @@ testClient("Transaction", async function (generateClient) {
   );
   await transaction.commit();
   assertEquals(
-    client.current_transaction,
+    client.session.current_transaction,
     null,
     "Client was not released after transaction",
   );
@@ -329,15 +429,14 @@ testClient("Transaction", async function (generateClient) {
 testClient(
   "Transaction with repeatable read isolation level",
   async function (generateClient) {
-    // deno-lint-ignore camelcase
     const client_1 = await generateClient();
-    // deno-lint-ignore camelcase
+
     const client_2 = await generateClient();
 
     await client_1.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
     await client_1.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
     await client_1.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
-    // deno-lint-ignore camelcase
+
     const transaction_rr = client_1.createTransaction(
       "transactionIsolationLevelRepeatableRead",
       { isolation_level: "repeatable_read" },
@@ -350,12 +449,11 @@ testClient(
 
     // Modify data outside the transaction
     await client_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
-    // deno-lint-ignore camelcase
+
     const { rows: query_1 } = await client_2.queryObject<{ x: number }>
       `SELECT X FROM FOR_TRANSACTION_TEST`;
     assertEquals(query_1, [{ x: 2 }]);
 
-    // deno-lint-ignore camelcase
     const { rows: query_2 } = await transaction_rr.queryObject<
       { x: number }
     >`SELECT X FROM FOR_TRANSACTION_TEST`;
@@ -367,7 +465,6 @@ testClient(
 
     await transaction_rr.commit();
 
-    // deno-lint-ignore camelcase
     const { rows: query_3 } = await client_1.queryObject<{ x: number }>
       `SELECT X FROM FOR_TRANSACTION_TEST`;
     assertEquals(
@@ -383,15 +480,14 @@ testClient(
 testClient(
   "Transaction with serializable isolation level",
   async function (generateClient) {
-    // deno-lint-ignore camelcase
     const client_1 = await generateClient();
-    // deno-lint-ignore camelcase
+
     const client_2 = await generateClient();
 
     await client_1.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
     await client_1.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
     await client_1.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
-    // deno-lint-ignore camelcase
+
     const transaction_rr = client_1.createTransaction(
       "transactionIsolationLevelRepeatableRead",
       { isolation_level: "serializable" },
@@ -412,7 +508,6 @@ testClient(
       "A serializable transaction should throw if the data read in the transaction has been modified externally",
     );
 
-    // deno-lint-ignore camelcase
     const { rows: query_3 } = await client_1.queryObject<{ x: number }>
       `SELECT X FROM FOR_TRANSACTION_TEST`;
     assertEquals(
@@ -445,15 +540,12 @@ testClient("Transaction read only", async function (generateClient) {
 });
 
 testClient("Transaction snapshot", async function (generateClient) {
-  // deno-lint-ignore camelcase
   const client_1 = await generateClient();
-  // deno-lint-ignore camelcase
   const client_2 = await generateClient();
 
   await client_1.queryArray`DROP TABLE IF EXISTS FOR_TRANSACTION_TEST`;
   await client_1.queryArray`CREATE TABLE FOR_TRANSACTION_TEST (X INTEGER)`;
   await client_1.queryArray`INSERT INTO FOR_TRANSACTION_TEST (X) VALUES (1)`;
-  // deno-lint-ignore camelcase
   const transaction_1 = client_1.createTransaction(
     "transactionSnapshot1",
     { isolation_level: "repeatable_read" },
@@ -467,7 +559,6 @@ testClient("Transaction snapshot", async function (generateClient) {
   // Modify data outside the transaction
   await client_2.queryArray`UPDATE FOR_TRANSACTION_TEST SET X = 2`;
 
-  // deno-lint-ignore camelcase
   const { rows: query_1 } = await transaction_1.queryObject<{ x: number }>
     `SELECT X FROM FOR_TRANSACTION_TEST`;
   assertEquals(
@@ -478,14 +569,12 @@ testClient("Transaction snapshot", async function (generateClient) {
 
   const snapshot = await transaction_1.getSnapshot();
 
-  // deno-lint-ignore camelcase
   const transaction_2 = client_2.createTransaction(
     "transactionSnapshot2",
     { isolation_level: "repeatable_read", snapshot },
   );
   await transaction_2.begin();
 
-  // deno-lint-ignore camelcase
   const { rows: query_2 } = await transaction_2.queryObject<{ x: number }>
     `SELECT X FROM FOR_TRANSACTION_TEST`;
   assertEquals(
@@ -517,7 +606,7 @@ testClient("Transaction locks client", async function (generateClient) {
 
   await client.queryArray`SELECT 1`;
   assertEquals(
-    client.current_transaction,
+    client.session.current_transaction,
     null,
     "Client was not released after transaction",
   );
@@ -533,14 +622,14 @@ testClient("Transaction commit chain", async function (generateClient) {
 
   await transaction.commit({ chain: true });
   assertEquals(
-    client.current_transaction,
+    client.session.current_transaction,
     name,
     "Client shouldn't have been released on chained commit",
   );
 
   await transaction.commit();
   assertEquals(
-    client.current_transaction,
+    client.session.current_transaction,
     null,
     "Client was not released after transaction ended",
   );
@@ -557,7 +646,7 @@ testClient(
     await client.queryArray`CREATE TEMP TABLE MY_TEST (X INTEGER)`;
     await transaction.begin();
     await transaction.queryArray`INSERT INTO MY_TEST (X) VALUES (1)`;
-    // deno-lint-ignore camelcase
+
     const { rows: query_1 } = await transaction.queryObject<{ x: number }>
       `SELECT X FROM MY_TEST`;
     assertEquals(query_1, [{ x: 1 }]);
@@ -565,20 +654,19 @@ testClient(
     await transaction.rollback({ chain: true });
 
     assertEquals(
-      client.current_transaction,
+      client.session.current_transaction,
       name,
       "Client shouldn't have been released after chained rollback",
     );
 
     await transaction.rollback();
 
-    // deno-lint-ignore camelcase
     const { rowCount: query_2 } = await client.queryObject<{ x: number }>
       `SELECT X FROM MY_TEST`;
     assertEquals(query_2, 0);
 
     assertEquals(
-      client.current_transaction,
+      client.session.current_transaction,
       null,
       "Client was not released after rollback",
     );
@@ -617,7 +705,7 @@ testClient(
       undefined,
       `The transaction "${name}" has been aborted due to \`PostgresError:`,
     );
-    assertEquals(client.current_transaction, null);
+    assertEquals(client.session.current_transaction, null);
 
     await transaction.begin();
     await assertThrowsAsync(
@@ -625,21 +713,19 @@ testClient(
       undefined,
       `The transaction "${name}" has been aborted due to \`PostgresError:`,
     );
-    assertEquals(client.current_transaction, null);
+    assertEquals(client.session.current_transaction, null);
   },
 );
 
 testClient("Transaction savepoints", async function (generateClient) {
   const client = await generateClient();
 
-  // deno-lint-ignore camelcase
   const savepoint_name = "a1";
   const transaction = client.createTransaction("x");
 
   await transaction.begin();
   await transaction.queryArray`CREATE TEMP TABLE X (Y INT)`;
   await transaction.queryArray`INSERT INTO X VALUES (1)`;
-  // deno-lint-ignore camelcase
   const { rows: query_1 } = await transaction.queryObject<{ y: number }>
     `SELECT Y FROM X`;
   assertEquals(query_1, [{ y: 1 }]);
@@ -647,7 +733,6 @@ testClient("Transaction savepoints", async function (generateClient) {
   const savepoint = await transaction.savepoint(savepoint_name);
 
   await transaction.queryArray`DELETE FROM X`;
-  // deno-lint-ignore camelcase
   const { rowCount: query_2 } = await transaction.queryObject<{ y: number }>
     `SELECT Y FROM X`;
   assertEquals(query_2, 0);
@@ -655,13 +740,11 @@ testClient("Transaction savepoints", async function (generateClient) {
   await savepoint.update();
 
   await transaction.queryArray`INSERT INTO X VALUES (2)`;
-  // deno-lint-ignore camelcase
   const { rows: query_3 } = await transaction.queryObject<{ y: number }>
     `SELECT Y FROM X`;
   assertEquals(query_3, [{ y: 2 }]);
 
   await transaction.rollback(savepoint);
-  // deno-lint-ignore camelcase
   const { rowCount: query_4 } = await transaction.queryObject<{ y: number }>
     `SELECT Y FROM X`;
   assertEquals(query_4, 0);
@@ -680,7 +763,6 @@ testClient("Transaction savepoints", async function (generateClient) {
 
   // This checks that the savepoint can be called by name as well
   await transaction.rollback(savepoint_name);
-  // deno-lint-ignore camelcase
   const { rows: query_5 } = await transaction.queryObject<{ y: number }>
     `SELECT Y FROM X`;
   assertEquals(query_5, [{ y: 1 }]);
@@ -756,9 +838,8 @@ testClient(
   async function (generateClient) {
     const client = await generateClient();
 
-    // deno-lint-ignore camelcase
     const transaction_x = client.createTransaction("x");
-    // deno-lint-ignore camelcase
+
     const transaction_y = client.createTransaction("y");
 
     await transaction_x.begin();
diff --git a/tests/scram_test.ts b/tests/scram_test.ts
index 8e0aa0bc..39a7396e 100644
--- a/tests/scram_test.ts
+++ b/tests/scram_test.ts
@@ -1,7 +1,11 @@
-import { assertEquals, assertNotEquals, assertThrows } from "./test_deps.ts";
+import {
+  assertEquals,
+  assertNotEquals,
+  assertThrowsAsync,
+} from "./test_deps.ts";
 import * as scram from "../connection/scram.ts";
 
-Deno.test("scram.Client reproduces RFC 7677 example", () => {
+Deno.test("scram.Client reproduces RFC 7677 example", async () => {
   // Example seen in https://tools.ietf.org/html/rfc7677
   const client = new scram.Client("user", "pencil", "rOprNGfwEbeRWgbNEkqO");
 
@@ -9,21 +13,21 @@ Deno.test("scram.Client reproduces RFC 7677 example", () => {
     client.composeChallenge(),
     "n,,n=user,r=rOprNGfwEbeRWgbNEkqO",
   );
-  client.receiveChallenge(
+  await client.receiveChallenge(
     "r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF$k0," +
       "s=W22ZaJ0SNY7soEsUEjb6gQ==,i=4096",
   );
   assertEquals(
-    client.composeResponse(),
+    await client.composeResponse(),
     "c=biws,r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF$k0," +
       "p=dHzbZapWIk4jUhN+Ute9ytag9zjfMHgsqmmiz7AndVQ=",
   );
-  client.receiveResponse(
+  await client.receiveResponse(
     "v=6rriTRBi23WpRR/wtup+mMhUZUn/dB5nLTJRsjl95G4=",
   );
 });
 
-Deno.test("scram.Client catches bad server nonce", () => {
+Deno.test("scram.Client catches bad server nonce", async () => {
   const testCases = [
     "s=c2FsdA==,i=4096", // no server nonce
     "r=,s=c2FsdA==,i=4096", // empty
@@ -32,11 +36,11 @@ Deno.test("scram.Client catches bad server nonce", () => {
   for (const testCase of testCases) {
     const client = new scram.Client("user", "password", "nonce1");
     client.composeChallenge();
-    assertThrows(() => client.receiveChallenge(testCase));
+    await assertThrowsAsync(() => client.receiveChallenge(testCase));
   }
 });
 
-Deno.test("scram.Client catches bad salt", () => {
+Deno.test("scram.Client catches bad salt", async () => {
   const testCases = [
     "r=nonce12,i=4096", // no salt
     "r=nonce12,s=*,i=4096", // ill-formed base-64 string
@@ -44,11 +48,11 @@ Deno.test("scram.Client catches bad salt", () => {
   for (const testCase of testCases) {
     const client = new scram.Client("user", "password", "nonce1");
     client.composeChallenge();
-    assertThrows(() => client.receiveChallenge(testCase));
+    await assertThrowsAsync(() => client.receiveChallenge(testCase));
   }
 });
 
-Deno.test("scram.Client catches bad iteration count", () => {
+Deno.test("scram.Client catches bad iteration count", async () => {
   const testCases = [
     "r=nonce12,s=c2FsdA==", // no iteration count
     "r=nonce12,s=c2FsdA==,i=", // empty
@@ -59,24 +63,24 @@ Deno.test("scram.Client catches bad iteration count", () => {
   for (const testCase of testCases) {
     const client = new scram.Client("user", "password", "nonce1");
     client.composeChallenge();
-    assertThrows(() => client.receiveChallenge(testCase));
+    await assertThrowsAsync(() => client.receiveChallenge(testCase));
   }
 });
 
-Deno.test("scram.Client catches bad verifier", () => {
+Deno.test("scram.Client catches bad verifier", async () => {
   const client = new scram.Client("user", "password", "nonce1");
   client.composeChallenge();
-  client.receiveChallenge("r=nonce12,s=c2FsdA==,i=4096");
-  client.composeResponse();
-  assertThrows(() => client.receiveResponse("v=xxxx"));
+  await client.receiveChallenge("r=nonce12,s=c2FsdA==,i=4096");
+  await client.composeResponse();
+  await assertThrowsAsync(() => client.receiveResponse("v=xxxx"));
 });
 
-Deno.test("scram.Client catches server rejection", () => {
+Deno.test("scram.Client catches server rejection", async () => {
   const client = new scram.Client("user", "password", "nonce1");
   client.composeChallenge();
-  client.receiveChallenge("r=nonce12,s=c2FsdA==,i=4096");
-  client.composeResponse();
-  assertThrows(() => client.receiveResponse("e=auth error"));
+  await client.receiveChallenge("r=nonce12,s=c2FsdA==,i=4096");
+  await client.composeResponse();
+  await assertThrowsAsync(() => client.receiveResponse("e=auth error"));
 });
 
 Deno.test("scram.Client generates unique challenge", () => {
diff --git a/tests/test_deps.ts b/tests/test_deps.ts
index d469391c..4a4643b1 100644
--- a/tests/test_deps.ts
+++ b/tests/test_deps.ts
@@ -5,8 +5,8 @@ export {
   assertNotEquals,
   assertThrows,
   assertThrowsAsync,
-} from "https://deno.land/std@0.93.0/testing/asserts.ts";
+} from "https://deno.land/std@0.98.0/testing/asserts.ts";
 export {
   format as formatDate,
   parse as parseDate,
-} from "https://deno.land/std@0.93.0/datetime/mod.ts";
+} from "https://deno.land/std@0.98.0/datetime/mod.ts";
diff --git a/tests/utils_test.ts b/tests/utils_test.ts
index e7dccae3..af6bcaf0 100644
--- a/tests/utils_test.ts
+++ b/tests/utils_test.ts
@@ -1,8 +1,29 @@
-const { test } = Deno;
+// deno-lint-ignore-file camelcase
 import { assertEquals } from "./test_deps.ts";
-import { DsnResult, parseDsn } from "../utils.ts";
+import { DsnResult, parseDsn } from "../utils/utils.ts";
+import { DeferredAccessStack } from "../utils/deferred.ts";
 
-test("testParseDsn", function () {
+class LazilyInitializedObject {
+  #initialized = false;
+
+  // Simulate async check
+  get initialized() {
+    return new Promise<boolean>((r) => r(this.#initialized));
+  }
+
+  async initialize(): Promise<void> {
+    // Fake delay
+    await new Promise<void>((resolve) => {
+      setTimeout(() => {
+        resolve();
+      }, 10);
+    });
+
+    this.#initialized = true;
+  }
+}
+
+Deno.test("parseDsn", function () {
   let c: DsnResult;
 
   c = parseDsn(
@@ -26,3 +47,53 @@ test("testParseDsn", function () {
   assertEquals(c.port, "");
   assertEquals(c.database, "test_database");
 });
+
+Deno.test("DeferredAccessStack", async () => {
+  const stack_size = 10;
+
+  const stack = new DeferredAccessStack(
+    Array.from({ length: stack_size }, () => new LazilyInitializedObject()),
+    (e) => e.initialize(),
+    (e) => e.initialized,
+  );
+
+  assertEquals(stack.size, stack_size);
+  assertEquals(stack.available, stack_size);
+  assertEquals(await stack.initialized(), 0);
+
+  const a = await stack.pop();
+  assertEquals(await a.initialized, true);
+  assertEquals(stack.size, stack_size);
+  assertEquals(stack.available, stack_size - 1);
+  assertEquals(await stack.initialized(), 0);
+
+  stack.push(a);
+  assertEquals(stack.size, stack_size);
+  assertEquals(stack.available, stack_size);
+  assertEquals(await stack.initialized(), 1);
+});
+
+Deno.test("An empty DeferredAccessStack awaits until an object is back in the stack", async () => {
+  const stack_size = 1;
+
+  const stack = new DeferredAccessStack(
+    Array.from({ length: stack_size }, () => new LazilyInitializedObject()),
+    (e) => e.initialize(),
+    (e) => e.initialized,
+  );
+
+  const a = await stack.pop();
+  let fulfilled = false;
+  const b = stack.pop()
+    .then((e) => {
+      fulfilled = true;
+      return e;
+    });
+
+  await new Promise((r) => setTimeout(r, 100));
+  assertEquals(fulfilled, false);
+
+  stack.push(a);
+  assertEquals(a, await b);
+  assertEquals(fulfilled, true);
+});
diff --git a/tests/workers/postgres_server.ts b/tests/workers/postgres_server.ts
new file mode 100644
index 00000000..9b5c90a8
--- /dev/null
+++ b/tests/workers/postgres_server.ts
@@ -0,0 +1,35 @@
+/// <reference no-default-lib="true" />
+/// <reference lib="deno.worker" />
+/// <reference lib="deno.unstable" />
+
+const server = Deno.listen({ port: 8080 });
+
+onmessage = ({ data }: { data: "initialize" | "close" }) => {
+  switch (data) {
+    case "initialize": {
+      listenServerConnections();
+      postMessage("initialized");
+      break;
+    }
+    case "close": {
+      server.close();
+      postMessage("closed");
+      break;
+    }
+    default: {
+      throw new Error(`Unexpected message "${data}" received on worker`);
+    }
+  }
+};
+
+async function listenServerConnections() {
+  for await (const conn of server) {
+    // The driver will attempt to check if the server receives
+    // a TLS connection, however we return an invalid response
+    conn.write(new TextEncoder().encode("INVALID"));
+    // Notify the parent thread that we have received a connection
+    postMessage("connection");
+  }
+}
+
+export {};
diff --git a/utils/deferred.ts b/utils/deferred.ts
new file mode 100644
index 00000000..03277fb1
--- /dev/null
+++ b/utils/deferred.ts
@@ -0,0 +1,136 @@
+import { Deferred, deferred } from "../deps.ts";
+
+export class DeferredStack<T> {
+  #array: Array<T>;
+  #creator?: () => Promise<T>;
+  #max_size: number;
+  #queue: Array<Deferred<T>>;
+  #size: number;
+
+  constructor(
+    max?: number,
+    ls?: Iterable<T>,
+    creator?: () => Promise<T>,
+  ) {
+    this.#array = ls ? [...ls] : [];
+    this.#creator = creator;
+    this.#max_size = max || 10;
+    this.#queue = [];
+    this.#size = this.#array.length;
+  }
+
+  get available(): number {
+    return this.#array.length;
+  }
+
+  async pop(): Promise<T> {
+    if (this.#array.length > 0) {
+      return this.#array.pop()!;
+    } else if (this.#size < this.#max_size && this.#creator) {
+      this.#size++;
+      return await this.#creator();
+    }
+    const d = deferred<T>();
+    this.#queue.push(d);
+    await d;
+    return this.#array.pop()!;
+  }
+
+  push(value: T): void {
+    this.#array.push(value);
+    if (this.#queue.length > 0) {
+      const d = this.#queue.shift()!;
+      d.resolve();
+    }
+  }
+
+  get size(): number {
+    return this.#size;
+  }
+}
+
+/**
+ * The DeferredAccessStack provides access to a series of elements provided on the stack creation,
+ * but with the caveat that they require an initialization of sorts before they can be used
+ *
+ * Instead of providing a `creator` function as you would with the `DeferredStack`, you provide
+ * an initialization callback to execute for each element that is retrieved from the stack and a check
+ * callback to determine if the element requires initialization and return a count of the initialized
+ * elements
+ */
+export class DeferredAccessStack<T> {
+  #elements: Array<T>;
+  #initializeElement: (element: T) => Promise<void>;
+  #checkElementInitialization: (element: T) => Promise<boolean> | boolean;
+  #queue: Array<Deferred<undefined>>;
+  #size: number;
+
+  get available(): number {
+    return this.#elements.length;
+  }
+
+  /**
+   * The max number of elements that can be contained in the stack a time
+   */
+  get size(): number {
+    return this.#size;
+  }
+
+  /**
+   * @param initialize This function will execute for each element that hasn't been initialized when requested from the stack
+   */
+  constructor(
+    elements: T[],
+    initCallback: (element: T) => Promise<void>,
+    checkInitCallback: (element: T) => Promise<boolean> | boolean,
+  ) {
+    this.#checkElementInitialization = checkInitCallback;
+    this.#elements = elements;
+    this.#initializeElement = initCallback;
+    this.#queue = [];
+    this.#size = elements.length;
+  }
+
+  /**
+   * Will execute the check for initialization on each element of the stack
+   * and then return the number of initialized elements that pass the check
+   */
+  async initialized(): Promise<number> {
+    const initialized = await Promise.all(
+      this.#elements.map((e) => this.#checkElementInitialization(e)),
+    );
+
+    return initialized
+      .filter((initialized) => initialized === true)
+      .length;
+  }
+
+  async pop(): Promise<T> {
+    let element: T;
+    if (this.available > 0) {
+      element = this.#elements.pop()!;
+    } else {
+      // If there are not elements left in the stack, it will await the call until
+      // at least one is restored and then return it
+      const d = deferred<undefined>();
+      this.#queue.push(d);
+      await d;
+      element = this.#elements.pop()!;
+    }
+
+    if (!await this.#checkElementInitialization(element)) {
+      await this.#initializeElement(element);
+    }
+    return element;
+  }
+
+  push(value: T): void {
+    this.#elements.push(value);
+    // If an element has been requested while the stack was empty, indicate
+    // that an element has been restored
+    if (this.#queue.length > 0) {
+      const d = this.#queue.shift()!;
+      d.resolve();
+    }
+  }
+}
diff --git a/utils.ts b/utils/utils.ts
similarity index 96%
rename from utils.ts
rename to utils/utils.ts
index 56148b01..a157df6d 100644
--- a/utils.ts
+++ b/utils/utils.ts
@@ -1,4 +1,4 @@
-import { createHash } from "./deps.ts";
+import { createHash } from "../deps.ts";
 
 export function readInt16BE(buffer: Uint8Array, offset: number): number {
   offset = offset >>> 0;
@@ -89,8 +89,7 @@ export function parseDsn(dsn: string): DsnResult {
 }
 
 export function isTemplateString(
-  // deno-lint-ignore no-explicit-any
-  template: any,
+  template: unknown,
 ): template is TemplateStringsArray {
   if (!Array.isArray(template)) {
     return false;
