diff --git a/.eslintrc.js b/.eslintrc.js
index 366522880..9401ebdda 100644
--- a/.eslintrc.js
+++ b/.eslintrc.js
@@ -6,7 +6,7 @@ module.exports = {
     "@typescript-eslint",
     "import",
     "simple-import-sort",
-    // 'prettier' commented as we don't want to run prettier through eslint because of performance degradation
+    "unused-imports",
   ],
   extends: [
     "eslint:recommended",
@@ -14,18 +14,17 @@ module.exports = {
     "prettier/@typescript-eslint", // Uses eslint-config-prettier to disable ESLint rules from @typescript-eslint/eslint-plugin that would conflict with prettier
   ],
   rules: {
-    /**
-     * eslint-plugin-import @see https://github.com/benmosher/eslint-plugin-import
-     */
-    "import/order": "off", // turn off in favor of eslint-plugin-simple-import-sort
-    "import/no-unresolved": "off",
-    "import/no-duplicates": "warn",
+    "import/order": 0, // turn off in favor of eslint-plugin-simple-import-sort
+    "import/no-unresolved": 0,
+    "import/no-duplicates": 1,
+
     /**
      * eslint-plugin-simple-import-sort @see https://github.com/lydell/eslint-plugin-simple-import-sort
      */
-    "sort-imports": "off", // we use eslint-plugin-import instead
-    "simple-import-sort/imports": "off",
-    "simple-import-sort/exports": "off",
+    "sort-imports": 0, // we use eslint-plugin-import instead
+    "simple-import-sort/imports": 1,
+    "simple-import-sort/exports": 1,
+
     /**
      * @typescript-eslint/eslint-plugin @see https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin
      */
diff --git a/.github/workflows/fix.yaml b/.github/workflows/fix.yaml
index 97475a9f0..254c2eab8 100644
--- a/.github/workflows/fix.yaml
+++ b/.github/workflows/fix.yaml
@@ -17,6 +17,7 @@ jobs:
         with:
           node-version: 14
       - run: yarn install
+      - run: yarn clean
       - run: yarn fix:lint
       - run: yarn build:deno
       - run: yarn fix:format
diff --git a/.github/workflows/test.yaml b/.github/workflows/test.yaml
index 322899814..01dd95234 100644
--- a/.github/workflows/test.yaml
+++ b/.github/workflows/test.yaml
@@ -14,7 +14,7 @@ jobs:
     strategy:
       matrix:
         node: [ '14' ]
-        typescript: [ '4.1', '4.1' ]
+        typescript: [ '4.1', '4.2' ]
     name: Test with TypeScript ${{ matrix.typescript }} on Node ${{ matrix.node }}
     steps:
       - uses: actions/checkout@v2
@@ -30,19 +30,24 @@ jobs:
     runs-on: Ubuntu-20.04
     strategy:
       matrix:
-        deno: [ '1.6' ]
+        deno: [ "v1.7.1", "v1.x" ]
     name: Test with Deno ${{ matrix.deno }}
     steps:
       - uses: actions/checkout@v2
       - uses: denolib/setup-deno@v2
         with:
           deno-version: ${{ matrix.deno }}
+      - run: deno --version
       - run: deno test
         working-directory: ./deno/lib
       - run: deno run ./index.ts
         working-directory: ./deno/lib
       - run: deno run ./mod.ts
         working-directory: ./deno/lib
+      - run: |
+          deno bundle ./mod.ts ./bundle.js
+          deno run ./bundle.js
+        working-directory: ./deno/lib
 
   lint:
     runs-on: Ubuntu-20.04
diff --git a/.gitignore b/.gitignore
index e0c176732..d2fe35be6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,4 +3,4 @@ node_modules
 /lib
 coverage
 .vscode
-*.log
+*.log
\ No newline at end of file
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7353299f0..f7d712896 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,24 +1,113 @@
 # Changelog
 
-| zod version | release notes                                                                                                                                                                                                                                                                                     |
-| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| zod@3       | New implementation of transformers, removed type guards                                                                                                                                                                                                                                           |
-| zod@2       | Transformers, async refinements                                                                                                                                                                                                                                                                   |
-| zod@1.11    | Introduced `.safeParse` option.<br>Introduced .regex method on string schemas.<br>Implemented `.primitives()` and `.nonprimitives()` on object schemas.<br>Implemented `z.nativeEnum()` for creating schemas from TypeScript `enum`s.<br>Switched to `new URL()` constructor to check valid URLs. |
-| zod@1.10    | Dropping support for TypeScript 3.2 .                                                                                                                                                                                                                                                             |
-| zod@1.9     | Added z.instanceof() and z.custom(). Implemented ZodSchema.array() method.                                                                                                                                                                                                                        |
-| zod@1.8     | Introduced z.void(). Major overhaul to error handling system, including the introduction of custom error maps. Wrote new [error handling guide](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md).                                                                                 |
-| zod@1.7     | Added several built-in validators to string, number, and array schemas. Calls to `.refine` now return new instance.                                                                                                                                                                               |
-| zod@1.5     | Any and unknown types                                                                                                                                                                                                                                                                             |
-| zod@1.4     | Refinement types (`.refine`), `.parse` no longer returns deep clone                                                                                                                                                                                                                               |
-| zod@1.3     | Promise schemas                                                                                                                                                                                                                                                                                   |
-| zod@1.2.6   | `.parse` accepts `unknown`, `bigint` schemas                                                                                                                                                                                                                                                      |
-| zod@1.2.5   | `.partial` and `.deepPartial` on object schemas                                                                                                                                                                                                                                                   |
-| zod@1.2.3   | Date schemas                                                                                                                                                                                                                                                                                      |
-| zod@1.2.0   | `.pick`, `.omit`, and `.extend` on object schemas                                                                                                                                                                                                                                                 |
-| zod@1.1.0   | Records                                                                                                                                                                                                                                                                                           |
-| zod@1.0.11  | `.nonstrict`                                                                                                                                                                                                                                                                                      |
-| zod@1.0.10  | Type assertions with `.check`                                                                                                                                                                                                                                                                     |
-| zod@1.0.4   | Empty tuples                                                                                                                                                                                                                                                                                      |
-| zod@1.0.0   | Type assertions, literals, enums, detailed error reporting                                                                                                                                                                                                                                        |
-| zod@1.0.0   | Initial release                                                                                                                                                                                                                                                                                   |
+### zod@3.0.0-alpha.5
+
+March 17, 2021
+
+- Refactored parsing logic into individual subclass methods
+- Eliminated ZodTypes to enable custom ZodType subclasses
+- Removed ZodIntersection
+- Added ZodEffects as a container for refinement and transform logic
+- Added `or` method to `ZodType`
+- Added `format` method to `ZodError`
+- Added `unwrap` method to `ZodOptional` and `ZodNullable`
+- Added new `default` method and moved default functionality into ZodOptional
+- Implemented `z.setErrorMap`
+- Exporting `z` variable from `index.ts` to enable `import { z } from 'zod';`
+
+### zod@3.0.0-alpha.4
+
+Jan 25, 2021
+
+- New implementation of transformers
+- Removed type guards
+
+### zod@2
+
+- Added ZodTransformer
+- Async refinements
+
+### zod@1.11
+
+- Introduced `.safeParse` option
+- Introduced .regex method on string schemas
+- Implemented `.primitives()` and `.nonprimitives()` on object schemas
+- Implemented `z.nativeEnum()` for creating schemas from TypeScript `enum`s
+- Switched to `new URL()` constructor to check valid URLs
+
+### zod@1.10
+
+- Dropping support for TypeScript 3.2
+
+### zod@1.9
+
+- Added z.instanceof() and z.custom()
+- Implemented ZodSchema.array() method
+
+### zod@1.8
+
+- Introduced z.void()
+- Major overhaul to error handling system, including the introduction of custom error maps
+- Wrote new [error handling guide](./ERROR_HANDLING.md)
+
+### zod@1.7
+
+- Added several built-in validators to string, number, and array schemas
+- Calls to `.refine` now return new instance
+
+### zod@1.5
+
+- Introduces ZodAny and ZodUnknown
+
+### zod@1.4
+
+- Refinement types (`.refine`)
+- Parsing no longer returns deep clone
+
+### zod@1.3
+
+- Promise schemas
+
+### zod@1.2.6
+
+- `.parse` accepts `unknown`
+- `bigint` schemas
+
+### zod@1.2.5
+
+- `.partial` and `.deepPartial` on object schemas
+
+### zod@1.2.3
+
+- Added ZodDate
+
+### zod@1.2.0
+
+- Added `.pick`, `.omit`, and `.extend` on object schemas
+
+### zod@1.1.0
+
+- Added ZodRecord
+
+### zod@1.0.11
+
+- Added `.nonstrict`
+
+### zod@1.0.10
+
+- Added type assertions with `.check`
+
+### zod@1.0.4
+
+- Support for empty tuples
+
+### zod@1.0.2
+
+- Added type assertions
+- Added ZodLiteral
+- Added ZodEnum
+- Improved error reporting
+
+### zod@1.0.0
+
+- Initial release
diff --git a/ERROR_HANDLING.md b/ERROR_HANDLING.md
index 861e6420b..9cd6e82af 100644
--- a/ERROR_HANDLING.md
+++ b/ERROR_HANDLING.md
@@ -15,7 +15,7 @@ class ZodError extends Error {
 ZodError is a subclass of `Error`; you can create your own instance easily:
 
 ```ts
-import * as z from 'zod';
+import * as z from "zod";
 
 const myError = new z.ZodError([]);
 ```
@@ -26,7 +26,7 @@ Each ZodError has an `issues` property that is an array of `ZodIssues`. Each iss
 
 `ZodIssue` is _not_ a class. It is a [discriminated union](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions).
 
-The link above is the best way to learn about the concept. Discriminated unions are an ideal way to represent a data structures that may be one of many possible variants. You can see all the possible variants defined [here](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts). They are also described in the table below if you prefer.
+The link above is the best way to learn about the concept. Discriminated unions are an ideal way to represent a data structures that may be one of many possible variants. You can see all the possible variants defined [here](./src/ZodError.ts). They are also described in the table below if you prefer.
 
 _Every_ ZodIssue has these fields:
 
@@ -40,21 +40,21 @@ _Every_ ZodIssue has these fields:
 
 ## ZodIssueCode
 
-| code                                 | additional fields                                                                                                                                                                                                                                                                    |
-| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
-| ZodIssueCode.invalid_type            | `expected: ZodParsedType` <br> `received: ZodParsedType` <br><br>Jump to [this section](#parsedtype) for a breakdown of the possible values of ZodParsedType.                                                                                                                        |
-| ZodIssueCode.nonempty_array_is_empty | _no additional properties_                                                                                                                                                                                                                                                           |
-| ZodIssueCode.unrecognized_keys       | `keys: string[]`<br>The list of unrecognized keys<br>                                                                                                                                                                                                                                |
-| ZodIssueCode.invalid_union           | `unionErrors: ZodError[]` <br> The errors thrown by each element of the union.                                                                                                                                                                                                       |
-| ZodIssueCode.invalid_literal_value   | `expected: string \| number \| boolean` <br> The literal value.                                                                                                                                                                                                                      |
-| ZodIssueCode.invalid_enum_value      | `options: string[]` <br> The set of acceptable string values for this enum.                                                                                                                                                                                                          |
-| ZodIssueCode.invalid_arguments       | `argumentsError: ZodError` <br> This is a special error code only thrown by a wrapped function returned by `ZodFunction.implement()`. The `argumentsError` property is another ZodError containing the validation error details.                                                     |
-| ZodIssueCode.invalid_return_type     | `returnTypeError: ZodError` <br> This is a special error code only thrown by a wrapped function returned by `ZodFunction.implement()`. The `returnTypeError` property is another ZodError containing the validation error details.                                                   |
-| ZodIssueCode.invalid_date            | _no additional properties_                                                                                                                                                                                                                                                           |
-| ZodIssueCode.invalid_string          | `validation: "url" \| "email" \| "uuid"`<br> Which built-in string validator failed                                                                                                                                                                                                  |
-| ZodIssueCode.too_small               | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `minimum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the minimum is included in the range of acceptable values.<br>                                   |
-| ZodIssueCode.too_big                 | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `maximum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the minimum is included in the range of acceptable values.<br>                                   |
-| ZodIssueCode.custom                  | `params: { [k: string]: any }` <br> This is the error code throw by **all custom refinements**. You are able to pass in a `params` object here that is available in your custom error maps (see [ZodErrorMap](#Customizing-errors-with-ZodErrorMap) below for details on error maps) |
+| code                             | additional fields                                                                                                                                                                                                                                                                    |
+| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------- | --- |
+| ZodIssueCode.invalid_type        | `expected: ZodParsedType` <br> `received: ZodParsedType` <br><br>Jump to [this section](#parsedtype) for a breakdown of the possible values of ZodParsedType.                                                                                                                        |
+| <!--                             | ZodIssueCode.nonempty_array_is_empty                                                                                                                                                                                                                                                 | _no additional properties_                                      | --> |
+| ZodIssueCode.unrecognized_keys   | `keys: string[]`<br>The list of unrecognized keys<br>                                                                                                                                                                                                                                |
+| ZodIssueCode.invalid_union       | `unionErrors: ZodError[]` <br> The errors thrown by each element of the union.                                                                                                                                                                                                       |
+| <!--                             | ZodIssueCode.invalid_literal_value                                                                                                                                                                                                                                                   | `expected: string \| number \| boolean` <br> The literal value. | --> |
+| ZodIssueCode.invalid_enum_value  | `options: string[]` <br> The set of acceptable string values for this enum.                                                                                                                                                                                                          |
+| ZodIssueCode.invalid_arguments   | `argumentsError: ZodError` <br> This is a special error code only thrown by a wrapped function returned by `ZodFunction.implement()`. The `argumentsError` property is another ZodError containing the validation error details.                                                     |
+| ZodIssueCode.invalid_return_type | `returnTypeError: ZodError` <br> This is a special error code only thrown by a wrapped function returned by `ZodFunction.implement()`. The `returnTypeError` property is another ZodError containing the validation error details.                                                   |
+| ZodIssueCode.invalid_date        | _no additional properties_                                                                                                                                                                                                                                                           |
+| ZodIssueCode.invalid_string      | `validation: "url" \| "email" \| "uuid"`<br> Which built-in string validator failed                                                                                                                                                                                                  |
+| ZodIssueCode.too_small           | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `minimum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the minimum is included in the range of acceptable values.<br>                                   |
+| ZodIssueCode.too_big             | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `maximum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the minimum is included in the range of acceptable values.<br>                                   |
+| ZodIssueCode.custom              | `params: { [k: string]: any }` <br> This is the error code throw by **all custom refinements**. You are able to pass in a `params` object here that is available in your custom error maps (see [ZodErrorMap](#Customizing-errors-with-ZodErrorMap) below for details on error maps) |
 
 ## ZodParsedType
 
@@ -64,6 +64,7 @@ This is an enum used by Zod internally to represent the type of a parsed value.
 - `nan`
 - `number`
 - `integer`
+- `float`
 - `boolean`
 - `date`
 - `bigint`
@@ -76,6 +77,9 @@ This is an enum used by Zod internally to represent the type of a parsed value.
 - `unknown`
 - `promise`
 - `void`
+- `never`
+- `map`
+- `set`
 
 ## A demonstrative example
 
@@ -96,11 +100,11 @@ Let's pass in some improperly formatted data.
 ```ts
 try {
   person.parse({
-    names: ['Dave', 12], // 12 is not a string
+    names: ["Dave", 12], // 12 is not a string
     address: {
-      line1: '123 Maple Ave',
+      line1: "123 Maple Ave",
       zipCode: 123, // zip code isnt 5 digits
-      extra: 'other stuff', // unrecognized key
+      extra: "other stuff", // unrecognized key
     },
   });
 } catch (err) {
@@ -115,25 +119,25 @@ Here are the errors that will be printed:
 ```ts
 [
   {
-    code: 'invalid_type',
-    expected: 'string',
-    received: 'number',
-    path: ['names', 1],
-    message: 'Invalid input: expected string, received number',
+    code: "invalid_type",
+    expected: "string",
+    received: "number",
+    path: ["names", 1],
+    message: "Invalid input: expected string, received number",
   },
   {
-    code: 'unrecognized_keys',
-    keys: ['extra'],
-    path: ['address'],
+    code: "unrecognized_keys",
+    keys: ["extra"],
+    path: ["address"],
     message: "Unrecognized key(s) in object: 'extra'",
   },
   {
-    code: 'too_small',
+    code: "too_small",
     minimum: 10000,
-    type: 'number',
+    type: "number",
     inclusive: true,
-    path: ['address', 'zipCode'],
-    message: 'Value should be greater than or equal to 10000',
+    path: ["address", "zipCode"],
+    message: "Value should be greater than or equal to 10000",
   },
 ];
 ```
@@ -142,7 +146,25 @@ As you can see three different issues were identified. Every ZodIssue has a `cod
 
 ## Customizing errors with ZodErrorMap
 
-You can customize **all** error messages produced by Zod by providing a custom instance of ZodErrorMap to `.parse()`. Internally, Zod uses a [default error map](https://github.com/colinhacks/zod/blob/master/defaultErrorMap.ts) to produce all error messages.
+You can customize **all** error messages produced by Zod by providing a custom "error map" to Zod, like so:
+
+```ts
+import { z } from "zod";
+
+const customErrorMap: z.ZodErrorMap = (issue, ctx) => {
+  if (issue.code === z.ZodIssueCode.invalid_type) {
+    if (issue.expected === "string") {
+      return { message: "bad type!" };
+    }
+  }
+  if (issue.code === z.ZodIssueCode.custom) {
+    return { message: `less-than-${(issue.params || {}).minimum}` };
+  }
+  return { message: ctx.defaultError };
+};
+
+z.setErrorMap(customErrorMap);
+```
 
 `ZodErrorMap` is a special function. It accepts two arguments: `error` and `ctx`. The return type is `{ message: string }`. Essentially the error map accepts some information about the validation that is failing and returns an appropriate error message.
 
@@ -156,33 +178,22 @@ You can customize **all** error messages produced by Zod by providing a custom i
 
   - `ctx.data` contains the data that was passed into `.parse`. You can use this to customize the error message.
 
+As in the example, you can modify certain error messages and simply fall back to `ctx.defaultError` otherwise.
+
 ### A working example
 
 Let's look at a practical example of of customized error map:
 
 ```ts
-import * as z from 'zod';
+import * as z from "zod";
 
 const errorMap: z.ZodErrorMap = (error, ctx) => {
-  /*
-
-  If error.message is set, that means the user is trying to
-  override the error message. This is how method-specific
-  error overrides work, like this:
-
-  z.string().min(5, { message: "TOO SMALL 🤬" })
-
-  It is a best practice to return `error.message` if it is set.
-  
-  */
-  if (error.message) return { message: error.message };
-
   /*
   This is where you override the various error codes
   */
   switch (error.code) {
     case z.ZodIssueCode.invalid_type:
-      if (error.expected === 'string') {
+      if (error.expected === "string") {
         return { message: `This ain't a string!` };
       }
       break;
@@ -201,6 +212,8 @@ const errorMap: z.ZodErrorMap = (error, ctx) => {
   return { message: ctx.defaultError };
 };
 
+z.setErrorMap(errorMap);
+
 z.string().parse(12, { errorMap });
 
 /* throws: 
@@ -240,9 +253,9 @@ Now lets pass in some invalid data:
 
 ```ts
 FormData.parse({
-  email: 'not an email',
-  password: 'tooshort',
-  confirm: 'nomatch',
+  email: "not an email",
+  password: "tooshort",
+  confirm: "nomatch",
 });
 ```
 
@@ -293,5 +306,5 @@ console.log(err.flatten());
 - `fieldErrors` is an object. The keys are the field(s) that threw the error. The values are an array of error strings that can be easily presented in the interface.
 - `formErrors: string[]` is an array of errors that occured on the "root" of the object schema. For instance if you called `FormData.parse(null)`, `formErrors` would be:
   ```ts
-  ['Invalid input: expected object, received null'];
+  ["Invalid input: expected object, received null"];
   ```
diff --git a/README.md b/README.md
index ca57d86ae..3bfb4ceb0 100644
--- a/README.md
+++ b/README.md
@@ -16,32 +16,93 @@ if you're happy and you know it, star this repo ⭐
 
 <br/>
 
-<!-- **Zod 2 is coming! Follow [@colinhacks](https://twitter.com/colinhacks) to stay updated and discuss the future of Zod.** -->
+# Table of contents
 
-### Migrating from v1
+- [What is Zod](#what-is-zod)
+- [Installation](#installation)
+- [Basic usage](#basic-usage)
+- [Defining schemas](#defining-schemas)
+  - [Primitives](#primitives)
+  - [Literals](#literals)
+  - [Strings](#strings)
+  - [Numbers](#numbers)
+  - [Objects](#objects)
+    - [.shape](#shape)
+    - [.extend](#extend)
+    - [.merge](#merge)
+    - [.pick/.omit](#pickomit)
+    - [.partial](#partial)
+    - [.deepPartial](#deepPartial)
+    - [.passthrough](#passthrough)
+    - [.strict](#strict)
+    - [.strip](#strip)
+    - [.catchall](#catchall)
+  - [Records](#records)
+  - [Maps](#maps)
+  - [Sets](#sets)
+  - [Arrays](#arrays)
+    - [.nonempty](#nonempty)
+    - [.min/.max/.length](#minmaxlength)
+  - [Unions](#unions)
+  - [Optionals](#optionals)
+  - [Nullables](#nullables)
+  - [Enums](#enums)
+    - [Zod enums](#zod-enums)
+    - [Native enums](#native-enums)
+  - [Tuples](#tuples)
+  - [Recursive types](#recursive-types)
+    - [JSON type](#json-type)
+    - [Cyclical data](#cyclical-objects)
+  - [Promises](#promises)
+  - [Instanceof](#instanceof)
+  - [Function schemas](#function-schemas)
+- [Methods](#methods)
+  - [.parse](#parse)
+  - [.parseAsync](#parseasync)
+  - [.safeParse](#safeparse)
+  - [.safeParseAsync](#safeparseasync)
+  - [.default](#default)
+  - [.refine](#refine)
+  - [.transform](#transform)
+- [Type inference](#type-inference)
+- [Errors](#errors)
+- [Comparison](#comparison)
+  - [Joi](#joi)
+  - [Yup](#yup)
+  - [io-ts](#io-ts)
+  - [Runtypes](#runtypes)
+- [Changelog](#changelog)
 
-If you're upgrading straight to v3 from v1, you'll need to be aware of the breaking changes introduced in both v2 and v3. The v1->v2 migration guide is [here](https://github.com/colinhacks/zod/tree/v2).
+<!-- **Zod 2 is coming! Follow [@colinhacks](https://twitter.com/colinhacks) to stay updated and discuss the future of Zod.** -->
 
-### Migrating from v2
+## Zod v3 is in alpha
 
-You can install v3 with `zod@next`. (v2 will continue to be availabe with `zod@beta` for the time being.)
+#### New features
 
-```
-npm install zod@next
-yarn add zod@next
-```
+- Transformers! But better! See the "breaking changes" section to understand the syntax changes.
+- You can now import Zod like `import { z } a from 'zod';` instead of using `import * as` syntax.
+- Added the `format` method to ZodError to convert the error into a strongly-typed, nested object: [format method](#error-formatting)
+- Added the `or` method to ZodType (the base class for all Zod schema) to easily create union types like `z.string().or(z.number())`
+- Added `z.setErrorMap`, an easier way to _globally_ customize the error messages produced by Zod: [setErrorMap](ERROR_HANDLING.md#customizing-errors-with-zoderrormap)
+- ZodOptional and ZodNullable now have a `.unwrap()` method for retrieving the schema they wrap
 
 #### Breaking changes in v3
 
-- The minimum TypeScript version has increased from 3.7 to _4.1_. Several features have been rewritten to use [recursive conditional types](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#recursive-conditional-types), an incredibly powerful new feature introduced in TS4.1.
-- Transformer syntax. Previously transformers required an input, an output schema, and a function to tranform between them. You created transformers like `z.transform(A, B, func)`, where `A` and `B` are Zod schemas. This is no longer the case. Accordingly:
+- The **minimum TypeScript version** is now _4.1_ (up from 3.7 for Zod 2). Several features have been rewritten to use [recursive conditional types](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#recursive-conditional-types), an incredibly powerful new feature introduced in TS4.1.
+
+- **Transformers syntax**. Previously, creating a transformer required an input schema, an output schema, and a function to tranform between them. You created transformers like `z.transform(A, B, func)`, where `A` and `B` are Zod schemas. This is no longer the case. Accordingly:
+
+  The old syntax (`z.transformer(A, B, func)`) is no longer available.
 
-  ⚠️ The old syntax (`z.transformer(A, B, func)`) is no longer available.
-  ⚠️ The convenience method `A.transform(B, func)` is no longer available.
+  The convenience method `A.transform(B, func)` is no longer available.
 
-  Instead, you apply transformations by simply using the `.transform()` method that exists on all Zod schema. For example: `z.string().transform(val => val.length)`.
+  Instead, you apply transformations by simply using the `.transform()` method that exists on all Zod schemas.
+
+  ```ts
+  z.string().transform((val) => val.length);
+  ```
 
-  Importantly, transformations are now _interleaved_ with refinements. So you can build chains of refinement + transformation logic that are executed in sequence:
+- Under the hood, all refinements and transformations are executed inside a dedicated "ZodEffects" class. Post-parsing, ZodEffects passes the data through a chain of refinements and transformations, then returns the final value. As such, you can now _interleave_ transformations and refinements. For instance:
 
   ```ts
   const test = z
@@ -53,35 +114,42 @@ yarn add zod@next
   test.parse("12characters"); // => 24
   ```
 
-- Type guards (the `.check()` method) have been removed. Type guards interact with transformers in unintuitive ways so they were removed. Use `.safeParse` instead.
+- **Type guards** (the `.check()` method) have been removed. Type guards interact with transformers in unintuitive ways so they were removed. Use `.safeParse` instead.
+- **ZodIntersection has been removed**. If you have an object schema, you can use the `A.merge(B)` instead. Note that this is equivalent to `A.extend(B.shape)` and is therefore not an intersection in the pure sense, as `B` takes precedence over `A` if the two schemas share a key.
+- There have been small internal changes to the ZodIssue type. This may impact user who have written a custom error maps. Most users will not be affected.
 
-<!-- - Errors that occur inside refinement functions are now caught. Previously these errors were considered unexpected and would crash the process (unless caught externally to Zod). If an error is caught, the refinement fails. -->
+#### Migrating from v1
 
-<!-- _Additional updates + features_ -->
+If you're upgrading straight to v3 from v1, you'll need to be aware of the breaking changes introduced in both v2 and v3. The v1->v2 migration guide is [here](https://github.com/colinhacks/zod/tree/v2#migration-from-v1).
 
-<!-- - Support for Deno!
-- Support for ES Modules! -->
-<!-- - Errors that occur inside refinement functions are now caught. Previously these errors were considered unexpected and would crash the process (unless caught externally to Zod). If an error is caught, the refinement fails. -->
+#### Migrating from v2
+
+Zod 2 is being retired and will not leave beta. This is due to some issues with it's implementation of transformers: details [here](https://github.com/colinhacks/zod/issues/264). Zod 3 is currently in alpha — install it at `zod@next`. (Zod 2 will continue to be available with `zod@beta` for the time being.)
+
+```
+npm install zod@next
+yarn add zod@next
+```
 
 # What is Zod
 
-Zod is a TypeScript-first schema declaration and validation library. I'm using the term "schema" to broadly refer to any data type/structure, from a simple `string` to a complex nested object.
+Zod is a TypeScript-first schema declaration and validation library. I'm using the term "schema" to broadly refer to any data type, from a simple `string` to a complex nested object.
 
-Zod is designed to be as developer-friendly as possible. My goal is to eliminate duplicative type declarations wherever possible. With Zod, you declare a validator _once_ and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.
+Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator _once_ and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.
 
 Some other great aspects:
 
 - Zero dependencies
-- Plain JavaScript: works in browsers and Node.js
+- Works in browsers and Node.js
 - Tiny: 8kb minified + zipped
-- Immutability: methods (i.e. `.optional()` return a new instance
+- Immutable: methods (i.e. `.optional()` return a new instance
 - Concise, chainable interface
 - Functional approach: [parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
 - Works with plain JavaScript too! You don't need to use TypeScript.
 
 # Sponsorship
 
-I work on Zod in my free time, so if you're making money from a product that is built with Zod, I'd massively appreciate sponsorship at any level. For solo devs, I recommend the [Chipotle Bowl tier](https://github.com/sponsors/colinhacks) or the [Cup of Coffee tier](https://github.com/sponsors/colinhacks). If you're making money from a product you built using Zod, consider the [Startup tier]([Cup of Coffee tier](https://github.com/sponsors/colinhacks)). You can learn more about the tiers at [github.com/sponsors/colinhacks](github.com/sponsors/colinhacks).
+Sponsorship at any level is appreciated and encouraged. Zod is maintained by a solo developer ([hi!](https://twitter.com/colinhacks)). For individual developers, consider the [Cup of Coffee tier](https://github.com/sponsors/colinhacks). If you built a paid product using Zod, consider the [Startup tier](https://github.com/sponsors/colinhacks). You can learn more about the tiers at [github.com/sponsors/colinhacks](https://github.com/sponsors/colinhacks).
 
 ### Sponsors
 
@@ -121,79 +189,21 @@ I work on Zod in my free time, so if you're making money from a product that is
 
 _To get your name + Twitter + website here, sponsor Zod at the [Freelancer](https://github.com/sponsors/colinhacks) or [Consultancy](https://github.com/sponsors/colinhacks) tier._
 
-# Table of contents
-
-- [Installation](#installation)
-
-  <!-- - [Usage](#usage) -->
-
-- [Primitives](#primitives)
-- [Literals](#literals)
-- [Parsing](#parsing)
-- [Type inference](#type-inference)
-- [Refinements](#refinements)
-- [Strings](#strings)
-- [Numbers](#numbers)
-- [Objects](#objects)
-  - [.shape](#shape-property)
-  - [.merge](#merging)
-  - [.extend](#extending-objects)
-  - [.pick/.omit](#pick-and-omit)
-  - [.partial/.deepPartial](#partials)
-  - [.passthrough](#pass-through-unknown-keys)
-  - [.strict](#disallow-unknown-keys)
-  - [.primitives/.nonprimitives](#primitives-and-nonprimitives)
-- [Records](#records)
-- [Arrays](#arrays)
-  - [.nonempty](#non-empty-lists)
-- [Unions](#unions)
-  - [.optional](#optional-types)
-  - [.nullable](#nullable-types)
-- [Enums](#enums)
-- [Intersections](#intersections)
-- [Tuples](#tuples)
-- [Recursive types](#recursive-types)
-  - [JSON type](#json-type)
-  - [Cyclical data](#cyclical-objects)
-- [Promises](#promises)
-- [Maps](#maps)
-- [Instanceof](#instanceof)
-- [Function schemas](#function-schemas)
-- [Transformers](#transformers)
-- [Errors](#errors)
-- [Comparison](#comparison)
-  - [Joi](#joi)
-  - [Yup](#yup)
-  - [io-ts](#io-ts)
-  - [Runtypes](#runtypes)
-- [Changelog](#changelog)
-
 # Installation
 
-To use the beta of Zod 2 (recommended for new projects).
-
-```
-
-yarn add zod@beta
-npm install zod@beta
-```
-
-To install the most recent v1 version:
+To install Zod v3:
 
 ```sh
-yarn add zod
-npm install zod
+npm install zod@next
 ```
 
 #### TypeScript requirements
 
-- Zod 3.x requires TypeScript 3.8+
+- Zod 3.x requires TypeScript 4.1+
 - Zod 2.x requires TypeScript 3.7+
 - Zod 1.x requires TypeScript 3.3+
 
-> Support for TS 3.2 was dropped with the release of zod@1.10 on 19 July 2020
-
-You must enable `strictNullChecks` or use `strict` mode which includes `strictNullChecks` . Otherwise Zod can't correctly infer the types of your schemas!
+⚠️ You must enable `strict` mode in your `tsconfig.json`. This is a best practice for all TypeScript projects:
 
 ```ts
 // tsconfig.json
@@ -201,34 +211,46 @@ You must enable `strictNullChecks` or use `strict` mode which includes `strictNu
   // ...
   "compilerOptions": {
     // ...
-    "strictNullChecks": true
+    "strict": true
   }
 }
 ```
 
-# Usage
+# Basic usage
 
-Zod is a validation library designed for optimal developer experience. It's a TypeScript-first schema declaration library with rigorous inferred types, incredible developer experience, and a few killer features missing from the existing libraries.
+Creating a simple string schema
 
-<!-- - It infers the statically types of your schemas
+```ts
+import { z } from "zod";
 
-* Eliminates the need to keep static types and runtime validators in sync by hand
-* It has a composable, declarative API that makes it easy to define complex types concisely.
-* Schemas are immutable. All methods return a new schema instance. -->
+// creating a schema for strings
+const mySchema = z.string();
+mySchema.parse("tuna"); // => "tuna"
+mySchema.parse(12); // => throws ZodError
+```
 
-<!-- Zod was also designed with some core principles designed to make all declarations as non-magical and developer-friendly as possible: -->
+Creating an object schema
 
-- Zero dependencies (5kb compressed)
-- Immutability; methods (i.e. `.optional()` return a new instance
-- Concise, chainable interface
-- Functional approach (["Parse, don't validate!"](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/))
+```ts
+import { z } from "zod";
 
-## Primitives
+const User = z.object({
+  username: z.string(),
+});
 
-You can create a Zod schema for any TypeScript primitive.
+User.parse({ username: string });
+
+// extract the inferred type
+type User = z.infer<typeof User>;
+// { username: string }
+```
+
+# Defining schemas
+
+## Primitives
 
 ```ts
-import * as z from "zod";
+import { z } from "zod";
 
 // primitive values
 z.string();
@@ -240,11 +262,16 @@ z.date();
 // empty types
 z.undefined();
 z.null();
-z.void();
+z.void(); // accepts null or undefined
 
 // catch-all types
+// allows any value
 z.any();
 z.unknown();
+
+// never type
+// allows no values
+z.never();
 ```
 
 ## Literals
@@ -257,188 +284,9 @@ const tru = z.literal(true);
 
 > Currently there is no support for Date or bigint literals in Zod. If you have a use case for this feature, please file an issue.
 
-## Validation
-
-### Parsing
-
-`.parse(data:unknown): T`
-
-Given any Zod schema, you can call its `.parse` method to check `data` is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.
-
-> IMPORTANT: In Zod 2 and Zod 1.11+, the value returned by `.parse` is a _deep clone_ of the variable you passed in. This was also the case in zod@1.4 and earlier.
-
-<!-- The only exception to this is `Union` and `Intersection` schemas, which return the same value you pass in. -->
-
-```ts
-const stringSchema = z.string();
-stringSchema.parse("fish"); // => returns "fish"
-stringSchema.parse(12); // throws Error('Non-string type: number');
-```
-
-### Safe parse
-
-`.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }`
-
-If you don't want Zod to throw when validation errors occur, you can use `.safeParse` . This method returns an object, even if validation errors occur:
-
-```ts
-stringSchema.safeParse(12);
-// => { success: false; error: ZodError }
-
-stringSchema.safeParse("billie");
-// => { success: true; data: 'billie' }
-```
-
-There is also an asynchronous version:
-
-```ts
-await stringSchema.safeParseAsync("billie");
-```
-
-> You must use .parseAsync() or .safeParseAsync() if your schema contains asynchronous refinements for transformers.
-
-The result is a _discriminated union_ so you can handle errors very conveniently:
-
-```ts
-const result = stringSchema.safeParse("billie");
-if (!result.success) {
-  // handle error then return
-  return;
-}
-
-// underneath the if statement, TypeScript knows
-// that validation passed
-console.log(result.data);
-```
-
-> Errors thrown from within refinement functions will _not_ be caught.
-
-### Type guards
-
-`.check(data:unknown)`
-
-> ⚠️ Type guards have been removed in Zod 3 because of compatibility issues with transformers. You should safeParse to achieve a similar result that is compatible with transformers.
-
-### Refinements
-
-> ⚠️ Refinements must not throw. Instead they should return a falsy value to signal failure.
-
-`.refine(validator: (data:T)=>any, params?: RefineParams)`
-
-Zod lets you provide custom validation logic via _refinements_.
-
-Zod was designed to mirror TypeScript as closely as possible. But there are many so-called "refinement types" you may wish to check for that can't be represented in TypeScript's type system. For instance: checking that a number is an integer or that a string is a valid email address.
-
-For example, you can define a custom validation check on _any_ Zod schema with `.refine` :
-
-```ts
-const myString = z.string().refine((val) => val.length <= 255, {
-  message: "String can't be more than 255 characters",
-});
-```
-
-Refinements can also be async:
-
-```ts
-const userId = z.string().refine(async (id) => {
-  // verify that ID exists in database
-  return true;
-});
-```
-
-> ⚠️If you use async refinements, you must use the `.parseAsync` method to parse data! Otherwise Zod will throw an error.
-
-As you can see, `.refine` takes two arguments.
-
-1. The first is the validation function. This function takes one input (of type `T` — the inferred type of the schema) and returns `any`. Any truthy value will pass validation. (Prior to zod@1.6.2 the validation function had to return a boolean.)
-2. The second argument accepts some options. You can use this to customize certain error-handling behavior:
-
-```ts
-type RefineParams = {
-  // override error message
-  message?: string;
-
-  // appended to error path
-  path?: (string | number)[];
-
-  // params object you can use to customize message
-  // in error map
-  params?: object;
-};
-```
-
-These options let you define powerful custom behavior. Zod is commonly used for form validation. If you want to verify that "password" and "confirm" match, you can do so like this:
-
-```ts
-const passwordForm = z
-  .object({
-    password: z.string(),
-    confirm: z.string(),
-  })
-  .refine((data) => data.password === data.confirm, {
-    message: "Passwords don't match",
-    path: ["confirm"], // path of error
-  })
-  .parse({ password: "asdf", confirm: "qwer" });
-```
-
-Because you provided a `path` parameter, the resulting error will be:
-
-```ts
-ZodError {
-  issues: [{
-    "code": "custom",
-    "path": [ "confirm" ],
-    "message": "Passwords don't match"
-  }]
-}
-```
-
-Note that the `path` is set to `["confirm"]` , so you can easily display this error underneath the "Confirm password" textbox.
-
-Important note, the value passed to the `path` option is _concatenated_ to the actual error path. So if you took `passwordForm` from above and nested it inside another object, you would still get the error path you expect.
-
-```ts
-const allForms = z.object({ passwordForm }).parse({
-  passwordForm: {
-    password: "asdf",
-    confirm: "qwer",
-  },
-});
-```
-
-would result in
-
-```
-
-ZodError {
-  issues: [{
-    "code": "custom",
-    "path": [ "passwordForm", "confirm" ],
-    "message": "Passwords don't match"
-  }]
-}
-```
-
-## Type inference
-
-You can extract the TypeScript type of any schema with `z.infer<typeof mySchema>` .
-
-```ts
-const A = z.string();
-type A = z.infer<typeof A>; // string
-
-const u: A = 12; // TypeError
-const u: A = "asdf"; // compiles
-```
-
-We'll include examples of inferred types throughout the rest of the documentation.
-
 ## Strings
 
-There are a handful of string-specific validations.
-
-All of these validations allow you to _optionally_ specify a custom error message.
+Zod includes a handful of string-specific validations.
 
 ```ts
 z.string().min(5);
@@ -457,7 +305,7 @@ z.string().nonempty();
 
 ### Custom error messages
 
-Like `.refine` , The final (optional) argument is an object that lets you provide a custom error in the `message` field.
+Optionally, you can pass in a second argument to provide a custom error message.
 
 ```ts
 z.string().min(5, { message: "Must be 5 or more characters long" });
@@ -468,11 +316,9 @@ z.string().url({ message: "Invalid url" });
 z.string().uuid({ message: "Invalid UUID" });
 ```
 
-> To see the email and url regexes, check out [this file](https://github.com/colinhacks/zod/blob/master/src/types/string.ts). To use a more advanced method, use a custom refinement.
-
 ## Numbers
 
-There are a handful of number-specific validations.
+Zod includes a handful of number-specific validations.
 
 ```ts
 z.number().min(5);
@@ -486,7 +332,7 @@ z.number().negative(); //     < 0
 z.number().nonpositive(); //  <= 0
 ```
 
-You can optionally pass in a params object as the second argument to provide a custom error message.
+Optionally, you can pass in a second argument to provide a custom error message.
 
 ```ts
 z.number().max(5, { message: "this👏is👏too👏big" });
@@ -496,113 +342,68 @@ z.number().max(5, { message: "this👏is👏too👏big" });
 
 ```ts
 // all properties are required by default
-const dogSchema = z.object({
+const Dog = z.object({
   name: z.string(),
   age: z.number(),
 });
 
-type Dog = z.infer<typeof dogSchema>;
-/* 
-equivalent to:
-type Dog = { 
-  name: string; 
+// extract the inferred type like this
+type Dog = z.infer<typeof Dog>;
+
+// equivalent to:
+type Dog = {
+  name: string;
   age: number;
-}
-*/
+};
+```
 
-const cujo = dogSchema.parse({
-  name: "Cujo",
-  age: 4,
-}); // passes, returns Dog
+### `.shape`
 
-const fido: Dog = {
-  name: "Fido",
-}; // TypeError: missing required property `age`
+Use `.shape` to access the schemas for a particular key.
+
+```ts
+Dog.shape.name; // => string schema
+Dog.shape.age; // => number schema
 ```
 
-#### `.shape` property
+### `.extend`
 
-Use `.shape` to access an object schema's property schemas.
+You can add additional fields an object schema with the `.extend` method.
 
 ```ts
-const Location = z.object({
-  latitude: z.number(),
-  longitude: z.number(),
+const DogWithBreed = Dog.extend({
+  breed: z.string(),
 });
-
-const Business = z.object({
-  location: Location,
-});
-
-Business.shape.location; // => Location schema
 ```
 
-#### Merging
+You can use `.extend` to overwrite fields! Be careful with this power!
+
+### `.merge`
 
-You can combine two object schemas with `.merge` , like so:
+Merge two object schemas with `.merge`, like so:
 
 ```ts
-const BaseTeacher = z.object({ subjects: z.array(z.string()) });
+const BaseTeacher = z.object({ students: z.array(z.string()) });
 const HasID = z.object({ id: z.string() });
 
 const Teacher = BaseTeacher.merge(HasID);
-type Teacher = z.infer<typeof Teacher>; // => { subjects: string[], id: string }
-```
-
-You're able to fluently chain together many `.merge` calls as well:
-
-```ts
-// chaining mixins
-const Teacher = BaseTeacher.merge(HasId).merge(HasName).merge(HasAddress);
+type Teacher = z.infer<typeof Teacher>; // => { students: string[], id: string }
 ```
 
-<!-- `.merge` is just syntactic sugar over the more generic `z.intersection` which is documented below. -->
-
-> IMPORTANT: the schema returned by `.merge` is the _intersection_ of the two schemas. The schema passed into `.merge` does not "overwrite" properties of the original schema. To demonstrate:
+If the two schemas share keys, the properties of the _merged schema_ take precedence.
 
 ```ts
 const Obj1 = z.object({ field: z.string() });
 const Obj2 = z.object({ field: z.number() });
-
 const Merged = Obj1.merge(Obj2);
 
 type Merged = z.infer<typeof merged>;
-// => { field: never }
-// because no type can simultaneously be both a string and a number
-```
-
-To "overwrite" existing keys, use `.extend` (documented below).
-
-#### Extending objects
-
-You can add additional fields an object schema with the `.extend` method.
-
-> Before zod@1.8 this method was called `.augment` . The `augment` method is still available for backwards compatibility but it is deprecated and will be removed in a future release.
-
-```ts
-const Animal = z
-  .object({
-    species: z.string(),
-  })
-  .extend({
-    population: z.number(),
-  });
+// => { field: number }
 ```
 
-> ⚠️ You can use `.extend` to overwrite fields! Be careful with this power!
+### `.pick/.omit`
 
-```ts
-// overwrites `species`
-const ModifiedAnimal = Animal.extend({
-  species: z.array(z.string()),
-});
-
-// => { population: number, species: string[] }
-```
-
-#### Pick and omit
-
-Object masking is one of Zod's killer features. It lets you create slight variations of your object schemas easily and succinctly. Inspired by TypeScript's built-in `Pick` and `Omit` utility types, all Zod object schemas have `.pick` and `.omit` methods that return a "masked" version of the schema.
+Inspired by TypeScript's built-in `Pick` and `Omit` utility types, all Zod object schemas have `.pick` and `.omit` methods that return a modified version. Consider this Recipe schema:
 
 ```ts
 const Recipe = z.object({
@@ -616,7 +417,6 @@ To only keep certain keys, use `.pick` .
 
 ```ts
 const JustTheName = Recipe.pick({ name: true });
-
 type JustTheName = z.infer<typeof JustTheName>;
 // => { name: string }
 ```
@@ -630,53 +430,39 @@ type NoIDRecipe = z.infer<typeof NoIDRecipe>;
 // => { name: string, ingredients: string[] }
 ```
 
-This is useful for database logic, where endpoints often accept as input slightly modified versions of your database schemas. For instance, the input to a hypothetical `createRecipe` endpoint would accept the `NoIDRecipe` type, since the ID will be generated by your database automatically.
+### `.partial`
 
-> This is a vital feature for implementing typesafe backend logic, yet as far as I know, no other validation library (yup, Joi, io-ts, runtypes, class-validator, ow...) offers similar functionality as of this writing (April 2020). This is one of the must-have features that inspired the creation of Zod.
-
-#### Partials
-
-Inspired by the built-in TypeScript utility type [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt), all Zod object schemas have a `.partial` method that makes all properties optional.
+Inspired by the built-in TypeScript utility type [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt), the `.partial` method makes all properties optional.
 
 Starting from this object:
 
 ```ts
 const user = z.object({
   username: z.string(),
-  location: z.object({
-    latitude: z.number(),
-    longitude: z.number(),
-  }),
 });
-/*
-  { username: string, location: { city: number, state: number } }
-*/
+// { username: string }
 ```
 
 We can create a partial version:
 
 ```ts
 const partialUser = user.partial();
-/*
-{ 
-  username?: string | undefined,
-  location?: {
-    city: number;
-    state: number;
-  } | undefined
-}
-*/
-
-// equivalent to:
-const partialUser = z.object({
-  username: user.shape.username.optional(),
-  location: user.shape.location.optional(),
-});
+// { username?: string | undefined }
 ```
 
-Or you can use `.deepPartial` :
+### `.deepPartial`
+
+The `.partial` method is shallow — it only applies one level deep. There is also a "deep" version:
 
 ```ts
+const user = z.object({
+  username: z.string(),
+  location: z.object({
+    latitude: z.number(),
+    longitude: z.number(),
+  }),
+});
+
 const deepPartialUser = user.deepPartial();
 
 /* 
@@ -690,15 +476,11 @@ const deepPartialUser = user.deepPartial();
 */
 ```
 
-> Important limitation: deep partials only work as expected in hierarchies of object schemas. It also can't be used on recursive schemas currently, since creating a recursive schema requires casting to the generic `ZodSchema` type (which doesn't include all the methods of the `ZodObject` class). Currently an improved version of Zod is under development that will have better support for recursive schemas.
-
-#### Unknown keys
-
-By default Zod object schema strip unknown keys from the output.
+> Important limitation: deep partials only work as expected in direct hierarchies of object schemas. A nested object schema can't be optional, nullable, contain refinements, contain transforms, etc.
 
-> ⚠️ Before version 2, Zod did NOT allow unknown keys by default.
+### Unrecognized keys
 
-Zod will return
+By default Zod objects schemas strip out unrecognized keys during parsing.
 
 ```ts
 const person = z.object({
@@ -710,29 +492,22 @@ person.parse({
   extraKey: 61,
 });
 // => { name: "bob dylan" }
+// extraKey has been stripped
 ```
 
-#### Pass through unknown keys
+### `.passthrough`
 
-If you want to pass through unknown keys, use `.passthrough()` .
-
-> For backwards compatibility, you can also use `.nonstrict()` which behaves identically.
+Instead, if you want to pass through unknown keys, use `.passthrough()` .
 
 ```ts
-const person = z
-  .object({
-    name: z.string(),
-  })
-  .passthrough();
-
-person.parse({
+person.passthrough().parse({
   name: "bob dylan",
   extraKey: 61,
 });
 // => { name: "bob dylan", extraKey: 61 }
 ```
 
-#### Disallow unknown keys
+### `.strict`
 
 You can _disallow_ unknown keys with `.strict()` . If there are any unknown keys in the input, Zod will throw an error.
 
@@ -750,45 +525,13 @@ person.parse({
 // => throws ZodError
 ```
 
-#### Primitives and nonprimitives
-
-Zod provides a convenience method for automatically picking all primitive or non-primitive fields from an object schema.
-
-```ts
-const Post = z.object({
-  title: z.string()
-});
-
-const User = z.object({
-  id: z.number(),
-  name: z.string(),
-  posts: z.array(Post)
-});
-
-const UserFields = User.primitives();
-typeof UserFields = z.infer<typeof UserFields>;
-// => { id: number; name; string; }
-
-const UserRelations = User.nonprimitives();
-typeof UserFields = z.infer<typeof UserFields>;
-// => { posts: Post[] }
-```
-
-These schemas are considering "primitive":
+### `.strip`
 
-- string
-- number
-- boolean
-- bigint
-- date
-- null/undefined
-- enums
-- any array of the above types
-- any union of the above types
+You can use the `.strip` method to reset an object schema to the default behavior (stripping unrecognized keys).
 
-#### Catchall
+### `.catchall`
 
-You can add a `catchall` schema with `.catchall()` . All unknown keys will be validated against the catchall schema.
+You can pass a "catchall" schema into an object schema. All unknown keys will be validated against it.
 
 ```ts
 const person = z
@@ -801,243 +544,211 @@ person.parse({
   name: "bob dylan",
   validExtraKey: 61, // works fine
 });
-// => { name: "bob dylan", validExtraKey: 61 }
-```
-
-> Using `.catchall()` overrides `.passsthrough()` , `.strip()` , or `.strict()` . All keys are now considered "known".
-
-## Records
-
-Record schemas are used to validate types such as this:
 
-```ts
-type NumberCache = { [k: string]: number };
+person.parse({
+  name: "bob dylan",
+  validExtraKey: false, // fails
+});
+// => throws ZodError
 ```
 
-If you want to validate that all the _values_ of an object match some schema, without caring about the keys, you should use a Record.
-
-<!-- Records are similar to object schemas, but don't enforce a type restriction on the keys. For instance: -->
-
-<!--
-
-``` ts
-const objectSchema = z.object({ name: z.string() });
-``` -->
+Using `.catchall()` obviates `.passthrough()` , `.strip()` , or `.strict()`. All keys are now considered "known".
 
-<!-- `objectSchema` only accepts objects with single key: `name`. You could use `.nonstrict()` to create a schema that accepts unknown keys, but that schema doesn't enforce a type on the _values_ associated with those unknown keys. -->
+## Arrays
 
-<!-- ```ts
-const nonstrict = objectSchema.nonstrict();
-type nonstrict = z.infer<typeof nonstrict>;
-// => { name: string, [k:string]: any }
+```ts
+const stringArray = z.array(z.string());
 
-const parsed = nonstrict.parse({ name: 'Serena', bar: ['whatever'] });
-parsed.bar; // no type information
-``` -->
+// equivalent
+const stringArray = z.string().array();
+```
 
-<!-- But what if you want an object that enforces a schema on all of the values it contains? That's when you would use a record. -->
+Be careful with the `.array()` method. It returns a new `ZodArray` instance. This means the _order_ in which you call methods matters. For instance:
 
 ```ts
-const User = z.object({
-  name: z.string(),
-});
-
-const UserStore = z.record(User);
-
-type UserStore = z.infer<typeof UserStore>;
-// => { [k: string]: User }
+z.string().optional().array(); // (string | undefined)[]
+z.string().array().optional(); // string[] | undefined
 ```
 
-This is particularly useful for storing or caching items by ID.
+### `.nonempty`
 
-```ts
-const userStore: UserStore = {};
+If you want to ensure that an array contains at least one element, use `.nonempty()`.
 
-userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
-  name: "Carlotta",
-}; // passes
+```ts
+const nonEmptyStrings = z.string().array().nonempty();
+// the inferred type is now
+// [string, ...string[]]
 
-userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
-  whatever: "Ice cream sundae",
-}; // TypeError
+nonEmptyStrings.parse([]); // throws: "Array cannot be empty"
+nonEmptyStrings.parse(["Ariana Grande"]); // passes
 ```
 
-And of course you can call `.parse` just like any other Zod schema.
+### `.min/.max/.length`
 
 ```ts
-UserStore.parse({
-  user_1328741234: { name: "James" },
-}); // => passes
+z.string().array().min(5); // must contain 5 or more items
+z.string().array().max(5); // must contain 5 or fewer items
+z.string().array().length(5); // must contain 5 items exactly
 ```
 
-#### A note on numerical keys
+Unlike `.nonempty()` these methods do not change the inferred type.
 
-You may have expected `z.record()` to accept two arguments, one for the keys and one for the values. After all, TypeScript's built-in Record type does: `Record<KeyType, ValueType>` . Otherwise, how do you represent the TypeScript type `Record<number, any>` in Zod?
+## Unions
 
-As it turns out, TypeScript's behavior surrounding `[k: number]` is a little unintuitive:
+Zod includes a built-in `z.union` method for composing "OR" types.
 
 ```ts
-const testMap: { [k: number]: string } = {
-  1: "one",
-};
+const stringOrNumber = z.union([z.string(), z.number()]);
 
-for (const key in testMap) {
-  console.log(`${key}: ${typeof key}`);
-}
-// prints: `1: string`
+stringOrNumber.parse("foo"); // passes
+stringOrNumber.parse(14); // passes
 ```
 
-As you can see, JavaScript automatically casts all object keys to strings under the hood.
-
-Since Zod is trying to bridge the gap between static and runtime types, it doesn't make sense to provide a way of creating a record schema with numerical keys, since there's no such thing as a numerical key in runtime JavaScript.
+Zod will test the input against each of the "options" in order and return the first value that validates successfully.
 
-## Arrays
+For convenience, you can also use the `.or` method:
 
-There are two ways to define array schemas:
+```ts
+const stringOrNumber = z.string().or(z.number());
+```
 
-#### `z.array(arg: ZodSchema)`
+## Optionals
 
-First, you can create an array schema with the `z.array()` function; it accepts another ZodSchema, which defines the type of each array element.
+You can make any schema optional with `z.optional()`:
 
 ```ts
-const stringArray = z.array(z.string());
-// inferred type: string[]
-```
+const schema = z.optional(z.string());
 
-#### the `.array()` method
+schema.parse(undefined); // => returns undefined
+type A = z.infer<typeof A>; // string | undefined
+```
 
-Second, you can call the `.array()` method on **any** Zod schema:
+You can make an existing schema optional with the `.optional()` method:
 
 ```ts
-const stringArray = z.string().array();
-// inferred type: string[]
+const user = z.object({
+  username: z.string().optional(),
+});
+type C = z.infer<typeof C>; // { username?: string | undefined };
 ```
 
-You have to be careful with the `.array()` method. It returns a new `ZodArray` instance. This means you need to be careful about the _order_ in which you call methods. These two schemas are very different:
+#### `.unwrap`
 
 ```ts
-z.string().undefined().array(); // (string | undefined)[]
-z.string().array().undefined(); // string[] | undefined
+const stringSchema = z.string();
+const optionalString = stringSchema.optional();
+optionalString.unwrap() === stringSchema; // true
 ```
 
-<!-- You can define arrays of **any** other Zod schema, no matter how complicated.
-
-``` ts
-const dogsList = z.array(dogSchema);
-dogsList.parse([{ name: 'Fido', age: 4, neutered: true }]); // passes
-dogsList.parse([]); // passes
-``` -->
+## Nullables
 
-#### Non-empty lists
+Similarly, you can create nullable types like so:
 
 ```ts
-const nonEmptyStrings = z.string().array().nonempty();
-// [string, ...string[]]
-
-nonEmptyStrings.parse([]); // throws: "Array cannot be empty"
-nonEmptyStrings.parse(["Ariana Grande"]); // passes
+const nullableString = z.nullable(z.string());
+nullableString.parse("asdf"); // => "asdf"
+nullableString.parse(null); // => null
 ```
 
-#### Length validations
+You can make an existing schema nullable with the `nullable` method:
 
 ```ts
-// must contain 5 or more items
-z.array(z.string()).min(5);
-
-// must contain 5 or fewer items
-z.array(z.string()).max(5);
-
-// must contain exactly 5 items
-z.array(z.string()).length(5);
+const E = z.string().nullable(); // equivalent to D
+type E = z.infer<typeof D>; // string | null
 ```
 
-## Unions
-
-Zod includes a built-in `z.union` method for composing "OR" types.
+#### `.unwrap`
 
 ```ts
-const stringOrNumber = z.union([z.string(), z.number()]);
-
-stringOrNumber.parse("foo"); // passes
-stringOrNumber.parse(14); // passes
+const stringSchema = z.string();
+const nullableString = stringSchema.nullable();
+nullableString.unwrap() === stringSchema; // true
 ```
 
-Zod will test the input against each of the "options" in order and return the first value that validates successfully.
-
 <!--
 
 ``` ts
-z.union([
-  z
-    .string()
-    .refine(val => val.length > 5)
-    .transform(val => val.toUpperCase()),
-  z.string().transform(val => val.toLowerCase()),
-]).parse('AsDf'); // => "asdf"
+/* Custom Union Types */
+
+const F = z
+  .union([z.string(), z.number(), z.boolean()])
+  .optional()
+  .nullable();
+
+F.parse('tuna'); // => tuna
+F.parse(42); // => 42
+F.parse(true); // => true
+F.parse(undefined); // => undefined
+F.parse(null); // => null
+F.parse({}); // => throws Error!
+
+type F = z.infer<typeof F>; // string | number | boolean | undefined | null;
 ``` -->
 
-## Optional types
+## Records
 
-<!-- Unions are the basis for defining optional schemas. An "optional string" is just the union of `string` and `undefined`. -->
+Record schemas are used to validate types such as `{ [k: string]: number }`.
 
-You can make any schema optional with `z.optional()`:
+If you want to validate the _values_ of an object against some schema but don't care about the keys, use `Record`.
 
 ```ts
-const A = z.optional(z.string());
+const NumberCache = z.record(z.number());
 
-A.parse(undefined); // => passes, returns undefined
-type A = z.infer<typeof A>; // string | undefined
+type NumberCache = z.infer<typeof NumberCache>;
+// => { [k: string]: number }
 ```
 
-You can also call the `.optional()` method on an existing schema:
+This is particularly useful for storing or caching items by ID.
 
 ```ts
-const B = z.boolean().optional();
+const userStore: UserStore = {};
 
-const C = z.object({
-  username: z.string().optional(),
-});
-type C = z.infer<typeof C>; // { username?: string | undefined };
-```
+userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
+  name: "Carlotta",
+}; // passes
 
-## Nullable types
+userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
+  whatever: "Ice cream sundae",
+}; // TypeError
+```
 
-Similarly, you can create nullable types like so:
+#### A note on numerical keys
 
-```ts
-const D = z.nullable(z.string());
-D.parse("asdf"); // => "asdf"
-D.parse(null); // => null
-```
+You may have expected `z.record()` to accept two arguments, one for the keys and one for the values. After all, TypeScript's built-in Record type does: `Record<KeyType, ValueType>` . Otherwise, how do you represent the TypeScript type `Record<number, any>` in Zod?
 
-Or you can use the `.nullable()` method on any existing schema:
+As it turns out, TypeScript's behavior surrounding `[k: number]` is a little unintuitive:
 
 ```ts
-const E = z.string().nullable(); // equivalent to D
-type E = z.infer<typeof D>; // string | null
+const testMap: { [k: number]: string } = {
+  1: "one",
+};
+
+for (const key in testMap) {
+  console.log(`${key}: ${typeof key}`);
+}
+// prints: `1: string`
 ```
 
-You can create unions of any two or more schemas.
+As you can see, JavaScript automatically casts all object keys to strings under the hood.
 
-<!--
+Since Zod is trying to bridge the gap between static and runtime types, it doesn't make sense to provide a way of creating a record schema with numerical keys, since there's no such thing as a numerical key in runtime JavaScript.
 
-``` ts
-/* Custom Union Types */
+## Maps
 
-const F = z
-  .union([z.string(), z.number(), z.boolean()])
-  .optional()
-  .nullable();
+```ts
+const stringNumberMap = z.map(z.string(), z.number());
 
-F.parse('tuna'); // => tuna
-F.parse(42); // => 42
-F.parse(true); // => true
-F.parse(undefined); // => undefined
-F.parse(null); // => null
-F.parse({}); // => throws Error!
+type StringNumberMap = z.infer<typeof stringNumberMap>;
+// type StringNumber = Map<string, number>
+```
 
-type F = z.infer<typeof F>; // string | number | boolean | undefined | null;
-``` -->
+## Sets
+
+```ts
+const numberSet = z.set(z.string());
+type numberSet = z.infer<typeof numberSet>;
+// Set<number>
+```
 
 ## Enums
 
@@ -1045,7 +756,7 @@ There are two ways to define enums in Zod.
 
 ### Zod enums
 
-An enum is just a union of string literals, so you _could_ define an enum like this:
+<!-- An enum is just a union of string literals, so you _could_ define an enum like this:
 
 ```ts
 const FishEnum = z.union([
@@ -1058,18 +769,24 @@ FishEnum.parse("Salmon"); // => "Salmon"
 FishEnum.parse("Flounder"); // => throws
 ```
 
-For convenience Zod provides a built-in `z.enum()` function. Here's is the equivalent code:
+For convenience Zod provides a built-in `z.enum()` function. Here's is the equivalent code: -->
 
 ```ts
 const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
-
 type FishEnum = z.infer<typeof FishEnum>;
 // 'Salmon' | 'Tuna' | 'Trout'
 ```
 
-> Important! You need to pass the literal array _directly_ into z.enum(). Do not define it separately, than pass it in as a variable! This is required for proper type inference.
+You must pass the array of values directly into `z.enum()`. This does not work:
+
+```ts
+const fish = ["Salmon", "Tuna", "Trout"];
+const FishEnum = z.enum(fish);
+```
+
+In that case, Zod isn't able to infer the individual enum elements; instead the inferred type will be `string` instead of `'Salmon' | 'Tuna' | 'Trout'`
 
-**Autocompletion**
+#### Autocompletion
 
 To get autocompletion with a Zod enum, use the `.enum` property of your schema:
 
@@ -1094,9 +811,7 @@ FishEnum.options; // ["Salmon", "Tuna", "Trout"]);
 
 ### Native enums
 
-> ⚠️ `nativeEnum()` requires TypeScript 3.6 or higher!
-
-Zod enums are the recommended approach to defining and validating enums. But there may be scenarios where you need to validate against an enum from a third-party library, or perhaps you don't want to rewrite your existing enums. For this you can use `z.nativeEnum()` .
+Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don't want to rewrite your existing enums) you can use `z.nativeEnum()` .
 
 **Numeric enums**
 
@@ -1156,49 +871,12 @@ FruitEnum.parse(3); // passes
 FruitEnum.parse("Cantaloupe"); // fails
 ```
 
-## Intersections
-
-<!-- > ⚠️ Intersections are deprecated. If you are trying to merge objects, use the `.merge` method instead. -->
-
-Intersections are useful for creating "logical AND" types.
-
-```ts
-const a = z.union([z.number(), z.string()]);
-const b = z.union([z.number(), z.boolean()]);
-const c = z.intersection(a, b);
-
-type c = z.infer<typeof c>; // => number
-
-const stringAndNumber = z.intersection(z.string(), z.number());
-type Never = z.infer<typeof stringAndNumber>; // => never
-```
-
-<!-- Intersections in Zod are not smart. Whatever data you pass into `.parse()` gets passed into the two intersected schemas. Because Zod object schemas don't allow any unknown keys by default, there are some unintuitive behavior surrounding intersections of object schemas. -->
-
-<!--
-
-``` ts
-const A = z.object({
-  a: z.string(),
-});
-
-const B = z.object({
-  b: z.string(),
-});
-
-const AB = z.intersection(A, B);
-
-type Teacher = z.infer<typeof Teacher>;
-// { id:string; name:string };
-```  -->
-
 ## Tuples
 
-These differ from arrays in that they have a fixed number of elements, and each element can have a different type.
+Unlike arrays, tuples have a fixed number of elements and each element can have a different type.
 
 ```ts
 const athleteSchema = z.tuple([
-  // takes an array of schemas
   z.string(), // name
   z.number(), // jersey number
   z.object({
@@ -1212,7 +890,7 @@ type Athlete = z.infer<typeof athleteSchema>;
 
 ## Recursive types
 
-You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. If you need a recursive Zod schema you'll need to define the type definition manually, and provide it to Zod as a "type hint".
+You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a "type hint".
 
 ```ts
 interface Category {
@@ -1220,6 +898,7 @@ interface Category {
   subcategories: Category[];
 }
 
+// cast to z.ZodSchema<Category>
 const Category: z.ZodSchema<Category> = z.lazy(() =>
   z.object({
     name: z.string(),
@@ -1240,7 +919,7 @@ Category.parse({
 
 Unfortunately this code is a bit duplicative, since you're declaring the types twice: once in the interface and again in the Zod definition.
 
-If your schema has lots of primitive fields, there's a way of reducing the amount of duplication:
+<!-- If your schema has lots of primitive fields, there's a way of reducing the amount of duplication:
 
 ```ts
 // define all the non-recursive stuff here
@@ -1262,11 +941,11 @@ const Category: z.ZodSchema<Category> = BaseCategory.merge(
     subcategories: z.lazy(() => z.array(Category)),
   })
 );
-```
+``` -->
 
-#### JSON type
+### JSON type
 
-If you want to validate any JSON value, you can use the snippet below. This requires TypeScript 3.7 or higher!
+If you want to validate any JSON value, you can use the snippet below.
 
 ```ts
 type Literal = boolean | null | number | string;
@@ -1276,32 +955,14 @@ const jsonSchema: z.ZodSchema<Json> = z.lazy(() =>
   z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])
 );
 
-jsonSchema.parse({
-  // data
-});
+jsonSchema.parse(data);
 ```
 
 Thanks to [ggoodman](https://github.com/ggoodman) for suggesting this.
 
-#### Cyclical objects
-
-As of Zod 2, Zod _no longer_ supports cyclical objects. If you absolutely need this feature you can still use Zod v1.
+### Cyclical objects
 
-<!-- Validation still works as expected even when there are cycles in the data.
-
-``` ts
-const cyclicalCategory: any = {
-  name: 'Category A',
-};
-
-// creating a cycle
-cyclicalCategory.subcategories = [cyclicalCategory];
-
-const parsedCategory = Category.parse(cyclicalCategory); // parses successfully
-
-parsedCategory.subcategories[0].subcategories[0].subcategories[0];
-// => parsedCategory: Category;
-``` -->
+Despite supporting recursive schemas, passing an cyclical data into Zod will cause an infinite loop.
 
 ## Promises
 
@@ -1312,7 +973,7 @@ const numberPromise = z.promise(z.number());
 "Parsing" works a little differently with promise schemas. Validation happens in two parts:
 
 1. Zod synchronously checks that the input is an instance of Promise (i.e. an object with `.then` and `.catch` methods.).
-2. Zod _waits for the promise to resolve_ then validates the resolved value.
+2. Zod uses `.then` to attach an additional validation step onto the existing Promise. You'll have to use `.catch` on the returned Promise to handle validation failures.
 
 ```ts
 numberPromise.parse("tuna");
@@ -1330,22 +991,13 @@ const test = async () => {
 };
 ```
 
-#### Non-native promise implementations
-
-When "parsing" a promise, Zod checks that the passed value is an object with `.then` and `.catch` methods — that's it. So you should be able to pass non-native Promises (Bluebird, etc) into `z.promise(...).parse` with no trouble. One gotcha: the return type of the parse function will be a _native_ `Promise` , so if you have downstream logic that uses non-standard Promise methods, this won't work.
+<!-- #### Non-native promise implementations
 
-## Maps
-
-```ts
-const stringNumberMap = z.map(z.string(), z.number());
-
-type StringNumberMap = z.infer<typeof stringNumberMap>;
-// type StringNumber = Map<string, number>
-```
+When "parsing" a promise, Zod checks that the passed value is an object with `.then` and `.catch` methods — that's it. So you should be able to pass non-native Promises (Bluebird, etc) into `z.promise(...).parse` with no trouble. One gotcha: the return type of the parse function will be a _native_ `Promise` , so if you have downstream logic that uses non-standard Promise methods, this won't work. -->
 
 ## Instanceof
 
-You can use `z.instanceof` to create a schema that checks if the input is an instance of a class.
+You can use `z.instanceof` to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-party libraries.
 
 ```ts
 class Test {
@@ -1355,10 +1007,8 @@ class Test {
 const TestSchema = z.instanceof(Test);
 
 const blob: any = "whatever";
-const parsed = TestSchema.safeParse(blob);
-if (parsed.success) {
-  parsed.data; // instance of Test
-}
+TestSchema.parse(new Test()); // passes
+TestSchema.parse("blob"); // throws
 ```
 
 ## Function schemas
@@ -1404,7 +1054,7 @@ type myFunction = z.infer<typeof myFunction>;
 // => (arg0: string)=>number
 ``` -->
 
-Function schemas have an `.implement()` method which accepts a function and returns a new function.
+Function schemas have an `.implement()` method which accepts a function and returns a new function that automatically validates it's inputs and outputs.
 
 ```ts
 const trimmedLength = z
@@ -1420,142 +1070,225 @@ trimmedLength("sandwich"); // => 8
 trimmedLength(" asdf "); // => 4
 ```
 
-`trimmedLength` now automatically validates both its inputs and return value against the schemas provided to `z.function` . If either is invalid, the function throws. This way you can confidently write application logic in a "validated function" without worrying about invalid inputs, scattering `schema.validate()` calls in your endpoint definitions, or writing duplicative types for your functions.
+If you only care about validating inputs, that's fine:
+
+```ts
+const myFunction = z
+  .function()
+  .args(z.string())
+  .implement((arg) => {
+    return [arg.length]; //
+  });
+myFunction; // (arg: string)=>number[]
+```
+
+# Methods
 
-Here's a more complex example showing how to write a typesafe API query endpoint:
+All Zod schemas contain certain methods.
+
+### `.parse`
+
+`.parse(data:unknown): T`
+
+Given any Zod schema, you can call its `.parse` method to check `data` is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.
+
+> IMPORTANT: In Zod 2 and Zod 1.11+, the value returned by `.parse` is a _deep clone_ of the variable you passed in. This was also the case in zod@1.4 and earlier.
 
 ```ts
-const FetcherEndpoint = z
-  .function(args, returnType)
-  .args(z.object({ id: z.string() }))
-  .returns(
-    z.promise(
-      z.object({
-        id: string(),
-        name: string(),
-      })
-    )
-  );
+const stringSchema = z.string();
+stringSchema.parse("fish"); // => returns "fish"
+stringSchema.parse(12); // throws Error('Non-string type: number');
+```
 
-const getUserByID = FetcherEndpoint.validate(async (args) => {
-  args; // => { id: string }
+### `.parseAsync`
 
-  const user = await User.findByID(args.id);
+`.parseAsync(data:unknown): Promise<T>`
 
-  // TypeScript statically verifies that value returned by
-  // this function is of type Promise<{ id: string; name: string; }>
-  return "salmon"; // TypeError
+If you use asynchronous [refinements](#refinements) or [transforms](#transformers) (more on those later), you'll need to use `.parseAsync`
 
-  return user; // compiles successfully
-});
+```ts
+const stringSchema = z.string().refine(async (val) => val.length > 20);
+const value = await stringSchema.parseAsync("hello"); // => hello
 ```
 
-> This is particularly useful for defining HTTP or RPC endpoints that accept complex payloads that require validation. Moreover, you can define your endpoints once with Zod and share the code with both your client and server code to achieve end-to-end type safety.
+### `.safeParse`
+
+`.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }`
+
+If you don't want Zod to throw errors when validation fails, use `.safeParse`. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.
 
 ```ts
-// Express example
-server.get(`/user/:id`, async (req, res) => {
-  const user = await getUserByID({ id: req.params.id }).catch((err) => {
-    res.status(400).send(err.message);
-  });
+stringSchema.safeParse(12);
+// => { success: false; error: ZodError }
 
-  res.status(200).send(user);
-});
+stringSchema.safeParse("billie");
+// => { success: true; data: 'billie' }
 ```
 
-<!--
+The result is a _discriminated union_ so you can handle errors very conveniently:
 
-## Masking
+```ts
+const result = stringSchema.safeParse("billie");
+if (!result.success) {
+  // handle error then return
+  result.error;
+} else {
+  // do something
+  result.data;
+}
+```
 
-Masking is one of Zod's killer features. It sets it a step ahead of most other libraries, especially those that utilize class-based validation schemas (like TypeORM). The problem with defining schemas as a class is that it's not possible to generate slight variations of it. Doing so would require high-order generics, which doesyou would need to implement a "doubly-generic" class factory.
+### `.safeParseAsync`
 
-Consider an example where you define a `User` schema with two fields:
+There is also an asynchronous version of `safeParse`:
 
-``` ts
-const User = z.object({
-  id: z.string(),
-  name: z.string(),
-});
+```ts
+await stringSchema.safeParseAsync("billie");
+```
+
+For convenience, this has been aliased to `.spa`:
+
+```ts
+await stringSchema.spa("billie");
 ```
 
-If you want to implement a typesafe "createUser" function, you'll need a slightly modified version of `User` as the argument. Specifically, you'll want to get rid of the `id` field, assuming your database auto-generates IDs. Historically you'd have to define a brand-new schema, say `CreateUserInput` .
+### `.refine`
 
-If this example sounds contrived, check out the homepage of the popular GraphQL schema definition library [TypeGraphQL](https://typegraphql.com/). The sample code shows two declarations: one for the `Recipe` model and another _nearly identical_ class for `RecipeInput` (the data type used to create new recipes). Unfortunately duplicative definitions like this are commonly needed (especially in the GraphQL ecosystem), meaning you have to keep a slew of slightly modified schemas in sync manually.
+`.refine(validator: (data:T)=>any, params?: RefineParams)`
 
-Zod's solution to this is "masking". Masking is known by a lot of other names too: _derived types_, _views_ (especially in the SQL world), _projections_, and more.
+Zod lets you provide custom validation logic via _refinements_.
 
-#### Picking
+Zod was designed to mirror TypeScript as closely as possible. But there are many so-called "refinement types" you may wish to check for that can't be represented in TypeScript's type system. For instance: checking that a number is an integer or that a string is a valid email address.
 
-``` ts
-const User = z.object({
-  id: z.string(),
-  name: z.string(),
+For example, you can define a custom validation check on _any_ Zod schema with `.refine` :
+
+```ts
+const myString = z.string().refine((val) => val.length <= 255, {
+  message: "String can't be more than 255 characters",
 });
+```
 
-const createUserInput = User.pick({ name: true });
+> ⚠️ Refinement functions should not throw. Instead they should return a falsy value to signal failure.
 
-type createUserInput = z.infer<typeof createUserInput>;
-// => { name: string }
+#### Arguments
+
+As you can see, `.refine` takes two arguments.
+
+1. The first is the validation function. This function takes one input (of type `T` — the inferred type of the schema) and returns `any`. Any truthy value will pass validation. (Prior to zod@1.6.2 the validation function had to return a boolean.)
+2. The second argument accepts some options. You can use this to customize certain error-handling behavior:
+
+```ts
+type RefineParams = {
+  // override error message
+  message?: string;
+
+  // appended to error path
+  path?: (string | number)[];
+
+  // params object you can use to customize message
+  // in error map
+  params?: object;
+};
 ```
 
-Equivalently, you can use `.omit` to remove keys from the object schema.
+For advanced cases, the second argument can also be a function that returns `RefineParams`/
 
-``` ts
-const createUserInput = User.pick({ id: true });
+```ts
+z.string().refine(
+  (val) => val.length > 10,
+  (val) => ({ message: `${val} is not more than 10 characters` })
+);
+```
 
-type createUserInput = z.infer<typeof createUserInput>;
-// => { name: string }
+#### Customize error path
+
+```ts
+const passwordForm = z
+  .object({
+    password: z.string(),
+    confirm: z.string(),
+  })
+  .refine((data) => data.password === data.confirm, {
+    message: "Passwords don't match",
+    path: ["confirm"], // path of error
+  })
+  .parse({ password: "asdf", confirm: "qwer" });
+```
+
+Because you provided a `path` parameter, the resulting error will be:
+
+```ts
+ZodError {
+  issues: [{
+    "code": "custom",
+    "path": [ "confirm" ],
+    "message": "Passwords don't match"
+  }]
+}
 ```
 
-#### Nested objects
+#### Asynchronous refinements
 
-Masking also works on nested object schemas:
+Refinements can also be async:
 
-``` ts
-const User = z.object({
-  outer: z.object({
-    prop1: z.string(),
-    inner: z.object({
-      prop2: z.number(),
-    }),
-  }),
+```ts
+const userId = z.string().refine(async (id) => {
+  // verify that ID exists in database
+  return true;
 });
+```
+
+> ⚠️If you use async refinements, you must use the `.parseAsync` method to parse data! Otherwise Zod will throw an error.
+
+#### Relationship to transforms
 
-// picking
-User.pick({ outer: true }); // { outer: inner: { prop1: string, prop2: number }}
-User.pick({ outer: { prop1: true } }); // { outer: { prop1: string }}
-User.pick({ outer: { inner: true } }); // { outer: { innfer: { prop2: number }}}
-User.pick({ outer: { prop1: true, inner: { prop2: true } } }); // { outer: inner: { prop1: string, prop2: number }}
+Transforms and refinements can be interleaved:
 
-// omiting
-User.omit({ outer: true }); // {}
-User.omit({ outer: { prop1: true } }); // { outer: { inner: { prop2: number }}}
-User.omit({ outer: { inner: true } }); // { outer: { prop1: string }}
-User.omit({ outer: { inner: { prop2: true } } }); // { outer: { prop1: string, inner: {} }}
+```ts
+z.string()
+  .transform((val) => val.length)
+  .refine((val) => val > 25);
 ```
 
-#### Recursive schemas -->
+<!-- Note that the `path` is set to `["confirm"]` , so you can easily display this error underneath the "Confirm password" textbox.
+
 
-## Transformers
+```ts
+const allForms = z.object({ passwordForm }).parse({
+  passwordForm: {
+    password: "asdf",
+    confirm: "qwer",
+  },
+});
+```
 
-You can integrate custom data transformations into your schemas with transformers. Transformers are just another type of Zod schema.
+would result in
 
-> ⚠️ Transformation functions must not throw. Make sure to use refinements before the transformer to make sure the input can be parsed by the transformer.
+```
 
-> ⚠️ The `z.transformer(A, B, func)` syntax was removed in Zod 3.
+ZodError {
+  issues: [{
+    "code": "custom",
+    "path": [ "passwordForm", "confirm" ],
+    "message": "Passwords don't match"
+  }]
+}
+``` -->
 
-### z.transformer()
+### `.transform`
 
-You use transformers using the `.transform()` method.
+To transform data after parsing, use the `transform` method.
 
 ```ts
 const stringToNumber = z.string().transform((val) => myString.length);
 stringToNumber.parse("string"); // => 6
 ```
 
+> ⚠️ Transformation functions must not throw. Make sure to use refinements before the transformer to make sure the input can be parsed by the transformer.
+
 #### Chaining order
 
-Note that `stringToNumber` above is an instance of the `ZodTransformer` subclass. It is NOT an instance of `ZodString`. If you want to use the built-in methods of `ZodString` (e.g. `.email()`) you must apply those methods _before_ any transformations.
+Note that `stringToNumber` above is an instance of the `ZodEffects` subclass. It is NOT an instance of `ZodString`. If you want to use the built-in methods of `ZodString` (e.g. `.email()`) you must apply those methods _before_ any transformations.
 
 ```ts
 const emailToDomain = z
@@ -1566,6 +1299,16 @@ const emailToDomain = z
 emailToDomain.parse("colinhacks@example.com"); // => example.com
 ```
 
+#### Relationship to refinements
+
+Transforms and refinements can be interleaved:
+
+```ts
+z.string()
+  .transform((val) => val.length)
+  .refine((val) => val > 25);
+```
+
 #### Async transformations
 
 Transformations can also be async.
@@ -1582,29 +1325,16 @@ const IdToUser = z.transformer(
 
 > ⚠️ If your schema contains asynchronous transformers, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error.
 
-### Default values
+### `.default`
 
 You can use transformers to implement the concept of "default values" in Zod.
 
 ```ts
-const stringWithDefault = z
-  .string()
-  .optional()
-  .transform((val) => {
-    return typeof val !== "undefined" ? val : "tuna";
-  });
+const stringWithDefault = z.string().default("tuna");
 
 stringWithDefault.parse(undefined); // => "tuna"
 ```
 
-### .default
-
-You can also use the provided convenience method `.default` like so:
-
-```ts
-const stringWithDefault = z.string().default("tuna");
-```
-
 Optionally, you can pass a function into `.default` that will be re-executed whenever a default value needs to be generated:
 
 ```ts
@@ -1615,28 +1345,70 @@ numberWithRandomDefault.parse(undefined); // => 0.1871840107401901
 numberWithRandomDefault.parse(undefined); // => 0.7223408162401552
 ```
 
-### Type inference for transformers
+# Type inference
+
+You can extract the TypeScript type of any schema with `z.infer<typeof mySchema>` .
+
+```ts
+const A = z.string();
+type A = z.infer<typeof A>; // string
+
+const u: A = 12; // TypeError
+const u: A = "asdf"; // compiles
+```
+
+#### What about transforms?
 
-Every Zod schema is associated with an _input type_ and and _output type_. For most schemas (e.g. `z.string()`) these two are the same. But for Transformers, they are different. For instance `z.string().transform(val => val.length)` has an input of `string` and an output of `number`.
+In reality each Zod schema is actually associated with **two** types: an input and an output. For most schemas (e.g. `z.string()`) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance `z.string().transform(val => val.length)` has an input of `string` and an output of `number`.
 
-Normally you can use `z.infer<typeof A>` to extract the inferred type of schema A. But for schemas we introduce two new methods that allow you to separately extract the input _and_ output independently.
+You can separately extract the input and output types like so:
 
 ```ts
 const stringToNumber = z.string().transform(val => val.length)
 
-// it is equivalent to z.output<>
-type out = z.output<stringToNumber>; // number
+// ⚠️ Important: z.infer returns the OUTPUT type!
+type type = z.infer<stringToNumber>; // number
+type out = z.output<stringToNumber>; // number, equivalent to z.infer
+type in = z.input<stringToNumber>; // string, returns input type
+```
+
+# Errors
 
-// you can use z.input<> to get the input type
-type in = z.input<stringToNumber>; // string
+Zod provides a subclass of Error called ZodError. ZodErrors contain an `issues` array containing detailed information about the validation problems.
 
-// ⚠️ Important: z.infer gives the OUTPUT type!
-type type = z.infer<stringToNumber>; // number
+```ts
+const data = z
+  .object({
+    name: z.string(),
+  })
+  .safeParse({ name: 12 });
+
+if (!data.success) {
+  data.error.issues;
+  /* [
+      {
+        "code": "invalid_type",
+        "expected": "string",
+        "received": "number",
+        "path": [ "name" ],
+        "message": "Expected string, received number"
+      }
+  ] */
+}
 ```
 
-## Errors
+#### Error formatting
+
+You can use the `.format()` method to convert this error into a nested object.
+
+```ts
+data.error.format();
+/* {
+  name: { _errors: [ 'Expected string, received number' ] }
+} */
+```
 
-There is a dedicated guide on Zod's error handling system here: [ERROR_HANDLING.md](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md)
+For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md)
 
 # Comparison
 
@@ -1686,7 +1458,7 @@ Branded -->
 * Missing lazy/recursive types
 * Missing promise schemas
 * Missing function schemas
-* Missing union & intersection schemas
+* Missing union schemas
 * Missing support for parsing cyclical data (maybe)
 * Missing error customization -->
 
@@ -1710,7 +1482,7 @@ Differences
 <!-- - Missing nonempty arrays with proper typing (`[T, ...T[]]`) -->
 - Missing promise schemas
 - Missing function schemas
-- Missing union & intersection schemas
+- Missing union schemas
 
 <!-- ¹Yup has a strange interpretation of the word `required`. Instead of meaning "not undefined", Yup uses it to mean "not empty". So `yup.string().required()` will not accept an empty string, and `yup.array(yup.string()).required()` will not accept an empty array. Instead, Yup us Zod arrays there is a dedicated `.nonempty()` method to indicate this, or you can implement it with a custom refinement. -->
 
@@ -1765,7 +1537,7 @@ This more declarative API makes schema definitions vastly more concise.
 - Missing lazy/recursive types
 - Missing promise schemas
 - Missing function schemas
-- Missing union & intersection schemas
+- Missing union schemas
 - Missing support for parsing cyclical data (maybe)
 - Missing error customization
 
@@ -1781,7 +1553,7 @@ Good type inference support, but limited options for object type masking (no `.p
 - Missing nonempty arrays with proper typing (`[T, ...T[]]`)
 - Missing lazy/recursive types
 - Missing promise schemas
-- Missing union & intersection schemas
+- Missing union schemas
 - Missing error customization
 - Missing record schemas (their "record" is equivalent to Zod "object")
 
@@ -1795,4 +1567,4 @@ If you want to validate function inputs, use function schemas in Zod! It's a muc
 
 # Changelog
 
-View the changelog at [CHANGELOG.md](https://github.com/colinhacks/zod/blob/master/CHANGELOG.md)
+View the changelog at [CHANGELOG.md](CHANGELOG.md)
diff --git a/coverage.svg b/coverage.svg
index c5cb758ff..1a6699f17 100644
--- a/coverage.svg
+++ b/coverage.svg
@@ -1 +1 @@
-<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="116" height="20" role="img" aria-label="Coverage: 92.36%"><title>Coverage: 92.36%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="116" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="53" height="20" fill="#4c1"/><rect width="116" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="885" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="430">92.36%</text><text x="885" y="140" transform="scale(.1)" fill="#fff" textLength="430">92.36%</text></g></svg>
\ No newline at end of file
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="110" height="20" role="img" aria-label="Coverage: 94.2%"><title>Coverage: 94.2%</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="110" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="63" height="20" fill="#555"/><rect x="63" width="47" height="20" fill="#4c1"/><rect width="110" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="325" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="530">Coverage</text><text x="325" y="140" transform="scale(.1)" fill="#fff" textLength="530">Coverage</text><text aria-hidden="true" x="855" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="370">94.2%</text><text x="855" y="140" transform="scale(.1)" fill="#fff" textLength="370">94.2%</text></g></svg>
\ No newline at end of file
diff --git a/deno/lib/PseudoPromise.ts b/deno/lib/PseudoPromise.ts
index 541f9f866..a77ba31a8 100644
--- a/deno/lib/PseudoPromise.ts
+++ b/deno/lib/PseudoPromise.ts
@@ -8,31 +8,33 @@ type CatcherItem = { type: "catcher"; catcher: Catcher };
 type Items = (FuncItem | CatcherItem)[];
 
 export const NOSET = Symbol("no_set");
-export class PseudoPromise<ReturnType = undefined> {
-  readonly _return: ReturnType | undefined;
+export class PseudoPromise<PayloadType = undefined> {
+  readonly _return: PayloadType | undefined;
   items: Items;
   constructor(funcs: Items = []) {
     this.items = funcs;
   }
 
-  static all = <T extends PseudoPromise<any>[]>(pps: T) => {
-    return new PseudoPromise().all(pps);
+  static all = <T extends [PseudoPromise<any>, ...PseudoPromise<any>[]]>(
+    pps: T
+  ) => {
+    return new PseudoPromise().all(() => pps);
   };
 
-  all = <T extends PseudoPromise<any>[]>(
-    pps: T
+  all = <P extends PseudoPromise<any>, T extends [P, ...P[]]>(
+    func: (arg: PayloadType, ctx: { async: boolean }) => T
   ): PseudoPromise<
     {
-      [k in keyof T]: T[k] extends PseudoPromise<any> ? T[k]["_return"] : never;
+      [k in keyof T]: T[k] extends PseudoPromise<infer U> ? U : never;
     }
   > => {
-    return this.then((_arg, ctx) => {
+    return this.then((arg, ctx) => {
+      const pps = func(arg, ctx);
       if (ctx.async) {
         const allValues = Promise.all(
           pps.map(async (pp) => {
             try {
-              const asdf = await pp.getValueAsync();
-              return asdf;
+              return await pp.getValueAsync();
             } catch (err) {
               return INVALID;
             }
@@ -107,15 +109,37 @@ export class PseudoPromise<ReturnType = undefined> {
     return new PseudoPromise().then(() => value) as any;
   };
 
-  then = <NewReturn>(
-    func: (arg: ReturnType, ctx: { async: boolean }) => NewReturn
-  ): PseudoPromise<NewReturn extends Promise<infer U> ? U : NewReturn> => {
+  then = <NewPayload>(
+    func: (arg: PayloadType, ctx: { async: boolean }) => NewPayload
+  ): PseudoPromise<NewPayload extends Promise<infer U> ? U : NewPayload> => {
     return new PseudoPromise([
       ...this.items,
       { type: "function", function: func },
     ]);
   };
 
+  // parallel = <
+  //   NewFunc extends (arg: PayloadType, ctx: { async: boolean }) => any,
+  //   ParallelArgs extends [NewFunc, ...NewFunc[]]
+  // >(
+  //   ...funcs: ParallelArgs
+  // ): PseudoPromise<
+  //   {
+  //     [k in keyof ParallelArgs]: ParallelArgs[k] extends (
+  //       ...args: any
+  //     ) => infer R
+  //       ? R extends Promise<infer U>
+  //         ? U
+  //         : R
+  //       : never;
+  //   }
+  // > => {
+  //   return new PseudoPromise([
+  //     ...this.items,
+  //     { type: "function", function: func },
+  //   ]);
+  // };
+
   catch = (catcher: (err: Error, ctx: { async: boolean }) => unknown): this => {
     return new PseudoPromise([
       ...this.items,
@@ -123,7 +147,7 @@ export class PseudoPromise<ReturnType = undefined> {
     ]) as this;
   };
 
-  getValueSync = (): ReturnType => {
+  getValueSync = (): PayloadType => {
     let val: any = undefined;
 
     for (let index = 0; index < this.items.length; index++) {
@@ -151,7 +175,7 @@ export class PseudoPromise<ReturnType = undefined> {
     return val;
   };
 
-  getValueAsync = async (): Promise<ReturnType> => {
+  getValueAsync = async (): Promise<PayloadType> => {
     let val: any = undefined;
 
     for (let index = 0; index < this.items.length; index++) {
diff --git a/deno/lib/ZodDef.ts b/deno/lib/ZodDef.ts
deleted file mode 100644
index 5f5ede96e..000000000
--- a/deno/lib/ZodDef.ts
+++ /dev/null
@@ -1,56 +0,0 @@
-import { ZodAnyDef } from "./types/any.ts";
-import { ZodArrayDef } from "./types/array.ts";
-import { ZodBigIntDef } from "./types/bigint.ts";
-import { ZodBooleanDef } from "./types/boolean.ts";
-import { ZodDateDef } from "./types/date.ts";
-import { ZodEnumDef } from "./types/enum.ts";
-import { ZodFunctionDef } from "./types/function.ts";
-import { ZodIntersectionDef } from "./types/intersection.ts";
-import { ZodLazyDef } from "./types/lazy.ts";
-import { ZodLiteralDef } from "./types/literal.ts";
-import { ZodMapDef } from "./types/map.ts";
-import { ZodNativeEnumDef } from "./types/nativeEnum.ts";
-import { ZodNeverDef } from "./types/never.ts";
-import { ZodNullDef } from "./types/null.ts";
-import { ZodNullableDef } from "./types/nullable.ts";
-import { ZodNumberDef } from "./types/number.ts";
-import { ZodObjectDef } from "./types/object.ts";
-import { ZodOptionalDef } from "./types/optional.ts";
-import { ZodPromiseDef } from "./types/promise.ts";
-import { ZodRecordDef } from "./types/record.ts";
-import { ZodStringDef } from "./types/string.ts";
-import { ZodTransformerDef } from "./types/transformer.ts";
-import { ZodTupleDef } from "./types/tuple.ts";
-import { ZodUndefinedDef } from "./types/undefined.ts";
-import { ZodUnionDef } from "./types/union.ts";
-import { ZodUnknownDef } from "./types/unknown.ts";
-import { ZodVoidDef } from "./types/void.ts";
-
-export type ZodDef =
-  | ZodStringDef
-  | ZodNumberDef
-  | ZodBigIntDef
-  | ZodBooleanDef
-  | ZodDateDef
-  | ZodUndefinedDef
-  | ZodNullDef
-  | ZodAnyDef
-  | ZodUnknownDef
-  | ZodNeverDef
-  | ZodVoidDef
-  | ZodArrayDef
-  | ZodObjectDef
-  | ZodUnionDef
-  | ZodIntersectionDef
-  | ZodTupleDef
-  | ZodRecordDef
-  | ZodMapDef
-  | ZodFunctionDef
-  | ZodLazyDef
-  | ZodLiteralDef
-  | ZodEnumDef
-  | ZodTransformerDef
-  | ZodNativeEnumDef
-  | ZodOptionalDef
-  | ZodNullableDef
-  | ZodPromiseDef;
diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index e1bd4b253..0eed71a29 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -1,12 +1,10 @@
+import { ZodParsedType } from "./helpers/parseUtil.ts";
 import { util } from "./helpers/util.ts";
-import { ZodParsedType } from "./ZodParsedType.ts";
 
 export const ZodIssueCode = util.arrayToEnum([
   "invalid_type",
-  "nonempty_array_is_empty",
   "custom",
   "invalid_union",
-  "invalid_literal_value",
   "invalid_enum_value",
   "unrecognized_keys",
   "invalid_arguments",
@@ -15,7 +13,6 @@ export const ZodIssueCode = util.arrayToEnum([
   "invalid_string",
   "too_small",
   "too_big",
-  "invalid_intersection_types",
 ]);
 
 export type ZodIssueCode = keyof typeof ZodIssueCode;
@@ -32,10 +29,6 @@ export interface ZodInvalidTypeIssue extends ZodIssueBase {
   received: ZodParsedType;
 }
 
-export interface ZodNonEmptyArrayIsEmptyIssue extends ZodIssueBase {
-  code: typeof ZodIssueCode.nonempty_array_is_empty;
-}
-
 export interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.unrecognized_keys;
   keys: string[];
@@ -46,11 +39,6 @@ export interface ZodInvalidUnionIssue extends ZodIssueBase {
   unionErrors: ZodError[];
 }
 
-export interface ZodInvalidLiteralValueIssue extends ZodIssueBase {
-  code: typeof ZodIssueCode.invalid_literal_value;
-  expected: string | number | boolean;
-}
-
 export interface ZodInvalidEnumValueIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.invalid_enum_value;
   options: (string | number)[];
@@ -91,21 +79,19 @@ export interface ZodTooBigIssue extends ZodIssueBase {
   type: "array" | "string" | "number";
 }
 
-export interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
-  code: typeof ZodIssueCode.invalid_intersection_types;
-}
-
 export interface ZodCustomIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.custom;
   params?: { [k: string]: any };
 }
 
+export type DenormalizedError = { [k: string]: DenormalizedError | string[] };
+
 export type ZodIssueOptionalMessage =
   | ZodInvalidTypeIssue
-  | ZodNonEmptyArrayIsEmptyIssue
+  // | ZodNonEmptyArrayIsEmptyIssue
   | ZodUnrecognizedKeysIssue
   | ZodInvalidUnionIssue
-  | ZodInvalidLiteralValueIssue
+  // | ZodInvalidLiteralValueIssue
   | ZodInvalidEnumValueIssue
   | ZodInvalidArgumentsIssue
   | ZodInvalidReturnTypeIssue
@@ -113,7 +99,6 @@ export type ZodIssueOptionalMessage =
   | ZodInvalidStringIssue
   | ZodTooSmallIssue
   | ZodTooBigIssue
-  | ZodInvalidIntersectionTypesIssue
   | ZodCustomIssue;
 
 export type ZodIssue = ZodIssueOptionalMessage & { message: string };
@@ -123,7 +108,15 @@ export const quotelessJson = (obj: any) => {
   return json.replace(/"([^"]+)":/g, "$1:");
 };
 
-export class ZodError extends Error {
+export type ZodFormattedError<T> = T extends [any, ...any]
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+  : T extends any[]
+  ? ZodFormattedError<T[number]>[] & { _errors: string[] }
+  : T extends object
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+  : { _errors: string[] };
+
+export class ZodError<T = any> extends Error {
   issues: ZodIssue[] = [];
 
   get errors() {
@@ -138,11 +131,57 @@ export class ZodError extends Error {
     this.issues = issues;
   }
 
+  format = (): ZodFormattedError<T> => {
+    const fieldErrors: ZodFormattedError<T> = { _errors: [] } as any;
+    const processError = (error: ZodError) => {
+      for (const issue of error.issues) {
+        if (issue.code === "invalid_union") {
+          issue.unionErrors.map(processError);
+        } else if (issue.code === "invalid_return_type") {
+          processError(issue.returnTypeError);
+        } else if (issue.code === "invalid_arguments") {
+          processError(issue.argumentsError);
+        } else if (issue.path.length === 0) {
+          fieldErrors._errors.push(issue.message);
+        } else {
+          let curr: any = fieldErrors;
+          let i = 0;
+          while (i < issue.path.length) {
+            const el = issue.path[i];
+            const terminal = i === issue.path.length - 1;
+
+            if (!terminal) {
+              if (typeof el === "string") {
+                curr[el] = curr[el] || { _errors: [] };
+              } else if (typeof el === "number") {
+                const errorArray: any = [];
+                errorArray._errors = [];
+                curr[el] = curr[el] || errorArray;
+              }
+            } else {
+              curr[el] = curr[el] || { _errors: [] };
+              curr[el]._errors.push(issue.message);
+            }
+
+            curr = curr[el];
+            i++;
+          }
+        }
+      }
+    };
+
+    processError(this);
+    return fieldErrors;
+  };
+
   static create = (issues: ZodIssue[]) => {
     const error = new ZodError(issues);
     return error;
   };
 
+  toString() {
+    return `ZodError: ${JSON.stringify(this.issues, null, 2)}`;
+  }
   get message() {
     return JSON.stringify(this.issues, null, 2);
     // const errorMessage: string[] = [
@@ -195,6 +234,10 @@ export class ZodError extends Error {
     return { formErrors, fieldErrors };
   };
 
+  // denormalize = ():DenormalizedError{
+
+  // }
+
   get formErrors() {
     return this.flatten();
   }
@@ -207,3 +250,112 @@ type stripPath<T extends object> = T extends any
 export type MakeErrorData = stripPath<ZodIssueOptionalMessage> & {
   path?: (string | number)[];
 };
+
+type ErrorMapCtx = {
+  // path: (string | number)[];
+  // details: any;
+  defaultError: string;
+  data: any;
+  // metadata: object;
+};
+
+export type ZodErrorMap = typeof defaultErrorMap;
+export let defaultErrorMap = (
+  error: ZodIssueOptionalMessage,
+  _ctx: ErrorMapCtx
+): { message: string } => {
+  let message: string;
+  switch (error.code) {
+    case ZodIssueCode.invalid_type:
+      if (error.received === "undefined") {
+        message = "Required";
+      } else {
+        message = `Expected ${error.expected}, received ${error.received}`;
+      }
+      break;
+    case ZodIssueCode.unrecognized_keys:
+      message = `Unrecognized key(s) in object: ${error.keys
+        .map((k) => `'${k}'`)
+        .join(", ")}`;
+      break;
+    case ZodIssueCode.invalid_union:
+      message = `Invalid input`;
+      break;
+    case ZodIssueCode.invalid_enum_value:
+      message = `Invalid enum value. Expected ${error.options
+        .map((val) => (typeof val === "string" ? `'${val}'` : val))
+        .join(" | ")}, received ${
+        typeof _ctx.data === "string" ? `'${_ctx.data}'` : _ctx.data
+      }`;
+      break;
+    case ZodIssueCode.invalid_arguments:
+      message = `Invalid function arguments`;
+      break;
+    case ZodIssueCode.invalid_return_type:
+      message = `Invalid function return type`;
+      break;
+    case ZodIssueCode.invalid_date:
+      message = `Invalid date`;
+      break;
+    // case ZodIssueCode.too_small:
+    //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
+    //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
+    //   break;
+    // case ZodIssueCode.too_big:
+    //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
+    //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
+    //   break;
+    case ZodIssueCode.invalid_string:
+      if (error.validation !== "regex") message = `Invalid ${error.validation}`;
+      else message = "Invalid";
+      break;
+    // case ZodIssueCode.invalid_url:
+    //   message = 'Invalid URL.';
+    //   break;
+    // case ZodIssueCode.invalid_uuid:
+    //   message = 'Invalid UUID.';
+    //   break;
+    case ZodIssueCode.too_small:
+      if (error.type === "array")
+        message = `Should have ${error.inclusive ? `at least` : `more than`} ${
+          error.minimum
+        } items`;
+      else if (error.type === "string")
+        message = `Should be ${error.inclusive ? `at least` : `over`} ${
+          error.minimum
+        } characters`;
+      else if (error.type === "number")
+        message = `Value should be greater than ${
+          error.inclusive ? `or equal to ` : ``
+        }${error.minimum}`;
+      else message = "Invalid input";
+      break;
+    case ZodIssueCode.too_big:
+      if (error.type === "array")
+        message = `Should have ${error.inclusive ? `at most` : `less than`} ${
+          error.maximum
+        } items`;
+      else if (error.type === "string")
+        message = `Should be ${error.inclusive ? `at most` : `under`} ${
+          error.maximum
+        } characters long`;
+      else if (error.type === "number")
+        message = `Value should be less than ${
+          error.inclusive ? `or equal to ` : ``
+        }${error.maximum}`;
+      else message = "Invalid input";
+      break;
+    case ZodIssueCode.custom:
+      message = `Invalid input.`;
+      break;
+    default:
+      message = `Invalid input.`;
+      util.assertNever(error);
+  }
+  return { message };
+  // return `Invalid input.`;
+};
+
+export const setErrorMap = (map: ZodErrorMap) => {
+  defaultErrorMap = map;
+};
diff --git a/deno/lib/ZodParsedType.ts b/deno/lib/ZodParsedType.ts
deleted file mode 100644
index 9ad8155e3..000000000
--- a/deno/lib/ZodParsedType.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-import { util } from "./helpers/util.ts";
-
-export const ZodParsedType = util.arrayToEnum([
-  "string",
-  "nan",
-  "number",
-  "integer",
-  "boolean",
-  "date",
-  "bigint",
-  "symbol",
-  "function",
-  "undefined",
-  "null",
-  "array",
-  "object",
-  "unknown",
-  "promise",
-  "void",
-  "never",
-  "map",
-]);
-
-export type ZodParsedType = keyof typeof ZodParsedType;
diff --git a/deno/lib/ZodTypes.ts b/deno/lib/ZodTypes.ts
deleted file mode 100644
index a5fc596cd..000000000
--- a/deno/lib/ZodTypes.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-export enum ZodTypes {
-  string = "string",
-  number = "number",
-  bigint = "bigint",
-  boolean = "boolean",
-  date = "date",
-  undefined = "undefined",
-  null = "null",
-  array = "array",
-  object = "object",
-  union = "union",
-  intersection = "intersection",
-  tuple = "tuple",
-  record = "record",
-  map = "map",
-  function = "function",
-  lazy = "lazy",
-  literal = "literal",
-  enum = "enum",
-  nativeEnum = "nativeEnum",
-  promise = "promise",
-  any = "any",
-  unknown = "unknown",
-  never = "never",
-  void = "void",
-  transformer = "transformer",
-  optional = "optional",
-  nullable = "nullable",
-}
diff --git a/deno/lib/helpers/Mocker.ts b/deno/lib/__tests__/Mocker.ts
similarity index 100%
rename from deno/lib/helpers/Mocker.ts
rename to deno/lib/__tests__/Mocker.ts
diff --git a/deno/lib/__tests__/anyunknown.test.ts b/deno/lib/__tests__/anyunknown.test.ts
index 97abbf07f..8ca24ee7e 100644
--- a/deno/lib/__tests__/anyunknown.test.ts
+++ b/deno/lib/__tests__/anyunknown.test.ts
@@ -9,7 +9,6 @@ test("check any inference", () => {
   const t1 = z.any();
   t1.optional();
   t1.nullable();
-  t1.toJSON();
   type t1 = z.infer<typeof t1>;
   const f1: util.AssertEqual<t1, any> = true;
   expect(f1).toBeTruthy();
@@ -19,7 +18,6 @@ test("check unknown inference", () => {
   const t1 = z.unknown();
   t1.optional();
   t1.nullable();
-  t1.toJSON();
   type t1 = z.infer<typeof t1>;
   const f1: util.AssertEqual<t1, unknown> = true;
   expect(f1).toBeTruthy();
diff --git a/deno/lib/__tests__/array.test.ts b/deno/lib/__tests__/array.test.ts
index 4f433e710..b48fac1d9 100644
--- a/deno/lib/__tests__/array.test.ts
+++ b/deno/lib/__tests__/array.test.ts
@@ -5,13 +5,9 @@ const test = Deno.test;
 import * as z from "../index.ts";
 
 const minTwo = z.string().array().min(2);
-
 const maxTwo = z.string().array().max(2);
-
 const justTwo = z.string().array().length(2);
-
 const intNum = z.string().array().nonempty();
-
 const nonEmptyMax = z.string().array().nonempty().max(2);
 
 test("passing validations", () => {
diff --git a/deno/lib/__tests__/async-parsing.test.ts b/deno/lib/__tests__/async-parsing.test.ts
index 8817006c5..bcc141f92 100644
--- a/deno/lib/__tests__/async-parsing.test.ts
+++ b/deno/lib/__tests__/async-parsing.test.ts
@@ -6,6 +6,7 @@ import * as z from "../index.ts";
 
 /// string
 const stringSchema = z.string();
+
 test("string async parse", async () => {
   const goodData = "XXX";
   const badData = 12;
@@ -199,27 +200,6 @@ test("union async parse", async () => {
   if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
 });
 
-/// tuple
-// const stringToNumber = z.transformer(
-//   z.string(),
-//   z.number(),
-//   (v) => v.length + 10
-// );
-
-// const tupleSchema = z.tuple([stringToNumber, z.object({})]);
-// test("tuple async parse", async () => {
-//   const goodData = ["XXX", {}];
-//   const badData = [12, {}];
-
-//   const goodResult = await tupleSchema.safeParseAsync(goodData);
-//   expect(goodResult.success).toBe(true);
-//   if (goodResult.success) expect(goodResult.data).toEqual([13, {}]);
-
-//   const badResult = await tupleSchema.safeParseAsync(badData);
-//   expect(badResult.success).toBe(false);
-//   if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
-// });
-
 /// record
 const recordSchema = z.record(z.object({}));
 test("record async parse", async () => {
@@ -301,38 +281,34 @@ test("nativeEnum async parse", async () => {
 
 /// promise
 const promiseSchema = z.promise(z.number());
-test("promise async parse", async () => {
+test("promise async parse good", async () => {
   const goodData = Promise.resolve(123);
-  const badData = Promise.resolve("XXX");
 
   const goodResult = await promiseSchema.safeParseAsync(goodData);
   expect(goodResult.success).toBe(true);
-  if (goodResult.success) expect(goodResult.data).toEqual(123);
+  if (goodResult.success) {
+    expect(goodResult.data).toBeInstanceOf(Promise);
+    const data = await goodResult.data;
+    expect(data).toEqual(123);
+    // expect(goodResult.data).resolves.toEqual(124);
+    // return goodResult.data;
+  } else {
+    throw new Error("success should be true");
+  }
+});
 
+test("promise async parse bad", async () => {
+  const badData = Promise.resolve("XXX");
   const badResult = await promiseSchema.safeParseAsync(badData);
-  expect(badResult.success).toBe(false);
-  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
+  expect(badResult.success).toBe(true);
+  if (badResult.success) {
+    await expect(badResult.data).rejects.toBeInstanceOf(Error);
+  } else {
+    console.log(`SUCCESS SHOULD BE TRUE`);
+    throw new Error("success should be true");
+  }
 });
 
-/// transformer
-// const transformerSchema = z.transformer(
-//   z.number(),
-//   z.string(),
-//   async (val) => `${Math.pow(val, 2)}`
-// );
-// test("transformer async parse", async () => {
-//   const goodData = 5;
-//   const badData = "5";
-
-//   const goodResult = await transformerSchema.safeParseAsync(goodData);
-//   expect(goodResult.success).toBe(true);
-//   if (goodResult.success) expect(goodResult.data).toEqual("25");
-
-//   const badResult = await transformerSchema.safeParseAsync(badData);
-//   expect(badResult.success).toBe(false);
-//   if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
-// });
-
 test("async validation non-empty strings", async () => {
   const base = z.object({
     hello: z.string().refine((x) => x && x.length > 0),
diff --git a/deno/lib/__tests__/async-refinements.test.ts b/deno/lib/__tests__/async-refinements.test.ts
index aca26c313..3bf468a8d 100644
--- a/deno/lib/__tests__/async-refinements.test.ts
+++ b/deno/lib/__tests__/async-refinements.test.ts
@@ -40,7 +40,7 @@ test("parseAsync async with value", async () => {
   const schema1 = z.string().refine(async (val) => {
     return val.length > 5;
   });
-  expect(schema1.parseAsync("asdf")).rejects.toBeDefined();
+  await expect(schema1.parseAsync("asdf")).rejects.toBeDefined();
 
   const v = await schema1.parseAsync("asdf123");
   return await expect(v).toEqual("asdf123");
diff --git a/deno/lib/__tests__/base.test.ts b/deno/lib/__tests__/base.test.ts
index 1a5286b86..366c8192d 100644
--- a/deno/lib/__tests__/base.test.ts
+++ b/deno/lib/__tests__/base.test.ts
@@ -2,8 +2,8 @@
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
-import * as z from "../index.ts";
 import { util } from "../helpers/util.ts";
+import * as z from "../index.ts";
 
 test("type guard", () => {
   const stringToNumber = z.string().transform((arg) => arg.length);
diff --git a/deno/lib/__tests__/codegen.test.ts b/deno/lib/__tests__/codegen.test.ts
deleted file mode 100644
index 3afc50288..000000000
--- a/deno/lib/__tests__/codegen.test.ts
+++ /dev/null
@@ -1,12 +0,0 @@
-// @ts-ignore TS6133
-import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
-const test = Deno.test;
-
-import { crazySchema } from "../crazySchema.ts";
-import * as z from "../index.ts";
-
-test("ZodCodeGenerator", () => {
-  const gen = new z.ZodCodeGenerator();
-  gen.generate(crazySchema);
-  gen.dump();
-});
diff --git a/deno/lib/__tests__/complex.test.ts b/deno/lib/__tests__/complex.test.ts
index 3637b93e5..571744187 100644
--- a/deno/lib/__tests__/complex.test.ts
+++ b/deno/lib/__tests__/complex.test.ts
@@ -2,8 +2,8 @@
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
-import { crazySchema } from "../crazySchema.ts";
-import * as z from "../index.ts";
+import { crazySchema } from "./crazySchema.ts";
+// import * as z from "../index";
 
 test("parse", () => {
   crazySchema.parse({
@@ -11,23 +11,10 @@ test("parse", () => {
     merged: { k1: "asdf", k2: 12 },
     union: ["asdf", 12, "asdf", 12, "asdf", 12],
     array: [12, 15, 16],
-    // sumTransformer: [12, 15, 16],
     sumMinLength: [12, 15, 16, 98, 24, 63],
-    intersection: {},
-    enum: "one",
+    mergedObjects: { p1: 3.154 },
     nonstrict: { points: 1234 },
     numProm: Promise.resolve(12),
     lenfun: (x: string) => x.length,
   });
-
-  // expect(typeof value.sumTransformer).toEqual("number");
-});
-
-test("to JSON", () => {
-  crazySchema.toJSON();
-});
-
-test("ZodCodeGenerator", () => {
-  const gen = new z.ZodCodeGenerator();
-  gen.generate(crazySchema);
 });
diff --git a/src/crazySchema.ts b/deno/lib/__tests__/crazySchema.ts
similarity index 62%
rename from src/crazySchema.ts
rename to deno/lib/__tests__/crazySchema.ts
index a5b5c191e..2e0c3c83a 100644
--- a/src/crazySchema.ts
+++ b/deno/lib/__tests__/crazySchema.ts
@@ -1,4 +1,4 @@
-import * as z from "./index";
+import * as z from "../index.ts";
 
 export const crazySchema = z.object({
   tuple: z.tuple([
@@ -16,27 +16,15 @@ export const crazySchema = z.object({
     .merge(z.object({ k1: z.string().nullable(), k2: z.number() })),
   union: z.array(z.union([z.literal("asdf"), z.literal(12)])).nonempty(),
   array: z.array(z.number()),
-  // sumTransformer: z.transformer(z.array(z.number()), z.number(), (arg) => {
-  //   return arg.reduce((a, b) => a + b, 0);
-  // }),
   sumMinLength: z.array(z.number()).refine((arg) => arg.length > 5),
-  intersection: z.intersection(
-    z.object({ p1: z.string().optional() }),
-    z.object({ p1: z.number().optional() })
-  ),
-  enum: z.intersection(z.enum(["zero", "one"]), z.enum(["one", "two"])),
+  mergedObjects: z
+    .object({ p1: z.string().optional() })
+    .merge(z.object({ p1: z.number().optional() })),
   nonstrict: z.object({ points: z.number() }).nonstrict(),
   numProm: z.promise(z.number()),
   lenfun: z.function(z.tuple([z.string()]), z.boolean()),
 });
 
 export const asyncCrazySchema = crazySchema.extend({
-  // async_transform: z.transformer(
-  //   z.array(z.number()),
-  //   z.number(),
-  //   async (arg) => {
-  //     return arg.reduce((a, b) => a + b, 0);
-  //   }
-  // ),
   async_refine: z.array(z.number()).refine(async (arg) => arg.length > 5),
 });
diff --git a/deno/lib/__tests__/default.test.ts b/deno/lib/__tests__/default.test.ts
new file mode 100644
index 000000000..3c6d6a225
--- /dev/null
+++ b/deno/lib/__tests__/default.test.ts
@@ -0,0 +1,96 @@
+// @ts-ignore TS6133
+import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
+const test = Deno.test;
+
+import { z } from "../index.ts";
+import { util } from "../helpers/util.ts";
+
+test("basic defaults", () => {
+  expect(z.string().default("default").parse(undefined)).toBe("default");
+});
+
+test("default with transform", () => {
+  const stringWithDefault = z
+    .string()
+    .transform((val) => val.toUpperCase())
+    .default("default");
+  expect(stringWithDefault.parse(undefined)).toBe("DEFAULT");
+  expect(stringWithDefault).toBeInstanceOf(z.ZodOptional);
+  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodEffects);
+  expect(stringWithDefault._def.innerType._def.schema).toBeInstanceOf(
+    z.ZodSchema
+  );
+
+  type inp = z.input<typeof stringWithDefault>;
+  const f1: util.AssertEqual<inp, string | undefined> = true;
+  type out = z.output<typeof stringWithDefault>;
+  const f2: util.AssertEqual<out, string> = true;
+  f1;
+  f2;
+});
+
+test("default on optional", () => {
+  const stringWithDefault = z.string().optional().default("asdf");
+  expect(stringWithDefault.parse(undefined)).toBe("asdf");
+  expect(stringWithDefault).toBeInstanceOf(z.ZodOptional);
+  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodString);
+  type inp = z.input<typeof stringWithDefault>;
+  const f1: util.AssertEqual<inp, string | undefined> = true;
+  type out = z.output<typeof stringWithDefault>;
+  const f2: util.AssertEqual<out, string> = true;
+  f1;
+  f2;
+});
+
+test("optional on default", () => {
+  const stringWithDefault = z.string().default("asdf").optional();
+
+  type inp = z.input<typeof stringWithDefault>;
+  const f1: util.AssertEqual<inp, string | undefined> = true;
+  type out = z.output<typeof stringWithDefault>;
+  const f2: util.AssertEqual<out, string> = true;
+  f1;
+  f2;
+});
+
+test("complex chain example", () => {
+  const complex = z
+    .string()
+    .default("asdf")
+    .optional()
+    .transform((val) => val.toUpperCase())
+    .default("qwer")
+    .removeDefault()
+    .optional()
+    .default("asdfasdf");
+
+  expect(complex.parse(undefined)).toBe("ASDFASDF");
+});
+
+test("removeDefault", () => {
+  const stringWithRemovedDefault = z.string().default("asdf").removeDefault();
+
+  type out = z.output<typeof stringWithRemovedDefault>;
+  const f2: util.AssertEqual<out, string | undefined> = true;
+  f2;
+  expect(stringWithRemovedDefault.parse(undefined)).toBe(undefined);
+});
+
+test("nested", () => {
+  const inner = z.string().default("asdf");
+  const outer = z.object({ inner }).default({
+    inner: undefined,
+  });
+  type input = z.input<typeof outer>;
+  const f1: util.AssertEqual<
+    input,
+    { inner?: string | undefined } | undefined
+  > = true;
+  type out = z.output<typeof outer>;
+  const f2: util.AssertEqual<out, { inner: string }> = true;
+  f1;
+  f2;
+  expect(outer.parse(undefined)).toEqual({ inner: "asdf" });
+  expect(outer.parse({})).toEqual({ inner: "asdf" });
+  expect(outer.parse({ inner: undefined })).toEqual({ inner: "asdf" });
+});
diff --git a/deno/lib/__tests__/error.test.ts b/deno/lib/__tests__/error.test.ts
index 2a72ab7d4..bc3d3e5d5 100644
--- a/deno/lib/__tests__/error.test.ts
+++ b/deno/lib/__tests__/error.test.ts
@@ -2,9 +2,9 @@
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
+import { ZodParsedType } from "../helpers/parseUtil.ts";
 import * as z from "../index.ts";
 import { ZodError, ZodIssueCode } from "../ZodError.ts";
-import { ZodParsedType } from "../ZodParsedType.ts";
 
 test("error creation", () => {
   const err1 = ZodError.create([]);
@@ -40,7 +40,7 @@ const errorMap: z.ZodErrorMap = (error, ctx) => {
 
 test("type error with custom error map", () => {
   try {
-    z.string().parse("asdf", { errorMap });
+    z.string().parse(234, { errorMap });
   } catch (err) {
     const zerr: z.ZodError = err;
 
@@ -133,23 +133,23 @@ test("array minimum", () => {
 });
 
 // implement test for semi-smart union logic that checks for type error on either left or right
-test("union smart errors", () => {
-  // expect.assertions(2);
-
-  const p1 = z
-    .union([z.string(), z.number().refine((x) => x > 0)])
-    .safeParse(-3.2);
-
-  if (p1.success === true) throw new Error();
-  expect(p1.success).toBe(false);
-  expect(p1.error.issues[0].code).toEqual(ZodIssueCode.custom);
-
-  const p2 = z.union([z.string(), z.number()]).safeParse(false);
-  // .catch(err => expect(err.issues[0].code).toEqual(ZodIssueCode.invalid_union));
-  if (p2.success === true) throw new Error();
-  expect(p2.success).toBe(false);
-  expect(p2.error.issues[0].code).toEqual(ZodIssueCode.invalid_union);
-});
+// test("union smart errors", () => {
+//   // expect.assertions(2);
+
+//   const p1 = z
+//     .union([z.string(), z.number().refine((x) => x > 0)])
+//     .safeParse(-3.2);
+
+//   if (p1.success === true) throw new Error();
+//   expect(p1.success).toBe(false);
+//   expect(p1.error.issues[0].code).toEqual(ZodIssueCode.custom);
+
+//   const p2 = z.union([z.string(), z.number()]).safeParse(false);
+//   // .catch(err => expect(err.issues[0].code).toEqual(ZodIssueCode.invalid_union));
+//   if (p2.success === true) throw new Error();
+//   expect(p2.success).toBe(false);
+//   expect(p2.error.issues[0].code).toEqual(ZodIssueCode.invalid_union);
+// });
 
 test("custom path in custom error map", () => {
   const schema = z.object({
@@ -198,3 +198,75 @@ test("error metadata from value", () => {
 
 //   expect(() => asdf.safeParse("foo")).not.toThrow();
 // });
+
+test("root level formatting", () => {
+  const schema = z.string().email();
+  const result = schema.safeParse("asdfsdf");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.format()._errors).toEqual(["Invalid email"]);
+  }
+});
+
+test("custom path", () => {
+  const schema = z
+    .object({
+      password: z.string(),
+      confirm: z.string(),
+    })
+    .refine((val) => val.confirm === val.password, { path: ["confirm"] });
+
+  const result = schema.safeParse({
+    password: "peanuts",
+    confirm: "qeanuts",
+  });
+
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    const error = result.error.format();
+    expect(error._errors).toEqual([]);
+    expect(error.password?._errors).toEqual(undefined);
+    expect(error.confirm?._errors).toEqual(["Invalid input."]);
+  }
+});
+
+test("formatting", () => {
+  const schema = z.object({
+    inner: z.object({
+      name: z
+        .string()
+        .refine((val) => val.length > 5)
+        .array()
+        .refine((val) => val.length <= 1),
+    }),
+  });
+
+  const invalidItem = {
+    inner: { name: ["aasd", "asdfasdfasfd"] },
+  };
+  const invalidArray = {
+    inner: { name: ["asdfasdf", "asdfasdfasfd"] },
+  };
+  const result1 = schema.safeParse(invalidItem);
+  const result2 = schema.safeParse(invalidArray);
+
+  expect(result1.success).toEqual(false);
+  expect(result2.success).toEqual(false);
+  if (!result1.success) {
+    const error = result1.error.format();
+    expect(error._errors).toEqual([]);
+    expect(error.inner?._errors).toEqual([]);
+    expect(error.inner?.name?._errors).toEqual([]);
+    expect(error.inner?.name?.[0]._errors).toEqual(["Invalid value."]);
+    expect(error.inner?.name?.[1]).toEqual(undefined);
+  }
+  if (!result2.success) {
+    const error = result2.error.format();
+    expect(error._errors).toEqual([]);
+    expect(error.inner?._errors).toEqual([]);
+    expect(error.inner?.name?._errors).toEqual(["Invalid value."]);
+    expect(error.inner?.name?.[0]).toEqual(undefined);
+    expect(error.inner?.name?.[1]).toEqual(undefined);
+    expect(error.inner?.name?.[2]).toEqual(undefined);
+  }
+});
diff --git a/deno/lib/__tests__/intersection.test.ts b/deno/lib/__tests__/intersection.test.ts
deleted file mode 100644
index 531b35eeb..000000000
--- a/deno/lib/__tests__/intersection.test.ts
+++ /dev/null
@@ -1,25 +0,0 @@
-// @ts-ignore TS6133
-import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
-const test = Deno.test;
-
-import * as z from "../index.ts";
-
-test("object intersection", () => {
-  const BaseTeacher = z.object({
-    subjects: z.array(z.string()),
-  });
-  const HasID = z.object({ id: z.string() });
-
-  const Teacher = z.intersection(BaseTeacher.passthrough(), HasID); // BaseTeacher.merge(HasID);
-  const data = {
-    subjects: ["math"],
-    id: "asdfasdf",
-  };
-  expect(Teacher.parse(data)).toEqual(data);
-  expect(() => Teacher.parse({ subject: data.subjects })).toThrow();
-  expect(Teacher.parse({ ...data, extra: 12 })).toEqual({ ...data, extra: 12 });
-
-  expect(() =>
-    z.intersection(BaseTeacher.strict(), HasID).parse({ ...data, extra: 12 })
-  ).toThrow();
-});
diff --git a/deno/lib/__tests__/mocker.test.ts b/deno/lib/__tests__/mocker.test.ts
index ff85892df..4deaee1f4 100644
--- a/deno/lib/__tests__/mocker.test.ts
+++ b/deno/lib/__tests__/mocker.test.ts
@@ -2,7 +2,7 @@
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
-import { Mocker } from "../helpers/Mocker.ts";
+import { Mocker } from "./Mocker.ts";
 
 test("mocker", () => {
   const mocker = new Mocker();
diff --git a/deno/lib/__tests__/nullable.test.ts b/deno/lib/__tests__/nullable.test.ts
new file mode 100644
index 000000000..56ba11d6e
--- /dev/null
+++ b/deno/lib/__tests__/nullable.test.ts
@@ -0,0 +1,43 @@
+// @ts-ignore TS6133
+import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
+const test = Deno.test;
+
+import * as z from "../index.ts";
+
+function checkErrors(a: z.ZodTypeAny, bad: any) {
+  let expected;
+  try {
+    a.parse(bad);
+  } catch (error) {
+    expected = error.formErrors;
+  }
+  try {
+    a.nullable().parse(bad);
+  } catch (error) {
+    expect(error.formErrors).toEqual(expected);
+  }
+}
+
+test("Should have error messages appropriate for the underlying type", () => {
+  checkErrors(z.string().min(2), 1);
+  z.string().min(2).nullable().parse(null);
+  checkErrors(z.number().min(2), 1);
+  z.number().min(2).nullable().parse(null);
+  checkErrors(z.boolean(), "");
+  z.boolean().nullable().parse(null);
+  checkErrors(z.null(), null);
+  z.null().nullable().parse(null);
+  checkErrors(z.null(), {});
+  z.null().nullable().parse(null);
+  checkErrors(z.object({}), 1);
+  z.object({}).nullable().parse(null);
+  checkErrors(z.tuple([]), 1);
+  z.tuple([]).nullable().parse(null);
+  checkErrors(z.unknown(), 1);
+  z.unknown().nullable().parse(null);
+});
+
+test("unwrap", () => {
+  const unwrapped = z.string().nullable().unwrap();
+  expect(unwrapped).toBeInstanceOf(z.ZodString);
+});
diff --git a/deno/lib/__tests__/object.test.ts b/deno/lib/__tests__/object.test.ts
index 02644293a..28474a0da 100644
--- a/deno/lib/__tests__/object.test.ts
+++ b/deno/lib/__tests__/object.test.ts
@@ -57,28 +57,6 @@ test("incorrect #1", () => {
   expect(() => Test.parse({} as any)).toThrow();
 });
 
-test("inference", () => {
-  const t1 = z.object({
-    name: z.string(),
-    obj: z.object({}),
-    arrayarray: z.array(z.array(z.string())),
-  });
-
-  const i1 = t1.primitives();
-  type i1 = z.infer<typeof i1>;
-  const f1: util.AssertEqual<i1, { name: string }> = true;
-
-  const i2 = t1.nonprimitives();
-  type i2 = z.infer<typeof i2>;
-  const f2: util.AssertEqual<i2, { obj: {}; arrayarray: string[][] }> = true;
-
-  expect(f1).toBeTruthy();
-  expect(f2).toBeTruthy();
-  i1.parse({ name: "name" });
-  i2.parse({ obj: {}, arrayarray: [["asdf"]] });
-  expect(() => i1.parse({} as any)).toThrow();
-});
-
 test("nonstrict by default", () => {
   z.object({ points: z.number() }).parse({
     points: 2314,
@@ -126,62 +104,6 @@ test("strict", () => {
   expect(val.success).toEqual(false);
 });
 
-test("primitives", () => {
-  const baseObj = z.object({
-    stringPrimitive: z.string(),
-    stringArrayPrimitive: z.array(z.string()),
-    numberPrimitive: z.number(),
-    numberArrayPrimitive: z.array(z.number()),
-    booleanPrimitive: z.boolean(),
-    booleanArrayPrimitive: z.array(z.boolean()),
-    bigintPrimitive: z.bigint(),
-    bigintArrayPrimitive: z.array(z.bigint()),
-    undefinedPrimitive: z.undefined(),
-    nullPrimitive: z.null(),
-    primitiveUnion: z.union([z.string(), z.number()]),
-    primitiveIntersection: z.intersection(z.string(), z.string()),
-    lazyPrimitive: z.lazy(() => z.string()),
-    literalPrimitive: z.literal("sup"),
-    enumPrimitive: z.enum(["asdf", "qwer"]),
-    datePrimitive: z.date(),
-    primitiveTuple: z.tuple([z.string(), z.number()]),
-
-    nonprimitiveUnion: z.union([z.string(), z.object({})]),
-    object: z.object({}),
-    objectArray: z.object({}).array(),
-    arrayarray: z.array(z.array(z.string())),
-    nonprimitiveTuple: z.tuple([z.string(), z.number().array()]),
-  });
-
-  expect(Object.keys(baseObj.primitives().shape)).toEqual([
-    "stringPrimitive",
-    "stringArrayPrimitive",
-    "numberPrimitive",
-    "numberArrayPrimitive",
-    "booleanPrimitive",
-    "booleanArrayPrimitive",
-    "bigintPrimitive",
-    "bigintArrayPrimitive",
-    "undefinedPrimitive",
-    "nullPrimitive",
-    "primitiveUnion",
-    "primitiveIntersection",
-    "lazyPrimitive",
-    "literalPrimitive",
-    "enumPrimitive",
-    "datePrimitive",
-    "primitiveTuple",
-  ]);
-
-  expect(Object.keys(baseObj.nonprimitives().shape)).toEqual([
-    "nonprimitiveUnion",
-    "object",
-    "objectArray",
-    "arrayarray",
-    "nonprimitiveTuple",
-  ]);
-});
-
 test("catchall inference", () => {
   const o1 = z
     .object({
@@ -285,3 +207,33 @@ test("test async PseudoPromise.all", async () => {
   const result = await Schema2.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21
   expect(result.success).toEqual(true);
 });
+
+test("merging", () => {
+  const BaseTeacher = z.object({
+    subjects: z.array(z.string()),
+  });
+  const HasID = z.object({ id: z.string() });
+
+  const Teacher = BaseTeacher.merge(HasID);
+
+  const data = {
+    subjects: ["math"],
+    id: "asdfasdf",
+  };
+  expect(Teacher.parse(data)).toEqual(data);
+  expect(() => Teacher.parse({ subject: data.subjects })).toThrow();
+  expect(
+    BaseTeacher.passthrough()
+      .merge(HasID)
+      .parse({ ...data, extra: 12 })
+  ).toEqual({
+    ...data,
+    extra: 12,
+  });
+
+  expect(() =>
+    BaseTeacher.strict()
+      .merge(HasID)
+      .parse({ ...data, extra: 12 })
+  ).toThrow();
+});
diff --git a/deno/lib/__tests__/optional.test.ts b/deno/lib/__tests__/optional.test.ts
index 49a2eeaf4..70bbaa636 100644
--- a/deno/lib/__tests__/optional.test.ts
+++ b/deno/lib/__tests__/optional.test.ts
@@ -36,3 +36,8 @@ test("Should have error messages appropriate for the underlying type", () => {
   checkErrors(z.unknown(), 1);
   z.unknown().optional().parse(undefined);
 });
+
+test("unwrap", () => {
+  const unwrapped = z.string().optional().unwrap();
+  expect(unwrapped).toBeInstanceOf(z.ZodString);
+});
diff --git a/deno/lib/__tests__/parser.test.ts b/deno/lib/__tests__/parser.test.ts
index 6d2e0de42..1f1069215 100644
--- a/deno/lib/__tests__/parser.test.ts
+++ b/deno/lib/__tests__/parser.test.ts
@@ -19,18 +19,6 @@ test("parse nonstrict object with unknown keys", () => {
     .parse({ name: "bill", unknownKey: 12 });
 });
 
-test("invalid left side of intersection", () => {
-  expect(() =>
-    z.intersection(z.string(), z.number()).parse(12 as any)
-  ).toThrow();
-});
-
-test("invalid right side of intersection", () => {
-  expect(() =>
-    z.intersection(z.string(), z.number()).parse("12" as any)
-  ).toThrow();
-});
-
 test("parsing non-array in tuple schema", () => {
   expect(() => z.tuple([]).parse("12" as any)).toThrow();
 });
diff --git a/deno/lib/__tests__/partials.test.ts b/deno/lib/__tests__/partials.test.ts
index 247a50b1c..0f1f44c64 100644
--- a/deno/lib/__tests__/partials.test.ts
+++ b/deno/lib/__tests__/partials.test.ts
@@ -49,6 +49,7 @@ test("deep partial inference", () => {
 
 test("deep partial parse", () => {
   const deep = nested.deepPartial();
+
   expect(deep.shape.name instanceof z.ZodOptional).toBe(true);
   expect(deep.shape.outer instanceof z.ZodOptional).toBe(true);
   expect(deep.shape.outer._def.innerType instanceof z.ZodObject).toBe(true);
diff --git a/deno/lib/__tests__/primitive.test.ts b/deno/lib/__tests__/primitive.test.ts
index ee447df91..f3fe2fd50 100644
--- a/deno/lib/__tests__/primitive.test.ts
+++ b/deno/lib/__tests__/primitive.test.ts
@@ -2,8 +2,8 @@
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
-import { Mocker } from "../helpers/Mocker.ts";
 import * as z from "../index.ts";
+import { Mocker } from "./Mocker.ts";
 
 const literalStringSchema = z.literal("asdf");
 const literalNumberSchema = z.literal(12);
diff --git a/deno/lib/__tests__/promise.test.ts b/deno/lib/__tests__/promise.test.ts
index de466931a..9cd1cbe5e 100644
--- a/deno/lib/__tests__/promise.test.ts
+++ b/deno/lib/__tests__/promise.test.ts
@@ -31,7 +31,15 @@ test("promise parsing success", async () => {
 });
 
 test("promise parsing success 2", () => {
-  promSchema.parse({ then: () => {}, catch: () => {} });
+  const fakePromise = {
+    then() {
+      return this;
+    },
+    catch() {
+      return this;
+    },
+  };
+  promSchema.parse(fakePromise);
 });
 
 test("promise parsing fail", async () => {
diff --git a/deno/lib/__tests__/record.test.ts b/deno/lib/__tests__/record.test.ts
index beed99b53..f39c8573d 100644
--- a/deno/lib/__tests__/record.test.ts
+++ b/deno/lib/__tests__/record.test.ts
@@ -14,7 +14,6 @@ test("type inference", () => {
 });
 
 test("methods", () => {
-  booleanRecord.toJSON();
   booleanRecord.optional();
   booleanRecord.nullable();
 });
diff --git a/deno/lib/__tests__/recursive.test.ts b/deno/lib/__tests__/recursive.test.ts
index 1cf30eb2b..0d72635cc 100644
--- a/deno/lib/__tests__/recursive.test.ts
+++ b/deno/lib/__tests__/recursive.test.ts
@@ -2,8 +2,50 @@
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
-test("test", () => {});
-// import * as z from '../index';
+import { z } from "../index.ts";
+
+interface Category {
+  name: string;
+  subcategories: Category[];
+}
+
+const testCategory: Category = {
+  name: "I",
+  subcategories: [
+    {
+      name: "A",
+      subcategories: [
+        {
+          name: "1",
+          subcategories: [
+            {
+              name: "a",
+              subcategories: [],
+            },
+          ],
+        },
+      ],
+    },
+  ],
+};
+
+test("recursion with z.late.object", () => {
+  const Category: z.Schema<Category> = z.late.object(() => ({
+    name: z.string(),
+    subcategories: z.array(Category),
+  }));
+  Category.parse(testCategory);
+});
+
+test("recursion with z.lazy", () => {
+  const Category: z.Schema<Category> = z.lazy(() =>
+    z.object({
+      name: z.string(),
+      subcategories: z.array(Category),
+    })
+  );
+  Category.parse(testCategory);
+});
 
 // interface A {
 //   val: number;
@@ -25,6 +67,16 @@ test("test", () => {});
 //   a: A,
 // }));
 
+// const Alazy: z.ZodType<A> = z.lazy(() => z.object({
+//   val: z.number(),
+//   b: B,
+// }));
+
+// const Blazy: z.ZodType<B> = z.lazy(() => z.object({
+//   val: z.number(),
+//   a: A,
+// }));
+
 // const a: any = { val: 1 };
 // const b: any = { val: 2 };
 // a.b = b;
@@ -35,6 +87,11 @@ test("test", () => {});
 //   B.parse(b);
 // });
 
+// test("valid check lazy", () => {
+//   A.parse({val:1, b:});
+//   B.parse(b);
+// });
+
 // test('masking check', () => {
 //   const FragmentOnA = z
 //     .object({
@@ -60,16 +117,11 @@ test("test", () => {});
 //   expect(() => A.parse({} as any)).toThrow();
 // });
 
-// test('toJSON throws', () => {
-//   const checker = () => A.toJSON();
-//   expect(checker).toThrow();
-// });
-
 // test('schema getter', () => {
 //   (A as z.ZodLazy<any>).schema;
 // });
 
-// test('self recursion', () => {
+// test("self recursion with cyclical data", () => {
 //   interface Category {
 //     name: string;
 //     subcategories: Category[];
@@ -81,14 +133,14 @@ test("test", () => {});
 //   }));
 
 //   const untypedCategory: any = {
-//     name: 'Category A',
+//     name: "Category A",
 //   };
 //   // creating a cycle
 //   untypedCategory.subcategories = [untypedCategory];
 //   Category.parse(untypedCategory);
 // });
 
-// test('self recursion with base type', () => {
+// test("self recursion with base type", () => {
 //   const BaseCategory = z.object({
 //     name: z.string(),
 //   });
@@ -105,96 +157,9 @@ test("test", () => {});
 //     });
 
 //   const untypedCategory: any = {
-//     name: 'Category A',
+//     name: "Category A",
 //   };
 //   // creating a cycle
 //   untypedCategory.subcategories = [untypedCategory];
 //   Category.parse(untypedCategory); // parses successfully
 // });
-
-// test('repeated parsing', () => {
-//   const extensions = z.object({
-//     name: z.string(),
-//   });
-
-//   const dog = z.object({
-//     extensions,
-//   });
-
-//   const cat = z.object({
-//     extensions,
-//   });
-
-//   const animal = z.union([dog, cat]);
-
-//   // it should output type error because name is ought to be type of string
-//   expect(() => animal.parse({ extensions: { name: 123 } })).toThrow;
-// });
-
-// test('repeated errors', () => {
-//   const Shape = z.array(
-//     z.object({
-//       name: z.string().nonempty(),
-//       value: z.string().nonempty(),
-//     }),
-//   );
-
-//   const data = [
-//     {
-//       name: 'Name 1',
-//       value: 'Value',
-//     },
-//     {
-//       name: '',
-//       value: 'Value',
-//     },
-//     {
-//       name: '',
-//       value: '',
-//     },
-//   ];
-
-//   try {
-//     Shape.parse(data);
-//   } catch (e) {
-//     if (e instanceof z.ZodError) {
-//       expect(e.issues.length).toEqual(3);
-//     }
-//   }
-// });
-
-// test('unions of object', () => {
-//   const base = z.object({
-//     id: z.string(),
-//   });
-
-//   const type1 = base.merge(
-//     z.object({
-//       type: z.literal('type1'),
-//     }),
-//   );
-
-//   const type2 = base.merge(
-//     z.object({
-//       type: z.literal('type2'),
-//     }),
-//   );
-
-//   const union1 = z.union([type1, type2]);
-//   const union2 = z.union([type2, type1]);
-
-//   const value1 = {
-//     type: 'type1',
-//   };
-
-//   const value2 = {
-//     type: 'type2',
-//   };
-
-//   expect(type1.check(value1)).toEqual(false);
-//   expect(union1.check(value1)).toEqual(false);
-//   expect(union2.check(value1)).toEqual(false);
-//   expect(type2.check(value2)).toEqual(false);
-//   expect(union1.check(value2)).toEqual(false);
-//   expect(union2.check(value2)).toEqual(false);
-// });
diff --git a/deno/lib/__tests__/refine.test.ts b/deno/lib/__tests__/refine.test.ts
index 5ee32f516..3e71e3ca2 100644
--- a/deno/lib/__tests__/refine.test.ts
+++ b/deno/lib/__tests__/refine.test.ts
@@ -18,7 +18,7 @@ test("refinement", () => {
   );
 
   expect(obj1 === (obj2 as any)).toEqual(false);
-  expect(obj2 === obj3).toEqual(false);
+  expect(obj2 === (obj3 as any)).toEqual(false);
 
   expect(() => obj1.parse({})).toThrow();
   expect(() => obj2.parse({ third: "adsf" })).toThrow();
diff --git a/deno/lib/__tests__/set.test.ts b/deno/lib/__tests__/set.test.ts
new file mode 100644
index 000000000..dfc248869
--- /dev/null
+++ b/deno/lib/__tests__/set.test.ts
@@ -0,0 +1,57 @@
+// @ts-ignore TS6133
+import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
+const test = Deno.test;
+
+import { util } from "../helpers/util.ts";
+import * as z from "../index.ts";
+import { ZodIssueCode } from "../index.ts";
+
+const stringSet = z.set(z.string());
+type stringSet = z.infer<typeof stringSet>;
+
+test("type inference", () => {
+  const f1: util.AssertEqual<stringSet, Set<string>> = true;
+  f1;
+});
+
+test("doesn’t throw when a valid value is given", () => {
+  const result = stringSet.safeParse(new Set(["first", "second"]));
+  expect(result.success).toEqual(true);
+});
+
+test("doesn’t throw when an empty set is given", () => {
+  const result = stringSet.safeParse(new Set([]));
+  expect(result.success).toEqual(true);
+});
+
+test("throws when a Map is given", () => {
+  const result = stringSet.safeParse(new Map([]));
+  expect(result.success).toEqual(false);
+  if (result.success === false) {
+    expect(result.error.issues.length).toEqual(1);
+    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
+  }
+});
+
+test("throws when the given set has invalid value", () => {
+  const result = stringSet.safeParse(new Set([Symbol()]));
+  expect(result.success).toEqual(false);
+  if (result.success === false) {
+    expect(result.error.issues.length).toEqual(1);
+    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
+    expect(result.error.issues[0].path).toEqual([0]);
+  }
+});
+
+test("throws when the given set has multiple invalid entries", () => {
+  const result = stringSet.safeParse(new Set([1, 2] as any[]) as Set<any>);
+
+  expect(result.success).toEqual(false);
+  if (result.success === false) {
+    expect(result.error.issues.length).toEqual(2);
+    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
+    expect(result.error.issues[0].path).toEqual([0]);
+    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);
+    expect(result.error.issues[1].path).toEqual([1]);
+  }
+});
diff --git a/deno/lib/__tests__/string.test.ts b/deno/lib/__tests__/string.test.ts
index 1a52dc680..4a9011f77 100644
--- a/deno/lib/__tests__/string.test.ts
+++ b/deno/lib/__tests__/string.test.ts
@@ -66,10 +66,13 @@ test("url error overrides", () => {
 });
 
 test("uuid", () => {
-  z.string().uuid().parse("9491d710-3185-4e06-bea0-6a2f275345e0");
-  expect(() =>
-    z.string().uuid().parse("9491d710-3185-4e06-bea0-6a2f275345e")
-  ).toThrow();
+  const uuid = z.string().uuid("custom error");
+  uuid.parse("9491d710-3185-4e06-bea0-6a2f275345e0");
+  const result = uuid.safeParse("invalid uuid");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual("custom error");
+  }
 });
 
 test("regex", () => {
diff --git a/deno/lib/__tests__/transformer.test.ts b/deno/lib/__tests__/transformer.test.ts
index 12a363b6a..0aa0d86f0 100644
--- a/deno/lib/__tests__/transformer.test.ts
+++ b/deno/lib/__tests__/transformer.test.ts
@@ -2,8 +2,8 @@
 import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
 const test = Deno.test;
 
-import * as z from "../index.ts";
 import { util } from "../helpers/util.ts";
+import * as z from "../index.ts";
 
 const stringToNumber = z.string().transform((arg) => parseFloat(arg));
 // const numberToString = z
@@ -64,7 +64,7 @@ test("default", () => {
 test("dynamic default", () => {
   const data = z
     .string()
-    .default((s) => s._def.t)
+    .default(() => "string")
     .parse(undefined); // => "asdf"
   expect(data).toEqual("string");
 });
diff --git a/deno/lib/__tests__/validations.test.ts b/deno/lib/__tests__/validations.test.ts
index 58491ebaa..94122c86a 100644
--- a/deno/lib/__tests__/validations.test.ts
+++ b/deno/lib/__tests__/validations.test.ts
@@ -108,3 +108,9 @@ test("instantiation", () => {
   z.string().url({ message: "Invalid url" });
   z.string().uuid({ message: "Invalid UUID" });
 });
+
+test("int", async () => {
+  const int = z.number().int();
+  int.parse(4);
+  expect(() => int.parse(3.5)).toThrow();
+});
diff --git a/deno/lib/codegen.ts b/deno/lib/codegen.ts
deleted file mode 100644
index 03c83c12e..000000000
--- a/deno/lib/codegen.ts
+++ /dev/null
@@ -1,182 +0,0 @@
-// import * as z from './index';
-
-import { util } from "./helpers/util.ts";
-import { ZodDef, ZodType, ZodTypes } from "./index.ts";
-// import { ZodTypes } from "./ZodTypes";
-
-type TypeResult = { schema: any; id: string; type: string };
-
-const isOptional = (schema: ZodType<any, any>): boolean => {
-  // const def: z.ZodDef = schema._def;
-  // if (def.t === ZodTypes.undefined) return true;
-  // else if (def.t === ZodTypes.intersection) {
-  //   return isOptional(def.right) && isOptional(def.left);
-  // } else if (def.t === ZodTypes.union) {
-  //   return def.options.map(isOptional).some(x => x === true);
-  // }
-  // return false;
-
-  return schema.isOptional();
-};
-
-export class ZodCodeGenerator {
-  seen: TypeResult[] = [];
-  serial = 0;
-
-  randomId = () => {
-    return `IZod${this.serial++}`;
-  };
-
-  findBySchema = (schema: ZodType<any, any>) => {
-    return this.seen.find((s) => s.schema === schema);
-  };
-
-  findById = (id: string) => {
-    const found = this.seen.find((s) => s.id === id);
-    if (!found) throw new Error(`Unfound ID: ${id}`);
-    return found;
-  };
-
-  dump = () => {
-    return `
-type Identity<T> = T;
-
-${this.seen
-  .map((item) => `type ${item.id} = Identity<${item.type}>;`)
-  .join("\n\n")}
-`;
-  };
-
-  setType = (id: string, type: string) => {
-    const found = this.findById(id);
-    found.type = type;
-    return found;
-  };
-
-  generate = (schema: ZodType<any, any>): TypeResult => {
-    const found = this.findBySchema(schema);
-    if (found) return found;
-
-    const def: ZodDef = schema._def;
-
-    const id = this.randomId();
-
-    const ty = {
-      schema,
-      id,
-      type: `__INCOMPLETE__`,
-    };
-
-    this.seen.push(ty);
-
-    switch (def.t) {
-      case ZodTypes.string:
-        return this.setType(id, `string`);
-      case ZodTypes.number:
-        return this.setType(id, `number`);
-      case ZodTypes.bigint:
-        return this.setType(id, `bigint`);
-      case ZodTypes.boolean:
-        return this.setType(id, `boolean`);
-      case ZodTypes.date:
-        return this.setType(id, `Date`);
-      case ZodTypes.undefined:
-        return this.setType(id, `undefined`);
-      case ZodTypes.null:
-        return this.setType(id, `null`);
-      case ZodTypes.any:
-        return this.setType(id, `any`);
-      case ZodTypes.unknown:
-        return this.setType(id, `unknown`);
-      case ZodTypes.never:
-        return this.setType(id, `never`);
-      case ZodTypes.void:
-        return this.setType(id, `void`);
-      case ZodTypes.literal:
-        const val = def.value;
-        const literalType = typeof val === "string" ? `"${val}"` : `${val}`;
-        return this.setType(id, literalType);
-      case ZodTypes.enum:
-        return this.setType(id, def.values.map((v) => `"${v}"`).join(" | "));
-      case ZodTypes.object:
-        const objectLines: string[] = [];
-        const shape = def.shape();
-
-        for (const key in shape) {
-          const childSchema = shape[key];
-          const childType = this.generate(childSchema);
-          const OPTKEY = isOptional(childSchema) ? "?" : "";
-          objectLines.push(`${key}${OPTKEY}: ${childType.id}`);
-        }
-        const baseStruct = `{\n${objectLines
-          .map((line) => `  ${line};`)
-          .join("\n")}\n}`;
-        this.setType(id, `${baseStruct}`);
-        break;
-      case ZodTypes.tuple:
-        const tupleLines: string[] = [];
-        for (const elSchema of def.items) {
-          const elType = this.generate(elSchema);
-          tupleLines.push(elType.id);
-        }
-        const baseTuple = `[\n${tupleLines
-          .map((line) => `  ${line},`)
-          .join("\n")}\n]`;
-        return this.setType(id, `${baseTuple}`);
-      case ZodTypes.array:
-        return this.setType(id, `${this.generate(def.type).id}[]`);
-      case ZodTypes.function:
-        const args = this.generate(def.args);
-        const returns = this.generate(def.returns);
-        return this.setType(id, `(...args: ${args.id})=>${returns.id}`);
-      case ZodTypes.promise:
-        const promValue = this.generate(def.type);
-        return this.setType(id, `Promise<${promValue.id}>`);
-      case ZodTypes.union:
-        const unionLines: string[] = [];
-        for (const elSchema of def.options) {
-          const elType = this.generate(elSchema);
-          unionLines.push(elType.id);
-        }
-        return this.setType(id, unionLines.join(` | `));
-      case ZodTypes.intersection:
-        return this.setType(
-          id,
-          `${this.generate(def.left).id} & ${this.generate(def.right).id}`
-        );
-      case ZodTypes.record:
-        return this.setType(
-          id,
-          `{[k:string]: ${this.generate(def.valueType).id}}`
-        );
-
-      case ZodTypes.map:
-        return this.setType(
-          id,
-          `Map<${this.generate(def.keyType).id}, ${
-            this.generate(def.valueType).id
-          }>`
-        );
-      case ZodTypes.lazy:
-        const lazyType = def.getter();
-        return this.setType(id, this.generate(lazyType).id);
-      case ZodTypes.nativeEnum:
-        // const lazyType = def.getter();
-        return this.setType(id, "asdf");
-      case ZodTypes.optional:
-        return this.setType(
-          id,
-          `${this.generate(def.innerType).id} | undefined`
-        );
-      case ZodTypes.nullable:
-        return this.setType(id, `${this.generate(def.innerType).id} | null`);
-      case ZodTypes.transformer:
-        return this.setType(id, `${this.generate(def.schema).id}`);
-      default:
-        util.assertNever(def);
-    }
-    return this.findById(id);
-  };
-
-  static create = () => new ZodCodeGenerator();
-}
diff --git a/deno/lib/defaultErrorMap.ts b/deno/lib/defaultErrorMap.ts
index 3cc35a0c9..2350edd04 100644
--- a/deno/lib/defaultErrorMap.ts
+++ b/deno/lib/defaultErrorMap.ts
@@ -2,14 +2,12 @@ import { util } from "./helpers/util.ts";
 import { ZodIssueCode, ZodIssueOptionalMessage } from "./ZodError.ts";
 
 type ErrorMapCtx = {
-  // path: (string | number)[];
-  // details: any;
   defaultError: string;
   data: any;
-  // metadata: object;
 };
 
 export type ZodErrorMap = typeof defaultErrorMap;
+
 export const defaultErrorMap = (
   error: ZodIssueOptionalMessage,
   _ctx: ErrorMapCtx
@@ -23,9 +21,6 @@ export const defaultErrorMap = (
         message = `Expected ${error.expected}, received ${error.received}`;
       }
       break;
-    case ZodIssueCode.nonempty_array_is_empty:
-      message = `List must contain at least one item`;
-      break;
     case ZodIssueCode.unrecognized_keys:
       message = `Unrecognized key(s) in object: ${error.keys
         .map((k) => `'${k}'`)
@@ -34,16 +29,12 @@ export const defaultErrorMap = (
     case ZodIssueCode.invalid_union:
       message = `Invalid input`;
       break;
-    // case ZodIssueCode.invalid_tuple_length:
-    //   message = `Expected list of ${error.expected} items, received ${error.received} items`;
-    //   break;
-    case ZodIssueCode.invalid_literal_value:
-      message = `Input must be "${error.expected}"`;
-      break;
     case ZodIssueCode.invalid_enum_value:
-      message = `Input must be one of these values: ${error.options.join(
-        ", "
-      )}`;
+      message = `Invalid enum value. Expected ${error.options
+        .map((val) => (typeof val === "string" ? `'${val}'` : val))
+        .join(" | ")}, received ${
+        typeof _ctx.data === "string" ? `'${_ctx.data}'` : _ctx.data
+      }`;
       break;
     case ZodIssueCode.invalid_arguments:
       message = `Invalid function arguments`;
@@ -54,35 +45,21 @@ export const defaultErrorMap = (
     case ZodIssueCode.invalid_date:
       message = `Invalid date`;
       break;
-    // case ZodIssueCode.too_small:
-    //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
-    //   break;
-    // case ZodIssueCode.too_big:
-    //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
-    //   break;
     case ZodIssueCode.invalid_string:
       if (error.validation !== "regex") message = `Invalid ${error.validation}`;
       else message = "Invalid";
       break;
-    // case ZodIssueCode.invalid_url:
-    //   message = 'Invalid URL.';
-    //   break;
-    // case ZodIssueCode.invalid_uuid:
-    //   message = 'Invalid UUID.';
-    //   break;
     case ZodIssueCode.too_small:
       if (error.type === "array")
         message = `Should have ${error.inclusive ? `at least` : `more than`} ${
           error.minimum
-        } items`;
+        } item(s)`;
       else if (error.type === "string")
         message = `Should be ${error.inclusive ? `at least` : `over`} ${
           error.minimum
-        } characters`;
+        } character(s) long`;
       else if (error.type === "number")
-        message = `Value should be greater than ${
+        message = `Should be greater than ${
           error.inclusive ? `or equal to ` : ``
         }${error.minimum}`;
       else message = "Invalid input";
@@ -97,7 +74,7 @@ export const defaultErrorMap = (
           error.maximum
         } characters long`;
       else if (error.type === "number")
-        message = `Value should be less than ${
+        message = `Should be less than ${
           error.inclusive ? `or equal to ` : ``
         }${error.maximum}`;
       else message = "Invalid input";
@@ -105,9 +82,6 @@ export const defaultErrorMap = (
     case ZodIssueCode.custom:
       message = `Invalid input.`;
       break;
-    case ZodIssueCode.invalid_intersection_types:
-      message = `Intersections only support objects`;
-      break;
     default:
       message = `Invalid input.`;
       util.assertNever(error);
diff --git a/deno/lib/external.ts b/deno/lib/external.ts
new file mode 100644
index 000000000..ccb1ae7a4
--- /dev/null
+++ b/deno/lib/external.ts
@@ -0,0 +1,3 @@
+export * from "./helpers/parseUtil.ts";
+export * from "./types.ts";
+export * from "./ZodError.ts";
diff --git a/deno/lib/helpers/errorUtil.ts b/deno/lib/helpers/errorUtil.ts
index f54953092..8d9afa2a8 100644
--- a/deno/lib/helpers/errorUtil.ts
+++ b/deno/lib/helpers/errorUtil.ts
@@ -2,4 +2,6 @@ export namespace errorUtil {
   export type ErrMessage = string | { message?: string };
   export const errToObj = (message?: ErrMessage) =>
     typeof message === "string" ? { message } : message || {};
+  export const toString = (message?: ErrMessage): string | undefined =>
+    typeof message === "string" ? message : message?.message;
 }
diff --git a/deno/lib/helpers/maskUtil.ts b/deno/lib/helpers/maskUtil.ts
deleted file mode 100644
index 9cf3b9e7a..000000000
--- a/deno/lib/helpers/maskUtil.ts
+++ /dev/null
@@ -1,72 +0,0 @@
-import { Primitive } from "./primitive.ts";
-
-type AnyObject = { [k: string]: any };
-type IsAny<T> = any extends T ? (T extends any ? true : false) : false;
-type IsNever<T> = never extends T ? (T extends never ? true : false) : false;
-type IsTrue<T> = true extends T ? (T extends true ? true : false) : false;
-type IsObject<T> = T extends { [k: string]: any }
-  ? T extends Array<any>
-    ? false
-    : true
-  : false;
-type IsObjectArray<T> = T extends Array<{ [k: string]: any }> ? true : false;
-// type IsObject<T> = T extends { [k: string]: any } ? (T extends Array<any> ? never : true) : never;
-
-export namespace maskUtil {
-  export type Params<T> = {
-    array: T extends Array<infer U>
-      ? true | { [k in keyof U]?: true | Params<U[k]> }
-      : never;
-    object: T extends AnyObject
-      ? { [k in keyof T]?: true | Params<T[k]> }
-      : never;
-    rest: never;
-    never: never;
-  }[T extends null | undefined | Primitive | Array<Primitive>
-    ? "never"
-    : any extends T
-    ? "never"
-    : T extends Array<AnyObject>
-    ? "array"
-    : IsObject<T> extends true
-    ? "object"
-    : "rest"];
-
-  export type PickTest<T, P extends any> = P extends true
-    ? "true"
-    : true extends IsObject<T>
-    ? "object"
-    : true extends IsObjectArray<T>
-    ? "array"
-    : "rest";
-
-  export type Pick<T, P> = null extends T
-    ? undefined extends T
-      ? BasePick<NonNullable<T>, P> | null | undefined
-      : BasePick<NonNullable<T>, P> | null
-    : undefined extends T
-    ? BasePick<NonNullable<T>, P> | undefined
-    : BasePick<NonNullable<T>, P>;
-
-  export type BasePick<T, P extends any> = {
-    primitive: T;
-    primitivearray: T;
-    true: T;
-    object: { [k in keyof P]: k extends keyof T ? Pick<T[k], P[k]> : never };
-    array: T extends (infer U)[] ? Pick<U, P>[] : never;
-    never: never;
-    any: any;
-  }[IsAny<T> extends true
-    ? "any"
-    : IsNever<T> extends true
-    ? "never"
-    : IsNever<P> extends true
-    ? "true"
-    : IsTrue<P> extends true
-    ? "true"
-    : true extends IsObject<T>
-    ? "object"
-    : true extends IsObjectArray<T>
-    ? "array"
-    : "any"];
-}
diff --git a/deno/lib/helpers/objectUtil.ts b/deno/lib/helpers/objectUtil.ts
deleted file mode 100644
index 96b43431b..000000000
--- a/deno/lib/helpers/objectUtil.ts
+++ /dev/null
@@ -1,110 +0,0 @@
-// import { ZodRawShape } from "../types/base";
-// import { ZodRawShape } from "../types/base";
-import { ZodRawShape, ZodIntersection } from "../index.ts";
-
-// import { mergeObjects as mergeObjectsBase } from "../../types/object";
-// import { mergeShapes as mergeShapesBase } from "./merge";
-
-export namespace objectUtil {
-  // export interface ZodObjectParams {
-  //   strict: boolean;
-  // }
-
-  // export type MergeObjectParams<
-  //   First extends ZodObjectParams,
-  //   Second extends ZodObjectParams
-  // > = {
-  //   strict: First['strict'] extends false
-  //     ? false
-  //     : Second['strict'] extends false
-  //     ? false
-  //     : true;
-  // };
-
-  export type MergeShapes<U extends ZodRawShape, V extends ZodRawShape> = {
-    [k in Exclude<keyof U, keyof V>]: U[k];
-  } &
-    V;
-
-  type optionalKeys<T extends object> = {
-    [k in keyof T]: undefined extends T[k] ? k : never;
-  }[keyof T];
-
-  type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;
-
-  export type addQuestionMarks<T extends object> = {
-    [k in optionalKeys<T>]?: T[k];
-  } &
-    { [k in requiredKeys<T>]: T[k] };
-
-  // type ObjectIntersection<T extends ZodRawShape> = addQuestionMarks<
-  //   {
-  //     [k in keyof T]: T[k]['_type'];
-  //   }
-  // >;
-
-  export type identity<T> = T;
-  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
-
-  export type NoNeverKeys<T extends ZodRawShape> = {
-    [k in keyof T]: [T[k]] extends [never] ? never : k;
-  }[keyof T];
-
-  export type NoNever<T extends ZodRawShape> = identity<
-    {
-      [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;
-    }
-  >;
-
-  // export type ObjectType<T extends ZodRawShape> = flatten<
-  //   ObjectIntersection<T>
-  // >;
-  // type ObjectIntersectionInput<T extends ZodRawShape> = addQuestionMarks<
-  //   {
-  //     [k in keyof T]: T[k]['_input'];
-  //   }
-  // >;
-  // type ObjectIntersectionOutput<T extends ZodRawShape> = addQuestionMarks<
-  //   {
-  //     [k in keyof T]: T[k]['_output'];
-  //   }
-  // >;
-
-  // export type objectInputType<T extends ZodObject<any, any, any>> = flatten<
-  //   addQuestionMarks<
-  //     {
-  //       [k in keyof T['_shape']]: T['_shape'][k]['_input'];
-  //     }
-  //   >
-  // >;
-
-  // export type objectOutputType<T extends ZodObject<any, any, any>> = flatten<
-  //   addQuestionMarks<
-  //     {
-  //       [k in keyof T['_shape']]: T['_shape'][k]['_output'];
-  //     }
-  //   >
-  // >;
-
-  export const mergeShapes = <U extends ZodRawShape, T extends ZodRawShape>(
-    first: U,
-    second: T
-  ): T & U => {
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
-    const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
-
-    const sharedShape: any = {};
-    for (const k of sharedKeys) {
-      sharedShape[k] = ZodIntersection.create(first[k], second[k]);
-    }
-    return {
-      ...(first as object),
-      ...(second as object),
-      ...sharedShape,
-    };
-  };
-
-  // export const mergeObjects = mergeObjectsBase;
-  // export const mergeShapes = mergeShapesBase;
-}
diff --git a/deno/lib/helpers/parseUtil.ts b/deno/lib/helpers/parseUtil.ts
new file mode 100644
index 000000000..e6f58d990
--- /dev/null
+++ b/deno/lib/helpers/parseUtil.ts
@@ -0,0 +1,139 @@
+import {
+  defaultErrorMap,
+  MakeErrorData,
+  ZodError,
+  ZodErrorMap,
+} from "../ZodError.ts";
+import { util } from "./util.ts";
+
+export const ZodParsedType = util.arrayToEnum([
+  "string",
+  "nan",
+  "number",
+  "integer",
+  "float",
+  "boolean",
+  "date",
+  "bigint",
+  "symbol",
+  "function",
+  "undefined",
+  "null",
+  "array",
+  "object",
+  "unknown",
+  "promise",
+  "void",
+  "never",
+  "map",
+  "set",
+]);
+
+export type ZodParsedType = keyof typeof ZodParsedType;
+
+export const getParsedType = (data: any): ZodParsedType => {
+  if (typeof data === "string") return ZodParsedType.string;
+  if (typeof data === "number") {
+    if (Number.isNaN(data)) return ZodParsedType.nan;
+    return ZodParsedType.number;
+  }
+  if (typeof data === "boolean") return ZodParsedType.boolean;
+  if (typeof data === "bigint") return ZodParsedType.bigint;
+  if (typeof data === "symbol") return ZodParsedType.symbol;
+  if (data instanceof Date) return ZodParsedType.date;
+  if (typeof data === "function") return ZodParsedType.function;
+  if (data === undefined) return ZodParsedType.undefined;
+  if (typeof data === "undefined") return ZodParsedType.undefined;
+  if (typeof data === "object") {
+    if (Array.isArray(data)) return ZodParsedType.array;
+    if (data === null) return ZodParsedType.null;
+    if (
+      data.then &&
+      typeof data.then === "function" &&
+      data.catch &&
+      typeof data.catch === "function"
+    ) {
+      return ZodParsedType.promise;
+    }
+    if (data instanceof Map) {
+      return ZodParsedType.map;
+    }
+    if (data instanceof Set) {
+      return ZodParsedType.set;
+    }
+    return ZodParsedType.object;
+  }
+  return ZodParsedType.unknown;
+};
+
+export const issueHelpers = (error: ZodError, params: ParseParams) => {
+  const makeIssue = (errorData: MakeErrorData) => {
+    const errorArg = {
+      ...errorData,
+      path: [...params.path, ...(errorData.path || [])],
+    };
+
+    const defaultError =
+      defaultErrorMap === params.errorMap
+        ? { message: `Invalid value` }
+        : defaultErrorMap(errorArg, {
+            data: params.data,
+            defaultError: `Invalid value`,
+          });
+    const issue = {
+      ...errorData,
+      path: [...params.path, ...(errorData.path || [])],
+      message:
+        errorData.message ||
+        params.errorMap(errorArg, {
+          data: params.data,
+          defaultError: defaultError.message,
+        }).message,
+    };
+
+    return issue;
+  };
+  const addIssue = (errorData: MakeErrorData) => {
+    const issue = makeIssue(errorData);
+    error.addIssue(issue);
+  };
+
+  return {
+    makeIssue,
+    addIssue,
+  };
+};
+
+export type ParseParams = {
+  data: any;
+  path: (string | number)[];
+  errorMap: ZodErrorMap;
+  parentError: ZodError;
+  async: boolean;
+};
+
+export type ParseParamsWithOptionals = util.flatten<
+  Partial<ParseParams> & { data: any }
+>;
+
+export type ParseParamsNoData = Omit<ParseParams, "data">;
+
+export type ParseContext = ParseParams &
+  ReturnType<typeof issueHelpers> & {
+    parsedType: ZodParsedType;
+    currentError: ZodError;
+  };
+
+export type ZodParserReturnPayload<T> =
+  | {
+      success: false;
+      error: ZodError;
+    }
+  | {
+      success: true;
+      data: T;
+    };
+
+export type ZodParserReturnType<T> =
+  | ZodParserReturnPayload<T>
+  | Promise<ZodParserReturnPayload<T>>;
diff --git a/deno/lib/helpers/partialUtil.ts b/deno/lib/helpers/partialUtil.ts
index 9763309eb..a95c2c73e 100644
--- a/deno/lib/helpers/partialUtil.ts
+++ b/deno/lib/helpers/partialUtil.ts
@@ -1,4 +1,4 @@
-import { ZodTypeAny, ZodObject, ZodOptional } from "../index.ts";
+import { ZodObject, ZodOptional, ZodTypeAny } from "../index.ts";
 
 type AnyZodObject = ZodObject<any, any, any>;
 
diff --git a/deno/lib/helpers/primitive.ts b/deno/lib/helpers/primitive.ts
deleted file mode 100644
index 3a0252f9a..000000000
--- a/deno/lib/helpers/primitive.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-export type Primitive = string | number | bigint | boolean | null | undefined;
-
-export type Scalars = Primitive | Primitive[];
diff --git a/deno/lib/helpers/util.ts b/deno/lib/helpers/util.ts
index 0c2333fe2..051865c05 100644
--- a/deno/lib/helpers/util.ts
+++ b/deno/lib/helpers/util.ts
@@ -1,7 +1,8 @@
 export const INVALID = Symbol("invalid_data");
+export type INVALID = typeof INVALID;
 export namespace util {
-  export type AssertEqual<T, Expected> = T extends Expected
-    ? Expected extends T
+  export type AssertEqual<T, Expected> = [T] extends [Expected]
+    ? [Expected] extends [T]
       ? true
       : false
     : false;
@@ -57,4 +58,11 @@ export namespace util {
     }
     return undefined;
   };
+
+  export type identity<T> = T;
+  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
+  export type noUndefined<T> = T extends undefined ? never : T;
+
+  export type Primitive = string | number | bigint | boolean | null | undefined;
+  export type Scalar = Primitive | Primitive[];
 }
diff --git a/deno/lib/index.ts b/deno/lib/index.ts
index 5b14d18c3..77368b4b5 100644
--- a/deno/lib/index.ts
+++ b/deno/lib/index.ts
@@ -1,182 +1,3 @@
-/* ZOD */
-
-import {
-  ZodType,
-  ZodTypeDef,
-  ZodTypeAny,
-  ZodRawShape,
-  input,
-  output,
-  TypeOf,
-  RefinementCtx,
-} from "./types/base.ts";
-
-import { ZodErrorMap } from "./defaultErrorMap.ts";
-import { ZodAny } from "./types/any.ts";
-import { ZodArray, ZodNonEmptyArray } from "./types/array.ts";
-import { ZodBigInt } from "./types/bigint.ts";
-import { ZodBoolean } from "./types/boolean.ts";
-import { ZodDate } from "./types/date.ts";
-import { ZodEnum } from "./types/enum.ts";
-import { ZodFunction } from "./types/function.ts";
-import { ZodIntersection } from "./types/intersection.ts";
-import { ZodLazy } from "./types/lazy.ts";
-import { ZodLiteral } from "./types/literal.ts";
-import { ZodMap } from "./types/map.ts";
-import { ZodNativeEnum } from "./types/nativeEnum.ts";
-import { ZodNever } from "./types/never.ts";
-import { ZodNull } from "./types/null.ts";
-import { ZodNullable, ZodNullableType } from "./types/nullable.ts";
-import { ZodNumber } from "./types/number.ts";
-import { ZodObject } from "./types/object.ts";
-import { ZodOptional, ZodOptionalType } from "./types/optional.ts";
-import { ZodPromise } from "./types/promise.ts";
-import { ZodRecord } from "./types/record.ts";
-import { ZodString } from "./types/string.ts";
-import { ZodTransformer } from "./types/transformer.ts";
-import { ZodTuple } from "./types/tuple.ts";
-import { ZodUndefined } from "./types/undefined.ts";
-import { ZodUnion } from "./types/union.ts";
-import { ZodUnknown } from "./types/unknown.ts";
-import { ZodVoid } from "./types/void.ts";
-import { ZodParsedType } from "./ZodParsedType.ts";
-import { ZodTypes } from "./ZodTypes.ts";
-import { ZodCodeGenerator } from "./codegen.ts";
-
-// export { ZodTypeDef, ZodRawShape, ZodTypes };
-
-const stringType = ZodString.create;
-const numberType = ZodNumber.create;
-const bigIntType = ZodBigInt.create;
-const booleanType = ZodBoolean.create;
-const dateType = ZodDate.create;
-const undefinedType = ZodUndefined.create;
-const nullType = ZodNull.create;
-const anyType = ZodAny.create;
-const unknownType = ZodUnknown.create;
-const neverType = ZodNever.create;
-const voidType = ZodVoid.create;
-const arrayType = ZodArray.create;
-const objectType = ZodObject.create;
-const unionType = ZodUnion.create;
-const intersectionType = ZodIntersection.create;
-const tupleType = ZodTuple.create;
-const recordType = ZodRecord.create;
-const mapType = ZodMap.create;
-const functionType = ZodFunction.create;
-const lazyType = ZodLazy.create;
-const literalType = ZodLiteral.create;
-const enumType = ZodEnum.create;
-const nativeEnumType = ZodNativeEnum.create;
-const promiseType = ZodPromise.create;
-const transformerType = ZodTransformer.create;
-const optionalType = ZodOptional.create;
-const nullableType = ZodNullable.create;
-const ostring = () => stringType().optional();
-const onumber = () => numberType().optional();
-const oboolean = () => booleanType().optional();
-const codegen = ZodCodeGenerator.create;
-
-export const custom = <T>(
-  check?: (data: unknown) => any,
-  params?: Parameters<ZodTypeAny["refine"]>[1]
-): ZodType<T> => {
-  if (check) return anyType().refine(check, params);
-  return anyType();
-};
-
-const instanceOfType = <T extends new (...args: any[]) => any>(
-  cls: T,
-  params: Parameters<ZodTypeAny["refine"]>[1] = {
-    message: `Input not instance of ${cls.name}`,
-  }
-) => custom<InstanceType<T>>((data) => data instanceof cls, params);
-
-export type {
-  ZodTypeDef,
-  ZodRawShape,
-  RefinementCtx,
-  ZodParsedType,
-  TypeOf as infer,
-  input,
-  output,
-  TypeOf,
-  ZodErrorMap,
-  ZodNullableType,
-  ZodOptionalType,
-  ZodTypeAny,
-};
-
-export {
-  ZodType,
-  ZodType as Schema,
-  ZodType as ZodSchema,
-  ZodTypes,
-  ZodAny,
-  ZodArray,
-  ZodNonEmptyArray,
-  ZodBigInt,
-  ZodBoolean,
-  ZodCodeGenerator,
-  ZodDate,
-  ZodEnum,
-  ZodFunction,
-  ZodIntersection,
-  ZodLazy,
-  ZodLiteral,
-  ZodNativeEnum,
-  ZodNever,
-  ZodNull,
-  ZodNullable,
-  ZodNumber,
-  ZodObject,
-  ZodOptional,
-  ZodPromise,
-  ZodRecord,
-  ZodString,
-  ZodTransformer,
-  ZodTuple,
-  ZodUndefined,
-  ZodUnion,
-  ZodUnknown,
-  ZodVoid,
-  anyType as any,
-  arrayType as array,
-  bigIntType as bigint,
-  booleanType as boolean,
-  codegen,
-  dateType as date,
-  enumType as enum,
-  functionType as function,
-  instanceOfType as instanceof,
-  intersectionType as intersection,
-  lazyType as lazy,
-  literalType as literal,
-  mapType as map,
-  nativeEnumType as nativeEnum,
-  neverType as never,
-  nullType as null,
-  nullableType as nullable,
-  numberType as number,
-  objectType as object,
-  oboolean,
-  onumber,
-  optionalType as optional,
-  ostring,
-  promiseType as promise,
-  recordType as record,
-  stringType as string,
-  transformerType as transformer,
-  tupleType as tuple,
-  undefinedType as undefined,
-  unionType as union,
-  unknownType as unknown,
-  voidType as void,
-};
-
-export const late = {
-  object: ZodObject.lazycreate,
-};
-
-export * from "./ZodDef.ts";
-export * from "./ZodError.ts";
+import * as z from "./external.ts";
+export * from "./external.ts";
+export { z };
diff --git a/deno/lib/isScalar.ts b/deno/lib/isScalar.ts
deleted file mode 100644
index 06d572ca2..000000000
--- a/deno/lib/isScalar.ts
+++ /dev/null
@@ -1,102 +0,0 @@
-import { ZodDef, ZodType, ZodTypes } from "./index.ts";
-import { util } from "./helpers/util.ts";
-
-// import { ZodTypes } from "./ZodTypes";
-
-export const isScalar = (
-  schema: ZodType<any, any>,
-  params: { root: boolean } = { root: true }
-): boolean => {
-  const def = schema._def as ZodDef;
-
-  let returnValue = false;
-  switch (def.t) {
-    case ZodTypes.string:
-      returnValue = true;
-      break;
-    case ZodTypes.number:
-      returnValue = true;
-      break;
-    case ZodTypes.bigint:
-      returnValue = true;
-      break;
-    case ZodTypes.boolean:
-      returnValue = true;
-      break;
-    case ZodTypes.undefined:
-      returnValue = true;
-      break;
-    case ZodTypes.null:
-      returnValue = true;
-      break;
-    case ZodTypes.any:
-      returnValue = false;
-      break;
-    case ZodTypes.unknown:
-      returnValue = false;
-      break;
-    case ZodTypes.never:
-      returnValue = false;
-      break;
-    case ZodTypes.void:
-      returnValue = false;
-      break;
-    case ZodTypes.array:
-      if (params.root === false) return false;
-      returnValue = isScalar(def.type, { root: false });
-      break;
-    case ZodTypes.object:
-      returnValue = false;
-      break;
-    case ZodTypes.union:
-      returnValue = def.options.every((x) => isScalar(x));
-      break;
-    case ZodTypes.intersection:
-      returnValue = isScalar(def.left) && isScalar(def.right);
-      break;
-    case ZodTypes.tuple:
-      returnValue = def.items.every((x) => isScalar(x, { root: false }));
-      break;
-    case ZodTypes.lazy:
-      returnValue = isScalar(def.getter());
-      break;
-    case ZodTypes.literal:
-      returnValue = true;
-      break;
-    case ZodTypes.enum:
-      returnValue = true;
-      break;
-    case ZodTypes.nativeEnum:
-      returnValue = true;
-      break;
-    case ZodTypes.function:
-      returnValue = false;
-      break;
-    case ZodTypes.record:
-      returnValue = false;
-      break;
-    case ZodTypes.map:
-      returnValue = false;
-      break;
-    case ZodTypes.date:
-      returnValue = true;
-      break;
-    case ZodTypes.promise:
-      returnValue = false;
-      break;
-
-    case ZodTypes.transformer:
-      returnValue = isScalar(def.schema);
-      break;
-    case ZodTypes.optional:
-      returnValue = isScalar(def.innerType);
-      break;
-    case ZodTypes.nullable:
-      returnValue = isScalar(def.innerType);
-      break;
-    default:
-      util.assertNever(def);
-    // returnValue = false; break;
-  }
-  return returnValue;
-};
diff --git a/deno/lib/parser.ts b/deno/lib/parser.ts
deleted file mode 100644
index 2043a70d6..000000000
--- a/deno/lib/parser.ts
+++ /dev/null
@@ -1,985 +0,0 @@
-import { defaultErrorMap, ZodErrorMap } from "./defaultErrorMap.ts";
-import { INVALID, util } from "./helpers/util.ts";
-import { NOSET, PseudoPromise } from "./PseudoPromise.ts";
-// import { inputSchema } from "../types/base/output-schema";
-import { ZodType, RefinementCtx } from "./index.ts";
-// type adsf = RefinementCtx
-// import { ZodNever } from "../types/never";
-// import { ZodPromise } from "../types/promise";
-import { ZodDef } from "./ZodDef.ts";
-import { ZodError, ZodIssue, ZodIssueCode, MakeErrorData } from "./ZodError.ts";
-import { ZodParsedType } from "./ZodParsedType.ts";
-import { ZodTypes } from "./ZodTypes.ts";
-
-export const getParsedType = (data: any): ZodParsedType => {
-  if (typeof data === "string") return "string";
-  if (typeof data === "number") {
-    if (Number.isNaN(data)) return "nan";
-    return "number";
-  }
-  if (typeof data === "boolean") return "boolean";
-  if (typeof data === "bigint") return "bigint";
-  if (typeof data === "symbol") return "symbol";
-  if (data instanceof Date) return "date";
-  if (typeof data === "function") return "function";
-  if (data === undefined) return "undefined";
-  if (typeof data === "undefined") return "undefined";
-  if (typeof data === "object") {
-    if (Array.isArray(data)) return "array";
-    if (data === null) return "null";
-    if (
-      data.then &&
-      typeof data.then === "function" &&
-      data.catch &&
-      typeof data.catch === "function"
-    ) {
-      return "promise";
-    }
-    if (data instanceof Map) {
-      return "map";
-    }
-    return "object";
-  }
-  return "unknown";
-};
-
-const makeError = (
-  params: Required<ParseParams>,
-  data: any,
-  errorData: MakeErrorData
-): ZodIssue => {
-  const errorArg = {
-    ...errorData,
-    path: [...params.path, ...(errorData.path || [])],
-  };
-  const ctxArg = { data };
-
-  const defaultError =
-    defaultErrorMap === params.errorMap
-      ? { message: `Invalid value.` }
-      : defaultErrorMap(errorArg, {
-          ...ctxArg,
-          defaultError: `Invalid value.`,
-        });
-  return {
-    ...errorData,
-    path: [...params.path, ...(errorData.path || [])],
-    message:
-      errorData.message ||
-      params.errorMap(errorArg, {
-        ...ctxArg,
-        defaultError: defaultError.message,
-      }).message,
-  };
-};
-
-export type ParseParams = {
-  seen?: {
-    schema: ZodType<any>;
-    objects: { input: any; error?: ZodError; output: any }[];
-  }[];
-  path?: (string | number)[];
-  errorMap?: ZodErrorMap;
-  async?: boolean;
-  runAsyncValidationsInSeries?: boolean;
-};
-
-export const ZodParser = (schema: ZodType<any>) => (
-  data: any,
-  baseParams: ParseParams = { seen: [], errorMap: defaultErrorMap, path: [] }
-) => {
-  const params: Required<ParseParams> = {
-    seen: baseParams.seen || [],
-    path: baseParams.path || [],
-    errorMap: baseParams.errorMap || defaultErrorMap,
-    async: baseParams.async ?? false,
-    runAsyncValidationsInSeries:
-      baseParams.runAsyncValidationsInSeries ?? false,
-  };
-
-  const def: ZodDef = schema._def as any;
-
-  let PROMISE: PseudoPromise<any> = new PseudoPromise();
-  (PROMISE as any)._default = true;
-
-  const RESULT: { input: any; output: any; error?: ZodError } = {
-    input: data,
-    output: INVALID,
-  };
-
-  params.seen = params.seen || [];
-
-  const ERROR = new ZodError([]);
-
-  const THROW = () => {
-    RESULT.error = ERROR;
-    throw ERROR;
-  };
-
-  const HANDLE = (err: Error) => {
-    if (err instanceof ZodError) {
-      ERROR.addIssues(err.issues);
-      return INVALID;
-    }
-    throw ERROR;
-  };
-
-  const parsedType = getParsedType(data);
-
-  switch (def.t) {
-    case ZodTypes.string:
-      if (parsedType !== ZodParsedType.string) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.string,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-
-      break;
-    case ZodTypes.number:
-      if (parsedType !== ZodParsedType.number) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.number,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      if (Number.isNaN(data)) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.number,
-            received: ZodParsedType.nan,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.bigint:
-      if (parsedType !== ZodParsedType.bigint) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.bigint,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.boolean:
-      if (parsedType !== ZodParsedType.boolean) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.boolean,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.undefined:
-      if (parsedType !== ZodParsedType.undefined) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.undefined,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.null:
-      if (parsedType !== ZodParsedType.null) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.null,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.any:
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.unknown:
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.never:
-      ERROR.addIssue(
-        makeError(params, data, {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.never,
-          received: parsedType,
-        })
-      );
-      PROMISE = PseudoPromise.resolve(INVALID);
-      break;
-    case ZodTypes.void:
-      if (
-        parsedType !== ZodParsedType.undefined &&
-        parsedType !== ZodParsedType.null
-      ) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.void,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.array:
-      RESULT.output = [];
-      if (parsedType !== ZodParsedType.array) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.array,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      // const data: any[] = data;
-      if (def.nonempty === true && data.length === 0) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.nonempty_array_is_empty,
-          })
-        );
-        THROW();
-      }
-
-      PROMISE = PseudoPromise.all(
-        (data as any[]).map((item, i) => {
-          return new PseudoPromise()
-            .then(() =>
-              def.type.parse(item, {
-                ...params,
-                path: [...params.path, i],
-              })
-            )
-            .catch((err) => {
-              if (!(err instanceof ZodError)) {
-                throw err;
-              }
-              ERROR.addIssues(err.issues);
-              return INVALID;
-            });
-        })
-      );
-
-      break;
-    case ZodTypes.map:
-      if (parsedType !== ZodParsedType.map) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.map,
-            received: parsedType,
-          })
-        );
-        THROW();
-      }
-
-      const dataMap: Map<unknown, unknown> = data;
-      const returnedMap = new Map();
-
-      PROMISE = PseudoPromise.all(
-        [...dataMap.entries()].map(([key, value], index) => {
-          return PseudoPromise.all([
-            new PseudoPromise()
-              .then(() => {
-                return def.keyType.parse(key, {
-                  ...params,
-                  path: [...params.path, index, "key"],
-                });
-              })
-              .catch(HANDLE),
-            new PseudoPromise()
-              .then(() => {
-                const mapValue = def.valueType.parse(value, {
-                  ...params,
-                  path: [...params.path, index, "value"],
-                });
-                return [key, mapValue];
-              })
-              .catch(HANDLE),
-          ])
-            .then((item: any) => {
-              if (item[0] !== INVALID && item[1] !== INVALID) {
-                returnedMap.set(item[0], item[1]);
-              }
-            })
-            .catch(HANDLE);
-        })
-      )
-        .then(() => {
-          if (!ERROR.isEmpty) {
-            throw ERROR;
-          }
-        })
-        .then(() => {
-          return returnedMap;
-        })
-        .then(() => {
-          return returnedMap;
-        });
-      break;
-    case ZodTypes.object:
-      RESULT.output = {};
-      if (parsedType !== ZodParsedType.object) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.object,
-            received: parsedType,
-          })
-        );
-        THROW();
-      }
-
-      const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-      const shape = def.shape();
-      const shapeKeys = Object.keys(shape);
-      const dataKeys = Object.keys(data);
-
-      const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
-
-      for (const key of shapeKeys) {
-        const keyValidator = shapeKeys.includes(key)
-          ? shape[key]
-          : !(def.catchall._def.t === ZodTypes.never)
-          ? def.catchall
-          : undefined;
-
-        if (!keyValidator) {
-          continue;
-        }
-
-        // first check is required to avoid non-enumerable keys
-        if (typeof data[key] === "undefined" && !dataKeys.includes(key)) {
-          objectPromises[key] = new PseudoPromise()
-            .then(() => {
-              return keyValidator.parse(undefined, {
-                ...params,
-                path: [...params.path, key],
-              });
-            })
-            .then((output) => {
-              if (output === undefined) {
-                // schema is optional
-                // data is undefined
-                // don't explicity add undefined to outut
-                // continue;
-                return NOSET;
-              } else {
-                return output;
-              }
-            })
-            .catch((err) => {
-              if (err instanceof ZodError) {
-                const zerr: ZodError = err;
-                ERROR.addIssues(zerr.issues);
-                objectPromises[key] = PseudoPromise.resolve(INVALID);
-              } else {
-                throw err;
-              }
-            });
-
-          continue;
-        }
-
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator.parse(data[key], {
-              ...params,
-              path: [...params.path, key],
-            });
-          })
-          .catch((err) => {
-            if (err instanceof ZodError) {
-              const zerr: ZodError = err;
-              ERROR.addIssues(zerr.issues);
-              return INVALID;
-            } else {
-              throw err;
-            }
-          });
-      }
-
-      if (def.catchall._def.t === ZodTypes.never) {
-        if (def.unknownKeys === "passthrough") {
-          for (const key of extraKeys) {
-            objectPromises[key] = PseudoPromise.resolve(data[key]);
-          }
-        } else if (def.unknownKeys === "strict") {
-          if (extraKeys.length > 0) {
-            ERROR.addIssue(
-              makeError(params, data, {
-                code: ZodIssueCode.unrecognized_keys,
-                keys: extraKeys,
-              })
-            );
-          }
-        } else if (def.unknownKeys === "strip") {
-          // do nothing
-        } else {
-          util.assertNever(def.unknownKeys);
-        }
-      } else {
-        // run catchall validation
-        for (const key of extraKeys) {
-          objectPromises[key] = new PseudoPromise()
-            .then(() => {
-              const parsedValue = def.catchall.parse(data[key], {
-                ...params,
-                path: [...params.path, key],
-              });
-              return parsedValue;
-            })
-            .catch((err) => {
-              if (err instanceof ZodError) {
-                ERROR.addIssues(err.issues);
-              } else {
-                throw err;
-              }
-            });
-        }
-      }
-
-      PROMISE = PseudoPromise.object(objectPromises)
-        .then((resolvedObject) => {
-          Object.assign(RESULT.output, resolvedObject);
-          return RESULT.output;
-        })
-        .then((finalObject) => {
-          if (ERROR.issues.length > 0) {
-            return INVALID;
-          }
-          return finalObject;
-        })
-        .catch((err) => {
-          if (err instanceof ZodError) {
-            ERROR.addIssues(err.issues);
-            return INVALID;
-          }
-          throw err;
-        });
-
-      break;
-    case ZodTypes.union:
-      let isValid = false;
-      const unionErrors: ZodError[] = [];
-
-      PROMISE = PseudoPromise.all(
-        def.options.map((opt, _j) => {
-          // return new PseudoPromise().then
-          return new PseudoPromise()
-            .then(() => {
-              return opt.parse(data, params);
-            })
-            .then((optionData) => {
-              isValid = true;
-              return optionData;
-            })
-            .catch((err) => {
-              if (err instanceof ZodError) {
-                unionErrors.push(err);
-                return INVALID;
-              }
-              throw err;
-            });
-        })
-      )
-        .then((unionResults) => {
-          if (!isValid) {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== "invalid_type";
-            });
-            if (nonTypeErrors.length === 1) {
-              ERROR.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ERROR.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_union,
-                  unionErrors,
-                })
-              );
-            }
-            THROW();
-            // return;
-          }
-          return unionResults;
-        })
-        .then((unionResults: any[]) => {
-          return util.find(unionResults, (val: any) => val !== INVALID);
-        });
-
-      break;
-    case ZodTypes.intersection:
-      PROMISE = PseudoPromise.all([
-        new PseudoPromise()
-          .then(() => {
-            return def.left.parse(data, params);
-          })
-          .catch(HANDLE),
-        new PseudoPromise()
-          .then(() => {
-            return def.right.parse(data, params);
-          })
-          .catch(HANDLE),
-      ]).then(([parsedLeft, parsedRight]: any) => {
-        if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-        const parsedLeftType = getParsedType(parsedLeft);
-        const parsedRightType = getParsedType(parsedRight);
-
-        if (parsedLeft === parsedRight) {
-          return parsedLeft;
-        } else if (
-          parsedLeftType === ZodParsedType.object &&
-          parsedRightType === ZodParsedType.object
-        ) {
-          return { ...parsedLeft, ...parsedRight };
-        } else {
-          ERROR.addIssue(
-            makeError(params, data, {
-              code: ZodIssueCode.invalid_intersection_types,
-            })
-          );
-        }
-      });
-
-      break;
-
-    case ZodTypes.optional:
-      if (parsedType === ZodParsedType.undefined) {
-        PROMISE = PseudoPromise.resolve(undefined);
-        break;
-      }
-
-      PROMISE = new PseudoPromise()
-        .then(() => {
-          return def.innerType.parse(data, params);
-        })
-        .catch(HANDLE);
-      break;
-    case ZodTypes.nullable:
-      if (parsedType === ZodParsedType.null) {
-        PROMISE = PseudoPromise.resolve(null);
-        break;
-      }
-
-      PROMISE = new PseudoPromise()
-        .then(() => {
-          return def.innerType.parse(data, params);
-        })
-        .catch(HANDLE);
-      break;
-    case ZodTypes.tuple:
-      if (parsedType !== ZodParsedType.array) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.array,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      if (data.length > def.items.length) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.too_big,
-            maximum: def.items.length,
-            inclusive: true,
-            type: "array",
-          })
-        );
-      } else if (data.length < def.items.length) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.too_small,
-            minimum: def.items.length,
-            inclusive: true,
-            type: "array",
-          })
-        );
-      }
-
-      const tupleData: any[] = data;
-
-      PROMISE = PseudoPromise.all(
-        tupleData.map((item, index) => {
-          const itemParser = def.items[index];
-          return new PseudoPromise()
-            .then(() => {
-              const tupleDatum = itemParser.parse(item, {
-                ...params,
-                path: [...params.path, index],
-              });
-              return tupleDatum;
-            })
-            .catch((err) => {
-              if (err instanceof ZodError) {
-                ERROR.addIssues(err.issues);
-                return;
-              }
-              throw err;
-            })
-            .then((arg) => {
-              return arg;
-            });
-        })
-      )
-        .then((tupleData) => {
-          if (!ERROR.isEmpty) THROW();
-          return tupleData;
-        })
-
-        .catch((err) => {
-          throw err;
-        });
-
-      break;
-    case ZodTypes.lazy:
-      const lazySchema = def.getter();
-      PROMISE = PseudoPromise.resolve(lazySchema.parse(data, params));
-      break;
-    case ZodTypes.literal:
-      if (data !== def.value) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_literal_value,
-            expected: def.value,
-          })
-        );
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.enum:
-      if (def.values.indexOf(data) === -1) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_enum_value,
-            options: def.values,
-          })
-        );
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.nativeEnum:
-      if (util.getValidEnumValues(def.values).indexOf(data) === -1) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_enum_value,
-            options: util.objectValues(def.values),
-          })
-        );
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.function:
-      if (parsedType !== ZodParsedType.function) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.function,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-
-      const isAsyncFunction = def.returns._def.t === ZodTypes.promise;
-
-      const validatedFunction = (...args: any[]) => {
-        const internalProm = new PseudoPromise()
-          .then(() => {
-            return def.args.parse(args as any, {
-              ...params,
-              async: isAsyncFunction,
-            });
-          })
-          .catch((err) => {
-            if (!(err instanceof ZodError)) throw err;
-            const argsError = new ZodError([]);
-            argsError.addIssue(
-              makeError(params, data, {
-                code: ZodIssueCode.invalid_arguments,
-                argumentsError: err,
-              })
-            );
-            throw argsError;
-          })
-          .then((args) => {
-            return data(...(args as any));
-          })
-          .then((result) => {
-            return def.returns.parse(result, {
-              ...params,
-              async: isAsyncFunction,
-            });
-          })
-          .catch((err) => {
-            if (err instanceof ZodError) {
-              const returnsError = new ZodError([]);
-              returnsError.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_return_type,
-                  returnTypeError: err,
-                })
-              );
-              throw returnsError;
-            }
-            throw err;
-          });
-
-        if (isAsyncFunction) {
-          return internalProm.getValueAsync();
-        } else {
-          return internalProm.getValueSync();
-        }
-      };
-      PROMISE = PseudoPromise.resolve(validatedFunction);
-
-      break;
-    case ZodTypes.record:
-      if (parsedType !== ZodParsedType.object) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.object,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-
-      const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-      for (const key in data) {
-        parsedRecordPromises[key] = new PseudoPromise()
-          .then(() => {
-            return def.valueType.parse(data[key], {
-              ...params,
-              path: [...params.path, key],
-            });
-          })
-          .catch(HANDLE);
-      }
-      PROMISE = PseudoPromise.object(parsedRecordPromises);
-
-      break;
-    case ZodTypes.date:
-      if (!(data instanceof Date)) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.date,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      if (isNaN(data.getTime())) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_date,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-
-    case ZodTypes.promise:
-      if (parsedType !== ZodParsedType.promise && params.async !== true) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.promise,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-
-      const promisified =
-        parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
-
-      PROMISE = PseudoPromise.resolve(
-        promisified.then((resolvedData: any) => {
-          return def.type.parse(resolvedData, params);
-        })
-      );
-
-      break;
-
-    case ZodTypes.transformer:
-      PROMISE = new PseudoPromise().then(() => {
-        return def.schema.parse(data, params);
-      });
-      break;
-    default:
-      PROMISE = PseudoPromise.resolve("adsf" as never);
-      util.assertNever(def);
-  }
-
-  if ((PROMISE as any)._default === true) {
-    throw new Error("Result is not materialized.");
-  }
-
-  if (!ERROR.isEmpty) {
-    THROW();
-  }
-  const effects = def.effects || [];
-
-  const checkCtx: RefinementCtx = {
-    addIssue: (arg: MakeErrorData) => {
-      ERROR.addIssue(makeError(params, data, arg));
-    },
-    path: params.path,
-  };
-
-  if (params.async === false) {
-    const resolvedValue = PROMISE.getValueSync();
-
-    if (resolvedValue === INVALID && ERROR.isEmpty) {
-      ERROR.addIssue(
-        makeError(params, data, {
-          code: ZodIssueCode.custom,
-          message: "Invalid",
-        })
-      );
-    }
-
-    if (!ERROR.isEmpty) {
-      THROW();
-    }
-
-    let finalValue = resolvedValue;
-
-    for (const effect of effects) {
-      // console.log(`running effect: `);
-      // console.log(effect);
-      if (effect.type === "check") {
-        const checkResult = effect.check(finalValue, checkCtx);
-        // console.log(`checkresult: ${checkResult}`);
-        if (checkResult instanceof Promise)
-          throw new Error(
-            "You can't use .parse() on a schema containing async refinements. Use .parseAsync instead."
-          );
-      } else if (effect.type === "mod") {
-        if (def.t !== ZodTypes.transformer)
-          throw new Error("Only Modders can contain mods");
-        finalValue = effect.mod(finalValue);
-        if (finalValue instanceof Promise) {
-          throw new Error(
-            `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-          );
-        }
-      } else {
-        throw new Error(`Invalid effect type.`);
-      }
-    }
-    if (!ERROR.isEmpty) {
-      THROW();
-    }
-
-    return finalValue as any;
-  } else {
-    // if (params.async == true) {
-    const checker = async () => {
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        // let someError: boolean = false;
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.custom,
-            message: "Invalid",
-          })
-        );
-      }
-
-      if (!ERROR.isEmpty) {
-        THROW();
-      }
-
-      let finalValue = resolvedValue;
-      for (const effect of effects) {
-        if (effect.type === "check") {
-          await effect.check(finalValue, checkCtx);
-        } else if (effect.type === "mod") {
-          if (def.t !== ZodTypes.transformer)
-            throw new Error("Only Modders can contain mods");
-          finalValue = await effect.mod(finalValue);
-        }
-      }
-
-      // if (params.runAsyncValidationsInSeries) {
-      //   let someError = false;
-      //   await customChecks.reduce((previousPromise, check) => {
-      //     return previousPromise.then(async () => {
-      //       if (!someError) {
-      //         const len = ERROR.issues.length;
-      //         await check.check(resolvedValue, checkCtx);
-      //         if (len < ERROR.issues.length) someError = true;
-      //       }
-      //     });
-      //   }, Promise.resolve());
-      // } else {
-      //   await Promise.all(
-      //     customChecks.map(async (check) => {
-      //       await check.check(resolvedValue, checkCtx);
-      //     })
-      //   );
-      // }
-
-      if (!ERROR.isEmpty) {
-        THROW();
-      }
-
-      return finalValue;
-    };
-
-    return checker();
-  }
-};
diff --git a/deno/lib/playground.ts b/deno/lib/playground.ts
index 46ed0c355..f96b6e003 100644
--- a/deno/lib/playground.ts
+++ b/deno/lib/playground.ts
@@ -1,9 +1,9 @@
-import * as z from "./index.ts";
+import { z } from "./index.ts";
 
-const numberWithRandomDefault = z.number().default(Math.random);
-console.log(numberWithRandomDefault.parse(undefined));
-console.log(numberWithRandomDefault.parse(undefined));
-console.log(numberWithRandomDefault.parse(undefined));
-console.log(numberWithRandomDefault.parse(undefined));
+const run = async () => {
+  z;
+};
+
+run();
 
 export {};
diff --git a/deno/lib/switcher.ts b/deno/lib/switcher.ts
deleted file mode 100644
index 8503e6219..000000000
--- a/deno/lib/switcher.ts
+++ /dev/null
@@ -1,66 +0,0 @@
-import { util } from "./helpers/util.ts";
-import { ZodType, ZodDef, ZodTypes } from "./index.ts";
-// import { ZodDef } from "./ZodDef";
-// import { ZodTypes } from "./ZodTypes";
-
-export const visitor = (schema: ZodType<any, any>) => {
-  const def = schema._def as ZodDef;
-  switch (def.t) {
-    case ZodTypes.string:
-      break;
-    case ZodTypes.number:
-      break;
-    case ZodTypes.bigint:
-      break;
-    case ZodTypes.boolean:
-      break;
-    case ZodTypes.undefined:
-      break;
-    case ZodTypes.null:
-      break;
-    case ZodTypes.any:
-      break;
-    case ZodTypes.unknown:
-      break;
-    case ZodTypes.never:
-      break;
-    case ZodTypes.void:
-      break;
-    case ZodTypes.array:
-      break;
-    case ZodTypes.object:
-      break;
-    case ZodTypes.union:
-      break;
-    case ZodTypes.intersection:
-      break;
-    case ZodTypes.tuple:
-      break;
-    case ZodTypes.lazy:
-      break;
-    case ZodTypes.literal:
-      break;
-    case ZodTypes.enum:
-      break;
-    case ZodTypes.nativeEnum:
-      break;
-    case ZodTypes.function:
-      break;
-    case ZodTypes.record:
-      break;
-    case ZodTypes.date:
-      break;
-    case ZodTypes.promise:
-      break;
-    case ZodTypes.transformer:
-      break;
-    case ZodTypes.optional:
-      break;
-    case ZodTypes.nullable:
-      break;
-    case ZodTypes.map:
-      break;
-    default:
-      util.assertNever(def);
-  }
-};
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
new file mode 100644
index 000000000..4e456fa23
--- /dev/null
+++ b/deno/lib/types.ts
@@ -0,0 +1,2659 @@
+import { errorUtil } from "./helpers/errorUtil.ts";
+import {
+  getParsedType,
+  issueHelpers,
+  ParseContext,
+  ParseParams,
+  ParseParamsNoData,
+  ParseParamsWithOptionals,
+  ZodParsedType,
+  ZodParserReturnType,
+} from "./helpers/parseUtil.ts";
+import { partialUtil } from "./helpers/partialUtil.ts";
+import { INVALID, util } from "./helpers/util.ts";
+import { NOSET, PseudoPromise } from "./PseudoPromise.ts";
+import {
+  defaultErrorMap,
+  MakeErrorData,
+  StringValidation,
+  ZodCustomIssue,
+  ZodError,
+  ZodIssueCode,
+} from "./ZodError.ts";
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodType      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+
+export type RefinementCtx = {
+  addIssue: (arg: MakeErrorData) => void;
+  path: (string | number)[];
+};
+export type ZodRawShape = { [k: string]: ZodTypeAny };
+export type ZodTypeAny = ZodType<any, any, any>;
+export type TypeOf<T extends ZodType<any>> = T["_output"];
+export type input<T extends ZodType<any>> = T["_input"];
+export type output<T extends ZodType<any>> = T["_output"];
+export type { TypeOf as infer };
+
+export type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
+export interface ZodTypeDef {
+  accepts?: ZodType<any, any>;
+}
+
+type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
+type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
+  infer Inner,
+  infer Out
+>
+  ? ZodEffects<Inner, Out>
+  : ZodEffects<T, T["_output"]>;
+export abstract class ZodType<
+  Output,
+  Def extends ZodTypeDef = ZodTypeDef,
+  Input = Output
+> {
+  readonly _type!: Output;
+  readonly _output!: Output;
+  readonly _input!: Input;
+  readonly _def!: Def;
+
+  abstract _parse(_ctx: ParseContext): any;
+
+  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
+    const data = params.data;
+    let PROMISE: PseudoPromise<any>;
+    const ERROR = new ZodError([]);
+    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
+
+    const parsedType = getParsedType(data);
+    try {
+      const parsedValue = this._parse({
+        ...params,
+        currentError: ERROR,
+        makeIssue,
+        addIssue,
+        parsedType,
+      });
+
+      PROMISE =
+        parsedValue instanceof PseudoPromise
+          ? parsedValue
+          : PseudoPromise.resolve(parsedValue);
+    } catch (err) {
+      // default to invalid
+      PROMISE = PseudoPromise.resolve(INVALID);
+    }
+
+    const isSync = params.async === false || this instanceof ZodPromise;
+
+    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
+      key;
+      if (!ERROR.isEmpty) throw ERROR;
+      return data;
+    };
+
+    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT("post effects"))
+      .then((data) => {
+        return { success: true, data };
+      })
+      .catch((error) => {
+        params.parentError.addIssues(ERROR.issues);
+        if (error instanceof ZodError) return { success: false, error: error };
+        throw error;
+      });
+
+    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
+  }
+
+  _parseInternalOptionalParams: (
+    params: ParseParamsWithOptionals
+  ) => ZodParserReturnType<Output> = (params) => {
+    // if(!params.data) throw
+
+    const fullParams: ParseParams = {
+      data: params.data,
+      path: params.path || [],
+      parentError: params.parentError || new ZodError([]),
+      errorMap: params.errorMap || defaultErrorMap,
+      async: params.async ?? false,
+    };
+
+    return this._parseInternal(fullParams);
+  };
+
+  parse: (data: unknown, params?: Partial<ParseParamsNoData>) => Output = (
+    data,
+    params
+  ) => {
+    const result = this._parseInternalOptionalParams({ data, ...params });
+    if (result instanceof Promise)
+      throw new Error(
+        "You can't use .parse() on a schema containing async elements. Use .parseAsync instead."
+      );
+    if (result.success) return result.data;
+    throw result.error;
+  };
+
+  safeParse: (
+    data: unknown,
+    params?: Partial<ParseParamsNoData>
+  ) =>
+    | { success: true; data: Output }
+    | { success: false; error: ZodError<Input> } = (data, params) => {
+    const result = this._parseInternalOptionalParams({ data, ...params });
+    if (result instanceof Promise)
+      throw new Error(
+        "You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead."
+      );
+    return result;
+  };
+
+  parseAsync: (
+    x: unknown,
+    params?: Partial<ParseParamsNoData>
+  ) => Promise<Output> = async (data, params) => {
+    const result = await this._parseInternalOptionalParams({
+      data,
+      ...params,
+      async: true,
+    });
+    if (result.success) return result.data;
+    throw result.error;
+  };
+
+  safeParseAsync: (
+    x: unknown,
+    params?: Partial<ParseParamsNoData>
+  ) => Promise<
+    { success: true; data: Output } | { success: false; error: ZodError }
+  > = async (data, params) => {
+    return await this._parseInternalOptionalParams({
+      data,
+      ...params,
+      async: true,
+    });
+  };
+
+  /** Alias of safeParseAsync */
+  spa = this.safeParseAsync;
+
+  _parseWithInvalidFallback: (
+    data: unknown,
+    params: ParseParamsNoData
+  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
+    const result = this._parseInternal({ ...params, data });
+    // const parser = ZodParser(this);
+    // const result = parser({ ...params, data });
+    if (result instanceof Promise) {
+      return result.then((result) => {
+        if (result.success) return result.data;
+        return INVALID;
+      });
+    }
+    if (result.success) return result.data;
+    return INVALID;
+  };
+
+  /** The .is method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
+  is: never;
+
+  /** The .check method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
+  check: never;
+
+  refine: <Func extends (arg: Output) => any, This extends this = this>(
+    check: Func,
+    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
+  ) => ZodEffectsType<This> = (check, message = "Invalid value.") => {
+    if (typeof message === "string") {
+      return this._refinement((val, ctx) => {
+        const result = check(val);
+        const setError = () =>
+          ctx.addIssue({
+            code: ZodIssueCode.custom,
+            message,
+          });
+        if (result instanceof Promise) {
+          return result.then((data) => {
+            if (!data) setError();
+          });
+        }
+        if (!result) {
+          setError();
+          return result;
+        }
+      });
+    }
+    if (typeof message === "function") {
+      return this._refinement((val, ctx) => {
+        const result = check(val);
+        const setError = () =>
+          ctx.addIssue({
+            code: ZodIssueCode.custom,
+            ...message(val),
+          });
+        if (result instanceof Promise) {
+          return result.then((data) => {
+            if (!data) setError();
+          });
+        }
+        if (!result) {
+          setError();
+          return result;
+        }
+      });
+    }
+    return this._refinement((val, ctx) => {
+      const result = check(val);
+      const setError = () =>
+        ctx.addIssue({
+          code: ZodIssueCode.custom,
+          ...message,
+        });
+      if (result instanceof Promise) {
+        return result.then((data) => {
+          if (!data) setError();
+        });
+      }
+
+      if (!result) {
+        setError();
+        return result;
+      }
+    });
+  };
+
+  refinement: <This extends this = this>(
+    check: (arg: Output) => any,
+    refinementData:
+      | MakeErrorData
+      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
+  ) => ZodEffectsType<This> = (check, refinementData) => {
+    return this._refinement((val, ctx) => {
+      if (!check(val)) {
+        ctx.addIssue(
+          typeof refinementData === "function"
+            ? refinementData(val, ctx)
+            : refinementData
+        );
+      }
+    });
+  };
+
+  // _refinement: (refinement: InternalCheck<Output>["refinement"]) => this = (
+  //   refinement
+  // ) => {
+  //   return new (this as any).constructor({
+  //     ...this._def,
+  //     effects: [
+  //       // ...(this._def.effects || []),
+  //       { type: "check", check: refinement },
+  //     ],
+  //   }) as this;
+  // };
+  _refinement<This extends this>(
+    refinement: InternalCheck<Output>["refinement"]
+  ): ZodEffectsType<This> {
+    let returnType;
+    if (this instanceof ZodEffects) {
+      returnType = new ZodEffects({
+        ...this._def,
+        effects: [
+          ...(this._def.effects || []),
+          { type: "refinement", refinement },
+        ],
+      }) as any;
+    } else {
+      returnType = new ZodEffects({
+        schema: this,
+        effects: [{ type: "refinement", refinement }],
+      }) as any;
+    }
+    return returnType;
+  }
+  superRefine = this._refinement;
+
+  constructor(def: Def) {
+    this._def = def;
+    this.transform = this.transform.bind(this) as any;
+    this.default = this.default.bind(this);
+  }
+
+  optional: <This extends this = this>() => ZodOptionalType<This> = () =>
+    ZodOptional.create(this) as any;
+  nullable: <This extends this = this>() => ZodNullableType<This> = () =>
+    ZodNullable.create(this) as any;
+
+  array: () => ZodArray<this> = () => ZodArray.create(this);
+
+  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
+    return ZodUnion.create([this, option]);
+  }
+
+  transform<NewOut, This extends this>(
+    transform: (arg: Output) => NewOut | Promise<NewOut>
+  ): This extends ZodEffects<infer T, any>
+    ? ZodEffects<T, NewOut>
+    : ZodEffects<This, NewOut> {
+    let returnType;
+    if (this instanceof ZodEffects) {
+      returnType = new ZodEffects({
+        ...this._def,
+        effects: [
+          ...(this._def.effects || []),
+          { type: "transform", transform },
+        ],
+      }) as any;
+    } else {
+      returnType = new ZodEffects({
+        schema: this,
+        effects: [{ type: "transform", transform }],
+      }) as any;
+    }
+    return returnType;
+  }
+
+  default<T extends util.noUndefined<Input>, This extends this = this>(
+    def: T
+  ): addDefaultToOptional<ZodOptionalType<This>>;
+  default<T extends () => Input, This extends this = this>(
+    def: T
+  ): addDefaultToOptional<ZodOptionalType<This>>;
+  default(def: any) {
+    const defaultValueFunc = typeof def === "function" ? def : () => def;
+    if (this instanceof ZodOptional) {
+      return new ZodOptional({
+        ...this._def,
+        defaultValue: defaultValueFunc,
+      }) as any;
+    }
+
+    return new ZodOptional({
+      innerType: this,
+      defaultValue: defaultValueFunc,
+    });
+  }
+
+  isOptional: () => boolean = () => this.safeParse(undefined).success;
+  isNullable: () => boolean = () => this.safeParse(null).success;
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodString      //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export interface ZodStringDef extends ZodTypeDef {
+  // validation: {
+  //   uuid?: true;
+  //   custom?: ((val: any) => boolean)[];
+  // };
+  isEmail: { message?: string } | false;
+  isURL: { message?: string } | false;
+  isUUID: { message?: string } | false;
+  minLength: { value: number; message?: string } | null;
+  maxLength: { value: number; message?: string } | null;
+}
+
+// eslint-disable-next-line
+const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
+const uuidRegex = /([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}){1}/i;
+
+export class ZodString extends ZodType<string, ZodStringDef> {
+  _parse(ctx: ParseContext): ParseReturnType<string> {
+    if (ctx.parsedType !== ZodParsedType.string) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.string,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    if (this._def.isEmail && !emailRegex.test(ctx.data)) {
+      ctx.addIssue({
+        validation: "email",
+        code: ZodIssueCode.invalid_string,
+        message: this._def.isEmail.message,
+      });
+    }
+
+    if (this._def.isURL) {
+      try {
+        new URL(ctx.data);
+      } catch {
+        ctx.addIssue({
+          validation: "url",
+          code: ZodIssueCode.invalid_string,
+          message: this._def.isURL.message,
+        });
+      }
+    }
+
+    if (this._def.isUUID && !uuidRegex.test(ctx.data)) {
+      ctx.addIssue({
+        validation: "email",
+        code: ZodIssueCode.invalid_string,
+        message: this._def.isUUID.message,
+      });
+    }
+
+    if (this._def.minLength !== null) {
+      if (ctx.data.length < this._def.minLength.value) {
+        ctx.addIssue({
+          code: ZodIssueCode.too_small,
+          minimum: this._def.minLength.value,
+          type: "string",
+          inclusive: true,
+          message: this._def.minLength.message,
+          // ...errorUtil.errToObj(this._def.minLength.message),
+        });
+      }
+    }
+
+    if (this._def.maxLength !== null) {
+      if (ctx.data.length > this._def.maxLength.value) {
+        ctx.addIssue({
+          code: ZodIssueCode.too_big,
+          maximum: this._def.maxLength.value,
+          type: "string",
+          inclusive: true,
+          message: this._def.maxLength.message,
+          // ...errorUtil.errToObj(this._def.maxLength.message),
+        });
+      }
+    }
+
+    return ctx.data;
+  }
+
+  protected _regex = (
+    regex: RegExp,
+    validation: StringValidation,
+    message?: errorUtil.ErrMessage
+  ) =>
+    this.refinement((data) => regex.test(data), {
+      validation,
+      code: ZodIssueCode.invalid_string,
+      ...errorUtil.errToObj(message),
+    });
+
+  email = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isEmail: errorUtil.errToObj(message),
+    });
+
+  url = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isURL: errorUtil.errToObj(message),
+    });
+
+  uuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isUUID: errorUtil.errToObj(message),
+    });
+
+  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) =>
+    this._regex(regexp, "regex", message);
+
+  min = (minLength: number, message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      minLength: {
+        value: minLength,
+        message: errorUtil.errToObj(message).message,
+      },
+    });
+
+  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      maxLength: {
+        value: maxLength,
+        message: errorUtil.errToObj(message).message,
+      },
+    });
+
+  length(len: number, message?: errorUtil.ErrMessage) {
+    return this.min(len, message).max(len, message);
+  }
+
+  nonempty = (message?: errorUtil.ErrMessage) =>
+    this.min(1, errorUtil.errToObj(message));
+
+  static create = (): ZodString => {
+    return new ZodString({
+      isEmail: false,
+      isURL: false,
+      isUUID: false,
+      minLength: null,
+      maxLength: null,
+    });
+  };
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodNumber      //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export interface ZodNumberDef extends ZodTypeDef {
+  minimum: null | { value: number; inclusive: boolean; message?: string };
+  maximum: null | { value: number; inclusive: boolean; message?: string };
+  isInteger: false | { message?: string };
+}
+
+export class ZodNumber extends ZodType<number, ZodNumberDef> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.number) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.number,
+        received: ctx.parsedType,
+      });
+
+      return INVALID;
+    }
+    if (Number.isNaN(ctx.data)) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.number,
+        received: ZodParsedType.nan,
+      });
+
+      return INVALID;
+    }
+
+    if (this._def.minimum) {
+      const MIN = this._def.minimum;
+      const tooSmall = MIN.inclusive
+        ? ctx.data < MIN.value
+        : ctx.data <= MIN.value;
+      if (tooSmall) {
+        ctx.addIssue({
+          code: ZodIssueCode.too_small,
+          minimum: MIN.value,
+          type: "number",
+          inclusive: MIN.inclusive,
+          message: MIN.message,
+        });
+      }
+    }
+
+    if (this._def.maximum) {
+      const MAX = this._def.maximum;
+      const tooBig = MAX.inclusive
+        ? ctx.data > MAX.value
+        : ctx.data >= MAX.value;
+      if (tooBig) {
+        ctx.addIssue({
+          code: ZodIssueCode.too_big,
+          maximum: MAX.value,
+          type: "number",
+          inclusive: MAX.inclusive,
+          message: MAX.message,
+        });
+      }
+    }
+
+    if (this._def.isInteger) {
+      if (!Number.isInteger(ctx.data)) {
+        ctx.addIssue({
+          code: ZodIssueCode.invalid_type,
+          expected: "integer",
+          received: "float",
+          message: this._def.isInteger.message,
+        });
+      }
+    }
+
+    return ctx.data as number;
+  }
+
+  static create = (): ZodNumber => {
+    return new ZodNumber({
+      minimum: null,
+      maximum: null,
+      isInteger: false,
+    });
+  };
+
+  min = (minimum: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      minimum: {
+        value: minimum,
+        inclusive: true,
+        message: errorUtil.toString(message),
+      },
+    });
+
+  max = (maximum: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      maximum: {
+        value: maximum,
+        inclusive: true,
+        message: errorUtil.toString(message),
+      },
+    });
+
+  int = (message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      isInteger: { message: errorUtil.toString(message) },
+    });
+
+  positive = (message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      minimum: {
+        value: 0,
+        inclusive: false,
+        message: errorUtil.toString(message),
+      },
+    });
+
+  negative = (message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      maximum: {
+        value: 0,
+        inclusive: false,
+        message: errorUtil.toString(message),
+      },
+    });
+
+  nonpositive = (message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      maximum: {
+        value: 0,
+        inclusive: true,
+        message: errorUtil.toString(message),
+      },
+    });
+
+  nonnegative = (message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      minimum: {
+        value: 0,
+        inclusive: true,
+        message: errorUtil.toString(message),
+      },
+    });
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodBigInt      //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export type ZodBigIntDef = ZodTypeDef;
+
+export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.bigint,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    return ctx.data;
+  }
+
+  static create = (): ZodBigInt => {
+    return new ZodBigInt({});
+  };
+}
+
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////                     ///////////
+//////////      ZodBoolean      //////////
+//////////                     ///////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+export type ZodBooleanDef = ZodTypeDef;
+
+export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.boolean,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    return ctx.data;
+  }
+
+  static create = (): ZodBoolean => {
+    return new ZodBoolean({});
+  };
+}
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                     ////////
+//////////      ZodDate        ////////
+//////////                     ////////
+///////////////////////////////////////
+///////////////////////////////////////
+export type ZodDateDef = ZodTypeDef;
+
+export class ZodDate extends ZodType<Date, ZodDateDef> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.date) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.date,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    if (isNaN(ctx.data.getTime())) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_date,
+      });
+
+      return;
+    }
+
+    return new Date((ctx.data as Date).getTime());
+  }
+
+  static create = (): ZodDate => {
+    return new ZodDate({});
+  };
+}
+
+////////////////////////////////////////////
+////////////////////////////////////////////
+//////////                        //////////
+//////////      ZodUndefined      //////////
+//////////                        //////////
+////////////////////////////////////////////
+////////////////////////////////////////////
+export type ZodUndefinedDef = ZodTypeDef;
+
+export class ZodUndefined extends ZodType<undefined> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.undefined,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    return ctx.data;
+  }
+
+  static create = (): ZodUndefined => {
+    return new ZodUndefined({});
+  };
+}
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodNull      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+export type ZodNullDef = ZodTypeDef;
+
+export class ZodNull extends ZodType<null, ZodNullDef> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.null) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.null,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    return ctx.data;
+  }
+  static create = (): ZodNull => {
+    return new ZodNull({});
+  };
+}
+
+//////////////////////////////////////
+//////////////////////////////////////
+//////////                  //////////
+//////////      ZodAny      //////////
+//////////                  //////////
+//////////////////////////////////////
+//////////////////////////////////////
+export type ZodAnyDef = ZodTypeDef;
+
+export class ZodAny extends ZodType<any, ZodAnyDef> {
+  _parse(ctx: ParseContext): any {
+    return ctx.data;
+  }
+  static create = (): ZodAny => {
+    return new ZodAny({});
+  };
+}
+
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////                      //////////
+//////////      ZodUnknown      //////////
+//////////                      //////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+export type ZodUnknownDef = ZodTypeDef;
+
+export class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
+  _parse(ctx: ParseContext): any {
+    return ctx.data;
+  }
+
+  static create = (): ZodUnknown => {
+    return new ZodUnknown({});
+  };
+}
+
+////////////////////////////////////////
+////////////////////////////////////////
+//////////                    //////////
+//////////      ZodNever      //////////
+//////////                    //////////
+////////////////////////////////////////
+////////////////////////////////////////
+export type ZodNeverDef = ZodTypeDef;
+
+export class ZodNever extends ZodType<never, ZodNeverDef> {
+  _parse(ctx: ParseContext): any {
+    ctx.addIssue({
+      code: ZodIssueCode.invalid_type,
+      expected: ZodParsedType.never,
+      received: ctx.parsedType,
+    });
+    return;
+  }
+  static create = (): ZodNever => {
+    return new ZodNever({});
+  };
+}
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodVoid      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+export type ZodVoidDef = ZodTypeDef;
+
+export class ZodVoid extends ZodType<void, ZodVoidDef> {
+  _parse(ctx: ParseContext): any {
+    if (
+      ctx.parsedType !== ZodParsedType.undefined &&
+      ctx.parsedType !== ZodParsedType.null
+    ) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.void,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    return ctx.data;
+  }
+
+  static create = (): ZodVoid => {
+    return new ZodVoid({});
+  };
+}
+
+////////////////////////////////////////
+////////////////////////////////////////
+//////////                    //////////
+//////////      ZodArray      //////////
+//////////                    //////////
+////////////////////////////////////////
+////////////////////////////////////////
+export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  type: T;
+  minLength: { value: number; message?: string } | null;
+  maxLength: { value: number; message?: string } | null;
+}
+
+const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
+  if (ctx.parsedType !== ZodParsedType.array) {
+    ctx.addIssue({
+      code: ZodIssueCode.invalid_type,
+      expected: ZodParsedType.array,
+      received: ctx.parsedType,
+    });
+
+    return false;
+  }
+
+  if (def.minLength !== null) {
+    if (ctx.data.length < def.minLength.value) {
+      ctx.addIssue({
+        code: ZodIssueCode.too_small,
+        minimum: def.minLength.value,
+        type: "array",
+        inclusive: true,
+        message: def.minLength.message,
+      });
+    }
+  }
+
+  if (def.maxLength !== null) {
+    if (ctx.data.length > def.maxLength.value) {
+      ctx.addIssue({
+        code: ZodIssueCode.too_big,
+        maximum: def.maxLength.value,
+        type: "array",
+        inclusive: true,
+        message: def.maxLength.message,
+      });
+    }
+  }
+
+  return true;
+};
+
+export class ZodArray<T extends ZodTypeAny> extends ZodType<
+  T["_output"][],
+  ZodArrayDef<T>,
+  T["_input"][]
+> {
+  _parse(ctx: ParseContext): any {
+    const result = parseArray(ctx, this._def);
+    if (!result) return;
+
+    return PseudoPromise.all(
+      (ctx.data as any[]).map((item, i) => {
+        return new PseudoPromise().then(() =>
+          this._def.type._parseWithInvalidFallback(item, {
+            ...ctx,
+            path: [...ctx.path, i],
+            parentError: ctx.currentError,
+          })
+        );
+      }) as any
+    );
+  }
+
+  get element() {
+    return this._def.type;
+  }
+
+  min = (minLength: number, message?: errorUtil.ErrMessage): this =>
+    new ZodArray({
+      ...this._def,
+      minLength: { value: minLength, message: errorUtil.toString(message) },
+    }) as any;
+
+  max = (maxLength: number, message?: errorUtil.ErrMessage): this =>
+    new ZodArray({
+      ...this._def,
+      maxLength: { value: maxLength, message: errorUtil.toString(message) },
+    }) as any;
+
+  length = (len: number, message?: errorUtil.ErrMessage): this =>
+    this.min(len, message).max(len, message) as any;
+
+  nonempty: () => ZodNonEmptyArray<T> = () => {
+    return new ZodNonEmptyArray({ ...this._def });
+  };
+
+  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+    return new ZodArray({
+      type: schema,
+      minLength: null,
+      maxLength: null,
+    });
+  };
+}
+
+////////////////////////////////////////////////
+////////////////////////////////////////////////
+//////////                            //////////
+//////////      ZodNonEmptyArray      //////////
+//////////                            //////////
+////////////////////////////////////////////////
+////////////////////////////////////////////////
+export interface ZodNonEmptyArrayDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  type: T;
+  minLength: { value: number; message?: string } | null;
+  maxLength: { value: number; message?: string } | null;
+}
+
+export class ZodNonEmptyArray<T extends ZodTypeAny> extends ZodType<
+  [T["_output"], ...T["_output"][]],
+  ZodNonEmptyArrayDef<T>,
+  [T["_input"], ...T["_input"][]]
+> {
+  _parse(ctx: ParseContext): any {
+    // if (ctx.parsedType !== ZodParsedType.array) {
+    //   ctx.addIssue({
+    //     code: ZodIssueCode.invalid_type,
+    //     expected: ZodParsedType.array,
+    //     received: ctx.parsedType,
+    //   });
+
+    //   return;
+    // }
+
+    const result = parseArray(ctx, this._def);
+    if (!result) return;
+
+    if (ctx.data.length < 1) {
+      ctx.addIssue({
+        code: ZodIssueCode.too_small,
+        minimum: 1,
+        type: "array",
+        inclusive: true,
+        // message: this._def.minLength.message,
+        // ...errorUtil.errToObj(this._def.minLength.message),
+      });
+    }
+
+    return PseudoPromise.all(
+      (ctx.data as any[]).map((item, i) => {
+        return new PseudoPromise().then(() =>
+          this._def.type._parseWithInvalidFallback(item, {
+            ...ctx,
+            path: [...ctx.path, i],
+            parentError: ctx.currentError,
+          })
+        );
+      }) as any
+    );
+  }
+
+  min = (minLength: number, message?: errorUtil.ErrMessage) =>
+    new ZodNonEmptyArray({
+      ...this._def,
+      minLength: { value: minLength, message: errorUtil.toString(message) },
+    });
+
+  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
+    new ZodNonEmptyArray({
+      ...this._def,
+      maxLength: { value: maxLength, message: errorUtil.toString(message) },
+    });
+
+  length = (len: number, message?: errorUtil.ErrMessage) =>
+    this.min(len, message).max(len, message);
+
+  static create = <T extends ZodTypeAny>(schema: T): ZodNonEmptyArray<T> => {
+    return new ZodNonEmptyArray({
+      type: schema,
+      minLength: null,
+      maxLength: null,
+    });
+  };
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodObject      //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export namespace objectUtil {
+  export type extendShape<U extends ZodRawShape, V extends ZodRawShape> = {
+    [k in Exclude<keyof U, keyof V>]: U[k];
+  } &
+    V;
+  export type optionalKeys<T extends object> = {
+    [k in keyof T]: undefined extends T[k] ? k : never;
+  }[keyof T];
+
+  export type requiredKeys<T extends object> = Exclude<
+    keyof T,
+    optionalKeys<T>
+  >;
+
+  export type addQuestionMarks<T extends object> = {
+    [k in optionalKeys<T>]?: T[k];
+  } &
+    { [k in requiredKeys<T>]: T[k] };
+
+  // export type identity<T> = T;
+  // export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
+
+  export type noNeverKeys<T extends ZodRawShape> = {
+    [k in keyof T]: [T[k]] extends [never] ? never : k;
+  }[keyof T];
+
+  export type noNever<T extends ZodRawShape> = util.identity<
+    {
+      [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
+    }
+  >;
+
+  export const mergeShapes = <U extends ZodRawShape, T extends ZodRawShape>(
+    first: U,
+    second: T
+  ): T & U => {
+    // const firstKeys = Object.keys(first);
+    // const secondKeys = Object.keys(second);
+    // const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
+
+    // const sharedShape: any = {};
+    // for (const k of sharedKeys) {
+    //   sharedShape[k] = ZodIntersection.create(first[k], second[k]);
+    // }
+    // return {
+    //   ...(first as object),
+    //   ...(second as object),
+    //   ...sharedShape,
+    // };
+    return {
+      ...first,
+      ...second, // second overwrites first
+    };
+  };
+}
+
+const ExtendFactory = <Def extends ZodObjectDef>(def: Def) => <
+  Augmentation extends ZodRawShape
+>(
+  augmentation: Augmentation
+): ZodObject<
+  {
+    [k in Exclude<
+      keyof ReturnType<Def["shape"]>,
+      keyof Augmentation
+    >]: ReturnType<Def["shape"]>[k];
+  } &
+    { [k in keyof Augmentation]: Augmentation[k] },
+  Def["unknownKeys"],
+  Def["catchall"]
+> => {
+  return new ZodObject({
+    ...def,
+    shape: () => ({
+      ...def.shape(),
+      ...augmentation,
+    }),
+  }) as any;
+};
+
+type UnknownKeysParam = "passthrough" | "strict" | "strip";
+
+export interface ZodObjectDef<
+  T extends ZodRawShape = ZodRawShape,
+  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,
+  Catchall extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  shape: () => T;
+  catchall: Catchall;
+  unknownKeys: UnknownKeys;
+}
+
+export type baseObjectOutputType<Shape extends ZodRawShape> = util.flatten<
+  objectUtil.addQuestionMarks<
+    {
+      [k in keyof Shape]: Shape[k]["_output"];
+    }
+  >
+>;
+
+export type objectOutputType<
+  Shape extends ZodRawShape,
+  Catchall extends ZodTypeAny
+> = ZodTypeAny extends Catchall
+  ? baseObjectOutputType<Shape>
+  : util.flatten<
+      baseObjectOutputType<Shape> & { [k: string]: Catchall["_output"] }
+    >;
+
+export type baseObjectInputType<Shape extends ZodRawShape> = util.flatten<
+  objectUtil.addQuestionMarks<
+    {
+      [k in keyof Shape]: Shape[k]["_input"];
+    }
+  >
+>;
+
+export type objectInputType<
+  Shape extends ZodRawShape,
+  Catchall extends ZodTypeAny
+> = ZodTypeAny extends Catchall
+  ? baseObjectInputType<Shape>
+  : util.flatten<
+      baseObjectInputType<Shape> & { [k: string]: Catchall["_input"] }
+    >;
+
+export class ZodObject<
+  T extends ZodRawShape,
+  UnknownKeys extends UnknownKeysParam = "strip",
+  Catchall extends ZodTypeAny = ZodTypeAny,
+  Output = objectOutputType<T, Catchall>,
+  Input = objectInputType<T, Catchall>
+> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
+  readonly _shape!: T;
+  readonly _unknownKeys!: UnknownKeys;
+  readonly _catchall!: Catchall;
+
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.object) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
+
+    const shape = this._def.shape();
+    const shapeKeys = Object.keys(shape);
+    const dataKeys = Object.keys(ctx.data);
+
+    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+
+    for (const key of shapeKeys) {
+      const keyValidator = shapeKeys.includes(key)
+        ? shape[key]
+        : !(this._def.catchall instanceof ZodNever)
+        ? this._def.catchall
+        : undefined;
+
+      if (!keyValidator) {
+        continue;
+      }
+
+      // if value for key is not set
+      // and schema is optional
+      // don't add the
+      // first check is required to avoid non-enumerable keys
+      if (typeof ctx.data[key] === "undefined" && !dataKeys.includes(key)) {
+        objectPromises[key] = new PseudoPromise()
+          .then(() => {
+            return keyValidator._parseWithInvalidFallback(undefined, {
+              ...ctx,
+              path: [...ctx.path, key],
+              parentError: ctx.currentError,
+            });
+          })
+
+          .then((data) => {
+            if (data === undefined) {
+              // schema is optional
+              // data is not defined
+              // don't explicity add `key: undefined` to outut
+              // this is a feature of PseudoPromises
+              return NOSET;
+            } else {
+              return data;
+            }
+          });
+
+        continue;
+      }
+
+      objectPromises[key] = new PseudoPromise()
+        .then(() => {
+          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
+            ...ctx,
+            path: [...ctx.path, key],
+            parentError: ctx.currentError,
+          });
+        })
+        .then((data) => {
+          return data;
+        });
+    }
+
+    if (this._def.catchall instanceof ZodNever) {
+      const unknownKeys = this._def.unknownKeys;
+
+      if (unknownKeys === "passthrough") {
+        for (const key of extraKeys) {
+          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+        }
+      } else if (unknownKeys === "strict") {
+        if (extraKeys.length > 0) {
+          ctx.addIssue({
+            code: ZodIssueCode.unrecognized_keys,
+            keys: extraKeys,
+          });
+        }
+      } else if (unknownKeys === "strip") {
+      } else {
+        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
+      }
+    } else {
+      // run catchall validation
+      for (const key of extraKeys) {
+        objectPromises[key] = new PseudoPromise().then(() => {
+          const parsedValue = this._def.catchall._parseWithInvalidFallback(
+            ctx.data[key],
+            {
+              ...ctx,
+              path: [...ctx.path, key],
+              parentError: ctx.currentError,
+            }
+          );
+
+          return parsedValue;
+        });
+      }
+    }
+
+    return PseudoPromise.object(objectPromises).then((data) => {
+      return data;
+    });
+  }
+
+  get shape() {
+    return this._def.shape();
+  }
+
+  strict = (): ZodObject<T, "strict", Catchall> =>
+    new ZodObject({
+      ...this._def,
+      unknownKeys: "strict",
+    }) as any;
+
+  strip = (): ZodObject<T, "strip", Catchall> =>
+    new ZodObject({
+      ...this._def,
+      unknownKeys: "strip",
+    }) as any;
+
+  passthrough = (): ZodObject<T, "passthrough", Catchall> =>
+    new ZodObject({
+      ...this._def,
+      unknownKeys: "passthrough",
+    }) as any;
+
+  nonstrict = this.passthrough;
+
+  augment = ExtendFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
+  extend = ExtendFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
+
+  setKey = <Key extends string, Schema extends ZodTypeAny>(
+    key: Key,
+    schema: Schema
+  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> => {
+    return this.augment({ [key]: schema }) as any;
+  };
+
+  /**
+   * Prior to zod@1.0.12 there was a bug in the
+   * inferred type of merged objects. Please
+   * upgrade if you are experiencing issues.
+   */
+  merge: <Incoming extends AnyZodObject>(
+    merging: Incoming
+  ) => ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
+    const mergedShape = objectUtil.mergeShapes(
+      this._def.shape(),
+      merging._def.shape()
+    );
+    const merged: any = new ZodObject({
+      // effects: [], // wipe all refinements
+      unknownKeys: this._def.unknownKeys,
+      catchall: this._def.catchall,
+      shape: () => mergedShape,
+    }) as any;
+    return merged;
+  };
+
+  catchall = <Index extends ZodTypeAny>(
+    index: Index
+  ): ZodObject<T, UnknownKeys, Index> => {
+    return new ZodObject({
+      ...this._def,
+      catchall: index,
+    }) as any;
+  };
+
+  pick = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
+    UnknownKeys,
+    Catchall
+  > => {
+    const shape: any = {};
+    Object.keys(mask).map((key) => {
+      shape[key] = this.shape[key];
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => shape,
+    }) as any;
+  };
+
+  omit = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
+    UnknownKeys,
+    Catchall
+  > => {
+    const shape: any = {};
+    Object.keys(this.shape).map((key) => {
+      if (Object.keys(mask).indexOf(key) === -1) {
+        shape[key] = this.shape[key];
+      }
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => shape,
+    }) as any;
+  };
+
+  partial = (): ZodObject<
+    { [k in keyof T]: ReturnType<T[k]["optional"]> },
+    UnknownKeys,
+    Catchall
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      const fieldSchema = this.shape[key];
+      newShape[key] = fieldSchema.isOptional()
+        ? fieldSchema
+        : fieldSchema.optional();
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
+  deepPartial: () => partialUtil.RootDeepPartial<this> = () => {
+    const newShape: any = {};
+
+    for (const key in this.shape) {
+      const fieldSchema = this.shape[key];
+      if (fieldSchema instanceof ZodObject) {
+        newShape[key] = fieldSchema.isOptional()
+          ? fieldSchema
+          : (fieldSchema.deepPartial() as any).optional();
+      } else {
+        newShape[key] = fieldSchema.isOptional()
+          ? fieldSchema
+          : fieldSchema.optional();
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
+  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+    return new ZodObject({
+      shape: () => shape,
+      unknownKeys: "strip",
+      catchall: ZodNever.create(),
+    }) as any;
+  };
+
+  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+    return new ZodObject({
+      shape,
+      unknownKeys: "strip",
+      catchall: ZodNever.create(),
+    }) as any;
+  };
+}
+
+export type AnyZodObject = ZodObject<any, any, any>;
+
+////////////////////////////////////////
+////////////////////////////////////////
+//////////                    //////////
+//////////      ZodUnion      //////////
+//////////                    //////////
+////////////////////////////////////////
+////////////////////////////////////////
+type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+export interface ZodUnionDef<
+  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+> extends ZodTypeDef {
+  options: T;
+}
+
+// export type toOpts<T> = T extends ZodUnionOptions ? T : never;
+// export type ZodUnionType<
+//   A extends ZodTypeAny,
+//   B extends ZodTypeAny
+// > = A extends ZodUnion<infer AOpts>
+//   ? B extends ZodUnion<infer BOpts>
+//     ? ZodUnion<toOpts<[...AOpts, ...BOpts]>>
+//     : ZodUnion<toOpts<[...AOpts, B]>>
+//   : B extends ZodUnion<infer BOpts>
+//   ? ZodUnion<toOpts<[A, ...BOpts]>>
+//   : ZodUnion<toOpts<[A, B]>>;
+
+export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
+  T[number]["_output"],
+  ZodUnionDef<T>,
+  T[number]["_input"]
+> {
+  _parse(ctx: ParseContext): any {
+    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
+      () => new ZodError([])
+    );
+
+    return PseudoPromise.all(
+      this._def.options.map((opt, _j) => {
+        return new PseudoPromise().then(() => {
+          return opt._parseWithInvalidFallback(ctx.data, {
+            ...ctx,
+            parentError: unionErrors[_j],
+          });
+        });
+      }) as any
+    )
+      .then((unionResults) => {
+        const isValid = !!unionErrors.find((err) => err.isEmpty);
+        const GUESSING = false;
+
+        if (!isValid) {
+          if (!GUESSING) {
+            ctx.addIssue({
+              code: ZodIssueCode.invalid_union,
+              unionErrors,
+            });
+          } else {
+            const nonTypeErrors = unionErrors.filter((err) => {
+              return err.issues[0].code !== "invalid_type";
+            });
+            if (nonTypeErrors.length === 1) {
+              ctx.currentError.addIssues(nonTypeErrors[0].issues);
+            } else {
+              ctx.addIssue({
+                code: ZodIssueCode.invalid_union,
+                unionErrors,
+              });
+            }
+          }
+        }
+
+        return unionResults;
+      })
+      .then((unionResults: any) => {
+        const validIndex = unionErrors.indexOf(
+          unionErrors.find((err) => err.isEmpty)!
+        );
+        return unionResults[validIndex];
+      });
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+    types: T
+  ): ZodUnion<T> => {
+    return new ZodUnion({
+      options: types,
+    });
+  };
+}
+
+////////////////////////////////////////
+////////////////////////////////////////
+//////////                    //////////
+//////////      ZodTuple      //////////
+//////////                    //////////
+////////////////////////////////////////
+////////////////////////////////////////
+export type OutputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
+};
+
+export type InputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
+};
+
+export interface ZodTupleDef<
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
+> extends ZodTypeDef {
+  items: T;
+}
+
+export class ZodTuple<
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
+> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.array) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    if (ctx.data.length > this._def.items.length) {
+      ctx.addIssue({
+        code: ZodIssueCode.too_big,
+        maximum: this._def.items.length,
+        inclusive: true,
+        type: "array",
+      });
+    } else if (ctx.data.length < this._def.items.length) {
+      ctx.addIssue({
+        code: ZodIssueCode.too_small,
+        minimum: this._def.items.length,
+        inclusive: true,
+        type: "array",
+      });
+    }
+
+    const tupleData: any[] = ctx.data;
+
+    return PseudoPromise.all(
+      tupleData.map((item, index) => {
+        const itemParser = this._def.items[index];
+        return new PseudoPromise()
+          .then(() => {
+            return itemParser._parseWithInvalidFallback(item, {
+              ...ctx,
+              path: [...ctx.path, index],
+              parentError: ctx.currentError,
+            });
+          })
+          .then((tupleItem) => {
+            return tupleItem;
+          });
+      }) as any
+    );
+  }
+
+  get items() {
+    return this._def.items;
+  }
+
+  static create = <T extends [ZodTypeAny, ...ZodTypeAny[]] | []>(
+    schemas: T
+  ): ZodTuple<T> => {
+    return new ZodTuple({
+      items: schemas,
+    });
+  };
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodRecord      //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  valueType: Value;
+}
+
+export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
+  Record<string, Value["_output"]>,
+  ZodRecordDef<Value>,
+  Record<string, Value["_input"]>
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.object) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
+    for (const key in ctx.data) {
+      parsedRecordPromises[key] = new PseudoPromise().then(() => {
+        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
+          ...ctx,
+          path: [...ctx.path, key],
+          parentError: ctx.currentError,
+        });
+      });
+    }
+    return PseudoPromise.object(parsedRecordPromises);
+  }
+
+  static create = <Value extends ZodTypeAny = ZodTypeAny>(
+    valueType: Value
+  ): ZodRecord<Value> => {
+    return new ZodRecord({
+      valueType,
+    });
+  };
+}
+
+//////////////////////////////////////
+//////////////////////////////////////
+//////////                  //////////
+//////////      ZodMap      //////////
+//////////                  //////////
+//////////////////////////////////////
+//////////////////////////////////////
+export interface ZodMapDef<
+  Key extends ZodTypeAny = ZodTypeAny,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  valueType: Value;
+  keyType: Key;
+}
+
+export class ZodMap<
+  Key extends ZodTypeAny = ZodTypeAny,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Map<Key["_output"], Value["_output"]>,
+  ZodMapDef<Key, Value>,
+  Map<Key["_input"], Value["_input"]>
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.map) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.map,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const dataMap: Map<unknown, unknown> = ctx.data;
+    const returnedMap = new Map();
+
+    return PseudoPromise.all(
+      [...dataMap.entries()].map(([key, value], index) => {
+        return PseudoPromise.all([
+          new PseudoPromise().then(() => {
+            return this._def.keyType._parseWithInvalidFallback(key, {
+              ...ctx,
+              path: [...ctx.path, index, "key"],
+              parentError: ctx.currentError,
+            });
+          }),
+          new PseudoPromise().then(() => {
+            const mapValue = this._def.valueType._parseWithInvalidFallback(
+              value,
+              {
+                ...ctx,
+                path: [...ctx.path, index, "value"],
+                parentError: ctx.currentError,
+              }
+            );
+
+            return mapValue;
+          }),
+        ]).then((item: any) => {
+          returnedMap.set(item[0], item[1]);
+        });
+      }) as any
+    ).then(() => {
+      return returnedMap;
+    });
+  }
+  static create = <
+    Key extends ZodTypeAny = ZodTypeAny,
+    Value extends ZodTypeAny = ZodTypeAny
+  >(
+    keyType: Key,
+    valueType: Value
+  ): ZodMap<Key, Value> => {
+    return new ZodMap({
+      valueType,
+      keyType,
+    });
+  };
+}
+
+//////////////////////////////////////
+//////////////////////////////////////
+//////////                  //////////
+//////////      ZodSet      //////////
+//////////                  //////////
+//////////////////////////////////////
+//////////////////////////////////////
+export interface ZodSetDef<Value extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  valueType: Value;
+}
+
+export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
+  Set<Value["_output"]>,
+  ZodSetDef<Value>,
+  Set<Value["_input"]>
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.set) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.set,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const dataSet: Set<unknown> = ctx.data;
+    const returnedSet = new Set();
+
+    return PseudoPromise.all(
+      [...dataSet.values()].map((item, i) => {
+        return new PseudoPromise()
+          .then(() =>
+            this._def.valueType._parseWithInvalidFallback(item, {
+              ...ctx,
+              path: [...ctx.path, i],
+              parentError: ctx.currentError,
+            })
+          )
+          .then((item) => {
+            returnedSet.add(item);
+          });
+      }) as any
+    ).then(() => {
+      return returnedSet;
+    });
+  }
+
+  static create = <Value extends ZodTypeAny = ZodTypeAny>(
+    valueType: Value
+  ): ZodSet<Value> => {
+    return new ZodSet({
+      valueType,
+    });
+  };
+}
+
+///////////////////////////////////////////
+///////////////////////////////////////////
+//////////                       //////////
+//////////      ZodFunction      //////////
+//////////                       //////////
+///////////////////////////////////////////
+///////////////////////////////////////////
+export interface ZodFunctionDef<
+  Args extends ZodTuple<any> = ZodTuple<any>,
+  Returns extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  args: Args;
+  returns: Returns;
+}
+
+export type OuterTypeOfFunction<
+  Args extends ZodTuple<any>,
+  Returns extends ZodTypeAny
+> = Args["_input"] extends Array<any>
+  ? (...args: Args["_input"]) => Returns["_output"]
+  : never;
+
+export type InnerTypeOfFunction<
+  Args extends ZodTuple<any>,
+  Returns extends ZodTypeAny
+> = Args["_output"] extends Array<any>
+  ? (...args: Args["_output"]) => Returns["_input"]
+  : never;
+
+export class ZodFunction<
+  Args extends ZodTuple<any>,
+  Returns extends ZodTypeAny
+> extends ZodType<
+  OuterTypeOfFunction<Args, Returns>,
+  ZodFunctionDef<Args, Returns>,
+  InnerTypeOfFunction<Args, Returns>
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.function) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.function,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const isAsyncFunction = this._def.returns instanceof ZodPromise;
+
+    const validatedFunction = (...args: any[]) => {
+      const argsError = new ZodError([]);
+      const returnsError = new ZodError([]);
+      const internalProm = new PseudoPromise()
+        .then(() => {
+          return this._def.args._parseWithInvalidFallback(args as any, {
+            ...ctx,
+            parentError: argsError,
+            async: isAsyncFunction,
+          });
+        })
+        .then((args) => {
+          if (!argsError.isEmpty) {
+            const newError = new ZodError([]);
+            const issue = ctx.makeIssue({
+              code: ZodIssueCode.invalid_arguments,
+              argumentsError: argsError,
+            });
+            newError.addIssue(issue);
+            throw newError;
+          }
+
+          return args;
+        })
+        .then((args) => {
+          return ctx.data(...(args as any));
+        })
+        .then((result) => {
+          return this._def.returns._parseWithInvalidFallback(result, {
+            ...ctx,
+            parentError: returnsError,
+            async: isAsyncFunction,
+          });
+        })
+        .then((result) => {
+          if (!returnsError.isEmpty) {
+            const newError = new ZodError([]);
+            const issue = ctx.makeIssue({
+              code: ZodIssueCode.invalid_return_type,
+              returnTypeError: returnsError,
+            });
+            newError.addIssue(issue);
+            throw newError;
+          }
+          return result;
+        });
+
+      if (isAsyncFunction) {
+        return internalProm.getValueAsync();
+      } else {
+        return internalProm.getValueSync();
+      }
+    };
+    return validatedFunction;
+  }
+
+  args = <Items extends Parameters<typeof ZodTuple["create"]>[0]>(
+    ...items: Items
+  ): ZodFunction<ZodTuple<Items>, Returns> => {
+    return new ZodFunction({
+      ...this._def,
+      args: ZodTuple.create(items),
+    });
+  };
+
+  returns = <NewReturnType extends ZodType<any, any>>(
+    returnType: NewReturnType
+  ): ZodFunction<Args, NewReturnType> => {
+    return new ZodFunction({
+      ...this._def,
+      returns: returnType,
+    });
+  };
+
+  implement = <F extends InnerTypeOfFunction<Args, Returns>>(func: F): F => {
+    const validatedFunc = this.parse(func);
+    return validatedFunc as any;
+  };
+
+  validate = this.implement;
+
+  static create = <
+    T extends ZodTuple<any> = ZodTuple<[]>,
+    U extends ZodTypeAny = ZodUnknown
+  >(
+    args?: T,
+    returns?: U
+  ): ZodFunction<T, U> => {
+    return new ZodFunction({
+      args: args || ZodTuple.create([]),
+      returns: returns || ZodUnknown.create(),
+    }) as any;
+  };
+}
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodLazy      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+export interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  getter: () => T;
+}
+
+export class ZodLazy<T extends ZodTypeAny> extends ZodType<
+  output<T>,
+  ZodLazyDef<T>,
+  input<T>
+> {
+  get schema(): T {
+    return this._def.getter();
+  }
+
+  _parse(ctx: ParseContext): any {
+    const lazySchema = this._def.getter();
+    return PseudoPromise.resolve(
+      lazySchema._parseWithInvalidFallback(ctx.data, {
+        ...ctx,
+        parentError: ctx.currentError,
+      })
+    );
+  }
+
+  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+    return new ZodLazy({
+      getter: getter,
+    });
+  };
+}
+
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////                      //////////
+//////////      ZodLiteral      //////////
+//////////                      //////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+export interface ZodLiteralDef<T extends any = any> extends ZodTypeDef {
+  value: T;
+}
+
+export class ZodLiteral<T extends any> extends ZodType<T, ZodLiteralDef<T>> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.data !== this._def.value) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: this._def.value as any,
+        received: ctx.data,
+      });
+      return;
+    }
+    return ctx.data;
+  }
+
+  static create = <T extends util.Primitive>(value: T): ZodLiteral<T> => {
+    return new ZodLiteral({
+      value: value,
+    });
+  };
+}
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodEnum      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+export type ArrayKeys = keyof any[];
+export type Indices<T> = Exclude<keyof T, ArrayKeys>;
+
+type EnumValues = [string, ...string[]];
+
+type Values<T extends EnumValues> = {
+  [k in T[number]]: k;
+};
+
+export interface ZodEnumDef<T extends EnumValues = EnumValues>
+  extends ZodTypeDef {
+  values: T;
+}
+
+export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
+  T[number],
+  ZodEnumDef<T>
+> {
+  _parse(ctx: ParseContext): any {
+    if (this._def.values.indexOf(ctx.data) === -1) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_enum_value,
+        options: this._def.values,
+      });
+      return;
+    }
+    return ctx.data;
+  }
+
+  get options() {
+    return this._def.values;
+  }
+
+  get enum(): Values<T> {
+    const enumValues: any = {};
+    for (const val of this._def.values) {
+      enumValues[val] = val;
+    }
+    return enumValues as any;
+  }
+
+  get Values(): Values<T> {
+    const enumValues: any = {};
+    for (const val of this._def.values) {
+      enumValues[val] = val;
+    }
+    return enumValues as any;
+  }
+
+  get Enum(): Values<T> {
+    const enumValues: any = {};
+    for (const val of this._def.values) {
+      enumValues[val] = val;
+    }
+    return enumValues as any;
+  }
+
+  static create = <U extends string, T extends [U, ...U[]]>(
+    values: T
+  ): ZodEnum<T> => {
+    return new ZodEnum({
+      values: values,
+    }) as any;
+  };
+}
+
+/////////////////////////////////////////////
+/////////////////////////////////////////////
+//////////                         //////////
+//////////      ZodNativeEnum      //////////
+//////////                         //////////
+/////////////////////////////////////////////
+/////////////////////////////////////////////
+export interface ZodNativeEnumDef<T extends EnumLike = EnumLike>
+  extends ZodTypeDef {
+  values: T;
+}
+
+type EnumLike = { [k: string]: string | number; [nu: number]: string };
+
+export class ZodNativeEnum<T extends EnumLike> extends ZodType<
+  T[keyof T],
+  ZodNativeEnumDef<T>
+> {
+  _parse(ctx: ParseContext): any {
+    const nativeEnumValues = util.getValidEnumValues(this._def.values);
+    if (nativeEnumValues.indexOf(ctx.data) === -1) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_enum_value,
+        options: util.objectValues(nativeEnumValues),
+      });
+      return;
+    }
+    return ctx.data;
+  }
+  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+    return new ZodNativeEnum({
+      values: values,
+    });
+  };
+}
+
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////                      //////////
+//////////      ZodPromise      //////////
+//////////                      //////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+export interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  type: T;
+}
+
+export class ZodPromise<T extends ZodTypeAny> extends ZodType<
+  Promise<T["_output"]>,
+  ZodPromiseDef<T>,
+  Promise<T["_input"]>
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.promise,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const promisified =
+      ctx.parsedType === ZodParsedType.promise
+        ? ctx.data
+        : Promise.resolve(ctx.data);
+    const promiseError = new ZodError([]);
+    return PseudoPromise.resolve(
+      promisified
+        .then((data: any) => {
+          const value = this._def.type._parseWithInvalidFallback(data, {
+            ...ctx,
+            parentError: promiseError,
+          });
+          return value;
+        })
+        .then((data: any) => {
+          if (!promiseError.isEmpty) {
+            throw promiseError;
+          }
+          return data;
+        })
+    );
+  }
+
+  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+    return new ZodPromise({
+      type: schema,
+    });
+  };
+}
+
+//////////////////////////////////////////////
+//////////////////////////////////////////////
+//////////                          //////////
+//////////      ZodEffects      //////////
+//////////                          //////////
+//////////////////////////////////////////////
+//////////////////////////////////////////////
+export type InternalCheck<T> = {
+  type: "refinement";
+  refinement: (arg: T, ctx: RefinementCtx) => any;
+};
+export type Mod<T> = {
+  type: "transform";
+  transform: (arg: T) => any;
+};
+export type Effect<T> = InternalCheck<T> | Mod<T>;
+
+export interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  schema: T;
+  effects?: Effect<any>[];
+}
+
+export class ZodEffects<
+  T extends ZodTypeAny,
+  Output = T["_type"]
+> extends ZodType<Output, ZodEffectsDef<T>, T["_input"]> {
+  _parse(ctx: ParseContext): any {
+    const isSync = ctx.async === false || this instanceof ZodPromise;
+    const effects = this._def.effects || [];
+    const checkCtx: RefinementCtx = {
+      addIssue: (arg: MakeErrorData) => {
+        ctx.addIssue(arg);
+      },
+      path: ctx.path,
+    };
+
+    // let refinementError: Error | null = null;
+
+    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
+      key;
+      if (!ctx.currentError.isEmpty) throw ctx.currentError;
+      // if (ctx.data === INVALID) throw ctx.currentError;
+      // if (refinementError !== null) throw refinementError;
+      return data;
+    };
+
+    let finalPromise = new PseudoPromise()
+      .then(() => {
+        return this._def.schema._parseWithInvalidFallback(ctx.data, {
+          ...ctx,
+          parentError: ctx.currentError,
+        });
+      })
+      .then(THROW_ERROR_IF_PRESENT("pre-refinement"));
+
+    for (const effect of effects) {
+      if (effect.type === "refinement") {
+        finalPromise = finalPromise
+          .all((data) => {
+            return [
+              PseudoPromise.resolve(data),
+              PseudoPromise.resolve(data).then(() => {
+                const result = effect.refinement(data, checkCtx);
+                // try {
+                //   result = effect.refinement(data, checkCtx);
+                // } catch (err) {
+                //   throw err;
+                //   // if (refinementError === null) refinementError = err;
+                // }
+
+                if (isSync && result instanceof Promise)
+                  throw new Error(
+                    "You can't use .parse() on a schema containing async refinements. Use .parseAsync instead."
+                  );
+                return result;
+              }),
+            ];
+          })
+          .then(([data, _]) => {
+            return data;
+          });
+      } else if (effect.type === "transform") {
+        finalPromise = finalPromise
+          .then(THROW_ERROR_IF_PRESENT("before transform"))
+          .then((data) => {
+            if (!(this instanceof ZodEffects))
+              throw new Error(
+                "Only transformers can contain transformation functions."
+              );
+            const newData = effect.transform(data);
+
+            return newData;
+          })
+          .then((data) => {
+            if (isSync && data instanceof Promise) {
+              throw new Error(
+                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              );
+            }
+            return data;
+          });
+      } else {
+        throw new Error(`Invalid effect type.`);
+      }
+    }
+
+    return finalPromise;
+  }
+
+  constructor(def: ZodEffectsDef<T>) {
+    super(def);
+    if (def.schema instanceof ZodEffects) {
+      throw new Error("ZodEffectss cannot be nested.");
+    }
+  }
+
+  static create = <I extends ZodTypeAny>(
+    schema: I
+  ): ZodEffects<I, I["_output"]> => {
+    const newTx = new ZodEffects({
+      schema,
+    });
+
+    return newTx;
+  };
+}
+
+export { ZodEffects as ZodTransformer };
+
+///////////////////////////////////////////
+///////////////////////////////////////////
+//////////                       //////////
+//////////      ZodOptional      //////////
+//////////                       //////////
+///////////////////////////////////////////
+///////////////////////////////////////////
+export interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  innerType: T;
+  defaultValue: undefined | (() => T["_input"]);
+}
+
+export type addDefaultToOptional<
+  T extends ZodOptional<any, any>
+> = T extends ZodOptional<infer U, any> ? ZodOptional<U, true> : never;
+export type removeDefaultFromOptional<
+  T extends ZodOptional<any, any>
+> = T extends ZodOptional<infer U, any> ? ZodOptional<U, false> : never;
+
+export type ZodOptionalType<T extends ZodTypeAny> = T extends ZodOptional<
+  infer U,
+  infer H
+>
+  ? ZodOptional<U, H>
+  : ZodOptional<T, false>; // no default by default
+
+export class ZodOptional<
+  T extends ZodTypeAny,
+  HasDefault extends boolean = false
+> extends ZodType<
+  HasDefault extends true ? T["_output"] : T["_output"] | undefined,
+  ZodOptionalDef<T>,
+  T["_input"] | undefined
+> {
+  _parse(ctx: ParseContext): any {
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
+      if (this._def.defaultValue !== undefined) {
+        data = this._def.defaultValue();
+      } else {
+        return undefined;
+      }
+    }
+
+    return new PseudoPromise().then(() => {
+      return this._def.innerType._parseWithInvalidFallback(data, {
+        ...ctx,
+        parentError: ctx.currentError,
+      });
+    });
+  }
+
+  unwrap() {
+    return this._def.innerType;
+  }
+
+  removeDefault(): ZodOptional<T, false> {
+    return new ZodOptional({
+      ...this._def,
+      defaultValue: undefined,
+    });
+  }
+
+  static create = <T extends ZodTypeAny>(type: T): ZodOptionalType<T> => {
+    if (type instanceof ZodOptional) return type as any;
+    return new ZodOptional({
+      innerType: type,
+      defaultValue: undefined,
+    }) as any;
+  };
+}
+
+///////////////////////////////////////////
+///////////////////////////////////////////
+//////////                       //////////
+//////////      ZodNullable      //////////
+//////////                       //////////
+///////////////////////////////////////////
+///////////////////////////////////////////
+export interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  innerType: T;
+}
+
+// This type allows for nullable flattening
+export type ZodNullableType<T extends ZodTypeAny> = T extends ZodNullable<
+  infer U
+>
+  ? ZodNullable<U>
+  : ZodNullable<T>;
+
+export class ZodNullable<T extends ZodTypeAny> extends ZodType<
+  T["_output"] | null,
+  ZodNullableDef<T>,
+  T["_input"] | null
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType === ZodParsedType.null) {
+      return null;
+    }
+
+    return new PseudoPromise().then(() => {
+      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
+        ...ctx,
+        parentError: ctx.currentError,
+      });
+    });
+  }
+
+  unwrap() {
+    return this._def.innerType;
+  }
+
+  static create = <T extends ZodTypeAny>(type: T): ZodNullableType<T> => {
+    // An nullable nullable is the original nullable
+    if (type instanceof ZodNullable) return type as any;
+    return new ZodNullable({
+      innerType: type,
+    }) as any;
+  };
+}
+
+export const custom = <T>(
+  check?: (data: unknown) => any,
+  params?: Parameters<ZodTypeAny["refine"]>[1]
+): ZodType<T> => {
+  if (check) return ZodAny.create().refine(check, params);
+  return ZodAny.create();
+};
+
+export { ZodType as Schema, ZodType as ZodSchema };
+
+export const late = {
+  object: ZodObject.lazycreate,
+};
+
+export type ZodFirstPartySchemaTypes =
+  | ZodString
+  | ZodNumber
+  | ZodBigInt
+  | ZodBoolean
+  | ZodDate
+  | ZodUndefined
+  | ZodNull
+  | ZodAny
+  | ZodUnknown
+  | ZodNever
+  | ZodVoid
+  | ZodArray<any>
+  | ZodObject<any>
+  | ZodUnion<any>
+  | ZodTuple
+  | ZodRecord
+  | ZodMap
+  | ZodSet
+  | ZodFunction<any, any>
+  | ZodLazy<any>
+  | ZodLiteral<any>
+  | ZodEnum<any>
+  | ZodEffects<any>
+  | ZodNativeEnum<any>
+  | ZodOptional<any>
+  | ZodNullable<any>
+  | ZodPromise<any>;
+
+const instanceOfType = <T extends new (...args: any[]) => any>(
+  cls: T,
+  params: Parameters<ZodTypeAny["refine"]>[1] = {
+    message: `Input not instance of ${cls.name}`,
+  }
+) => custom<InstanceType<T>>((data) => data instanceof cls, params);
+
+const stringType = ZodString.create;
+const numberType = ZodNumber.create;
+const bigIntType = ZodBigInt.create;
+const booleanType = ZodBoolean.create;
+const dateType = ZodDate.create;
+const undefinedType = ZodUndefined.create;
+const nullType = ZodNull.create;
+const anyType = ZodAny.create;
+const unknownType = ZodUnknown.create;
+const neverType = ZodNever.create;
+const voidType = ZodVoid.create;
+const arrayType = ZodArray.create;
+const objectType = ZodObject.create;
+const unionType = ZodUnion.create;
+const tupleType = ZodTuple.create;
+const recordType = ZodRecord.create;
+const mapType = ZodMap.create;
+const setType = ZodSet.create;
+const functionType = ZodFunction.create;
+const lazyType = ZodLazy.create;
+const literalType = ZodLiteral.create;
+const enumType = ZodEnum.create;
+const nativeEnumType = ZodNativeEnum.create;
+const promiseType = ZodPromise.create;
+const effectsType = ZodEffects.create;
+const optionalType = ZodOptional.create;
+const nullableType = ZodNullable.create;
+const ostring = () => stringType().optional();
+const onumber = () => numberType().optional();
+const oboolean = () => booleanType().optional();
+
+export {
+  anyType as any,
+  arrayType as array,
+  bigIntType as bigint,
+  booleanType as boolean,
+  dateType as date,
+  effectsType as effect,
+  enumType as enum,
+  functionType as function,
+  instanceOfType as instanceof,
+  lazyType as lazy,
+  literalType as literal,
+  mapType as map,
+  nativeEnumType as nativeEnum,
+  neverType as never,
+  nullType as null,
+  nullableType as nullable,
+  numberType as number,
+  objectType as object,
+  oboolean,
+  onumber,
+  optionalType as optional,
+  ostring,
+  promiseType as promise,
+  recordType as record,
+  setType as set,
+  stringType as string,
+  effectsType as transformer,
+  tupleType as tuple,
+  undefinedType as undefined,
+  unionType as union,
+  unknownType as unknown,
+  voidType as void,
+};
diff --git a/deno/lib/types/any.ts b/deno/lib/types/any.ts
deleted file mode 100644
index d620cb8e4..000000000
--- a/deno/lib/types/any.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodAnyDef extends ZodTypeDef {
-  t: ZodTypes.any;
-}
-
-export class ZodAny extends ZodType<any, ZodAnyDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-  toJSON = () => this._def;
-
-  static create = (): ZodAny => {
-    return new ZodAny({
-      t: ZodTypes.any,
-    });
-  };
-}
diff --git a/deno/lib/types/array.ts b/deno/lib/types/array.ts
deleted file mode 100644
index bf0565d32..000000000
--- a/deno/lib/types/array.ts
+++ /dev/null
@@ -1,109 +0,0 @@
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-import { ZodIssueCode } from "../ZodError.ts";
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.array;
-  type: T;
-  nonempty: boolean;
-}
-
-export class ZodArray<T extends ZodTypeAny> extends ZodType<
-  T["_output"][],
-  ZodArrayDef<T>,
-  T["_input"][]
-> {
-  toJSON = () => {
-    return {
-      t: this._def.t,
-      nonempty: this._def.nonempty,
-      type: this._def.type.toJSON(),
-    };
-  };
-
-  get element() {
-    return this._def.type;
-  }
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  min = (minLength: number, message?: string | { message?: string }) =>
-    this.refinement((data) => data.length >= minLength, {
-      code: ZodIssueCode.too_small,
-      type: "array",
-      inclusive: true,
-      minimum: minLength,
-      ...(typeof message === "string" ? { message } : message),
-    });
-
-  max = (maxLength: number, message?: string | { message?: string }) =>
-    this.refinement((data) => data.length <= maxLength, {
-      // check: data => data.length <= maxLength,
-      code: ZodIssueCode.too_big,
-      type: "array",
-      inclusive: true,
-      maximum: maxLength,
-      ...(typeof message === "string" ? { message } : message),
-    });
-
-  length = (len: number, message?: string) =>
-    this.min(len, { message }).max(len, { message });
-
-  nonempty: () => ZodNonEmptyArray<T> = () => {
-    return new ZodNonEmptyArray({ ...this._def, nonempty: true });
-  };
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
-    return new ZodArray({
-      t: ZodTypes.array,
-      type: schema,
-      nonempty: false,
-    });
-  };
-}
-
-export class ZodNonEmptyArray<T extends ZodTypeAny> extends ZodType<
-  [T["_output"], ...T["_output"][]],
-  ZodArrayDef<T>,
-  [T["_input"], ...T["_input"][]]
-> {
-  toJSON = () => {
-    return {
-      t: this._def.t,
-      type: this._def.type.toJSON(),
-    };
-  };
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  min = (minLength: number, message?: string | { message?: string }) =>
-    this.refinement((data) => data.length >= minLength, {
-      // check: data => data.length >= minLength,
-      code: ZodIssueCode.too_small,
-      minimum: minLength,
-      type: "array",
-      inclusive: true,
-      ...(typeof message === "string" ? { message } : message),
-    });
-
-  max = (maxLength: number, message?: string | { message?: string }) =>
-    this.refinement((data) => data.length <= maxLength, {
-      // check:
-      code: ZodIssueCode.too_big,
-      maximum: maxLength,
-      type: "array",
-      inclusive: true,
-      ...(typeof message === "string" ? { message } : message),
-    });
-
-  length = (len: number, message?: string) =>
-    this.min(len, { message }).max(len, { message });
-}
diff --git a/deno/lib/types/base.ts b/deno/lib/types/base.ts
deleted file mode 100644
index 22bceb5eb..000000000
--- a/deno/lib/types/base.ts
+++ /dev/null
@@ -1,400 +0,0 @@
-import { util } from "../helpers/util.ts";
-import { ZodTypes } from "../ZodTypes.ts";
-import { ParseParams, ZodParser } from "../parser.ts";
-import {
-  ZodCustomIssue,
-  ZodError,
-  ZodIssueCode,
-  MakeErrorData,
-} from "../ZodError.ts";
-
-import {
-  ZodArray,
-  ZodNullable,
-  ZodNullableType,
-  ZodOptional,
-  ZodOptionalType,
-  ZodTransformer,
-} from "../index.ts";
-// import { outputSchema } from "../output-schema";
-
-type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
-type InternalCheck<T> = {
-  type: "check";
-  check: (arg: T, ctx: RefinementCtx) => any;
-  // refinementError: (arg: T) => MakeErrorData;
-};
-
-type Mod<T> = {
-  type: "mod";
-  mod: (arg: T) => any;
-  // refinementError: (arg: T) => MakeErrorData;
-};
-
-type Effect<T> = InternalCheck<T> | Mod<T>;
-
-// type Check<T> = {
-//   check: (arg: T) => any;
-//   path?: (string | number)[];
-//   // message?: string;
-//   // params?: {[k:string]:any}
-// } & util.Omit<CustomError, 'code' | 'path'>;
-
-// type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
-// type Check<T> = {
-//   check: (arg: T) => any;
-//   refinementError: (arg: T) => CustomErrorParams;
-// };
-// export function declareZodType() {}
-
-export interface ZodTypeDef {
-  t: ZodTypes;
-  effects?: Effect<any>[];
-  // mods?: Mod<any>[];
-  accepts?: ZodType<any, any>;
-}
-
-export abstract class ZodType<
-  Output,
-  Def extends ZodTypeDef = ZodTypeDef,
-  Input = Output
-> {
-  readonly _type!: Output;
-  readonly _output!: Output;
-  readonly _input!: Input;
-  readonly _def!: Def;
-
-  // get inputSchema(): ZodTypeAny = this;
-  // outputSchema: ZodTypeAny = this;
-  //  = ()=>{
-  //   return this;
-  // }
-  //  outputSchema = () => {
-  //    return this;
-  //  };
-
-  parse: (x: unknown, params?: ParseParams) => Output = ZodParser(this);
-
-  safeParse: (
-    x: unknown,
-    params?: ParseParams
-  ) => { success: true; data: Output } | { success: false; error: ZodError } = (
-    data,
-    params
-  ) => {
-    try {
-      const parsed = this.parse(data, params);
-      return { success: true, data: parsed };
-    } catch (err) {
-      if (err instanceof ZodError) {
-        return { success: false, error: err };
-      }
-      throw err;
-    }
-  };
-
-  parseAsync: (x: unknown, params?: ParseParams) => Promise<Output> = async (
-    value,
-    params
-  ) => {
-    return await this.parse(value, { ...params, async: true });
-  };
-
-  safeParseAsync: (
-    x: unknown,
-    params?: ParseParams
-  ) => Promise<
-    { success: true; data: Output } | { success: false; error: ZodError }
-  > = async (data, params) => {
-    try {
-      const parsed = await this.parseAsync(data, params);
-      return { success: true, data: parsed };
-    } catch (err) {
-      if (err instanceof ZodError) {
-        return { success: false, error: err };
-      }
-      throw err;
-    }
-  };
-
-  spa = this.safeParseAsync;
-
-  // is(u: Input): u is Input {
-  //   try {
-  //     this.parse(u as any);
-  //     return true;
-  //   } catch (err) {
-  //     return false;
-  //   }
-  // }
-
-  // check(u: unknown): u is Input {
-  //   try {
-  //     this.parse(u as any);
-  //     return true;
-  //   } catch (err) {
-  //     return false;
-  //   }
-  // }
-  /** The .is method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
-  is: never;
-
-  /** The .check method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
-  check: never;
-
-  refine = <Func extends (arg: Output) => any>(
-    check: Func,
-    message:
-      | string
-      | CustomErrorParams
-      | ((arg: Output) => CustomErrorParams) = "Invalid value."
-  ) => {
-    if (typeof message === "string") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === "function") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    return this._refinement((val, ctx) => {
-      const result = check(val);
-      const setError = () =>
-        ctx.addIssue({
-          code: ZodIssueCode.custom,
-          ...message,
-        });
-      if (result instanceof Promise) {
-        return result.then((data) => {
-          if (!data) setError();
-        });
-      }
-
-      if (!result) {
-        setError();
-        return result;
-      }
-    });
-  };
-
-  refinement = (
-    check: (arg: Output) => any,
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => {
-    return this._refinement((val, ctx) => {
-      if (!check(val)) {
-        ctx.addIssue(
-          typeof refinementData === "function"
-            ? refinementData(val, ctx)
-            : refinementData
-        );
-      }
-    });
-  };
-
-  _refinement: (refinement: InternalCheck<Output>["check"]) => this = (
-    refinement
-  ) => {
-    return new (this as any).constructor({
-      ...this._def,
-      effects: [
-        ...(this._def.effects || []),
-        { type: "check", check: refinement },
-      ],
-    }) as this;
-  };
-
-  constructor(def: Def) {
-    this._def = def;
-    // this.is = this.is.bind(this);
-    // this.check = this.check.bind(this);
-    this.transform = this.transform.bind(this);
-    this.default = this.default.bind(this);
-  }
-
-  abstract toJSON: () => object;
-
-  optional: () => ZodOptionalType<this> = () => ZodOptional.create(this);
-  or = this.optional;
-  nullable: () => ZodNullableType<this> = () => {
-    return ZodNullable.create(this) as any;
-  };
-  array: () => ZodArray<this> = () => ZodArray.create(this);
-
-  // transform<
-  //   This extends this,
-  //   U extends ZodType<any>,
-  //   Tx extends (arg: This["_output"]) => U["_input"] | Promise<U["_input"]>
-  // >(input: U, transformer: Tx): ZodTransformer<This, U>;
-  // transform<
-  //   This extends this,
-  //   Tx extends (
-  //     arg: This["_output"]
-  //   ) => This["_input"] | Promise<This["_input"]>
-  // >(transformer: Tx): ZodTransformer<This, This>;
-  // transform(input: any, transformer?: any) {
-  //   if (transformer) {
-  //     return ZodTransformer.create(this as any, input, transformer) as any;
-  //   }
-  //   return ZodTransformer.create(this as any, outputSchema(this), input) as any;
-  // }
-
-  // default<
-  //   T extends Input = Input,
-  //   Opt extends ReturnType<this["optional"]> = ReturnType<this["optional"]>
-  // >(def: T): ZodTransformer<Opt, this>;
-  // default<
-  //   T extends (arg: this) => Input,
-  //   Opt extends ReturnType<this["optional"]> = ReturnType<this["optional"]>
-  // >(def: T): ZodTransformer<Opt, this>;
-  // default(def: any) {
-  //   return ZodTransformer.create(this.optional(), this, (x: any) => {
-  //     return x === undefined
-  //       ? typeof def === "function"
-  //         ? def(this)
-  //         : def
-  //       : x;
-  //   }) as any;
-  // }
-
-  // transform<This extends this, Out, U extends ZodType<any>>(
-  //   input: U,
-  //   transformer: (arg: Output) => Out | Promise<Out>
-  // ): This extends ZodTransformer<infer T, any>
-  //   ? ZodTransformer<T, Out>
-  //   : ZodTransformer<This, Out>;
-  // transform<Out, This extends this>(
-  //   transformer: (arg: Output) => Out | Promise<Out>
-  // ): This extends ZodTransformer<infer T, any>
-  //   ? ZodTransformer<T, Out>
-  //   : ZodTransformer<This, Out>;
-  transform: <Out, This extends this>(
-    transformer: (arg: Output) => Out | Promise<Out>
-  ) => This extends ZodTransformer<infer T, any>
-    ? ZodTransformer<T, Out>
-    : ZodTransformer<This, Out> = (mod) => {
-    // if(typeof first === "function")
-    // const mod = typeof first === "function" ? first : second;
-    // const newSchema = this.transform(txFunc);
-    // if (!second) return newSchema;
-    // if (typeof mod !== "function")
-    //   throw new Error("Must provide a function to the .transform() method");
-
-    let returnType;
-    if (this instanceof ZodTransformer) {
-      returnType = new (this as any).constructor({
-        ...this._def,
-        effects: [...(this._def.effects || []), { type: "mod", mod }],
-      }) as any;
-    } else {
-      returnType = new ZodTransformer({
-        // ...this._def,
-        t: ZodTypes.transformer,
-        schema: this,
-        effects: [{ type: "mod", mod }],
-      }) as any;
-    }
-    return returnType;
-  };
-
-  //   if (!second) {
-  //     return returnType;
-  //   } else {
-  //     return returnType.refine(
-  //       (val: any) => {
-  //         return first.parse(val);
-  //       },
-  //       { message: "Parsing error!" }
-  //     );
-  //   }
-  // };
-
-  prependMod = <Out>(
-    mod: (arg: Output) => Out | Promise<Out>
-  ): ZodType<Out, Def, Input> => {
-    return new (this as any).constructor({
-      ...this._def,
-      effects: [{ type: "mod", mod }, ...(this._def.effects || [])],
-    }) as any;
-  };
-
-  clearEffects = <Out>(): ZodType<Out, Def, Input> => {
-    return new (this as any).constructor({
-      ...this._def,
-      effects: [],
-    }) as any;
-  };
-
-  setEffects = <Out>(effects: Effect<any>[]): ZodType<Out, Def, Input> => {
-    return new (this as any).constructor({
-      ...this._def,
-      effects,
-    }) as any;
-  };
-
-  default<T extends Input, This extends this = this>(
-    def: T
-  ): ZodTransformer<ZodOptional<This>, Input>;
-  default<T extends (arg: this) => Input, This extends this = this>(
-    def: T
-  ): ZodTransformer<ZodOptional<This>, Input>;
-  // default<
-  //   T extends (arg: this) => Input,
-  //   Opt extends ReturnType<this["optional"]> = ReturnType<this["optional"]>
-  // >(def: T): ZodTransformer<Opt, this>;
-  default(def: any) {
-    return this.optional().transform((val: any) => {
-      const defaultVal = typeof def === "function" ? def(this) : def;
-      return typeof val !== "undefined" ? val : defaultVal;
-    }) as any;
-  }
-
-  isOptional: () => boolean = () => this.safeParse(undefined).success;
-  isNullable: () => boolean = () => this.safeParse(null).success;
-}
-
-export type RefinementCtx = {
-  addIssue: (arg: MakeErrorData) => void;
-  path: (string | number)[];
-};
-
-export type ZodRawShape = { [k: string]: ZodTypeAny };
-
-export type TypeOf<T extends ZodType<any>> = T["_output"];
-export type input<T extends ZodType<any>> = T["_input"];
-export type output<T extends ZodType<any>> = T["_output"];
-export type infer<T extends ZodType<any>> = T["_output"];
-
-export type ZodTypeAny = ZodType<any, any, any>;
diff --git a/deno/lib/types/bigint.ts b/deno/lib/types/bigint.ts
deleted file mode 100644
index c1646df05..000000000
--- a/deno/lib/types/bigint.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodBigIntDef extends ZodTypeDef {
-  t: ZodTypes.bigint;
-}
-
-export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({
-      t: ZodTypes.bigint,
-    });
-  };
-}
diff --git a/deno/lib/types/boolean.ts b/deno/lib/types/boolean.ts
deleted file mode 100644
index 0d4391454..000000000
--- a/deno/lib/types/boolean.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodBooleanDef extends ZodTypeDef {
-  t: ZodTypes.boolean;
-}
-
-export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({
-      t: ZodTypes.boolean,
-    });
-  };
-}
diff --git a/deno/lib/types/date.ts b/deno/lib/types/date.ts
deleted file mode 100644
index b446bc2b7..000000000
--- a/deno/lib/types/date.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodDateDef extends ZodTypeDef {
-  t: ZodTypes.date;
-}
-
-export class ZodDate extends ZodType<Date, ZodDateDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-  static create = (): ZodDate => {
-    return new ZodDate({
-      t: ZodTypes.date,
-    });
-  };
-}
diff --git a/deno/lib/types/enum.ts b/deno/lib/types/enum.ts
deleted file mode 100644
index b937aed70..000000000
--- a/deno/lib/types/enum.ts
+++ /dev/null
@@ -1,68 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export type ArrayKeys = keyof any[];
-export type Indices<T> = Exclude<keyof T, ArrayKeys>;
-
-type EnumValues = [string, ...string[]];
-
-type Values<T extends EnumValues> = {
-  [k in T[number]]: k;
-};
-
-export interface ZodEnumDef<T extends EnumValues = EnumValues>
-  extends ZodTypeDef {
-  t: ZodTypes.enum;
-  values: T;
-}
-
-export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
-  T[number],
-  ZodEnumDef<T>
-> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-
-  get options() {
-    return this._def.values;
-  }
-
-  get enum(): Values<T> {
-    const enumValues: any = {};
-    for (const val of this._def.values) {
-      enumValues[val] = val;
-    }
-    return enumValues as any;
-  }
-
-  get Values(): Values<T> {
-    const enumValues: any = {};
-    for (const val of this._def.values) {
-      enumValues[val] = val;
-    }
-    return enumValues as any;
-  }
-
-  get Enum(): Values<T> {
-    const enumValues: any = {};
-    for (const val of this._def.values) {
-      enumValues[val] = val;
-    }
-    return enumValues as any;
-  }
-
-  static create = <U extends string, T extends [U, ...U[]]>(
-    values: T
-  ): ZodEnum<T> => {
-    return new ZodEnum({
-      t: ZodTypes.enum,
-      values: values,
-    }) as any;
-  };
-}
diff --git a/deno/lib/types/function.ts b/deno/lib/types/function.ts
deleted file mode 100644
index 15cb9574a..000000000
--- a/deno/lib/types/function.ts
+++ /dev/null
@@ -1,92 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-import { ZodTuple } from "./tuple.ts";
-import { ZodUnknown } from "./unknown.ts";
-
-export interface ZodFunctionDef<
-  Args extends ZodTuple<any> = ZodTuple<any>,
-  Returns extends ZodTypeAny = ZodTypeAny
-> extends ZodTypeDef {
-  t: ZodTypes.function;
-  args: Args;
-  returns: Returns;
-}
-
-export type OuterTypeOfFunction<
-  Args extends ZodTuple<any>,
-  Returns extends ZodTypeAny
-> = Args["_input"] extends Array<any>
-  ? (...args: Args["_input"]) => Returns["_output"]
-  : never;
-
-export type InnerTypeOfFunction<
-  Args extends ZodTuple<any>,
-  Returns extends ZodTypeAny
-> = Args["_output"] extends Array<any>
-  ? (...args: Args["_output"]) => Returns["_input"]
-  : never;
-
-// type as df = string extends unknown  ? true : false
-export class ZodFunction<
-  Args extends ZodTuple<any>,
-  Returns extends ZodTypeAny
-> extends ZodType<
-  OuterTypeOfFunction<Args, Returns>,
-  ZodFunctionDef,
-  InnerTypeOfFunction<Args, Returns>
-> {
-  readonly _def!: ZodFunctionDef<Args, Returns>;
-  //  readonly _type!: TypeOfFunction<Args, Returns>;
-
-  args = <Items extends Parameters<typeof ZodTuple["create"]>[0]>(
-    ...items: Items
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
-    return new ZodFunction({
-      ...this._def,
-      args: ZodTuple.create(items),
-    });
-  };
-
-  returns = <NewReturnType extends ZodType<any, any>>(
-    returnType: NewReturnType
-  ): ZodFunction<Args, NewReturnType> => {
-    return new ZodFunction({
-      ...this._def,
-      returns: returnType,
-    });
-  };
-
-  implement = <F extends InnerTypeOfFunction<Args, Returns>>(func: F): F => {
-    const validatedFunc = this.parse(func);
-    return validatedFunc as any;
-  };
-
-  validate = this.implement;
-
-  static create = <
-    T extends ZodTuple<any> = ZodTuple<[]>,
-    U extends ZodTypeAny = ZodUnknown
-  >(
-    args?: T,
-    returns?: U
-  ): ZodFunction<T, U> => {
-    return new ZodFunction({
-      t: ZodTypes.function,
-      args: args || ZodTuple.create([]),
-      returns: returns || ZodUnknown.create(),
-    });
-  };
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => {
-    return {
-      t: this._def.t,
-      args: this._def.args.toJSON(),
-      returns: this._def.returns.toJSON(),
-    };
-  };
-}
diff --git a/deno/lib/types/intersection.ts b/deno/lib/types/intersection.ts
deleted file mode 100644
index 60192e919..000000000
--- a/deno/lib/types/intersection.ts
+++ /dev/null
@@ -1,44 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodIntersectionDef<
-  T extends ZodTypeAny = ZodTypeAny,
-  U extends ZodTypeAny = ZodTypeAny
-> extends ZodTypeDef {
-  t: ZodTypes.intersection;
-  left: T;
-  right: U;
-}
-
-export class ZodIntersection<
-  T extends ZodTypeAny,
-  U extends ZodTypeAny
-> extends ZodType<
-  T["_output"] & U["_output"],
-  ZodIntersectionDef<T, U>,
-  T["_input"] & U["_input"]
-> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => ({
-    t: this._def.t,
-    left: this._def.left.toJSON(),
-    right: this._def.right.toJSON(),
-  });
-
-  static create = <T extends ZodTypeAny, U extends ZodTypeAny>(
-    left: T,
-    right: U
-  ): ZodIntersection<T, U> => {
-    return new ZodIntersection({
-      t: ZodTypes.intersection,
-      left: left,
-      right: right,
-    });
-  };
-}
diff --git a/deno/lib/types/lazy.ts b/deno/lib/types/lazy.ts
deleted file mode 100644
index c5805b170..000000000
--- a/deno/lib/types/lazy.ts
+++ /dev/null
@@ -1,37 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { input, output, ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.lazy;
-  getter: () => T;
-}
-
-export class ZodLazy<T extends ZodTypeAny> extends ZodType<
-  output<T>,
-  ZodLazyDef<T>,
-  input<T>
-> {
-  get schema(): T {
-    return this._def.getter();
-  }
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => {
-    throw new Error("Can't JSONify recursive structure");
-  };
-
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
-    return new ZodLazy({
-      t: ZodTypes.lazy,
-      getter: getter,
-    });
-  };
-}
diff --git a/deno/lib/types/literal.ts b/deno/lib/types/literal.ts
deleted file mode 100644
index b02cf680c..000000000
--- a/deno/lib/types/literal.ts
+++ /dev/null
@@ -1,28 +0,0 @@
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-import { Primitive } from "../helpers/primitive.ts";
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-
-type LiteralValue = Primitive;
-
-export interface ZodLiteralDef<T extends any = any> extends ZodTypeDef {
-  t: ZodTypes.literal;
-  value: T;
-}
-
-export class ZodLiteral<T extends any> extends ZodType<T, ZodLiteralDef<T>> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-
-  static create = <T extends LiteralValue>(value: T): ZodLiteral<T> => {
-    return new ZodLiteral({
-      t: ZodTypes.literal,
-      value: value,
-    });
-  };
-}
diff --git a/deno/lib/types/map.ts b/deno/lib/types/map.ts
deleted file mode 100644
index 8af425c1f..000000000
--- a/deno/lib/types/map.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-export interface ZodMapDef<
-  Key extends ZodTypeAny = ZodTypeAny,
-  Value extends ZodTypeAny = ZodTypeAny
-> extends ZodTypeDef {
-  t: ZodTypes.map;
-  valueType: Value;
-  keyType: Key;
-}
-
-export class ZodMap<
-  Key extends ZodTypeAny = ZodTypeAny,
-  Value extends ZodTypeAny = ZodTypeAny
-> extends ZodType<
-  Map<Key["_output"], Value["_output"]>,
-  ZodMapDef<Key, Value>,
-  Map<Key["_input"], Value["_input"]>
-> {
-  readonly _value!: Value;
-
-  toJSON = () => ({
-    t: this._def.t,
-    valueType: this._def.valueType.toJSON(),
-    keyType: this._def.keyType.toJSON(),
-  });
-
-  static create = <
-    Key extends ZodTypeAny = ZodTypeAny,
-    Value extends ZodTypeAny = ZodTypeAny
-  >(
-    keyType: Key,
-    valueType: Value
-  ): ZodMap<Key, Value> => {
-    return new ZodMap({
-      t: ZodTypes.map,
-      valueType,
-      keyType,
-    });
-  };
-}
diff --git a/deno/lib/types/nativeEnum.ts b/deno/lib/types/nativeEnum.ts
deleted file mode 100644
index 362994d67..000000000
--- a/deno/lib/types/nativeEnum.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-
-export interface ZodNativeEnumDef<T extends EnumLike = EnumLike>
-  extends ZodTypeDef {
-  t: ZodTypes.nativeEnum;
-  values: T;
-}
-
-type EnumLike = { [k: string]: string | number; [nu: number]: string };
-
-export class ZodNativeEnum<T extends EnumLike> extends ZodType<
-  T[keyof T],
-  ZodNativeEnumDef<T>
-> {
-  toJSON = () => this._def;
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
-    return new ZodNativeEnum({
-      t: ZodTypes.nativeEnum,
-      values: values,
-    });
-  };
-}
diff --git a/deno/lib/types/never.ts b/deno/lib/types/never.ts
deleted file mode 100644
index adaa82a22..000000000
--- a/deno/lib/types/never.ts
+++ /dev/null
@@ -1,17 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-
-export interface ZodNeverDef extends ZodTypeDef {
-  t: ZodTypes.never;
-}
-
-export class ZodNever extends ZodType<never, ZodNeverDef> {
-  __class = "ZodNever";
-  toJSON = () => this._def;
-
-  static create = (): ZodNever => {
-    return new ZodNever({
-      t: ZodTypes.never,
-    });
-  };
-}
diff --git a/deno/lib/types/null.ts b/deno/lib/types/null.ts
deleted file mode 100644
index cfcce7216..000000000
--- a/deno/lib/types/null.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-// import { ZodUndefined } from './undefined';
-// import { ZodUnion } from './union';
-
-export interface ZodNullDef extends ZodTypeDef {
-  t: ZodTypes.null;
-}
-
-export class ZodNull extends ZodType<null, ZodNullDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-  static create = (): ZodNull => {
-    return new ZodNull({
-      t: ZodTypes.null,
-    });
-  };
-}
diff --git a/deno/lib/types/nullable.ts b/deno/lib/types/nullable.ts
deleted file mode 100644
index 2f96cdf55..000000000
--- a/deno/lib/types/nullable.ts
+++ /dev/null
@@ -1,34 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-export interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.nullable;
-  innerType: T;
-}
-
-// This type allows for nullable flattening
-export type ZodNullableType<
-  T extends ZodTypeAny
-> = T extends ZodNullable<ZodTypeAny> ? T : ZodNullable<T>;
-
-export class ZodNullable<
-  T extends ZodTypeAny
-  //  Output extends T['_output'] | null = T['_output'] | null,
-  //  Input extends T['_input'] | null = T['_input'] | null
-> extends ZodType<T["_output"] | null, ZodNullableDef<T>, T["_input"] | null> {
-  // An nullable nullable is the original nullable
-  // nullable: () => ZodNullableType<this> = () => this as ZodNullableType<this>;
-  toJSON = () => ({
-    t: this._def.t,
-    innerType: this._def.innerType.toJSON(),
-  });
-
-  static create = <T extends ZodTypeAny>(type: T): ZodNullableType<T> => {
-    if (type instanceof ZodNullable) return type as ZodNullableType<T>;
-    return new ZodNullable({
-      t: ZodTypes.nullable,
-      innerType: type,
-    }) as ZodNullableType<T>;
-  };
-}
diff --git a/deno/lib/types/number.ts b/deno/lib/types/number.ts
deleted file mode 100644
index 690905410..000000000
--- a/deno/lib/types/number.ts
+++ /dev/null
@@ -1,86 +0,0 @@
-import { errorUtil } from "../helpers/errorUtil.ts";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-import { ZodIssueCode } from "../ZodError.ts";
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-
-export interface ZodNumberDef extends ZodTypeDef {
-  t: ZodTypes.number;
-}
-
-export class ZodNumber extends ZodType<number, ZodNumberDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-  static create = (): ZodNumber => {
-    return new ZodNumber({
-      t: ZodTypes.number,
-    });
-  };
-
-  min = (minimum: number, message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data >= minimum, {
-      code: ZodIssueCode.too_small,
-      minimum,
-      type: "number",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-
-  max = (maximum: number, message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data <= maximum, {
-      code: ZodIssueCode.too_big,
-      maximum,
-      type: "number",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-
-  int = (message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => Number.isInteger(data), {
-      code: ZodIssueCode.invalid_type,
-      expected: "integer",
-      received: "number",
-      ...errorUtil.errToObj(message),
-    });
-
-  positive = (message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data > 0, {
-      code: ZodIssueCode.too_small,
-      minimum: 0,
-      type: "number",
-      inclusive: false,
-      ...errorUtil.errToObj(message),
-    });
-
-  negative = (message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data < 0, {
-      code: ZodIssueCode.too_big,
-      maximum: 0,
-      type: "number",
-      inclusive: false,
-      ...errorUtil.errToObj(message),
-    });
-
-  nonpositive = (message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data <= 0, {
-      code: ZodIssueCode.too_big,
-      maximum: 0,
-      type: "number",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-
-  nonnegative = (message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data >= 0, {
-      code: ZodIssueCode.too_small,
-      minimum: 0,
-      type: "number",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-}
diff --git a/deno/lib/types/object.ts b/deno/lib/types/object.ts
deleted file mode 100644
index 939ad7d5c..000000000
--- a/deno/lib/types/object.ts
+++ /dev/null
@@ -1,426 +0,0 @@
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-import { objectUtil } from "../helpers/objectUtil.ts";
-// import { mergeShapes } from "../helpers/objectUtil/merge";
-import { partialUtil } from "../helpers/partialUtil.ts";
-import { Scalars } from "../helpers/primitive.ts";
-import { isScalar } from "../isScalar.ts";
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodRawShape, ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-import { ZodNever } from "./never.ts";
-
-export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-  Second extends AnyZodObject
->(
-  second: Second
-): ZodObject<
-  First["_shape"] & Second["_shape"],
-  First["_unknownKeys"],
-  First["_catchall"]
-  // MergeObjectParams<First['_params'], Second['_params']>,
-  // First['_input'] & Second['_input'],
-  // First['_output'] & Second['_output']
-> => {
-  const mergedShape = objectUtil.mergeShapes(
-    first._def.shape(),
-    second._def.shape()
-  );
-  const merged: any = new ZodObject({
-    t: ZodTypes.object,
-    effects: [...(first._def.effects || []), ...(second._def.effects || [])],
-    unknownKeys: first._def.unknownKeys,
-    catchall: first._def.catchall,
-    // params: {
-    //   strict: first.params.strict && second.params.strict,
-    // },
-    shape: () => mergedShape,
-  }) as any;
-  return merged;
-};
-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
-  Augmentation extends ZodRawShape
->(
-  augmentation: Augmentation
-): ZodObject<
-  {
-    [k in Exclude<
-      keyof ReturnType<Def["shape"]>,
-      keyof Augmentation
-    >]: ReturnType<Def["shape"]>[k];
-  } &
-    { [k in keyof Augmentation]: Augmentation[k] },
-  Def["unknownKeys"],
-  Def["catchall"]
-> => {
-  return new ZodObject({
-    ...def,
-    shape: () => ({
-      ...def.shape(),
-      ...augmentation,
-    }),
-  }) as any;
-};
-
-type UnknownKeysParam = "passthrough" | "strict" | "strip";
-
-export interface ZodObjectDef<
-  T extends ZodRawShape = ZodRawShape,
-  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,
-  Catchall extends ZodTypeAny = ZodTypeAny
-  // Params extends ZodObjectParams = ZodObjectParams
-> extends ZodTypeDef {
-  t: ZodTypes.object;
-  shape: () => T;
-  catchall: Catchall;
-  unknownKeys: UnknownKeys;
-  // params: Params;
-}
-
-export type baseObjectOutputType<
-  Shape extends ZodRawShape
-  // Catchall extends ZodTypeAny
-> = objectUtil.flatten<
-  objectUtil.addQuestionMarks<
-    {
-      [k in keyof Shape]: Shape[k]["_output"];
-    }
-  > //{ [k: string]: Catchall['_output'] }
->;
-
-export type objectOutputType<
-  Shape extends ZodRawShape,
-  Catchall extends ZodTypeAny
-> = ZodTypeAny extends Catchall
-  ? baseObjectOutputType<Shape>
-  : objectUtil.flatten<
-      baseObjectOutputType<Shape> & { [k: string]: Catchall["_output"] }
-    >;
-
-export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<
-  objectUtil.addQuestionMarks<
-    {
-      [k in keyof Shape]: Shape[k]["_input"];
-    }
-  >
->;
-
-export type objectInputType<
-  Shape extends ZodRawShape,
-  Catchall extends ZodTypeAny
-> = ZodTypeAny extends Catchall
-  ? baseObjectInputType<Shape>
-  : objectUtil.flatten<
-      baseObjectInputType<Shape> & { [k: string]: Catchall["_input"] }
-    >;
-
-const objectDefToJson = (def: ZodObjectDef<any, any>) => ({
-  t: def.t,
-  shape: Object.assign(
-    {},
-    ...Object.keys(def.shape()).map((k) => ({
-      [k]: def.shape()[k].toJSON(),
-    }))
-  ),
-});
-
-// interface ZodObjectParams {
-//   strict: boolean;
-// }
-
-// type SetKey<
-//   Target extends object,
-//   Key extends string,
-//   Value extends any
-// > = objectUtil.Flatten<
-//   { [k in Exclude<keyof Target, Key>]: Target[k] } & { [k in Key]: Value }
-// >;
-
-// type makeKeysRequired<T extends ZodObject<any, any, any>> = T extends ZodObject<
-//   infer U,
-//   infer P,
-//   infer C
-// >
-//   ? ZodObject<objectUtil.NoNever<{ [k in keyof U]: makeRequired<U[k]> }>, P, C>
-//   : never;
-
-// type makeRequired<T extends ZodType<any>> = T extends ZodUnion<infer U>
-//   ? U extends [infer Y, ZodUndefined]
-//     ? Y
-//     : U extends [ZodUndefined, infer Z]
-//     ? Z
-//     : T
-//   : T;
-
-// type ZodObjectType<
-//   T extends ZodRawShape,
-//   Params extends ZodObjectParams
-// > = Params['strict'] extends true
-//   ? objectUtil.ObjectType<T>
-//   : objectUtil.Flatten<objectUtil.ObjectType<T> & { [k: string]: any }>;
-
-export class ZodObject<
-  T extends ZodRawShape,
-  UnknownKeys extends UnknownKeysParam = "strip",
-  Catchall extends ZodTypeAny = ZodTypeAny,
-  // Params extends ZodObjectParams = { strict: true },
-  // Type extends ZodObjectType<T, Params> = ZodObjectType<T, Params>
-  Output = objectOutputType<T, Catchall>,
-  Input = objectInputType<T, Catchall>
-> extends ZodType<
-  //  objectUtil.objectOutputType<T, UnknownKeys, Catchall>,
-  Output,
-  ZodObjectDef<T, UnknownKeys, Catchall>,
-  Input
-> {
-  readonly _shape!: T;
-  readonly _unknownKeys!: UnknownKeys;
-  readonly _catchall!: Catchall;
-
-  get shape() {
-    return this._def.shape();
-  }
-
-  // get params() {
-  //   return this._def.params;
-  // }
-
-  //  get t() {
-  //    return this;
-  //  }
-
-  toJSON = () => objectDefToJson(this._def);
-
-  strict = (): ZodObject<T, "strict", Catchall> =>
-    new ZodObject({
-      ...this._def,
-      unknownKeys: "strict",
-    });
-
-  strip = (): ZodObject<T, "strip", Catchall> =>
-    new ZodObject({
-      ...this._def,
-      unknownKeys: "strip",
-    });
-
-  passthrough = (): ZodObject<T, "passthrough", Catchall> =>
-    new ZodObject({
-      ...this._def,
-      unknownKeys: "passthrough",
-    });
-
-  nonstrict = this.passthrough;
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  augment = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
-  extend = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
-
-  setKey = <Key extends string, Schema extends ZodTypeAny>(
-    key: Key,
-    schema: Schema
-  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> => {
-    return this.augment({ [key]: schema }) as any;
-  };
-
-  /**
-   * Prior to zod@1.0.12 there was a bug in the
-   * inferred type of merged objects. Please
-   * upgrade if you are experiencing issues.
-   */
-  merge: <Incoming extends AnyZodObject>(
-    other: Incoming
-  ) => ZodObject<
-    T & Incoming["_shape"],
-    UnknownKeys,
-    Catchall
-    // objectUtil.MergeObjectParams<Params, MergeUnknownKeys>
-  > = mergeObjects(this as any) as any;
-
-  catchall = <Index extends ZodTypeAny>(
-    index: Index
-  ): ZodObject<
-    T,
-    UnknownKeys,
-    Index
-    // objectUtil.MergeObjectParams<Params, MergeUnknownKeys>
-  > => {
-    return new ZodObject({
-      ...this._def,
-      // unknownKeys: 'passthrough',
-      catchall: index,
-    });
-  };
-
-  pick = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
-    UnknownKeys,
-    Catchall
-  > => {
-    const shape: any = {};
-    Object.keys(mask).map((key) => {
-      shape[key] = this.shape[key];
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => shape,
-    });
-  };
-
-  omit = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
-    UnknownKeys,
-    Catchall
-  > => {
-    const shape: any = {};
-    Object.keys(this.shape).map((key) => {
-      if (Object.keys(mask).indexOf(key) === -1) {
-        shape[key] = this.shape[key];
-      }
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => shape,
-    });
-  };
-
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k]["optional"]> },
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    });
-  };
-
-  // require: <This extends this>() => makeKeysRequired<This> = () => {
-  //   const newShape: any = {};
-  //   for (const key in this.shape) {
-  //     const val = this.shape[key];
-  //     if (val instanceof ZodUnion) {
-  //       const options = (val as ZodUnion<any>)._def.options;
-  //       if (options.length === 2) {
-  //         // .length === 2;
-  //         if (options[0] instanceof ZodUndefined) {
-  //           newShape[key] = options[1];
-  //         } else if (options[1] instanceof ZodUndefined) {
-  //           newShape[key] = options[0];
-  //         }
-  //       } else {
-  //         newShape[key] = val;
-  //       }
-  //     } else {
-  //       newShape[key] = val;
-  //     }
-  //   }
-  //   return new ZodObject({
-  //     ...this._def,
-  //     shape: () => newShape,
-  //   }) as any;
-  // };
-
-  primitives = (): ZodObject<
-    objectUtil.NoNever<
-      {
-        [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? T[k] : never;
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    for (const key in this.shape) {
-      if (isScalar(this.shape[key])) {
-        newShape[key] = this.shape[key];
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    });
-  };
-
-  nonprimitives = (): ZodObject<
-    objectUtil.NoNever<
-      {
-        [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? never : T[k];
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    for (const key in this.shape) {
-      if (!isScalar(this.shape[key])) {
-        newShape[key] = this.shape[key];
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    });
-  };
-
-  deepPartial: () => partialUtil.RootDeepPartial<this> = () => {
-    const newShape: any = {};
-
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      if (fieldSchema instanceof ZodObject) {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : (fieldSchema.deepPartial() as any).optional();
-      } else {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : fieldSchema.optional();
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
-  };
-
-  // keyof: ()=>ZodEnum<{[k in T]: k}>
-
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
-    return new ZodObject({
-      t: ZodTypes.object,
-      shape: () => shape,
-      unknownKeys: "strip",
-      catchall: ZodNever.create(),
-      //  params: {
-      //    strict: true,
-      //  },
-    }) as any;
-  };
-
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
-    return new ZodObject({
-      t: ZodTypes.object,
-      shape,
-      unknownKeys: "strip",
-      catchall: ZodNever.create(),
-    }) as any;
-  };
-}
-
-export type AnyZodObject = ZodObject<any, any, any>;
diff --git a/deno/lib/types/optional.ts b/deno/lib/types/optional.ts
deleted file mode 100644
index 924036e60..000000000
--- a/deno/lib/types/optional.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-export interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.optional;
-  innerType: T;
-}
-
-// This type allows for optional flattening
-export type ZodOptionalType<
-  T extends ZodTypeAny
-> = T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
-
-export class ZodOptional<T extends ZodTypeAny> extends ZodType<
-  T["_output"] | undefined,
-  ZodOptionalDef<T>,
-  T["_input"] | undefined
-> {
-  // An optional optional is the original optional
-  // optional: () => ZodOptionalType<this> = () => this as ZodOptionalType<this>;
-  toJSON = () => ({
-    t: this._def.t,
-    innerType: this._def.innerType.toJSON(),
-  });
-
-  static create = <T extends ZodTypeAny>(type: T): ZodOptionalType<T> => {
-    if (type instanceof ZodOptional) return type as ZodOptionalType<T>;
-
-    return new ZodOptional({
-      t: ZodTypes.optional,
-      innerType: type,
-    }) as ZodOptionalType<T>;
-  };
-}
diff --git a/deno/lib/types/promise.ts b/deno/lib/types/promise.ts
deleted file mode 100644
index b4f36265f..000000000
--- a/deno/lib/types/promise.ts
+++ /dev/null
@@ -1,36 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.promise;
-  type: T;
-}
-
-export class ZodPromise<T extends ZodTypeAny> extends ZodType<
-  Promise<T["_output"]>,
-  ZodPromiseDef<T>,
-  Promise<T["_input"]>
-> {
-  toJSON = () => {
-    return {
-      t: this._def.t,
-      type: this._def.type.toJSON(),
-    };
-  };
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
-    return new ZodPromise({
-      t: ZodTypes.promise,
-      type: schema,
-    });
-  };
-}
diff --git a/deno/lib/types/record.ts b/deno/lib/types/record.ts
deleted file mode 100644
index b508f24ff..000000000
--- a/deno/lib/types/record.ts
+++ /dev/null
@@ -1,38 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.record;
-  valueType: Value;
-}
-
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value["_output"]>, // { [k in keyof T]: T[k]['_type'] },
-  ZodRecordDef<Value>,
-  Record<string, Value["_input"]>
-> {
-  readonly _value!: Value;
-
-  toJSON = () => ({
-    t: this._def.t,
-    valueType: this._def.valueType.toJSON(),
-  });
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
-    return new ZodRecord({
-      t: ZodTypes.record,
-      valueType,
-    });
-  };
-}
diff --git a/deno/lib/types/string.ts b/deno/lib/types/string.ts
deleted file mode 100644
index 3d80bd4e5..000000000
--- a/deno/lib/types/string.ts
+++ /dev/null
@@ -1,97 +0,0 @@
-import { errorUtil } from "../helpers/errorUtil.ts";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-import { StringValidation, ZodIssueCode } from "../ZodError.ts";
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-
-export interface ZodStringDef extends ZodTypeDef {
-  t: ZodTypes.string;
-  validation: {
-    uuid?: true;
-    custom?: ((val: any) => boolean)[];
-  };
-}
-
-// eslint-disable-next-line
-const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
-const uuidRegex = /([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}){1}/i;
-
-export class ZodString extends ZodType<string, ZodStringDef> {
-  inputSchema = this;
-  outputSchema = this;
-
-  toJSON = () => this._def;
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data.length >= minLength, {
-      code: ZodIssueCode.too_small,
-      minimum: minLength,
-      type: "string",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data.length <= maxLength, {
-      code: ZodIssueCode.too_big,
-      maximum: maxLength,
-      type: "string",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-
-  length(len: number, message?: errorUtil.ErrMessage) {
-    return this.min(len, message).max(len, message);
-  }
-
-  protected _regex = (
-    regex: RegExp,
-    validation: StringValidation,
-    message?: errorUtil.ErrMessage
-  ) =>
-    this.refinement((data) => regex.test(data), {
-      validation,
-      code: ZodIssueCode.invalid_string,
-
-      ...errorUtil.errToObj(message),
-    });
-
-  email = (message?: errorUtil.ErrMessage) =>
-    this._regex(emailRegex, "email", message);
-
-  url = (message?: errorUtil.ErrMessage) =>
-    this.refinement(
-      (data) => {
-        try {
-          new URL(data);
-          return true;
-        } catch {
-          return false;
-        }
-      },
-      {
-        code: ZodIssueCode.invalid_string,
-        validation: "url",
-        ...errorUtil.errToObj(message),
-      }
-    );
-
-  // url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
-
-  uuid = (message?: errorUtil.ErrMessage) =>
-    this._regex(uuidRegex, "uuid", message);
-
-  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) =>
-    this._regex(regexp, "regex", message);
-
-  nonempty = (message?: errorUtil.ErrMessage) =>
-    this.min(1, errorUtil.errToObj(message));
-
-  static create = (): ZodString => {
-    return new ZodString({
-      t: ZodTypes.string,
-      validation: {},
-    });
-  };
-}
diff --git a/deno/lib/types/transformer.ts b/deno/lib/types/transformer.ts
deleted file mode 100644
index 37bf3febe..000000000
--- a/deno/lib/types/transformer.ts
+++ /dev/null
@@ -1,66 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodTransformerDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.transformer;
-  schema: T;
-  // transforms: (arg: T["_output"]) => U["_input"];
-}
-
-export class ZodTransformer<
-  T extends ZodTypeAny,
-  Output = T["_type"]
-> extends ZodType<Output, ZodTransformerDef<T>, T["_input"]> {
-  toJSON = () => ({
-    t: this._def.t,
-    schema: this._def.schema.toJSON(),
-  });
-
-  constructor(def: ZodTransformerDef<T>) {
-    super(def);
-    if (def.schema instanceof ZodTransformer) {
-      throw new Error("ZodTransformers cannot be nested.");
-    }
-  }
-
-  /** You can't use the .default method on transformers! */
-  default: (..._args: any[]) => never = (..._args: any[]) => {
-    throw new Error(
-      "You can't use the default method on a ZodTransformer instance."
-    );
-  };
-
-  // static create = <I extends ZodTypeAny, O extends ZodTypeAny, Out>(
-  static create = <I extends ZodTypeAny>(
-    schema: I
-    // outputSchema?: O,
-    // tx?: (arg: I["_output"]) => Out | Promise<Out>
-  ): ZodTransformer<I, I["_output"]> => {
-    // if (schema instanceof ZodTransformer) {
-    //   throw new Error("Can't nest transformers inside each other.");
-    // }
-    const newTx = new ZodTransformer({
-      t: ZodTypes.transformer,
-      schema,
-    });
-
-    // if (outputSchema && tx) {
-    //   console.warn(
-    //     `Calling transform() with three arguments is deprecated and not recommended.`
-    //   );
-    //   newTx = newTx.transform(tx).transform((val) => outputSchema.parse);
-    // }
-    return newTx;
-  };
-
-  // mod: <NewOut>(
-  //   arg: (curr: Output) => NewOut | Promise<NewOut>
-  // ) => ZodTransformer<T, NewOut> = (arg) => {
-  //   return this.mod(arg);
-  // };
-}
diff --git a/deno/lib/types/tuple.ts b/deno/lib/types/tuple.ts
deleted file mode 100644
index 272ebbf72..000000000
--- a/deno/lib/types/tuple.ts
+++ /dev/null
@@ -1,76 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-// import { objectUtil } from '../helpers/objectUtil';
-// import { ZodUnion } from './union';
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-
-// export type identity<T> = T;
-// export type flatten<T extends [any, ...any[]]> = identity<
-//   { [k in keyof T]: T[k] }
-// >;
-// type tupleOptionalKeys<T extends [any, ...any[]]> = {
-//   [k in keyof T]?: undefined extends T[k] ? T[k] : unknown;
-// }; //[keyof T];
-
-// type tupleRequiredKeys<T extends [any, ...any[]]> = {
-//   [k in keyof T]: undefined extends T[k] ? unknown : T[k];
-// };
-
-// export type addTupleQuestionMarks<T extends [any, ...any[]]> = flatten<
-//   tupleOptionalKeys<T> & tupleRequiredKeys<T>
-// >;
-
-// export type addTupleQuestionMarks<T extends [any, ...any[]]> = {
-//   [k in tupleOptionalKeys<T>]?: T[k];
-// } &
-//   { [k in tupleRequiredKeys<T>]: T[k] };
-
-// type test = [string, number | undefined]
-// type t2 = tupleOptionalKeys<test>;
-// type t3 = tupleRequiredKeys<test>;
-// type t4 = addTupleQuestionMarks<test>;
-// const x:t4 = ['asdf'];
-// type t5 = string & unknown;
-
-export type OutputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
-};
-
-export type InputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
-};
-
-export interface ZodTupleDef<
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodTypeDef {
-  t: ZodTypes.tuple;
-  items: T;
-}
-
-export class ZodTuple<
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
-  toJSON = () => ({
-    t: this._def.t,
-    items: (this._def.items as any[]).map((item) => item.toJSON()),
-  });
-
-  get items() {
-    return this._def.items;
-  }
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  static create = <T extends [ZodTypeAny, ...ZodTypeAny[]] | []>(
-    schemas: T
-  ): ZodTuple<T> => {
-    return new ZodTuple({
-      t: ZodTypes.tuple,
-      items: schemas,
-    });
-  };
-}
diff --git a/deno/lib/types/undefined.ts b/deno/lib/types/undefined.ts
deleted file mode 100644
index ff5a810ed..000000000
--- a/deno/lib/types/undefined.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-// import { ZodUnion } from './union';
-// import { ZodNull } from './null';
-
-export interface ZodUndefinedDef extends ZodTypeDef {
-  t: ZodTypes.undefined;
-}
-
-export class ZodUndefined extends ZodType<undefined> {
-  toJSON = () => this._def;
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({
-      t: ZodTypes.undefined,
-    });
-  };
-}
diff --git a/deno/lib/types/union.ts b/deno/lib/types/union.ts
deleted file mode 100644
index 22b1166f7..000000000
--- a/deno/lib/types/union.ts
+++ /dev/null
@@ -1,46 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base.ts";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-
-export interface ZodUnionDef<
-  T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]] = [
-    ZodTypeAny,
-    ZodTypeAny,
-    ...ZodTypeAny[]
-  ]
-> extends ZodTypeDef {
-  t: ZodTypes.union;
-  options: T;
-}
-
-export class ZodUnion<
-  T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<T[number]["_output"], ZodUnionDef<T>, T[number]["_input"]> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = (): object => ({
-    t: this._def.t,
-    options: this._def.options.map((x) => x.toJSON()),
-  });
-
-  get options() {
-    return this._def.options;
-  }
-
-  // distribute = <F extends (arg: T[number]) => ZodTypeAny>(f: F): ZodUnion<{ [k in keyof T]: ReturnType<F> }> => {
-  //   return ZodUnion.create(this._def.options.map(f) as any);
-  // };
-
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
-    types: T
-  ): ZodUnion<T> => {
-    return new ZodUnion({
-      t: ZodTypes.union,
-      options: types,
-    });
-  };
-}
diff --git a/deno/lib/types/unknown.ts b/deno/lib/types/unknown.ts
deleted file mode 100644
index 7aa2b6c67..000000000
--- a/deno/lib/types/unknown.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodUnknownDef extends ZodTypeDef {
-  t: ZodTypes.unknown;
-}
-
-export class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-  toJSON = () => this._def;
-
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({
-      t: ZodTypes.unknown,
-    });
-  };
-}
diff --git a/deno/lib/types/void.ts b/deno/lib/types/void.ts
deleted file mode 100644
index 950794d8a..000000000
--- a/deno/lib/types/void.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { ZodTypes } from "../ZodTypes.ts";
-import { ZodType, ZodTypeDef } from "./base.ts";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodVoidDef extends ZodTypeDef {
-  t: ZodTypes.void;
-}
-
-export class ZodVoid extends ZodType<void, ZodVoidDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-  toJSON = () => this._def;
-
-  static create = (): ZodVoid => {
-    return new ZodVoid({
-      t: ZodTypes.void,
-    });
-  };
-}
diff --git a/package.json b/package.json
index c792674c7..d628346b5 100644
--- a/package.json
+++ b/package.json
@@ -1,9 +1,14 @@
 {
   "name": "zod",
-  "version": "3.0.0-alpha.4",
+  "version": "3.0.0-alpha.7",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/cjs/index.js",
   "types": "./lib/cjs/index.d.ts",
+  "module": "./lib/esm/index.js",
+  "exports": {
+    "require": "./lib/cjs/index.js",
+    "import": "./lib/esm/index.js"
+  },
   "files": [
     "/lib"
   ],
@@ -39,14 +44,16 @@
     "check": "yarn check:lint && yarn check:format",
     "fix": "yarn fix:lint && yarn fix:format",
     "clean": "rm -rf lib/* deno/lib/*",
+    "build": "yarn run clean && npm run build:cjs && npm run build:esm && npm run build:deno",
     "build:deno": "node ./deno/build.mjs",
-    "build": "yarn run clean && tsc --p tsconfig.cjs.json",
     "build:esm": "tsc --p tsconfig.esm.json",
-    "test": "jest --coverage && yarn run badge",
+    "build:cjs": "tsc --p tsconfig.cjs.json",
+    "test": "node --trace-warnings node_modules/.bin/jest --coverage && yarn run badge",
     "testone": "jest",
     "badge": "make-coverage-badge --output-path ./coverage.svg",
     "prepublishOnly": "npm run build && npm run build:deno",
-    "play": "nodemon -e ts -w . -x ts-node src/playground.ts --project tsconfig.json"
+    "play": "nodemon -e ts -w . -x ts-node src/playground.ts --project tsconfig.json --trace-warnings",
+    "depcruise": "depcruise -c .dependency-cruiser.js src"
   },
   "devDependencies": {
     "@types/jest": "^26.0.17",
@@ -78,5 +85,8 @@
       "yarn fix:lint",
       "yarn fix:format"
     ]
+  },
+  "dependencies": {
+    "eslint-plugin-unused-imports": "^1.1.0"
   }
 }
\ No newline at end of file
diff --git a/src/PseudoPromise.ts b/src/PseudoPromise.ts
index 98dd85e7a..36feb96ee 100644
--- a/src/PseudoPromise.ts
+++ b/src/PseudoPromise.ts
@@ -8,31 +8,33 @@ type CatcherItem = { type: "catcher"; catcher: Catcher };
 type Items = (FuncItem | CatcherItem)[];
 
 export const NOSET = Symbol("no_set");
-export class PseudoPromise<ReturnType = undefined> {
-  readonly _return: ReturnType | undefined;
+export class PseudoPromise<PayloadType = undefined> {
+  readonly _return: PayloadType | undefined;
   items: Items;
   constructor(funcs: Items = []) {
     this.items = funcs;
   }
 
-  static all = <T extends PseudoPromise<any>[]>(pps: T) => {
-    return new PseudoPromise().all(pps);
+  static all = <T extends [PseudoPromise<any>, ...PseudoPromise<any>[]]>(
+    pps: T
+  ) => {
+    return new PseudoPromise().all(() => pps);
   };
 
-  all = <T extends PseudoPromise<any>[]>(
-    pps: T
+  all = <P extends PseudoPromise<any>, T extends [P, ...P[]]>(
+    func: (arg: PayloadType, ctx: { async: boolean }) => T
   ): PseudoPromise<
     {
-      [k in keyof T]: T[k] extends PseudoPromise<any> ? T[k]["_return"] : never;
+      [k in keyof T]: T[k] extends PseudoPromise<infer U> ? U : never;
     }
   > => {
-    return this.then((_arg, ctx) => {
+    return this.then((arg, ctx) => {
+      const pps = func(arg, ctx);
       if (ctx.async) {
         const allValues = Promise.all(
           pps.map(async (pp) => {
             try {
-              const asdf = await pp.getValueAsync();
-              return asdf;
+              return await pp.getValueAsync();
             } catch (err) {
               return INVALID;
             }
@@ -107,15 +109,37 @@ export class PseudoPromise<ReturnType = undefined> {
     return new PseudoPromise().then(() => value) as any;
   };
 
-  then = <NewReturn>(
-    func: (arg: ReturnType, ctx: { async: boolean }) => NewReturn
-  ): PseudoPromise<NewReturn extends Promise<infer U> ? U : NewReturn> => {
+  then = <NewPayload>(
+    func: (arg: PayloadType, ctx: { async: boolean }) => NewPayload
+  ): PseudoPromise<NewPayload extends Promise<infer U> ? U : NewPayload> => {
     return new PseudoPromise([
       ...this.items,
       { type: "function", function: func },
     ]);
   };
 
+  // parallel = <
+  //   NewFunc extends (arg: PayloadType, ctx: { async: boolean }) => any,
+  //   ParallelArgs extends [NewFunc, ...NewFunc[]]
+  // >(
+  //   ...funcs: ParallelArgs
+  // ): PseudoPromise<
+  //   {
+  //     [k in keyof ParallelArgs]: ParallelArgs[k] extends (
+  //       ...args: any
+  //     ) => infer R
+  //       ? R extends Promise<infer U>
+  //         ? U
+  //         : R
+  //       : never;
+  //   }
+  // > => {
+  //   return new PseudoPromise([
+  //     ...this.items,
+  //     { type: "function", function: func },
+  //   ]);
+  // };
+
   catch = (catcher: (err: Error, ctx: { async: boolean }) => unknown): this => {
     return new PseudoPromise([
       ...this.items,
@@ -123,7 +147,7 @@ export class PseudoPromise<ReturnType = undefined> {
     ]) as this;
   };
 
-  getValueSync = (): ReturnType => {
+  getValueSync = (): PayloadType => {
     let val: any = undefined;
 
     for (let index = 0; index < this.items.length; index++) {
@@ -151,7 +175,7 @@ export class PseudoPromise<ReturnType = undefined> {
     return val;
   };
 
-  getValueAsync = async (): Promise<ReturnType> => {
+  getValueAsync = async (): Promise<PayloadType> => {
     let val: any = undefined;
 
     for (let index = 0; index < this.items.length; index++) {
diff --git a/src/ZodDef.ts b/src/ZodDef.ts
deleted file mode 100644
index cfc54213a..000000000
--- a/src/ZodDef.ts
+++ /dev/null
@@ -1,56 +0,0 @@
-import { ZodAnyDef } from "./types/any";
-import { ZodArrayDef } from "./types/array";
-import { ZodBigIntDef } from "./types/bigint";
-import { ZodBooleanDef } from "./types/boolean";
-import { ZodDateDef } from "./types/date";
-import { ZodEnumDef } from "./types/enum";
-import { ZodFunctionDef } from "./types/function";
-import { ZodIntersectionDef } from "./types/intersection";
-import { ZodLazyDef } from "./types/lazy";
-import { ZodLiteralDef } from "./types/literal";
-import { ZodMapDef } from "./types/map";
-import { ZodNativeEnumDef } from "./types/nativeEnum";
-import { ZodNeverDef } from "./types/never";
-import { ZodNullDef } from "./types/null";
-import { ZodNullableDef } from "./types/nullable";
-import { ZodNumberDef } from "./types/number";
-import { ZodObjectDef } from "./types/object";
-import { ZodOptionalDef } from "./types/optional";
-import { ZodPromiseDef } from "./types/promise";
-import { ZodRecordDef } from "./types/record";
-import { ZodStringDef } from "./types/string";
-import { ZodTransformerDef } from "./types/transformer";
-import { ZodTupleDef } from "./types/tuple";
-import { ZodUndefinedDef } from "./types/undefined";
-import { ZodUnionDef } from "./types/union";
-import { ZodUnknownDef } from "./types/unknown";
-import { ZodVoidDef } from "./types/void";
-
-export type ZodDef =
-  | ZodStringDef
-  | ZodNumberDef
-  | ZodBigIntDef
-  | ZodBooleanDef
-  | ZodDateDef
-  | ZodUndefinedDef
-  | ZodNullDef
-  | ZodAnyDef
-  | ZodUnknownDef
-  | ZodNeverDef
-  | ZodVoidDef
-  | ZodArrayDef
-  | ZodObjectDef
-  | ZodUnionDef
-  | ZodIntersectionDef
-  | ZodTupleDef
-  | ZodRecordDef
-  | ZodMapDef
-  | ZodFunctionDef
-  | ZodLazyDef
-  | ZodLiteralDef
-  | ZodEnumDef
-  | ZodTransformerDef
-  | ZodNativeEnumDef
-  | ZodOptionalDef
-  | ZodNullableDef
-  | ZodPromiseDef;
diff --git a/src/ZodError.ts b/src/ZodError.ts
index 9a6930ddf..5ee38d2f8 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -1,12 +1,10 @@
+import { ZodParsedType } from "./helpers/parseUtil";
 import { util } from "./helpers/util";
-import { ZodParsedType } from "./ZodParsedType";
 
 export const ZodIssueCode = util.arrayToEnum([
   "invalid_type",
-  "nonempty_array_is_empty",
   "custom",
   "invalid_union",
-  "invalid_literal_value",
   "invalid_enum_value",
   "unrecognized_keys",
   "invalid_arguments",
@@ -15,7 +13,6 @@ export const ZodIssueCode = util.arrayToEnum([
   "invalid_string",
   "too_small",
   "too_big",
-  "invalid_intersection_types",
 ]);
 
 export type ZodIssueCode = keyof typeof ZodIssueCode;
@@ -32,10 +29,6 @@ export interface ZodInvalidTypeIssue extends ZodIssueBase {
   received: ZodParsedType;
 }
 
-export interface ZodNonEmptyArrayIsEmptyIssue extends ZodIssueBase {
-  code: typeof ZodIssueCode.nonempty_array_is_empty;
-}
-
 export interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.unrecognized_keys;
   keys: string[];
@@ -46,11 +39,6 @@ export interface ZodInvalidUnionIssue extends ZodIssueBase {
   unionErrors: ZodError[];
 }
 
-export interface ZodInvalidLiteralValueIssue extends ZodIssueBase {
-  code: typeof ZodIssueCode.invalid_literal_value;
-  expected: string | number | boolean;
-}
-
 export interface ZodInvalidEnumValueIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.invalid_enum_value;
   options: (string | number)[];
@@ -91,21 +79,19 @@ export interface ZodTooBigIssue extends ZodIssueBase {
   type: "array" | "string" | "number";
 }
 
-export interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
-  code: typeof ZodIssueCode.invalid_intersection_types;
-}
-
 export interface ZodCustomIssue extends ZodIssueBase {
   code: typeof ZodIssueCode.custom;
   params?: { [k: string]: any };
 }
 
+export type DenormalizedError = { [k: string]: DenormalizedError | string[] };
+
 export type ZodIssueOptionalMessage =
   | ZodInvalidTypeIssue
-  | ZodNonEmptyArrayIsEmptyIssue
+  // | ZodNonEmptyArrayIsEmptyIssue
   | ZodUnrecognizedKeysIssue
   | ZodInvalidUnionIssue
-  | ZodInvalidLiteralValueIssue
+  // | ZodInvalidLiteralValueIssue
   | ZodInvalidEnumValueIssue
   | ZodInvalidArgumentsIssue
   | ZodInvalidReturnTypeIssue
@@ -113,7 +99,6 @@ export type ZodIssueOptionalMessage =
   | ZodInvalidStringIssue
   | ZodTooSmallIssue
   | ZodTooBigIssue
-  | ZodInvalidIntersectionTypesIssue
   | ZodCustomIssue;
 
 export type ZodIssue = ZodIssueOptionalMessage & { message: string };
@@ -123,7 +108,15 @@ export const quotelessJson = (obj: any) => {
   return json.replace(/"([^"]+)":/g, "$1:");
 };
 
-export class ZodError extends Error {
+export type ZodFormattedError<T> = T extends [any, ...any]
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+  : T extends any[]
+  ? ZodFormattedError<T[number]>[] & { _errors: string[] }
+  : T extends object
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+  : { _errors: string[] };
+
+export class ZodError<T = any> extends Error {
   issues: ZodIssue[] = [];
 
   get errors() {
@@ -138,11 +131,57 @@ export class ZodError extends Error {
     this.issues = issues;
   }
 
+  format = (): ZodFormattedError<T> => {
+    const fieldErrors: ZodFormattedError<T> = { _errors: [] } as any;
+    const processError = (error: ZodError) => {
+      for (const issue of error.issues) {
+        if (issue.code === "invalid_union") {
+          issue.unionErrors.map(processError);
+        } else if (issue.code === "invalid_return_type") {
+          processError(issue.returnTypeError);
+        } else if (issue.code === "invalid_arguments") {
+          processError(issue.argumentsError);
+        } else if (issue.path.length === 0) {
+          fieldErrors._errors.push(issue.message);
+        } else {
+          let curr: any = fieldErrors;
+          let i = 0;
+          while (i < issue.path.length) {
+            const el = issue.path[i];
+            const terminal = i === issue.path.length - 1;
+
+            if (!terminal) {
+              if (typeof el === "string") {
+                curr[el] = curr[el] || { _errors: [] };
+              } else if (typeof el === "number") {
+                const errorArray: any = [];
+                errorArray._errors = [];
+                curr[el] = curr[el] || errorArray;
+              }
+            } else {
+              curr[el] = curr[el] || { _errors: [] };
+              curr[el]._errors.push(issue.message);
+            }
+
+            curr = curr[el];
+            i++;
+          }
+        }
+      }
+    };
+
+    processError(this);
+    return fieldErrors;
+  };
+
   static create = (issues: ZodIssue[]) => {
     const error = new ZodError(issues);
     return error;
   };
 
+  toString() {
+    return `ZodError: ${JSON.stringify(this.issues, null, 2)}`;
+  }
   get message() {
     return JSON.stringify(this.issues, null, 2);
     // const errorMessage: string[] = [
@@ -195,6 +234,10 @@ export class ZodError extends Error {
     return { formErrors, fieldErrors };
   };
 
+  // denormalize = ():DenormalizedError{
+
+  // }
+
   get formErrors() {
     return this.flatten();
   }
@@ -207,3 +250,112 @@ type stripPath<T extends object> = T extends any
 export type MakeErrorData = stripPath<ZodIssueOptionalMessage> & {
   path?: (string | number)[];
 };
+
+type ErrorMapCtx = {
+  // path: (string | number)[];
+  // details: any;
+  defaultError: string;
+  data: any;
+  // metadata: object;
+};
+
+export type ZodErrorMap = typeof defaultErrorMap;
+export let defaultErrorMap = (
+  error: ZodIssueOptionalMessage,
+  _ctx: ErrorMapCtx
+): { message: string } => {
+  let message: string;
+  switch (error.code) {
+    case ZodIssueCode.invalid_type:
+      if (error.received === "undefined") {
+        message = "Required";
+      } else {
+        message = `Expected ${error.expected}, received ${error.received}`;
+      }
+      break;
+    case ZodIssueCode.unrecognized_keys:
+      message = `Unrecognized key(s) in object: ${error.keys
+        .map((k) => `'${k}'`)
+        .join(", ")}`;
+      break;
+    case ZodIssueCode.invalid_union:
+      message = `Invalid input`;
+      break;
+    case ZodIssueCode.invalid_enum_value:
+      message = `Invalid enum value. Expected ${error.options
+        .map((val) => (typeof val === "string" ? `'${val}'` : val))
+        .join(" | ")}, received ${
+        typeof _ctx.data === "string" ? `'${_ctx.data}'` : _ctx.data
+      }`;
+      break;
+    case ZodIssueCode.invalid_arguments:
+      message = `Invalid function arguments`;
+      break;
+    case ZodIssueCode.invalid_return_type:
+      message = `Invalid function return type`;
+      break;
+    case ZodIssueCode.invalid_date:
+      message = `Invalid date`;
+      break;
+    // case ZodIssueCode.too_small:
+    //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
+    //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
+    //   break;
+    // case ZodIssueCode.too_big:
+    //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
+    //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
+    //   break;
+    case ZodIssueCode.invalid_string:
+      if (error.validation !== "regex") message = `Invalid ${error.validation}`;
+      else message = "Invalid";
+      break;
+    // case ZodIssueCode.invalid_url:
+    //   message = 'Invalid URL.';
+    //   break;
+    // case ZodIssueCode.invalid_uuid:
+    //   message = 'Invalid UUID.';
+    //   break;
+    case ZodIssueCode.too_small:
+      if (error.type === "array")
+        message = `Should have ${error.inclusive ? `at least` : `more than`} ${
+          error.minimum
+        } items`;
+      else if (error.type === "string")
+        message = `Should be ${error.inclusive ? `at least` : `over`} ${
+          error.minimum
+        } characters`;
+      else if (error.type === "number")
+        message = `Value should be greater than ${
+          error.inclusive ? `or equal to ` : ``
+        }${error.minimum}`;
+      else message = "Invalid input";
+      break;
+    case ZodIssueCode.too_big:
+      if (error.type === "array")
+        message = `Should have ${error.inclusive ? `at most` : `less than`} ${
+          error.maximum
+        } items`;
+      else if (error.type === "string")
+        message = `Should be ${error.inclusive ? `at most` : `under`} ${
+          error.maximum
+        } characters long`;
+      else if (error.type === "number")
+        message = `Value should be less than ${
+          error.inclusive ? `or equal to ` : ``
+        }${error.maximum}`;
+      else message = "Invalid input";
+      break;
+    case ZodIssueCode.custom:
+      message = `Invalid input.`;
+      break;
+    default:
+      message = `Invalid input.`;
+      util.assertNever(error);
+  }
+  return { message };
+  // return `Invalid input.`;
+};
+
+export const setErrorMap = (map: ZodErrorMap) => {
+  defaultErrorMap = map;
+};
diff --git a/src/ZodParsedType.ts b/src/ZodParsedType.ts
deleted file mode 100644
index a6a0910e2..000000000
--- a/src/ZodParsedType.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-import { util } from "./helpers/util";
-
-export const ZodParsedType = util.arrayToEnum([
-  "string",
-  "nan",
-  "number",
-  "integer",
-  "boolean",
-  "date",
-  "bigint",
-  "symbol",
-  "function",
-  "undefined",
-  "null",
-  "array",
-  "object",
-  "unknown",
-  "promise",
-  "void",
-  "never",
-  "map",
-]);
-
-export type ZodParsedType = keyof typeof ZodParsedType;
diff --git a/src/ZodTypes.ts b/src/ZodTypes.ts
deleted file mode 100644
index a5fc596cd..000000000
--- a/src/ZodTypes.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-export enum ZodTypes {
-  string = "string",
-  number = "number",
-  bigint = "bigint",
-  boolean = "boolean",
-  date = "date",
-  undefined = "undefined",
-  null = "null",
-  array = "array",
-  object = "object",
-  union = "union",
-  intersection = "intersection",
-  tuple = "tuple",
-  record = "record",
-  map = "map",
-  function = "function",
-  lazy = "lazy",
-  literal = "literal",
-  enum = "enum",
-  nativeEnum = "nativeEnum",
-  promise = "promise",
-  any = "any",
-  unknown = "unknown",
-  never = "never",
-  void = "void",
-  transformer = "transformer",
-  optional = "optional",
-  nullable = "nullable",
-}
diff --git a/src/helpers/Mocker.ts b/src/__tests__/Mocker.ts
similarity index 100%
rename from src/helpers/Mocker.ts
rename to src/__tests__/Mocker.ts
diff --git a/src/__tests__/anyunknown.test.ts b/src/__tests__/anyunknown.test.ts
index bccc79cc2..6e27bd001 100644
--- a/src/__tests__/anyunknown.test.ts
+++ b/src/__tests__/anyunknown.test.ts
@@ -8,7 +8,6 @@ test("check any inference", () => {
   const t1 = z.any();
   t1.optional();
   t1.nullable();
-  t1.toJSON();
   type t1 = z.infer<typeof t1>;
   const f1: util.AssertEqual<t1, any> = true;
   expect(f1).toBeTruthy();
@@ -18,7 +17,6 @@ test("check unknown inference", () => {
   const t1 = z.unknown();
   t1.optional();
   t1.nullable();
-  t1.toJSON();
   type t1 = z.infer<typeof t1>;
   const f1: util.AssertEqual<t1, unknown> = true;
   expect(f1).toBeTruthy();
diff --git a/src/__tests__/array.test.ts b/src/__tests__/array.test.ts
index e31d4937d..1557254af 100644
--- a/src/__tests__/array.test.ts
+++ b/src/__tests__/array.test.ts
@@ -4,13 +4,9 @@ import { expect, test } from "@jest/globals";
 import * as z from "../index";
 
 const minTwo = z.string().array().min(2);
-
 const maxTwo = z.string().array().max(2);
-
 const justTwo = z.string().array().length(2);
-
 const intNum = z.string().array().nonempty();
-
 const nonEmptyMax = z.string().array().nonempty().max(2);
 
 test("passing validations", () => {
diff --git a/src/__tests__/async-parsing.test.ts b/src/__tests__/async-parsing.test.ts
index 9f1346d50..4edf7e9a3 100644
--- a/src/__tests__/async-parsing.test.ts
+++ b/src/__tests__/async-parsing.test.ts
@@ -1,10 +1,11 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-import * as z from "..";
+import * as z from "../index";
 
 /// string
 const stringSchema = z.string();
+
 test("string async parse", async () => {
   const goodData = "XXX";
   const badData = 12;
@@ -198,27 +199,6 @@ test("union async parse", async () => {
   if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
 });
 
-/// tuple
-// const stringToNumber = z.transformer(
-//   z.string(),
-//   z.number(),
-//   (v) => v.length + 10
-// );
-
-// const tupleSchema = z.tuple([stringToNumber, z.object({})]);
-// test("tuple async parse", async () => {
-//   const goodData = ["XXX", {}];
-//   const badData = [12, {}];
-
-//   const goodResult = await tupleSchema.safeParseAsync(goodData);
-//   expect(goodResult.success).toBe(true);
-//   if (goodResult.success) expect(goodResult.data).toEqual([13, {}]);
-
-//   const badResult = await tupleSchema.safeParseAsync(badData);
-//   expect(badResult.success).toBe(false);
-//   if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
-// });
-
 /// record
 const recordSchema = z.record(z.object({}));
 test("record async parse", async () => {
@@ -300,38 +280,34 @@ test("nativeEnum async parse", async () => {
 
 /// promise
 const promiseSchema = z.promise(z.number());
-test("promise async parse", async () => {
+test("promise async parse good", async () => {
   const goodData = Promise.resolve(123);
-  const badData = Promise.resolve("XXX");
 
   const goodResult = await promiseSchema.safeParseAsync(goodData);
   expect(goodResult.success).toBe(true);
-  if (goodResult.success) expect(goodResult.data).toEqual(123);
+  if (goodResult.success) {
+    expect(goodResult.data).toBeInstanceOf(Promise);
+    const data = await goodResult.data;
+    expect(data).toEqual(123);
+    // expect(goodResult.data).resolves.toEqual(124);
+    // return goodResult.data;
+  } else {
+    throw new Error("success should be true");
+  }
+});
 
+test("promise async parse bad", async () => {
+  const badData = Promise.resolve("XXX");
   const badResult = await promiseSchema.safeParseAsync(badData);
-  expect(badResult.success).toBe(false);
-  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
+  expect(badResult.success).toBe(true);
+  if (badResult.success) {
+    await expect(badResult.data).rejects.toBeInstanceOf(Error);
+  } else {
+    console.log(`SUCCESS SHOULD BE TRUE`);
+    throw new Error("success should be true");
+  }
 });
 
-/// transformer
-// const transformerSchema = z.transformer(
-//   z.number(),
-//   z.string(),
-//   async (val) => `${Math.pow(val, 2)}`
-// );
-// test("transformer async parse", async () => {
-//   const goodData = 5;
-//   const badData = "5";
-
-//   const goodResult = await transformerSchema.safeParseAsync(goodData);
-//   expect(goodResult.success).toBe(true);
-//   if (goodResult.success) expect(goodResult.data).toEqual("25");
-
-//   const badResult = await transformerSchema.safeParseAsync(badData);
-//   expect(badResult.success).toBe(false);
-//   if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
-// });
-
 test("async validation non-empty strings", async () => {
   const base = z.object({
     hello: z.string().refine((x) => x && x.length > 0),
diff --git a/src/__tests__/async-refinements.test.ts b/src/__tests__/async-refinements.test.ts
index 2c2270c4d..c9b5319c6 100644
--- a/src/__tests__/async-refinements.test.ts
+++ b/src/__tests__/async-refinements.test.ts
@@ -1,7 +1,7 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-import * as z from "..";
+import * as z from "../index";
 
 test("parse async test", async () => {
   const schema1 = z.string().refine(async (_val) => false);
@@ -39,7 +39,7 @@ test("parseAsync async with value", async () => {
   const schema1 = z.string().refine(async (val) => {
     return val.length > 5;
   });
-  expect(schema1.parseAsync("asdf")).rejects.toBeDefined();
+  await expect(schema1.parseAsync("asdf")).rejects.toBeDefined();
 
   const v = await schema1.parseAsync("asdf123");
   return await expect(v).toEqual("asdf123");
diff --git a/src/__tests__/base.test.ts b/src/__tests__/base.test.ts
index 3fabec794..85b4a2ba0 100644
--- a/src/__tests__/base.test.ts
+++ b/src/__tests__/base.test.ts
@@ -1,8 +1,8 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-import * as z from "..";
 import { util } from "../helpers/util";
+import * as z from "../index";
 
 test("type guard", () => {
   const stringToNumber = z.string().transform((arg) => arg.length);
diff --git a/src/__tests__/codegen.test.ts b/src/__tests__/codegen.test.ts
deleted file mode 100644
index 73613cf8e..000000000
--- a/src/__tests__/codegen.test.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-// @ts-ignore TS6133
-import { expect, test } from "@jest/globals";
-
-import { crazySchema } from "../crazySchema";
-import * as z from "../index";
-
-test("ZodCodeGenerator", () => {
-  const gen = new z.ZodCodeGenerator();
-  gen.generate(crazySchema);
-  gen.dump();
-});
diff --git a/src/__tests__/complex.test.ts b/src/__tests__/complex.test.ts
index b4b0655b0..6676ccf2d 100644
--- a/src/__tests__/complex.test.ts
+++ b/src/__tests__/complex.test.ts
@@ -1,8 +1,8 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-import { crazySchema } from "../crazySchema";
-import * as z from "../index";
+import { crazySchema } from "./crazySchema";
+// import * as z from "../index";
 
 test("parse", () => {
   crazySchema.parse({
@@ -10,23 +10,10 @@ test("parse", () => {
     merged: { k1: "asdf", k2: 12 },
     union: ["asdf", 12, "asdf", 12, "asdf", 12],
     array: [12, 15, 16],
-    // sumTransformer: [12, 15, 16],
     sumMinLength: [12, 15, 16, 98, 24, 63],
-    intersection: {},
-    enum: "one",
+    mergedObjects: { p1: 3.154 },
     nonstrict: { points: 1234 },
     numProm: Promise.resolve(12),
     lenfun: (x: string) => x.length,
   });
-
-  // expect(typeof value.sumTransformer).toEqual("number");
-});
-
-test("to JSON", () => {
-  crazySchema.toJSON();
-});
-
-test("ZodCodeGenerator", () => {
-  const gen = new z.ZodCodeGenerator();
-  gen.generate(crazySchema);
 });
diff --git a/deno/lib/crazySchema.ts b/src/__tests__/crazySchema.ts
similarity index 62%
rename from deno/lib/crazySchema.ts
rename to src/__tests__/crazySchema.ts
index 06318bd20..81088e589 100644
--- a/deno/lib/crazySchema.ts
+++ b/src/__tests__/crazySchema.ts
@@ -1,4 +1,4 @@
-import * as z from "./index.ts";
+import * as z from "../index";
 
 export const crazySchema = z.object({
   tuple: z.tuple([
@@ -16,27 +16,15 @@ export const crazySchema = z.object({
     .merge(z.object({ k1: z.string().nullable(), k2: z.number() })),
   union: z.array(z.union([z.literal("asdf"), z.literal(12)])).nonempty(),
   array: z.array(z.number()),
-  // sumTransformer: z.transformer(z.array(z.number()), z.number(), (arg) => {
-  //   return arg.reduce((a, b) => a + b, 0);
-  // }),
   sumMinLength: z.array(z.number()).refine((arg) => arg.length > 5),
-  intersection: z.intersection(
-    z.object({ p1: z.string().optional() }),
-    z.object({ p1: z.number().optional() })
-  ),
-  enum: z.intersection(z.enum(["zero", "one"]), z.enum(["one", "two"])),
+  mergedObjects: z
+    .object({ p1: z.string().optional() })
+    .merge(z.object({ p1: z.number().optional() })),
   nonstrict: z.object({ points: z.number() }).nonstrict(),
   numProm: z.promise(z.number()),
   lenfun: z.function(z.tuple([z.string()]), z.boolean()),
 });
 
 export const asyncCrazySchema = crazySchema.extend({
-  // async_transform: z.transformer(
-  //   z.array(z.number()),
-  //   z.number(),
-  //   async (arg) => {
-  //     return arg.reduce((a, b) => a + b, 0);
-  //   }
-  // ),
   async_refine: z.array(z.number()).refine(async (arg) => arg.length > 5),
 });
diff --git a/src/__tests__/default.test.ts b/src/__tests__/default.test.ts
new file mode 100644
index 000000000..af745b6f9
--- /dev/null
+++ b/src/__tests__/default.test.ts
@@ -0,0 +1,95 @@
+// @ts-ignore TS6133
+import { expect, test } from "@jest/globals";
+
+import { z } from "..";
+import { util } from "../helpers/util";
+
+test("basic defaults", () => {
+  expect(z.string().default("default").parse(undefined)).toBe("default");
+});
+
+test("default with transform", () => {
+  const stringWithDefault = z
+    .string()
+    .transform((val) => val.toUpperCase())
+    .default("default");
+  expect(stringWithDefault.parse(undefined)).toBe("DEFAULT");
+  expect(stringWithDefault).toBeInstanceOf(z.ZodOptional);
+  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodEffects);
+  expect(stringWithDefault._def.innerType._def.schema).toBeInstanceOf(
+    z.ZodSchema
+  );
+
+  type inp = z.input<typeof stringWithDefault>;
+  const f1: util.AssertEqual<inp, string | undefined> = true;
+  type out = z.output<typeof stringWithDefault>;
+  const f2: util.AssertEqual<out, string> = true;
+  f1;
+  f2;
+});
+
+test("default on optional", () => {
+  const stringWithDefault = z.string().optional().default("asdf");
+  expect(stringWithDefault.parse(undefined)).toBe("asdf");
+  expect(stringWithDefault).toBeInstanceOf(z.ZodOptional);
+  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodString);
+  type inp = z.input<typeof stringWithDefault>;
+  const f1: util.AssertEqual<inp, string | undefined> = true;
+  type out = z.output<typeof stringWithDefault>;
+  const f2: util.AssertEqual<out, string> = true;
+  f1;
+  f2;
+});
+
+test("optional on default", () => {
+  const stringWithDefault = z.string().default("asdf").optional();
+
+  type inp = z.input<typeof stringWithDefault>;
+  const f1: util.AssertEqual<inp, string | undefined> = true;
+  type out = z.output<typeof stringWithDefault>;
+  const f2: util.AssertEqual<out, string> = true;
+  f1;
+  f2;
+});
+
+test("complex chain example", () => {
+  const complex = z
+    .string()
+    .default("asdf")
+    .optional()
+    .transform((val) => val.toUpperCase())
+    .default("qwer")
+    .removeDefault()
+    .optional()
+    .default("asdfasdf");
+
+  expect(complex.parse(undefined)).toBe("ASDFASDF");
+});
+
+test("removeDefault", () => {
+  const stringWithRemovedDefault = z.string().default("asdf").removeDefault();
+
+  type out = z.output<typeof stringWithRemovedDefault>;
+  const f2: util.AssertEqual<out, string | undefined> = true;
+  f2;
+  expect(stringWithRemovedDefault.parse(undefined)).toBe(undefined);
+});
+
+test("nested", () => {
+  const inner = z.string().default("asdf");
+  const outer = z.object({ inner }).default({
+    inner: undefined,
+  });
+  type input = z.input<typeof outer>;
+  const f1: util.AssertEqual<
+    input,
+    { inner?: string | undefined } | undefined
+  > = true;
+  type out = z.output<typeof outer>;
+  const f2: util.AssertEqual<out, { inner: string }> = true;
+  f1;
+  f2;
+  expect(outer.parse(undefined)).toEqual({ inner: "asdf" });
+  expect(outer.parse({})).toEqual({ inner: "asdf" });
+  expect(outer.parse({ inner: undefined })).toEqual({ inner: "asdf" });
+});
diff --git a/src/__tests__/error.test.ts b/src/__tests__/error.test.ts
index 373a0eb0d..62e8d9d50 100644
--- a/src/__tests__/error.test.ts
+++ b/src/__tests__/error.test.ts
@@ -1,9 +1,9 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
+import { ZodParsedType } from "../helpers/parseUtil";
 import * as z from "../index";
 import { ZodError, ZodIssueCode } from "../ZodError";
-import { ZodParsedType } from "../ZodParsedType";
 
 test("error creation", () => {
   const err1 = ZodError.create([]);
@@ -39,7 +39,7 @@ const errorMap: z.ZodErrorMap = (error, ctx) => {
 
 test("type error with custom error map", () => {
   try {
-    z.string().parse("asdf", { errorMap });
+    z.string().parse(234, { errorMap });
   } catch (err) {
     const zerr: z.ZodError = err;
 
@@ -132,23 +132,23 @@ test("array minimum", () => {
 });
 
 // implement test for semi-smart union logic that checks for type error on either left or right
-test("union smart errors", () => {
-  // expect.assertions(2);
-
-  const p1 = z
-    .union([z.string(), z.number().refine((x) => x > 0)])
-    .safeParse(-3.2);
-
-  if (p1.success === true) throw new Error();
-  expect(p1.success).toBe(false);
-  expect(p1.error.issues[0].code).toEqual(ZodIssueCode.custom);
-
-  const p2 = z.union([z.string(), z.number()]).safeParse(false);
-  // .catch(err => expect(err.issues[0].code).toEqual(ZodIssueCode.invalid_union));
-  if (p2.success === true) throw new Error();
-  expect(p2.success).toBe(false);
-  expect(p2.error.issues[0].code).toEqual(ZodIssueCode.invalid_union);
-});
+// test("union smart errors", () => {
+//   // expect.assertions(2);
+
+//   const p1 = z
+//     .union([z.string(), z.number().refine((x) => x > 0)])
+//     .safeParse(-3.2);
+
+//   if (p1.success === true) throw new Error();
+//   expect(p1.success).toBe(false);
+//   expect(p1.error.issues[0].code).toEqual(ZodIssueCode.custom);
+
+//   const p2 = z.union([z.string(), z.number()]).safeParse(false);
+//   // .catch(err => expect(err.issues[0].code).toEqual(ZodIssueCode.invalid_union));
+//   if (p2.success === true) throw new Error();
+//   expect(p2.success).toBe(false);
+//   expect(p2.error.issues[0].code).toEqual(ZodIssueCode.invalid_union);
+// });
 
 test("custom path in custom error map", () => {
   const schema = z.object({
@@ -197,3 +197,75 @@ test("error metadata from value", () => {
 
 //   expect(() => asdf.safeParse("foo")).not.toThrow();
 // });
+
+test("root level formatting", () => {
+  const schema = z.string().email();
+  const result = schema.safeParse("asdfsdf");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.format()._errors).toEqual(["Invalid email"]);
+  }
+});
+
+test("custom path", () => {
+  const schema = z
+    .object({
+      password: z.string(),
+      confirm: z.string(),
+    })
+    .refine((val) => val.confirm === val.password, { path: ["confirm"] });
+
+  const result = schema.safeParse({
+    password: "peanuts",
+    confirm: "qeanuts",
+  });
+
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    const error = result.error.format();
+    expect(error._errors).toEqual([]);
+    expect(error.password?._errors).toEqual(undefined);
+    expect(error.confirm?._errors).toEqual(["Invalid input."]);
+  }
+});
+
+test("formatting", () => {
+  const schema = z.object({
+    inner: z.object({
+      name: z
+        .string()
+        .refine((val) => val.length > 5)
+        .array()
+        .refine((val) => val.length <= 1),
+    }),
+  });
+
+  const invalidItem = {
+    inner: { name: ["aasd", "asdfasdfasfd"] },
+  };
+  const invalidArray = {
+    inner: { name: ["asdfasdf", "asdfasdfasfd"] },
+  };
+  const result1 = schema.safeParse(invalidItem);
+  const result2 = schema.safeParse(invalidArray);
+
+  expect(result1.success).toEqual(false);
+  expect(result2.success).toEqual(false);
+  if (!result1.success) {
+    const error = result1.error.format();
+    expect(error._errors).toEqual([]);
+    expect(error.inner?._errors).toEqual([]);
+    expect(error.inner?.name?._errors).toEqual([]);
+    expect(error.inner?.name?.[0]._errors).toEqual(["Invalid value."]);
+    expect(error.inner?.name?.[1]).toEqual(undefined);
+  }
+  if (!result2.success) {
+    const error = result2.error.format();
+    expect(error._errors).toEqual([]);
+    expect(error.inner?._errors).toEqual([]);
+    expect(error.inner?.name?._errors).toEqual(["Invalid value."]);
+    expect(error.inner?.name?.[0]).toEqual(undefined);
+    expect(error.inner?.name?.[1]).toEqual(undefined);
+    expect(error.inner?.name?.[2]).toEqual(undefined);
+  }
+});
diff --git a/src/__tests__/intersection.test.ts b/src/__tests__/intersection.test.ts
deleted file mode 100644
index 7784ef2fc..000000000
--- a/src/__tests__/intersection.test.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-// @ts-ignore TS6133
-import { expect, test } from "@jest/globals";
-
-import * as z from "..";
-
-test("object intersection", () => {
-  const BaseTeacher = z.object({
-    subjects: z.array(z.string()),
-  });
-  const HasID = z.object({ id: z.string() });
-
-  const Teacher = z.intersection(BaseTeacher.passthrough(), HasID); // BaseTeacher.merge(HasID);
-  const data = {
-    subjects: ["math"],
-    id: "asdfasdf",
-  };
-  expect(Teacher.parse(data)).toEqual(data);
-  expect(() => Teacher.parse({ subject: data.subjects })).toThrow();
-  expect(Teacher.parse({ ...data, extra: 12 })).toEqual({ ...data, extra: 12 });
-
-  expect(() =>
-    z.intersection(BaseTeacher.strict(), HasID).parse({ ...data, extra: 12 })
-  ).toThrow();
-});
diff --git a/src/__tests__/masking.test.ts b/src/__tests__/masking.test.ts
index 826e7da9c..85de4ca5b 100644
--- a/src/__tests__/masking.test.ts
+++ b/src/__tests__/masking.test.ts
@@ -1,7 +1,7 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-import * as z from "..";
+import * as z from "../index";
 
 test("masking test", () => {});
 
diff --git a/src/__tests__/mocker.test.ts b/src/__tests__/mocker.test.ts
index 00717f4ef..a4c5ca1e2 100644
--- a/src/__tests__/mocker.test.ts
+++ b/src/__tests__/mocker.test.ts
@@ -1,7 +1,7 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-import { Mocker } from "../helpers/Mocker";
+import { Mocker } from "./Mocker";
 
 test("mocker", () => {
   const mocker = new Mocker();
diff --git a/src/__tests__/nullable.test.ts b/src/__tests__/nullable.test.ts
new file mode 100644
index 000000000..7d5625e10
--- /dev/null
+++ b/src/__tests__/nullable.test.ts
@@ -0,0 +1,42 @@
+// @ts-ignore TS6133
+import { expect, test } from "@jest/globals";
+
+import * as z from "../index";
+
+function checkErrors(a: z.ZodTypeAny, bad: any) {
+  let expected;
+  try {
+    a.parse(bad);
+  } catch (error) {
+    expected = error.formErrors;
+  }
+  try {
+    a.nullable().parse(bad);
+  } catch (error) {
+    expect(error.formErrors).toEqual(expected);
+  }
+}
+
+test("Should have error messages appropriate for the underlying type", () => {
+  checkErrors(z.string().min(2), 1);
+  z.string().min(2).nullable().parse(null);
+  checkErrors(z.number().min(2), 1);
+  z.number().min(2).nullable().parse(null);
+  checkErrors(z.boolean(), "");
+  z.boolean().nullable().parse(null);
+  checkErrors(z.null(), null);
+  z.null().nullable().parse(null);
+  checkErrors(z.null(), {});
+  z.null().nullable().parse(null);
+  checkErrors(z.object({}), 1);
+  z.object({}).nullable().parse(null);
+  checkErrors(z.tuple([]), 1);
+  z.tuple([]).nullable().parse(null);
+  checkErrors(z.unknown(), 1);
+  z.unknown().nullable().parse(null);
+});
+
+test("unwrap", () => {
+  const unwrapped = z.string().nullable().unwrap();
+  expect(unwrapped).toBeInstanceOf(z.ZodString);
+});
diff --git a/src/__tests__/object.test.ts b/src/__tests__/object.test.ts
index abef33a30..28e062446 100644
--- a/src/__tests__/object.test.ts
+++ b/src/__tests__/object.test.ts
@@ -56,28 +56,6 @@ test("incorrect #1", () => {
   expect(() => Test.parse({} as any)).toThrow();
 });
 
-test("inference", () => {
-  const t1 = z.object({
-    name: z.string(),
-    obj: z.object({}),
-    arrayarray: z.array(z.array(z.string())),
-  });
-
-  const i1 = t1.primitives();
-  type i1 = z.infer<typeof i1>;
-  const f1: util.AssertEqual<i1, { name: string }> = true;
-
-  const i2 = t1.nonprimitives();
-  type i2 = z.infer<typeof i2>;
-  const f2: util.AssertEqual<i2, { obj: {}; arrayarray: string[][] }> = true;
-
-  expect(f1).toBeTruthy();
-  expect(f2).toBeTruthy();
-  i1.parse({ name: "name" });
-  i2.parse({ obj: {}, arrayarray: [["asdf"]] });
-  expect(() => i1.parse({} as any)).toThrow();
-});
-
 test("nonstrict by default", () => {
   z.object({ points: z.number() }).parse({
     points: 2314,
@@ -125,62 +103,6 @@ test("strict", () => {
   expect(val.success).toEqual(false);
 });
 
-test("primitives", () => {
-  const baseObj = z.object({
-    stringPrimitive: z.string(),
-    stringArrayPrimitive: z.array(z.string()),
-    numberPrimitive: z.number(),
-    numberArrayPrimitive: z.array(z.number()),
-    booleanPrimitive: z.boolean(),
-    booleanArrayPrimitive: z.array(z.boolean()),
-    bigintPrimitive: z.bigint(),
-    bigintArrayPrimitive: z.array(z.bigint()),
-    undefinedPrimitive: z.undefined(),
-    nullPrimitive: z.null(),
-    primitiveUnion: z.union([z.string(), z.number()]),
-    primitiveIntersection: z.intersection(z.string(), z.string()),
-    lazyPrimitive: z.lazy(() => z.string()),
-    literalPrimitive: z.literal("sup"),
-    enumPrimitive: z.enum(["asdf", "qwer"]),
-    datePrimitive: z.date(),
-    primitiveTuple: z.tuple([z.string(), z.number()]),
-
-    nonprimitiveUnion: z.union([z.string(), z.object({})]),
-    object: z.object({}),
-    objectArray: z.object({}).array(),
-    arrayarray: z.array(z.array(z.string())),
-    nonprimitiveTuple: z.tuple([z.string(), z.number().array()]),
-  });
-
-  expect(Object.keys(baseObj.primitives().shape)).toEqual([
-    "stringPrimitive",
-    "stringArrayPrimitive",
-    "numberPrimitive",
-    "numberArrayPrimitive",
-    "booleanPrimitive",
-    "booleanArrayPrimitive",
-    "bigintPrimitive",
-    "bigintArrayPrimitive",
-    "undefinedPrimitive",
-    "nullPrimitive",
-    "primitiveUnion",
-    "primitiveIntersection",
-    "lazyPrimitive",
-    "literalPrimitive",
-    "enumPrimitive",
-    "datePrimitive",
-    "primitiveTuple",
-  ]);
-
-  expect(Object.keys(baseObj.nonprimitives().shape)).toEqual([
-    "nonprimitiveUnion",
-    "object",
-    "objectArray",
-    "arrayarray",
-    "nonprimitiveTuple",
-  ]);
-});
-
 test("catchall inference", () => {
   const o1 = z
     .object({
@@ -284,3 +206,33 @@ test("test async PseudoPromise.all", async () => {
   const result = await Schema2.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21
   expect(result.success).toEqual(true);
 });
+
+test("merging", () => {
+  const BaseTeacher = z.object({
+    subjects: z.array(z.string()),
+  });
+  const HasID = z.object({ id: z.string() });
+
+  const Teacher = BaseTeacher.merge(HasID);
+
+  const data = {
+    subjects: ["math"],
+    id: "asdfasdf",
+  };
+  expect(Teacher.parse(data)).toEqual(data);
+  expect(() => Teacher.parse({ subject: data.subjects })).toThrow();
+  expect(
+    BaseTeacher.passthrough()
+      .merge(HasID)
+      .parse({ ...data, extra: 12 })
+  ).toEqual({
+    ...data,
+    extra: 12,
+  });
+
+  expect(() =>
+    BaseTeacher.strict()
+      .merge(HasID)
+      .parse({ ...data, extra: 12 })
+  ).toThrow();
+});
diff --git a/src/__tests__/optional.test.ts b/src/__tests__/optional.test.ts
index e8b7ef494..4f879beb4 100644
--- a/src/__tests__/optional.test.ts
+++ b/src/__tests__/optional.test.ts
@@ -35,3 +35,8 @@ test("Should have error messages appropriate for the underlying type", () => {
   checkErrors(z.unknown(), 1);
   z.unknown().optional().parse(undefined);
 });
+
+test("unwrap", () => {
+  const unwrapped = z.string().optional().unwrap();
+  expect(unwrapped).toBeInstanceOf(z.ZodString);
+});
diff --git a/src/__tests__/parser.test.ts b/src/__tests__/parser.test.ts
index 5769fafd7..01058cfdf 100644
--- a/src/__tests__/parser.test.ts
+++ b/src/__tests__/parser.test.ts
@@ -18,18 +18,6 @@ test("parse nonstrict object with unknown keys", () => {
     .parse({ name: "bill", unknownKey: 12 });
 });
 
-test("invalid left side of intersection", () => {
-  expect(() =>
-    z.intersection(z.string(), z.number()).parse(12 as any)
-  ).toThrow();
-});
-
-test("invalid right side of intersection", () => {
-  expect(() =>
-    z.intersection(z.string(), z.number()).parse("12" as any)
-  ).toThrow();
-});
-
 test("parsing non-array in tuple schema", () => {
   expect(() => z.tuple([]).parse("12" as any)).toThrow();
 });
diff --git a/src/__tests__/partials.test.ts b/src/__tests__/partials.test.ts
index 721cc2996..b09292e98 100644
--- a/src/__tests__/partials.test.ts
+++ b/src/__tests__/partials.test.ts
@@ -48,6 +48,7 @@ test("deep partial inference", () => {
 
 test("deep partial parse", () => {
   const deep = nested.deepPartial();
+
   expect(deep.shape.name instanceof z.ZodOptional).toBe(true);
   expect(deep.shape.outer instanceof z.ZodOptional).toBe(true);
   expect(deep.shape.outer._def.innerType instanceof z.ZodObject).toBe(true);
diff --git a/src/__tests__/primitive.test.ts b/src/__tests__/primitive.test.ts
index d82dee3e4..d3bd5d992 100644
--- a/src/__tests__/primitive.test.ts
+++ b/src/__tests__/primitive.test.ts
@@ -1,8 +1,8 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-import { Mocker } from "../helpers/Mocker";
 import * as z from "../index";
+import { Mocker } from "./Mocker";
 
 const literalStringSchema = z.literal("asdf");
 const literalNumberSchema = z.literal(12);
diff --git a/src/__tests__/promise.test.ts b/src/__tests__/promise.test.ts
index 3dc5b3fc4..5e8ec938c 100644
--- a/src/__tests__/promise.test.ts
+++ b/src/__tests__/promise.test.ts
@@ -30,7 +30,15 @@ test("promise parsing success", async () => {
 });
 
 test("promise parsing success 2", () => {
-  promSchema.parse({ then: () => {}, catch: () => {} });
+  const fakePromise = {
+    then() {
+      return this;
+    },
+    catch() {
+      return this;
+    },
+  };
+  promSchema.parse(fakePromise);
 });
 
 test("promise parsing fail", async () => {
diff --git a/src/__tests__/record.test.ts b/src/__tests__/record.test.ts
index f673d99b3..30eb0dd90 100644
--- a/src/__tests__/record.test.ts
+++ b/src/__tests__/record.test.ts
@@ -13,7 +13,6 @@ test("type inference", () => {
 });
 
 test("methods", () => {
-  booleanRecord.toJSON();
   booleanRecord.optional();
   booleanRecord.nullable();
 });
diff --git a/src/__tests__/recursive.test.ts b/src/__tests__/recursive.test.ts
index c3338d29f..d8de21bb3 100644
--- a/src/__tests__/recursive.test.ts
+++ b/src/__tests__/recursive.test.ts
@@ -1,8 +1,50 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-test("test", () => {});
-// import * as z from '../index';
+import { z } from "..";
+
+interface Category {
+  name: string;
+  subcategories: Category[];
+}
+
+const testCategory: Category = {
+  name: "I",
+  subcategories: [
+    {
+      name: "A",
+      subcategories: [
+        {
+          name: "1",
+          subcategories: [
+            {
+              name: "a",
+              subcategories: [],
+            },
+          ],
+        },
+      ],
+    },
+  ],
+};
+
+test("recursion with z.late.object", () => {
+  const Category: z.Schema<Category> = z.late.object(() => ({
+    name: z.string(),
+    subcategories: z.array(Category),
+  }));
+  Category.parse(testCategory);
+});
+
+test("recursion with z.lazy", () => {
+  const Category: z.Schema<Category> = z.lazy(() =>
+    z.object({
+      name: z.string(),
+      subcategories: z.array(Category),
+    })
+  );
+  Category.parse(testCategory);
+});
 
 // interface A {
 //   val: number;
@@ -24,6 +66,16 @@ test("test", () => {});
 //   a: A,
 // }));
 
+// const Alazy: z.ZodType<A> = z.lazy(() => z.object({
+//   val: z.number(),
+//   b: B,
+// }));
+
+// const Blazy: z.ZodType<B> = z.lazy(() => z.object({
+//   val: z.number(),
+//   a: A,
+// }));
+
 // const a: any = { val: 1 };
 // const b: any = { val: 2 };
 // a.b = b;
@@ -34,6 +86,11 @@ test("test", () => {});
 //   B.parse(b);
 // });
 
+// test("valid check lazy", () => {
+//   A.parse({val:1, b:});
+//   B.parse(b);
+// });
+
 // test('masking check', () => {
 //   const FragmentOnA = z
 //     .object({
@@ -59,16 +116,11 @@ test("test", () => {});
 //   expect(() => A.parse({} as any)).toThrow();
 // });
 
-// test('toJSON throws', () => {
-//   const checker = () => A.toJSON();
-//   expect(checker).toThrow();
-// });
-
 // test('schema getter', () => {
 //   (A as z.ZodLazy<any>).schema;
 // });
 
-// test('self recursion', () => {
+// test("self recursion with cyclical data", () => {
 //   interface Category {
 //     name: string;
 //     subcategories: Category[];
@@ -80,14 +132,14 @@ test("test", () => {});
 //   }));
 
 //   const untypedCategory: any = {
-//     name: 'Category A',
+//     name: "Category A",
 //   };
 //   // creating a cycle
 //   untypedCategory.subcategories = [untypedCategory];
 //   Category.parse(untypedCategory);
 // });
 
-// test('self recursion with base type', () => {
+// test("self recursion with base type", () => {
 //   const BaseCategory = z.object({
 //     name: z.string(),
 //   });
@@ -104,96 +156,9 @@ test("test", () => {});
 //     });
 
 //   const untypedCategory: any = {
-//     name: 'Category A',
+//     name: "Category A",
 //   };
 //   // creating a cycle
 //   untypedCategory.subcategories = [untypedCategory];
 //   Category.parse(untypedCategory); // parses successfully
 // });
-
-// test('repeated parsing', () => {
-//   const extensions = z.object({
-//     name: z.string(),
-//   });
-
-//   const dog = z.object({
-//     extensions,
-//   });
-
-//   const cat = z.object({
-//     extensions,
-//   });
-
-//   const animal = z.union([dog, cat]);
-
-//   // it should output type error because name is ought to be type of string
-//   expect(() => animal.parse({ extensions: { name: 123 } })).toThrow;
-// });
-
-// test('repeated errors', () => {
-//   const Shape = z.array(
-//     z.object({
-//       name: z.string().nonempty(),
-//       value: z.string().nonempty(),
-//     }),
-//   );
-
-//   const data = [
-//     {
-//       name: 'Name 1',
-//       value: 'Value',
-//     },
-//     {
-//       name: '',
-//       value: 'Value',
-//     },
-//     {
-//       name: '',
-//       value: '',
-//     },
-//   ];
-
-//   try {
-//     Shape.parse(data);
-//   } catch (e) {
-//     if (e instanceof z.ZodError) {
-//       expect(e.issues.length).toEqual(3);
-//     }
-//   }
-// });
-
-// test('unions of object', () => {
-//   const base = z.object({
-//     id: z.string(),
-//   });
-
-//   const type1 = base.merge(
-//     z.object({
-//       type: z.literal('type1'),
-//     }),
-//   );
-
-//   const type2 = base.merge(
-//     z.object({
-//       type: z.literal('type2'),
-//     }),
-//   );
-
-//   const union1 = z.union([type1, type2]);
-//   const union2 = z.union([type2, type1]);
-
-//   const value1 = {
-//     type: 'type1',
-//   };
-
-//   const value2 = {
-//     type: 'type2',
-//   };
-
-//   expect(type1.check(value1)).toEqual(false);
-//   expect(union1.check(value1)).toEqual(false);
-//   expect(union2.check(value1)).toEqual(false);
-//   expect(type2.check(value2)).toEqual(false);
-//   expect(union1.check(value2)).toEqual(false);
-//   expect(union2.check(value2)).toEqual(false);
-// });
diff --git a/src/__tests__/refine.test.ts b/src/__tests__/refine.test.ts
index 48804f308..2ad4194ef 100644
--- a/src/__tests__/refine.test.ts
+++ b/src/__tests__/refine.test.ts
@@ -17,7 +17,7 @@ test("refinement", () => {
   );
 
   expect(obj1 === (obj2 as any)).toEqual(false);
-  expect(obj2 === obj3).toEqual(false);
+  expect(obj2 === (obj3 as any)).toEqual(false);
 
   expect(() => obj1.parse({})).toThrow();
   expect(() => obj2.parse({ third: "adsf" })).toThrow();
diff --git a/src/__tests__/set.test.ts b/src/__tests__/set.test.ts
new file mode 100644
index 000000000..3365233f7
--- /dev/null
+++ b/src/__tests__/set.test.ts
@@ -0,0 +1,56 @@
+// @ts-ignore TS6133
+import { expect, test } from "@jest/globals";
+
+import { util } from "../helpers/util";
+import * as z from "../index";
+import { ZodIssueCode } from "../index";
+
+const stringSet = z.set(z.string());
+type stringSet = z.infer<typeof stringSet>;
+
+test("type inference", () => {
+  const f1: util.AssertEqual<stringSet, Set<string>> = true;
+  f1;
+});
+
+test("doesn’t throw when a valid value is given", () => {
+  const result = stringSet.safeParse(new Set(["first", "second"]));
+  expect(result.success).toEqual(true);
+});
+
+test("doesn’t throw when an empty set is given", () => {
+  const result = stringSet.safeParse(new Set([]));
+  expect(result.success).toEqual(true);
+});
+
+test("throws when a Map is given", () => {
+  const result = stringSet.safeParse(new Map([]));
+  expect(result.success).toEqual(false);
+  if (result.success === false) {
+    expect(result.error.issues.length).toEqual(1);
+    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
+  }
+});
+
+test("throws when the given set has invalid value", () => {
+  const result = stringSet.safeParse(new Set([Symbol()]));
+  expect(result.success).toEqual(false);
+  if (result.success === false) {
+    expect(result.error.issues.length).toEqual(1);
+    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
+    expect(result.error.issues[0].path).toEqual([0]);
+  }
+});
+
+test("throws when the given set has multiple invalid entries", () => {
+  const result = stringSet.safeParse(new Set([1, 2] as any[]) as Set<any>);
+
+  expect(result.success).toEqual(false);
+  if (result.success === false) {
+    expect(result.error.issues.length).toEqual(2);
+    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
+    expect(result.error.issues[0].path).toEqual([0]);
+    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);
+    expect(result.error.issues[1].path).toEqual([1]);
+  }
+});
diff --git a/src/__tests__/string.test.ts b/src/__tests__/string.test.ts
index 4f13a450c..1ab4d40a9 100644
--- a/src/__tests__/string.test.ts
+++ b/src/__tests__/string.test.ts
@@ -65,10 +65,13 @@ test("url error overrides", () => {
 });
 
 test("uuid", () => {
-  z.string().uuid().parse("9491d710-3185-4e06-bea0-6a2f275345e0");
-  expect(() =>
-    z.string().uuid().parse("9491d710-3185-4e06-bea0-6a2f275345e")
-  ).toThrow();
+  const uuid = z.string().uuid("custom error");
+  uuid.parse("9491d710-3185-4e06-bea0-6a2f275345e0");
+  const result = uuid.safeParse("invalid uuid");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual("custom error");
+  }
 });
 
 test("regex", () => {
diff --git a/src/__tests__/transformer.test.ts b/src/__tests__/transformer.test.ts
index 891f9b0d4..d5e1c1016 100644
--- a/src/__tests__/transformer.test.ts
+++ b/src/__tests__/transformer.test.ts
@@ -1,8 +1,8 @@
 // @ts-ignore TS6133
 import { expect, test } from "@jest/globals";
 
-import * as z from "..";
 import { util } from "../helpers/util";
+import * as z from "../index";
 
 const stringToNumber = z.string().transform((arg) => parseFloat(arg));
 // const numberToString = z
@@ -63,7 +63,7 @@ test("default", () => {
 test("dynamic default", () => {
   const data = z
     .string()
-    .default((s) => s._def.t)
+    .default(() => "string")
     .parse(undefined); // => "asdf"
   expect(data).toEqual("string");
 });
diff --git a/src/__tests__/validations.test.ts b/src/__tests__/validations.test.ts
index 103cd8070..cdf87580e 100644
--- a/src/__tests__/validations.test.ts
+++ b/src/__tests__/validations.test.ts
@@ -107,3 +107,9 @@ test("instantiation", () => {
   z.string().url({ message: "Invalid url" });
   z.string().uuid({ message: "Invalid UUID" });
 });
+
+test("int", async () => {
+  const int = z.number().int();
+  int.parse(4);
+  expect(() => int.parse(3.5)).toThrow();
+});
diff --git a/src/codegen.ts b/src/codegen.ts
deleted file mode 100644
index 98006e3a0..000000000
--- a/src/codegen.ts
+++ /dev/null
@@ -1,182 +0,0 @@
-// import * as z from './index';
-
-import { util } from "./helpers/util";
-import { ZodDef, ZodType, ZodTypes } from ".";
-// import { ZodTypes } from "./ZodTypes";
-
-type TypeResult = { schema: any; id: string; type: string };
-
-const isOptional = (schema: ZodType<any, any>): boolean => {
-  // const def: z.ZodDef = schema._def;
-  // if (def.t === ZodTypes.undefined) return true;
-  // else if (def.t === ZodTypes.intersection) {
-  //   return isOptional(def.right) && isOptional(def.left);
-  // } else if (def.t === ZodTypes.union) {
-  //   return def.options.map(isOptional).some(x => x === true);
-  // }
-  // return false;
-
-  return schema.isOptional();
-};
-
-export class ZodCodeGenerator {
-  seen: TypeResult[] = [];
-  serial = 0;
-
-  randomId = () => {
-    return `IZod${this.serial++}`;
-  };
-
-  findBySchema = (schema: ZodType<any, any>) => {
-    return this.seen.find((s) => s.schema === schema);
-  };
-
-  findById = (id: string) => {
-    const found = this.seen.find((s) => s.id === id);
-    if (!found) throw new Error(`Unfound ID: ${id}`);
-    return found;
-  };
-
-  dump = () => {
-    return `
-type Identity<T> = T;
-
-${this.seen
-  .map((item) => `type ${item.id} = Identity<${item.type}>;`)
-  .join("\n\n")}
-`;
-  };
-
-  setType = (id: string, type: string) => {
-    const found = this.findById(id);
-    found.type = type;
-    return found;
-  };
-
-  generate = (schema: ZodType<any, any>): TypeResult => {
-    const found = this.findBySchema(schema);
-    if (found) return found;
-
-    const def: ZodDef = schema._def;
-
-    const id = this.randomId();
-
-    const ty = {
-      schema,
-      id,
-      type: `__INCOMPLETE__`,
-    };
-
-    this.seen.push(ty);
-
-    switch (def.t) {
-      case ZodTypes.string:
-        return this.setType(id, `string`);
-      case ZodTypes.number:
-        return this.setType(id, `number`);
-      case ZodTypes.bigint:
-        return this.setType(id, `bigint`);
-      case ZodTypes.boolean:
-        return this.setType(id, `boolean`);
-      case ZodTypes.date:
-        return this.setType(id, `Date`);
-      case ZodTypes.undefined:
-        return this.setType(id, `undefined`);
-      case ZodTypes.null:
-        return this.setType(id, `null`);
-      case ZodTypes.any:
-        return this.setType(id, `any`);
-      case ZodTypes.unknown:
-        return this.setType(id, `unknown`);
-      case ZodTypes.never:
-        return this.setType(id, `never`);
-      case ZodTypes.void:
-        return this.setType(id, `void`);
-      case ZodTypes.literal:
-        const val = def.value;
-        const literalType = typeof val === "string" ? `"${val}"` : `${val}`;
-        return this.setType(id, literalType);
-      case ZodTypes.enum:
-        return this.setType(id, def.values.map((v) => `"${v}"`).join(" | "));
-      case ZodTypes.object:
-        const objectLines: string[] = [];
-        const shape = def.shape();
-
-        for (const key in shape) {
-          const childSchema = shape[key];
-          const childType = this.generate(childSchema);
-          const OPTKEY = isOptional(childSchema) ? "?" : "";
-          objectLines.push(`${key}${OPTKEY}: ${childType.id}`);
-        }
-        const baseStruct = `{\n${objectLines
-          .map((line) => `  ${line};`)
-          .join("\n")}\n}`;
-        this.setType(id, `${baseStruct}`);
-        break;
-      case ZodTypes.tuple:
-        const tupleLines: string[] = [];
-        for (const elSchema of def.items) {
-          const elType = this.generate(elSchema);
-          tupleLines.push(elType.id);
-        }
-        const baseTuple = `[\n${tupleLines
-          .map((line) => `  ${line},`)
-          .join("\n")}\n]`;
-        return this.setType(id, `${baseTuple}`);
-      case ZodTypes.array:
-        return this.setType(id, `${this.generate(def.type).id}[]`);
-      case ZodTypes.function:
-        const args = this.generate(def.args);
-        const returns = this.generate(def.returns);
-        return this.setType(id, `(...args: ${args.id})=>${returns.id}`);
-      case ZodTypes.promise:
-        const promValue = this.generate(def.type);
-        return this.setType(id, `Promise<${promValue.id}>`);
-      case ZodTypes.union:
-        const unionLines: string[] = [];
-        for (const elSchema of def.options) {
-          const elType = this.generate(elSchema);
-          unionLines.push(elType.id);
-        }
-        return this.setType(id, unionLines.join(` | `));
-      case ZodTypes.intersection:
-        return this.setType(
-          id,
-          `${this.generate(def.left).id} & ${this.generate(def.right).id}`
-        );
-      case ZodTypes.record:
-        return this.setType(
-          id,
-          `{[k:string]: ${this.generate(def.valueType).id}}`
-        );
-
-      case ZodTypes.map:
-        return this.setType(
-          id,
-          `Map<${this.generate(def.keyType).id}, ${
-            this.generate(def.valueType).id
-          }>`
-        );
-      case ZodTypes.lazy:
-        const lazyType = def.getter();
-        return this.setType(id, this.generate(lazyType).id);
-      case ZodTypes.nativeEnum:
-        // const lazyType = def.getter();
-        return this.setType(id, "asdf");
-      case ZodTypes.optional:
-        return this.setType(
-          id,
-          `${this.generate(def.innerType).id} | undefined`
-        );
-      case ZodTypes.nullable:
-        return this.setType(id, `${this.generate(def.innerType).id} | null`);
-      case ZodTypes.transformer:
-        return this.setType(id, `${this.generate(def.schema).id}`);
-      default:
-        util.assertNever(def);
-    }
-    return this.findById(id);
-  };
-
-  static create = () => new ZodCodeGenerator();
-}
diff --git a/src/defaultErrorMap.ts b/src/defaultErrorMap.ts
index dd25741b0..db1ad1047 100644
--- a/src/defaultErrorMap.ts
+++ b/src/defaultErrorMap.ts
@@ -2,14 +2,12 @@ import { util } from "./helpers/util";
 import { ZodIssueCode, ZodIssueOptionalMessage } from "./ZodError";
 
 type ErrorMapCtx = {
-  // path: (string | number)[];
-  // details: any;
   defaultError: string;
   data: any;
-  // metadata: object;
 };
 
 export type ZodErrorMap = typeof defaultErrorMap;
+
 export const defaultErrorMap = (
   error: ZodIssueOptionalMessage,
   _ctx: ErrorMapCtx
@@ -23,9 +21,6 @@ export const defaultErrorMap = (
         message = `Expected ${error.expected}, received ${error.received}`;
       }
       break;
-    case ZodIssueCode.nonempty_array_is_empty:
-      message = `List must contain at least one item`;
-      break;
     case ZodIssueCode.unrecognized_keys:
       message = `Unrecognized key(s) in object: ${error.keys
         .map((k) => `'${k}'`)
@@ -34,16 +29,12 @@ export const defaultErrorMap = (
     case ZodIssueCode.invalid_union:
       message = `Invalid input`;
       break;
-    // case ZodIssueCode.invalid_tuple_length:
-    //   message = `Expected list of ${error.expected} items, received ${error.received} items`;
-    //   break;
-    case ZodIssueCode.invalid_literal_value:
-      message = `Input must be "${error.expected}"`;
-      break;
     case ZodIssueCode.invalid_enum_value:
-      message = `Input must be one of these values: ${error.options.join(
-        ", "
-      )}`;
+      message = `Invalid enum value. Expected ${error.options
+        .map((val) => (typeof val === "string" ? `'${val}'` : val))
+        .join(" | ")}, received ${
+        typeof _ctx.data === "string" ? `'${_ctx.data}'` : _ctx.data
+      }`;
       break;
     case ZodIssueCode.invalid_arguments:
       message = `Invalid function arguments`;
@@ -54,35 +45,21 @@ export const defaultErrorMap = (
     case ZodIssueCode.invalid_date:
       message = `Invalid date`;
       break;
-    // case ZodIssueCode.too_small:
-    //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
-    //   break;
-    // case ZodIssueCode.too_big:
-    //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
-    //   break;
     case ZodIssueCode.invalid_string:
       if (error.validation !== "regex") message = `Invalid ${error.validation}`;
       else message = "Invalid";
       break;
-    // case ZodIssueCode.invalid_url:
-    //   message = 'Invalid URL.';
-    //   break;
-    // case ZodIssueCode.invalid_uuid:
-    //   message = 'Invalid UUID.';
-    //   break;
     case ZodIssueCode.too_small:
       if (error.type === "array")
         message = `Should have ${error.inclusive ? `at least` : `more than`} ${
           error.minimum
-        } items`;
+        } item(s)`;
       else if (error.type === "string")
         message = `Should be ${error.inclusive ? `at least` : `over`} ${
           error.minimum
-        } characters`;
+        } character(s) long`;
       else if (error.type === "number")
-        message = `Value should be greater than ${
+        message = `Should be greater than ${
           error.inclusive ? `or equal to ` : ``
         }${error.minimum}`;
       else message = "Invalid input";
@@ -97,7 +74,7 @@ export const defaultErrorMap = (
           error.maximum
         } characters long`;
       else if (error.type === "number")
-        message = `Value should be less than ${
+        message = `Should be less than ${
           error.inclusive ? `or equal to ` : ``
         }${error.maximum}`;
       else message = "Invalid input";
@@ -105,9 +82,6 @@ export const defaultErrorMap = (
     case ZodIssueCode.custom:
       message = `Invalid input.`;
       break;
-    case ZodIssueCode.invalid_intersection_types:
-      message = `Intersections only support objects`;
-      break;
     default:
       message = `Invalid input.`;
       util.assertNever(error);
diff --git a/src/external.ts b/src/external.ts
new file mode 100644
index 000000000..92dd6e49c
--- /dev/null
+++ b/src/external.ts
@@ -0,0 +1,3 @@
+export * from "./helpers/parseUtil";
+export * from "./types";
+export * from "./ZodError";
diff --git a/src/helpers/errorUtil.ts b/src/helpers/errorUtil.ts
index f54953092..8d9afa2a8 100644
--- a/src/helpers/errorUtil.ts
+++ b/src/helpers/errorUtil.ts
@@ -2,4 +2,6 @@ export namespace errorUtil {
   export type ErrMessage = string | { message?: string };
   export const errToObj = (message?: ErrMessage) =>
     typeof message === "string" ? { message } : message || {};
+  export const toString = (message?: ErrMessage): string | undefined =>
+    typeof message === "string" ? message : message?.message;
 }
diff --git a/src/helpers/maskUtil.ts b/src/helpers/maskUtil.ts
deleted file mode 100644
index c3596345f..000000000
--- a/src/helpers/maskUtil.ts
+++ /dev/null
@@ -1,72 +0,0 @@
-import { Primitive } from "./primitive";
-
-type AnyObject = { [k: string]: any };
-type IsAny<T> = any extends T ? (T extends any ? true : false) : false;
-type IsNever<T> = never extends T ? (T extends never ? true : false) : false;
-type IsTrue<T> = true extends T ? (T extends true ? true : false) : false;
-type IsObject<T> = T extends { [k: string]: any }
-  ? T extends Array<any>
-    ? false
-    : true
-  : false;
-type IsObjectArray<T> = T extends Array<{ [k: string]: any }> ? true : false;
-// type IsObject<T> = T extends { [k: string]: any } ? (T extends Array<any> ? never : true) : never;
-
-export namespace maskUtil {
-  export type Params<T> = {
-    array: T extends Array<infer U>
-      ? true | { [k in keyof U]?: true | Params<U[k]> }
-      : never;
-    object: T extends AnyObject
-      ? { [k in keyof T]?: true | Params<T[k]> }
-      : never;
-    rest: never;
-    never: never;
-  }[T extends null | undefined | Primitive | Array<Primitive>
-    ? "never"
-    : any extends T
-    ? "never"
-    : T extends Array<AnyObject>
-    ? "array"
-    : IsObject<T> extends true
-    ? "object"
-    : "rest"];
-
-  export type PickTest<T, P extends any> = P extends true
-    ? "true"
-    : true extends IsObject<T>
-    ? "object"
-    : true extends IsObjectArray<T>
-    ? "array"
-    : "rest";
-
-  export type Pick<T, P> = null extends T
-    ? undefined extends T
-      ? BasePick<NonNullable<T>, P> | null | undefined
-      : BasePick<NonNullable<T>, P> | null
-    : undefined extends T
-    ? BasePick<NonNullable<T>, P> | undefined
-    : BasePick<NonNullable<T>, P>;
-
-  export type BasePick<T, P extends any> = {
-    primitive: T;
-    primitivearray: T;
-    true: T;
-    object: { [k in keyof P]: k extends keyof T ? Pick<T[k], P[k]> : never };
-    array: T extends (infer U)[] ? Pick<U, P>[] : never;
-    never: never;
-    any: any;
-  }[IsAny<T> extends true
-    ? "any"
-    : IsNever<T> extends true
-    ? "never"
-    : IsNever<P> extends true
-    ? "true"
-    : IsTrue<P> extends true
-    ? "true"
-    : true extends IsObject<T>
-    ? "object"
-    : true extends IsObjectArray<T>
-    ? "array"
-    : "any"];
-}
diff --git a/src/helpers/objectUtil.ts b/src/helpers/objectUtil.ts
deleted file mode 100644
index 6c6879f4f..000000000
--- a/src/helpers/objectUtil.ts
+++ /dev/null
@@ -1,110 +0,0 @@
-// import { ZodRawShape } from "../types/base";
-// import { ZodRawShape } from "../types/base";
-import { ZodRawShape, ZodIntersection } from "..";
-
-// import { mergeObjects as mergeObjectsBase } from "../../types/object";
-// import { mergeShapes as mergeShapesBase } from "./merge";
-
-export namespace objectUtil {
-  // export interface ZodObjectParams {
-  //   strict: boolean;
-  // }
-
-  // export type MergeObjectParams<
-  //   First extends ZodObjectParams,
-  //   Second extends ZodObjectParams
-  // > = {
-  //   strict: First['strict'] extends false
-  //     ? false
-  //     : Second['strict'] extends false
-  //     ? false
-  //     : true;
-  // };
-
-  export type MergeShapes<U extends ZodRawShape, V extends ZodRawShape> = {
-    [k in Exclude<keyof U, keyof V>]: U[k];
-  } &
-    V;
-
-  type optionalKeys<T extends object> = {
-    [k in keyof T]: undefined extends T[k] ? k : never;
-  }[keyof T];
-
-  type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;
-
-  export type addQuestionMarks<T extends object> = {
-    [k in optionalKeys<T>]?: T[k];
-  } &
-    { [k in requiredKeys<T>]: T[k] };
-
-  // type ObjectIntersection<T extends ZodRawShape> = addQuestionMarks<
-  //   {
-  //     [k in keyof T]: T[k]['_type'];
-  //   }
-  // >;
-
-  export type identity<T> = T;
-  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
-
-  export type NoNeverKeys<T extends ZodRawShape> = {
-    [k in keyof T]: [T[k]] extends [never] ? never : k;
-  }[keyof T];
-
-  export type NoNever<T extends ZodRawShape> = identity<
-    {
-      [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;
-    }
-  >;
-
-  // export type ObjectType<T extends ZodRawShape> = flatten<
-  //   ObjectIntersection<T>
-  // >;
-  // type ObjectIntersectionInput<T extends ZodRawShape> = addQuestionMarks<
-  //   {
-  //     [k in keyof T]: T[k]['_input'];
-  //   }
-  // >;
-  // type ObjectIntersectionOutput<T extends ZodRawShape> = addQuestionMarks<
-  //   {
-  //     [k in keyof T]: T[k]['_output'];
-  //   }
-  // >;
-
-  // export type objectInputType<T extends ZodObject<any, any, any>> = flatten<
-  //   addQuestionMarks<
-  //     {
-  //       [k in keyof T['_shape']]: T['_shape'][k]['_input'];
-  //     }
-  //   >
-  // >;
-
-  // export type objectOutputType<T extends ZodObject<any, any, any>> = flatten<
-  //   addQuestionMarks<
-  //     {
-  //       [k in keyof T['_shape']]: T['_shape'][k]['_output'];
-  //     }
-  //   >
-  // >;
-
-  export const mergeShapes = <U extends ZodRawShape, T extends ZodRawShape>(
-    first: U,
-    second: T
-  ): T & U => {
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
-    const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
-
-    const sharedShape: any = {};
-    for (const k of sharedKeys) {
-      sharedShape[k] = ZodIntersection.create(first[k], second[k]);
-    }
-    return {
-      ...(first as object),
-      ...(second as object),
-      ...sharedShape,
-    };
-  };
-
-  // export const mergeObjects = mergeObjectsBase;
-  // export const mergeShapes = mergeShapesBase;
-}
diff --git a/src/helpers/parseUtil.ts b/src/helpers/parseUtil.ts
new file mode 100644
index 000000000..909ed1ec2
--- /dev/null
+++ b/src/helpers/parseUtil.ts
@@ -0,0 +1,139 @@
+import {
+  defaultErrorMap,
+  MakeErrorData,
+  ZodError,
+  ZodErrorMap,
+} from "../ZodError";
+import { util } from "./util";
+
+export const ZodParsedType = util.arrayToEnum([
+  "string",
+  "nan",
+  "number",
+  "integer",
+  "float",
+  "boolean",
+  "date",
+  "bigint",
+  "symbol",
+  "function",
+  "undefined",
+  "null",
+  "array",
+  "object",
+  "unknown",
+  "promise",
+  "void",
+  "never",
+  "map",
+  "set",
+]);
+
+export type ZodParsedType = keyof typeof ZodParsedType;
+
+export const getParsedType = (data: any): ZodParsedType => {
+  if (typeof data === "string") return ZodParsedType.string;
+  if (typeof data === "number") {
+    if (Number.isNaN(data)) return ZodParsedType.nan;
+    return ZodParsedType.number;
+  }
+  if (typeof data === "boolean") return ZodParsedType.boolean;
+  if (typeof data === "bigint") return ZodParsedType.bigint;
+  if (typeof data === "symbol") return ZodParsedType.symbol;
+  if (data instanceof Date) return ZodParsedType.date;
+  if (typeof data === "function") return ZodParsedType.function;
+  if (data === undefined) return ZodParsedType.undefined;
+  if (typeof data === "undefined") return ZodParsedType.undefined;
+  if (typeof data === "object") {
+    if (Array.isArray(data)) return ZodParsedType.array;
+    if (data === null) return ZodParsedType.null;
+    if (
+      data.then &&
+      typeof data.then === "function" &&
+      data.catch &&
+      typeof data.catch === "function"
+    ) {
+      return ZodParsedType.promise;
+    }
+    if (data instanceof Map) {
+      return ZodParsedType.map;
+    }
+    if (data instanceof Set) {
+      return ZodParsedType.set;
+    }
+    return ZodParsedType.object;
+  }
+  return ZodParsedType.unknown;
+};
+
+export const issueHelpers = (error: ZodError, params: ParseParams) => {
+  const makeIssue = (errorData: MakeErrorData) => {
+    const errorArg = {
+      ...errorData,
+      path: [...params.path, ...(errorData.path || [])],
+    };
+
+    const defaultError =
+      defaultErrorMap === params.errorMap
+        ? { message: `Invalid value` }
+        : defaultErrorMap(errorArg, {
+            data: params.data,
+            defaultError: `Invalid value`,
+          });
+    const issue = {
+      ...errorData,
+      path: [...params.path, ...(errorData.path || [])],
+      message:
+        errorData.message ||
+        params.errorMap(errorArg, {
+          data: params.data,
+          defaultError: defaultError.message,
+        }).message,
+    };
+
+    return issue;
+  };
+  const addIssue = (errorData: MakeErrorData) => {
+    const issue = makeIssue(errorData);
+    error.addIssue(issue);
+  };
+
+  return {
+    makeIssue,
+    addIssue,
+  };
+};
+
+export type ParseParams = {
+  data: any;
+  path: (string | number)[];
+  errorMap: ZodErrorMap;
+  parentError: ZodError;
+  async: boolean;
+};
+
+export type ParseParamsWithOptionals = util.flatten<
+  Partial<ParseParams> & { data: any }
+>;
+
+export type ParseParamsNoData = Omit<ParseParams, "data">;
+
+export type ParseContext = ParseParams &
+  ReturnType<typeof issueHelpers> & {
+    parsedType: ZodParsedType;
+    currentError: ZodError;
+  };
+
+export type ZodParserReturnPayload<T> =
+  | {
+      success: false;
+      error: ZodError;
+    }
+  | {
+      success: true;
+      data: T;
+    };
+
+export type ZodParserReturnType<T> =
+  | ZodParserReturnPayload<T>
+  | Promise<ZodParserReturnPayload<T>>;
diff --git a/src/helpers/partialUtil.ts b/src/helpers/partialUtil.ts
index 9acbd58c6..b6390c937 100644
--- a/src/helpers/partialUtil.ts
+++ b/src/helpers/partialUtil.ts
@@ -1,4 +1,4 @@
-import { ZodTypeAny, ZodObject, ZodOptional } from "..";
+import { ZodObject, ZodOptional, ZodTypeAny } from "../index";
 
 type AnyZodObject = ZodObject<any, any, any>;
 
diff --git a/src/helpers/primitive.ts b/src/helpers/primitive.ts
deleted file mode 100644
index 3a0252f9a..000000000
--- a/src/helpers/primitive.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-export type Primitive = string | number | bigint | boolean | null | undefined;
-
-export type Scalars = Primitive | Primitive[];
diff --git a/src/helpers/util.ts b/src/helpers/util.ts
index 0c2333fe2..051865c05 100644
--- a/src/helpers/util.ts
+++ b/src/helpers/util.ts
@@ -1,7 +1,8 @@
 export const INVALID = Symbol("invalid_data");
+export type INVALID = typeof INVALID;
 export namespace util {
-  export type AssertEqual<T, Expected> = T extends Expected
-    ? Expected extends T
+  export type AssertEqual<T, Expected> = [T] extends [Expected]
+    ? [Expected] extends [T]
       ? true
       : false
     : false;
@@ -57,4 +58,11 @@ export namespace util {
     }
     return undefined;
   };
+
+  export type identity<T> = T;
+  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
+  export type noUndefined<T> = T extends undefined ? never : T;
+
+  export type Primitive = string | number | bigint | boolean | null | undefined;
+  export type Scalar = Primitive | Primitive[];
 }
diff --git a/src/index.ts b/src/index.ts
index b18f81315..85d41ec84 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -1,182 +1,3 @@
-/* ZOD */
-
-import {
-  ZodType,
-  ZodTypeDef,
-  ZodTypeAny,
-  ZodRawShape,
-  input,
-  output,
-  TypeOf,
-  RefinementCtx,
-} from "./types/base";
-
-import { ZodErrorMap } from "./defaultErrorMap";
-import { ZodAny } from "./types/any";
-import { ZodArray, ZodNonEmptyArray } from "./types/array";
-import { ZodBigInt } from "./types/bigint";
-import { ZodBoolean } from "./types/boolean";
-import { ZodDate } from "./types/date";
-import { ZodEnum } from "./types/enum";
-import { ZodFunction } from "./types/function";
-import { ZodIntersection } from "./types/intersection";
-import { ZodLazy } from "./types/lazy";
-import { ZodLiteral } from "./types/literal";
-import { ZodMap } from "./types/map";
-import { ZodNativeEnum } from "./types/nativeEnum";
-import { ZodNever } from "./types/never";
-import { ZodNull } from "./types/null";
-import { ZodNullable, ZodNullableType } from "./types/nullable";
-import { ZodNumber } from "./types/number";
-import { ZodObject } from "./types/object";
-import { ZodOptional, ZodOptionalType } from "./types/optional";
-import { ZodPromise } from "./types/promise";
-import { ZodRecord } from "./types/record";
-import { ZodString } from "./types/string";
-import { ZodTransformer } from "./types/transformer";
-import { ZodTuple } from "./types/tuple";
-import { ZodUndefined } from "./types/undefined";
-import { ZodUnion } from "./types/union";
-import { ZodUnknown } from "./types/unknown";
-import { ZodVoid } from "./types/void";
-import { ZodParsedType } from "./ZodParsedType";
-import { ZodTypes } from "./ZodTypes";
-import { ZodCodeGenerator } from "./codegen";
-
-// export { ZodTypeDef, ZodRawShape, ZodTypes };
-
-const stringType = ZodString.create;
-const numberType = ZodNumber.create;
-const bigIntType = ZodBigInt.create;
-const booleanType = ZodBoolean.create;
-const dateType = ZodDate.create;
-const undefinedType = ZodUndefined.create;
-const nullType = ZodNull.create;
-const anyType = ZodAny.create;
-const unknownType = ZodUnknown.create;
-const neverType = ZodNever.create;
-const voidType = ZodVoid.create;
-const arrayType = ZodArray.create;
-const objectType = ZodObject.create;
-const unionType = ZodUnion.create;
-const intersectionType = ZodIntersection.create;
-const tupleType = ZodTuple.create;
-const recordType = ZodRecord.create;
-const mapType = ZodMap.create;
-const functionType = ZodFunction.create;
-const lazyType = ZodLazy.create;
-const literalType = ZodLiteral.create;
-const enumType = ZodEnum.create;
-const nativeEnumType = ZodNativeEnum.create;
-const promiseType = ZodPromise.create;
-const transformerType = ZodTransformer.create;
-const optionalType = ZodOptional.create;
-const nullableType = ZodNullable.create;
-const ostring = () => stringType().optional();
-const onumber = () => numberType().optional();
-const oboolean = () => booleanType().optional();
-const codegen = ZodCodeGenerator.create;
-
-export const custom = <T>(
-  check?: (data: unknown) => any,
-  params?: Parameters<ZodTypeAny["refine"]>[1]
-): ZodType<T> => {
-  if (check) return anyType().refine(check, params);
-  return anyType();
-};
-
-const instanceOfType = <T extends new (...args: any[]) => any>(
-  cls: T,
-  params: Parameters<ZodTypeAny["refine"]>[1] = {
-    message: `Input not instance of ${cls.name}`,
-  }
-) => custom<InstanceType<T>>((data) => data instanceof cls, params);
-
-export type {
-  ZodTypeDef,
-  ZodRawShape,
-  RefinementCtx,
-  ZodParsedType,
-  TypeOf as infer,
-  input,
-  output,
-  TypeOf,
-  ZodErrorMap,
-  ZodNullableType,
-  ZodOptionalType,
-  ZodTypeAny,
-};
-
-export {
-  ZodType,
-  ZodType as Schema,
-  ZodType as ZodSchema,
-  ZodTypes,
-  ZodAny,
-  ZodArray,
-  ZodNonEmptyArray,
-  ZodBigInt,
-  ZodBoolean,
-  ZodCodeGenerator,
-  ZodDate,
-  ZodEnum,
-  ZodFunction,
-  ZodIntersection,
-  ZodLazy,
-  ZodLiteral,
-  ZodNativeEnum,
-  ZodNever,
-  ZodNull,
-  ZodNullable,
-  ZodNumber,
-  ZodObject,
-  ZodOptional,
-  ZodPromise,
-  ZodRecord,
-  ZodString,
-  ZodTransformer,
-  ZodTuple,
-  ZodUndefined,
-  ZodUnion,
-  ZodUnknown,
-  ZodVoid,
-  anyType as any,
-  arrayType as array,
-  bigIntType as bigint,
-  booleanType as boolean,
-  codegen,
-  dateType as date,
-  enumType as enum,
-  functionType as function,
-  instanceOfType as instanceof,
-  intersectionType as intersection,
-  lazyType as lazy,
-  literalType as literal,
-  mapType as map,
-  nativeEnumType as nativeEnum,
-  neverType as never,
-  nullType as null,
-  nullableType as nullable,
-  numberType as number,
-  objectType as object,
-  oboolean,
-  onumber,
-  optionalType as optional,
-  ostring,
-  promiseType as promise,
-  recordType as record,
-  stringType as string,
-  transformerType as transformer,
-  tupleType as tuple,
-  undefinedType as undefined,
-  unionType as union,
-  unknownType as unknown,
-  voidType as void,
-};
-
-export const late = {
-  object: ZodObject.lazycreate,
-};
-
-export * from "./ZodDef";
-export * from "./ZodError";
+import * as z from "./external";
+export * from "./external";
+export { z };
diff --git a/src/isScalar.ts b/src/isScalar.ts
deleted file mode 100644
index 736376d06..000000000
--- a/src/isScalar.ts
+++ /dev/null
@@ -1,102 +0,0 @@
-import { ZodDef, ZodType, ZodTypes } from ".";
-import { util } from "./helpers/util";
-
-// import { ZodTypes } from "./ZodTypes";
-
-export const isScalar = (
-  schema: ZodType<any, any>,
-  params: { root: boolean } = { root: true }
-): boolean => {
-  const def = schema._def as ZodDef;
-
-  let returnValue = false;
-  switch (def.t) {
-    case ZodTypes.string:
-      returnValue = true;
-      break;
-    case ZodTypes.number:
-      returnValue = true;
-      break;
-    case ZodTypes.bigint:
-      returnValue = true;
-      break;
-    case ZodTypes.boolean:
-      returnValue = true;
-      break;
-    case ZodTypes.undefined:
-      returnValue = true;
-      break;
-    case ZodTypes.null:
-      returnValue = true;
-      break;
-    case ZodTypes.any:
-      returnValue = false;
-      break;
-    case ZodTypes.unknown:
-      returnValue = false;
-      break;
-    case ZodTypes.never:
-      returnValue = false;
-      break;
-    case ZodTypes.void:
-      returnValue = false;
-      break;
-    case ZodTypes.array:
-      if (params.root === false) return false;
-      returnValue = isScalar(def.type, { root: false });
-      break;
-    case ZodTypes.object:
-      returnValue = false;
-      break;
-    case ZodTypes.union:
-      returnValue = def.options.every((x) => isScalar(x));
-      break;
-    case ZodTypes.intersection:
-      returnValue = isScalar(def.left) && isScalar(def.right);
-      break;
-    case ZodTypes.tuple:
-      returnValue = def.items.every((x) => isScalar(x, { root: false }));
-      break;
-    case ZodTypes.lazy:
-      returnValue = isScalar(def.getter());
-      break;
-    case ZodTypes.literal:
-      returnValue = true;
-      break;
-    case ZodTypes.enum:
-      returnValue = true;
-      break;
-    case ZodTypes.nativeEnum:
-      returnValue = true;
-      break;
-    case ZodTypes.function:
-      returnValue = false;
-      break;
-    case ZodTypes.record:
-      returnValue = false;
-      break;
-    case ZodTypes.map:
-      returnValue = false;
-      break;
-    case ZodTypes.date:
-      returnValue = true;
-      break;
-    case ZodTypes.promise:
-      returnValue = false;
-      break;
-
-    case ZodTypes.transformer:
-      returnValue = isScalar(def.schema);
-      break;
-    case ZodTypes.optional:
-      returnValue = isScalar(def.innerType);
-      break;
-    case ZodTypes.nullable:
-      returnValue = isScalar(def.innerType);
-      break;
-    default:
-      util.assertNever(def);
-    // returnValue = false; break;
-  }
-  return returnValue;
-};
diff --git a/src/parser.ts b/src/parser.ts
deleted file mode 100644
index bc1065012..000000000
--- a/src/parser.ts
+++ /dev/null
@@ -1,985 +0,0 @@
-import { defaultErrorMap, ZodErrorMap } from "./defaultErrorMap";
-import { INVALID, util } from "./helpers/util";
-import { NOSET, PseudoPromise } from "./PseudoPromise";
-// import { inputSchema } from "../types/base/output-schema";
-import { ZodType, RefinementCtx } from ".";
-// type adsf = RefinementCtx
-// import { ZodNever } from "../types/never";
-// import { ZodPromise } from "../types/promise";
-import { ZodDef } from "./ZodDef";
-import { ZodError, ZodIssue, ZodIssueCode, MakeErrorData } from "./ZodError";
-import { ZodParsedType } from "./ZodParsedType";
-import { ZodTypes } from "./ZodTypes";
-
-export const getParsedType = (data: any): ZodParsedType => {
-  if (typeof data === "string") return "string";
-  if (typeof data === "number") {
-    if (Number.isNaN(data)) return "nan";
-    return "number";
-  }
-  if (typeof data === "boolean") return "boolean";
-  if (typeof data === "bigint") return "bigint";
-  if (typeof data === "symbol") return "symbol";
-  if (data instanceof Date) return "date";
-  if (typeof data === "function") return "function";
-  if (data === undefined) return "undefined";
-  if (typeof data === "undefined") return "undefined";
-  if (typeof data === "object") {
-    if (Array.isArray(data)) return "array";
-    if (data === null) return "null";
-    if (
-      data.then &&
-      typeof data.then === "function" &&
-      data.catch &&
-      typeof data.catch === "function"
-    ) {
-      return "promise";
-    }
-    if (data instanceof Map) {
-      return "map";
-    }
-    return "object";
-  }
-  return "unknown";
-};
-
-const makeError = (
-  params: Required<ParseParams>,
-  data: any,
-  errorData: MakeErrorData
-): ZodIssue => {
-  const errorArg = {
-    ...errorData,
-    path: [...params.path, ...(errorData.path || [])],
-  };
-  const ctxArg = { data };
-
-  const defaultError =
-    defaultErrorMap === params.errorMap
-      ? { message: `Invalid value.` }
-      : defaultErrorMap(errorArg, {
-          ...ctxArg,
-          defaultError: `Invalid value.`,
-        });
-  return {
-    ...errorData,
-    path: [...params.path, ...(errorData.path || [])],
-    message:
-      errorData.message ||
-      params.errorMap(errorArg, {
-        ...ctxArg,
-        defaultError: defaultError.message,
-      }).message,
-  };
-};
-
-export type ParseParams = {
-  seen?: {
-    schema: ZodType<any>;
-    objects: { input: any; error?: ZodError; output: any }[];
-  }[];
-  path?: (string | number)[];
-  errorMap?: ZodErrorMap;
-  async?: boolean;
-  runAsyncValidationsInSeries?: boolean;
-};
-
-export const ZodParser = (schema: ZodType<any>) => (
-  data: any,
-  baseParams: ParseParams = { seen: [], errorMap: defaultErrorMap, path: [] }
-) => {
-  const params: Required<ParseParams> = {
-    seen: baseParams.seen || [],
-    path: baseParams.path || [],
-    errorMap: baseParams.errorMap || defaultErrorMap,
-    async: baseParams.async ?? false,
-    runAsyncValidationsInSeries:
-      baseParams.runAsyncValidationsInSeries ?? false,
-  };
-
-  const def: ZodDef = schema._def as any;
-
-  let PROMISE: PseudoPromise<any> = new PseudoPromise();
-  (PROMISE as any)._default = true;
-
-  const RESULT: { input: any; output: any; error?: ZodError } = {
-    input: data,
-    output: INVALID,
-  };
-
-  params.seen = params.seen || [];
-
-  const ERROR = new ZodError([]);
-
-  const THROW = () => {
-    RESULT.error = ERROR;
-    throw ERROR;
-  };
-
-  const HANDLE = (err: Error) => {
-    if (err instanceof ZodError) {
-      ERROR.addIssues(err.issues);
-      return INVALID;
-    }
-    throw ERROR;
-  };
-
-  const parsedType = getParsedType(data);
-
-  switch (def.t) {
-    case ZodTypes.string:
-      if (parsedType !== ZodParsedType.string) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.string,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-
-      break;
-    case ZodTypes.number:
-      if (parsedType !== ZodParsedType.number) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.number,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      if (Number.isNaN(data)) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.number,
-            received: ZodParsedType.nan,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.bigint:
-      if (parsedType !== ZodParsedType.bigint) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.bigint,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.boolean:
-      if (parsedType !== ZodParsedType.boolean) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.boolean,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.undefined:
-      if (parsedType !== ZodParsedType.undefined) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.undefined,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.null:
-      if (parsedType !== ZodParsedType.null) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.null,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.any:
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.unknown:
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.never:
-      ERROR.addIssue(
-        makeError(params, data, {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.never,
-          received: parsedType,
-        })
-      );
-      PROMISE = PseudoPromise.resolve(INVALID);
-      break;
-    case ZodTypes.void:
-      if (
-        parsedType !== ZodParsedType.undefined &&
-        parsedType !== ZodParsedType.null
-      ) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.void,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.array:
-      RESULT.output = [];
-      if (parsedType !== ZodParsedType.array) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.array,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      // const data: any[] = data;
-      if (def.nonempty === true && data.length === 0) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.nonempty_array_is_empty,
-          })
-        );
-        THROW();
-      }
-
-      PROMISE = PseudoPromise.all(
-        (data as any[]).map((item, i) => {
-          return new PseudoPromise()
-            .then(() =>
-              def.type.parse(item, {
-                ...params,
-                path: [...params.path, i],
-              })
-            )
-            .catch((err) => {
-              if (!(err instanceof ZodError)) {
-                throw err;
-              }
-              ERROR.addIssues(err.issues);
-              return INVALID;
-            });
-        })
-      );
-
-      break;
-    case ZodTypes.map:
-      if (parsedType !== ZodParsedType.map) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.map,
-            received: parsedType,
-          })
-        );
-        THROW();
-      }
-
-      const dataMap: Map<unknown, unknown> = data;
-      const returnedMap = new Map();
-
-      PROMISE = PseudoPromise.all(
-        [...dataMap.entries()].map(([key, value], index) => {
-          return PseudoPromise.all([
-            new PseudoPromise()
-              .then(() => {
-                return def.keyType.parse(key, {
-                  ...params,
-                  path: [...params.path, index, "key"],
-                });
-              })
-              .catch(HANDLE),
-            new PseudoPromise()
-              .then(() => {
-                const mapValue = def.valueType.parse(value, {
-                  ...params,
-                  path: [...params.path, index, "value"],
-                });
-                return [key, mapValue];
-              })
-              .catch(HANDLE),
-          ])
-            .then((item: any) => {
-              if (item[0] !== INVALID && item[1] !== INVALID) {
-                returnedMap.set(item[0], item[1]);
-              }
-            })
-            .catch(HANDLE);
-        })
-      )
-        .then(() => {
-          if (!ERROR.isEmpty) {
-            throw ERROR;
-          }
-        })
-        .then(() => {
-          return returnedMap;
-        })
-        .then(() => {
-          return returnedMap;
-        });
-      break;
-    case ZodTypes.object:
-      RESULT.output = {};
-      if (parsedType !== ZodParsedType.object) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.object,
-            received: parsedType,
-          })
-        );
-        THROW();
-      }
-
-      const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-      const shape = def.shape();
-      const shapeKeys = Object.keys(shape);
-      const dataKeys = Object.keys(data);
-
-      const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
-
-      for (const key of shapeKeys) {
-        const keyValidator = shapeKeys.includes(key)
-          ? shape[key]
-          : !(def.catchall._def.t === ZodTypes.never)
-          ? def.catchall
-          : undefined;
-
-        if (!keyValidator) {
-          continue;
-        }
-
-        // first check is required to avoid non-enumerable keys
-        if (typeof data[key] === "undefined" && !dataKeys.includes(key)) {
-          objectPromises[key] = new PseudoPromise()
-            .then(() => {
-              return keyValidator.parse(undefined, {
-                ...params,
-                path: [...params.path, key],
-              });
-            })
-            .then((output) => {
-              if (output === undefined) {
-                // schema is optional
-                // data is undefined
-                // don't explicity add undefined to outut
-                // continue;
-                return NOSET;
-              } else {
-                return output;
-              }
-            })
-            .catch((err) => {
-              if (err instanceof ZodError) {
-                const zerr: ZodError = err;
-                ERROR.addIssues(zerr.issues);
-                objectPromises[key] = PseudoPromise.resolve(INVALID);
-              } else {
-                throw err;
-              }
-            });
-
-          continue;
-        }
-
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator.parse(data[key], {
-              ...params,
-              path: [...params.path, key],
-            });
-          })
-          .catch((err) => {
-            if (err instanceof ZodError) {
-              const zerr: ZodError = err;
-              ERROR.addIssues(zerr.issues);
-              return INVALID;
-            } else {
-              throw err;
-            }
-          });
-      }
-
-      if (def.catchall._def.t === ZodTypes.never) {
-        if (def.unknownKeys === "passthrough") {
-          for (const key of extraKeys) {
-            objectPromises[key] = PseudoPromise.resolve(data[key]);
-          }
-        } else if (def.unknownKeys === "strict") {
-          if (extraKeys.length > 0) {
-            ERROR.addIssue(
-              makeError(params, data, {
-                code: ZodIssueCode.unrecognized_keys,
-                keys: extraKeys,
-              })
-            );
-          }
-        } else if (def.unknownKeys === "strip") {
-          // do nothing
-        } else {
-          util.assertNever(def.unknownKeys);
-        }
-      } else {
-        // run catchall validation
-        for (const key of extraKeys) {
-          objectPromises[key] = new PseudoPromise()
-            .then(() => {
-              const parsedValue = def.catchall.parse(data[key], {
-                ...params,
-                path: [...params.path, key],
-              });
-              return parsedValue;
-            })
-            .catch((err) => {
-              if (err instanceof ZodError) {
-                ERROR.addIssues(err.issues);
-              } else {
-                throw err;
-              }
-            });
-        }
-      }
-
-      PROMISE = PseudoPromise.object(objectPromises)
-        .then((resolvedObject) => {
-          Object.assign(RESULT.output, resolvedObject);
-          return RESULT.output;
-        })
-        .then((finalObject) => {
-          if (ERROR.issues.length > 0) {
-            return INVALID;
-          }
-          return finalObject;
-        })
-        .catch((err) => {
-          if (err instanceof ZodError) {
-            ERROR.addIssues(err.issues);
-            return INVALID;
-          }
-          throw err;
-        });
-
-      break;
-    case ZodTypes.union:
-      let isValid = false;
-      const unionErrors: ZodError[] = [];
-
-      PROMISE = PseudoPromise.all(
-        def.options.map((opt, _j) => {
-          // return new PseudoPromise().then
-          return new PseudoPromise()
-            .then(() => {
-              return opt.parse(data, params);
-            })
-            .then((optionData) => {
-              isValid = true;
-              return optionData;
-            })
-            .catch((err) => {
-              if (err instanceof ZodError) {
-                unionErrors.push(err);
-                return INVALID;
-              }
-              throw err;
-            });
-        })
-      )
-        .then((unionResults) => {
-          if (!isValid) {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== "invalid_type";
-            });
-            if (nonTypeErrors.length === 1) {
-              ERROR.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ERROR.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_union,
-                  unionErrors,
-                })
-              );
-            }
-            THROW();
-            // return;
-          }
-          return unionResults;
-        })
-        .then((unionResults: any[]) => {
-          return util.find(unionResults, (val: any) => val !== INVALID);
-        });
-
-      break;
-    case ZodTypes.intersection:
-      PROMISE = PseudoPromise.all([
-        new PseudoPromise()
-          .then(() => {
-            return def.left.parse(data, params);
-          })
-          .catch(HANDLE),
-        new PseudoPromise()
-          .then(() => {
-            return def.right.parse(data, params);
-          })
-          .catch(HANDLE),
-      ]).then(([parsedLeft, parsedRight]: any) => {
-        if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-        const parsedLeftType = getParsedType(parsedLeft);
-        const parsedRightType = getParsedType(parsedRight);
-
-        if (parsedLeft === parsedRight) {
-          return parsedLeft;
-        } else if (
-          parsedLeftType === ZodParsedType.object &&
-          parsedRightType === ZodParsedType.object
-        ) {
-          return { ...parsedLeft, ...parsedRight };
-        } else {
-          ERROR.addIssue(
-            makeError(params, data, {
-              code: ZodIssueCode.invalid_intersection_types,
-            })
-          );
-        }
-      });
-
-      break;
-
-    case ZodTypes.optional:
-      if (parsedType === ZodParsedType.undefined) {
-        PROMISE = PseudoPromise.resolve(undefined);
-        break;
-      }
-
-      PROMISE = new PseudoPromise()
-        .then(() => {
-          return def.innerType.parse(data, params);
-        })
-        .catch(HANDLE);
-      break;
-    case ZodTypes.nullable:
-      if (parsedType === ZodParsedType.null) {
-        PROMISE = PseudoPromise.resolve(null);
-        break;
-      }
-
-      PROMISE = new PseudoPromise()
-        .then(() => {
-          return def.innerType.parse(data, params);
-        })
-        .catch(HANDLE);
-      break;
-    case ZodTypes.tuple:
-      if (parsedType !== ZodParsedType.array) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.array,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      if (data.length > def.items.length) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.too_big,
-            maximum: def.items.length,
-            inclusive: true,
-            type: "array",
-          })
-        );
-      } else if (data.length < def.items.length) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.too_small,
-            minimum: def.items.length,
-            inclusive: true,
-            type: "array",
-          })
-        );
-      }
-
-      const tupleData: any[] = data;
-
-      PROMISE = PseudoPromise.all(
-        tupleData.map((item, index) => {
-          const itemParser = def.items[index];
-          return new PseudoPromise()
-            .then(() => {
-              const tupleDatum = itemParser.parse(item, {
-                ...params,
-                path: [...params.path, index],
-              });
-              return tupleDatum;
-            })
-            .catch((err) => {
-              if (err instanceof ZodError) {
-                ERROR.addIssues(err.issues);
-                return;
-              }
-              throw err;
-            })
-            .then((arg) => {
-              return arg;
-            });
-        })
-      )
-        .then((tupleData) => {
-          if (!ERROR.isEmpty) THROW();
-          return tupleData;
-        })
-
-        .catch((err) => {
-          throw err;
-        });
-
-      break;
-    case ZodTypes.lazy:
-      const lazySchema = def.getter();
-      PROMISE = PseudoPromise.resolve(lazySchema.parse(data, params));
-      break;
-    case ZodTypes.literal:
-      if (data !== def.value) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_literal_value,
-            expected: def.value,
-          })
-        );
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.enum:
-      if (def.values.indexOf(data) === -1) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_enum_value,
-            options: def.values,
-          })
-        );
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.nativeEnum:
-      if (util.getValidEnumValues(def.values).indexOf(data) === -1) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_enum_value,
-            options: util.objectValues(def.values),
-          })
-        );
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case ZodTypes.function:
-      if (parsedType !== ZodParsedType.function) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.function,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-
-      const isAsyncFunction = def.returns._def.t === ZodTypes.promise;
-
-      const validatedFunction = (...args: any[]) => {
-        const internalProm = new PseudoPromise()
-          .then(() => {
-            return def.args.parse(args as any, {
-              ...params,
-              async: isAsyncFunction,
-            });
-          })
-          .catch((err) => {
-            if (!(err instanceof ZodError)) throw err;
-            const argsError = new ZodError([]);
-            argsError.addIssue(
-              makeError(params, data, {
-                code: ZodIssueCode.invalid_arguments,
-                argumentsError: err,
-              })
-            );
-            throw argsError;
-          })
-          .then((args) => {
-            return data(...(args as any));
-          })
-          .then((result) => {
-            return def.returns.parse(result, {
-              ...params,
-              async: isAsyncFunction,
-            });
-          })
-          .catch((err) => {
-            if (err instanceof ZodError) {
-              const returnsError = new ZodError([]);
-              returnsError.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_return_type,
-                  returnTypeError: err,
-                })
-              );
-              throw returnsError;
-            }
-            throw err;
-          });
-
-        if (isAsyncFunction) {
-          return internalProm.getValueAsync();
-        } else {
-          return internalProm.getValueSync();
-        }
-      };
-      PROMISE = PseudoPromise.resolve(validatedFunction);
-
-      break;
-    case ZodTypes.record:
-      if (parsedType !== ZodParsedType.object) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.object,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-
-      const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-      for (const key in data) {
-        parsedRecordPromises[key] = new PseudoPromise()
-          .then(() => {
-            return def.valueType.parse(data[key], {
-              ...params,
-              path: [...params.path, key],
-            });
-          })
-          .catch(HANDLE);
-      }
-      PROMISE = PseudoPromise.object(parsedRecordPromises);
-
-      break;
-    case ZodTypes.date:
-      if (!(data instanceof Date)) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.date,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-      if (isNaN(data.getTime())) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_date,
-          })
-        );
-
-        THROW();
-      }
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-
-    case ZodTypes.promise:
-      if (parsedType !== ZodParsedType.promise && params.async !== true) {
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.promise,
-            received: parsedType,
-          })
-        );
-
-        THROW();
-      }
-
-      const promisified =
-        parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
-
-      PROMISE = PseudoPromise.resolve(
-        promisified.then((resolvedData: any) => {
-          return def.type.parse(resolvedData, params);
-        })
-      );
-
-      break;
-
-    case ZodTypes.transformer:
-      PROMISE = new PseudoPromise().then(() => {
-        return def.schema.parse(data, params);
-      });
-      break;
-    default:
-      PROMISE = PseudoPromise.resolve("adsf" as never);
-      util.assertNever(def);
-  }
-
-  if ((PROMISE as any)._default === true) {
-    throw new Error("Result is not materialized.");
-  }
-
-  if (!ERROR.isEmpty) {
-    THROW();
-  }
-  const effects = def.effects || [];
-
-  const checkCtx: RefinementCtx = {
-    addIssue: (arg: MakeErrorData) => {
-      ERROR.addIssue(makeError(params, data, arg));
-    },
-    path: params.path,
-  };
-
-  if (params.async === false) {
-    const resolvedValue = PROMISE.getValueSync();
-
-    if (resolvedValue === INVALID && ERROR.isEmpty) {
-      ERROR.addIssue(
-        makeError(params, data, {
-          code: ZodIssueCode.custom,
-          message: "Invalid",
-        })
-      );
-    }
-
-    if (!ERROR.isEmpty) {
-      THROW();
-    }
-
-    let finalValue = resolvedValue;
-
-    for (const effect of effects) {
-      // console.log(`running effect: `);
-      // console.log(effect);
-      if (effect.type === "check") {
-        const checkResult = effect.check(finalValue, checkCtx);
-        // console.log(`checkresult: ${checkResult}`);
-        if (checkResult instanceof Promise)
-          throw new Error(
-            "You can't use .parse() on a schema containing async refinements. Use .parseAsync instead."
-          );
-      } else if (effect.type === "mod") {
-        if (def.t !== ZodTypes.transformer)
-          throw new Error("Only Modders can contain mods");
-        finalValue = effect.mod(finalValue);
-        if (finalValue instanceof Promise) {
-          throw new Error(
-            `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-          );
-        }
-      } else {
-        throw new Error(`Invalid effect type.`);
-      }
-    }
-    if (!ERROR.isEmpty) {
-      THROW();
-    }
-
-    return finalValue as any;
-  } else {
-    // if (params.async == true) {
-    const checker = async () => {
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        // let someError: boolean = false;
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.custom,
-            message: "Invalid",
-          })
-        );
-      }
-
-      if (!ERROR.isEmpty) {
-        THROW();
-      }
-
-      let finalValue = resolvedValue;
-      for (const effect of effects) {
-        if (effect.type === "check") {
-          await effect.check(finalValue, checkCtx);
-        } else if (effect.type === "mod") {
-          if (def.t !== ZodTypes.transformer)
-            throw new Error("Only Modders can contain mods");
-          finalValue = await effect.mod(finalValue);
-        }
-      }
-
-      // if (params.runAsyncValidationsInSeries) {
-      //   let someError = false;
-      //   await customChecks.reduce((previousPromise, check) => {
-      //     return previousPromise.then(async () => {
-      //       if (!someError) {
-      //         const len = ERROR.issues.length;
-      //         await check.check(resolvedValue, checkCtx);
-      //         if (len < ERROR.issues.length) someError = true;
-      //       }
-      //     });
-      //   }, Promise.resolve());
-      // } else {
-      //   await Promise.all(
-      //     customChecks.map(async (check) => {
-      //       await check.check(resolvedValue, checkCtx);
-      //     })
-      //   );
-      // }
-
-      if (!ERROR.isEmpty) {
-        THROW();
-      }
-
-      return finalValue;
-    };
-
-    return checker();
-  }
-};
diff --git a/src/playground.ts b/src/playground.ts
index 18e56d983..746f94e03 100644
--- a/src/playground.ts
+++ b/src/playground.ts
@@ -1,9 +1,9 @@
-import * as z from ".";
+import { z } from "./index";
 
-const numberWithRandomDefault = z.number().default(Math.random);
-console.log(numberWithRandomDefault.parse(undefined));
-console.log(numberWithRandomDefault.parse(undefined));
-console.log(numberWithRandomDefault.parse(undefined));
-console.log(numberWithRandomDefault.parse(undefined));
+const run = async () => {
+  z;
+};
+
+run();
 
 export {};
diff --git a/src/switcher.ts b/src/switcher.ts
deleted file mode 100644
index ada810576..000000000
--- a/src/switcher.ts
+++ /dev/null
@@ -1,66 +0,0 @@
-import { util } from "./helpers/util";
-import { ZodType, ZodDef, ZodTypes } from ".";
-// import { ZodDef } from "./ZodDef";
-// import { ZodTypes } from "./ZodTypes";
-
-export const visitor = (schema: ZodType<any, any>) => {
-  const def = schema._def as ZodDef;
-  switch (def.t) {
-    case ZodTypes.string:
-      break;
-    case ZodTypes.number:
-      break;
-    case ZodTypes.bigint:
-      break;
-    case ZodTypes.boolean:
-      break;
-    case ZodTypes.undefined:
-      break;
-    case ZodTypes.null:
-      break;
-    case ZodTypes.any:
-      break;
-    case ZodTypes.unknown:
-      break;
-    case ZodTypes.never:
-      break;
-    case ZodTypes.void:
-      break;
-    case ZodTypes.array:
-      break;
-    case ZodTypes.object:
-      break;
-    case ZodTypes.union:
-      break;
-    case ZodTypes.intersection:
-      break;
-    case ZodTypes.tuple:
-      break;
-    case ZodTypes.lazy:
-      break;
-    case ZodTypes.literal:
-      break;
-    case ZodTypes.enum:
-      break;
-    case ZodTypes.nativeEnum:
-      break;
-    case ZodTypes.function:
-      break;
-    case ZodTypes.record:
-      break;
-    case ZodTypes.date:
-      break;
-    case ZodTypes.promise:
-      break;
-    case ZodTypes.transformer:
-      break;
-    case ZodTypes.optional:
-      break;
-    case ZodTypes.nullable:
-      break;
-    case ZodTypes.map:
-      break;
-    default:
-      util.assertNever(def);
-  }
-};
diff --git a/src/types.ts b/src/types.ts
new file mode 100644
index 000000000..4158bd932
--- /dev/null
+++ b/src/types.ts
@@ -0,0 +1,2659 @@
+import { errorUtil } from "./helpers/errorUtil";
+import {
+  getParsedType,
+  issueHelpers,
+  ParseContext,
+  ParseParams,
+  ParseParamsNoData,
+  ParseParamsWithOptionals,
+  ZodParsedType,
+  ZodParserReturnType,
+} from "./helpers/parseUtil";
+import { partialUtil } from "./helpers/partialUtil";
+import { INVALID, util } from "./helpers/util";
+import { NOSET, PseudoPromise } from "./PseudoPromise";
+import {
+  defaultErrorMap,
+  MakeErrorData,
+  StringValidation,
+  ZodCustomIssue,
+  ZodError,
+  ZodIssueCode,
+} from "./ZodError";
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodType      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+
+export type RefinementCtx = {
+  addIssue: (arg: MakeErrorData) => void;
+  path: (string | number)[];
+};
+export type ZodRawShape = { [k: string]: ZodTypeAny };
+export type ZodTypeAny = ZodType<any, any, any>;
+export type TypeOf<T extends ZodType<any>> = T["_output"];
+export type input<T extends ZodType<any>> = T["_input"];
+export type output<T extends ZodType<any>> = T["_output"];
+export type { TypeOf as infer };
+
+export type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
+export interface ZodTypeDef {
+  accepts?: ZodType<any, any>;
+}
+
+type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
+type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
+  infer Inner,
+  infer Out
+>
+  ? ZodEffects<Inner, Out>
+  : ZodEffects<T, T["_output"]>;
+export abstract class ZodType<
+  Output,
+  Def extends ZodTypeDef = ZodTypeDef,
+  Input = Output
+> {
+  readonly _type!: Output;
+  readonly _output!: Output;
+  readonly _input!: Input;
+  readonly _def!: Def;
+
+  abstract _parse(_ctx: ParseContext): any;
+
+  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
+    const data = params.data;
+    let PROMISE: PseudoPromise<any>;
+    const ERROR = new ZodError([]);
+    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
+
+    const parsedType = getParsedType(data);
+    try {
+      const parsedValue = this._parse({
+        ...params,
+        currentError: ERROR,
+        makeIssue,
+        addIssue,
+        parsedType,
+      });
+
+      PROMISE =
+        parsedValue instanceof PseudoPromise
+          ? parsedValue
+          : PseudoPromise.resolve(parsedValue);
+    } catch (err) {
+      // default to invalid
+      PROMISE = PseudoPromise.resolve(INVALID);
+    }
+
+    const isSync = params.async === false || this instanceof ZodPromise;
+
+    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
+      key;
+      if (!ERROR.isEmpty) throw ERROR;
+      return data;
+    };
+
+    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT("post effects"))
+      .then((data) => {
+        return { success: true, data };
+      })
+      .catch((error) => {
+        params.parentError.addIssues(ERROR.issues);
+        if (error instanceof ZodError) return { success: false, error: error };
+        throw error;
+      });
+
+    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
+  }
+
+  _parseInternalOptionalParams: (
+    params: ParseParamsWithOptionals
+  ) => ZodParserReturnType<Output> = (params) => {
+    // if(!params.data) throw
+
+    const fullParams: ParseParams = {
+      data: params.data,
+      path: params.path || [],
+      parentError: params.parentError || new ZodError([]),
+      errorMap: params.errorMap || defaultErrorMap,
+      async: params.async ?? false,
+    };
+
+    return this._parseInternal(fullParams);
+  };
+
+  parse: (data: unknown, params?: Partial<ParseParamsNoData>) => Output = (
+    data,
+    params
+  ) => {
+    const result = this._parseInternalOptionalParams({ data, ...params });
+    if (result instanceof Promise)
+      throw new Error(
+        "You can't use .parse() on a schema containing async elements. Use .parseAsync instead."
+      );
+    if (result.success) return result.data;
+    throw result.error;
+  };
+
+  safeParse: (
+    data: unknown,
+    params?: Partial<ParseParamsNoData>
+  ) =>
+    | { success: true; data: Output }
+    | { success: false; error: ZodError<Input> } = (data, params) => {
+    const result = this._parseInternalOptionalParams({ data, ...params });
+    if (result instanceof Promise)
+      throw new Error(
+        "You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead."
+      );
+    return result;
+  };
+
+  parseAsync: (
+    x: unknown,
+    params?: Partial<ParseParamsNoData>
+  ) => Promise<Output> = async (data, params) => {
+    const result = await this._parseInternalOptionalParams({
+      data,
+      ...params,
+      async: true,
+    });
+    if (result.success) return result.data;
+    throw result.error;
+  };
+
+  safeParseAsync: (
+    x: unknown,
+    params?: Partial<ParseParamsNoData>
+  ) => Promise<
+    { success: true; data: Output } | { success: false; error: ZodError }
+  > = async (data, params) => {
+    return await this._parseInternalOptionalParams({
+      data,
+      ...params,
+      async: true,
+    });
+  };
+
+  /** Alias of safeParseAsync */
+  spa = this.safeParseAsync;
+
+  _parseWithInvalidFallback: (
+    data: unknown,
+    params: ParseParamsNoData
+  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
+    const result = this._parseInternal({ ...params, data });
+    // const parser = ZodParser(this);
+    // const result = parser({ ...params, data });
+    if (result instanceof Promise) {
+      return result.then((result) => {
+        if (result.success) return result.data;
+        return INVALID;
+      });
+    }
+    if (result.success) return result.data;
+    return INVALID;
+  };
+
+  /** The .is method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
+  is: never;
+
+  /** The .check method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
+  check: never;
+
+  refine: <Func extends (arg: Output) => any, This extends this = this>(
+    check: Func,
+    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
+  ) => ZodEffectsType<This> = (check, message = "Invalid value.") => {
+    if (typeof message === "string") {
+      return this._refinement((val, ctx) => {
+        const result = check(val);
+        const setError = () =>
+          ctx.addIssue({
+            code: ZodIssueCode.custom,
+            message,
+          });
+        if (result instanceof Promise) {
+          return result.then((data) => {
+            if (!data) setError();
+          });
+        }
+        if (!result) {
+          setError();
+          return result;
+        }
+      });
+    }
+    if (typeof message === "function") {
+      return this._refinement((val, ctx) => {
+        const result = check(val);
+        const setError = () =>
+          ctx.addIssue({
+            code: ZodIssueCode.custom,
+            ...message(val),
+          });
+        if (result instanceof Promise) {
+          return result.then((data) => {
+            if (!data) setError();
+          });
+        }
+        if (!result) {
+          setError();
+          return result;
+        }
+      });
+    }
+    return this._refinement((val, ctx) => {
+      const result = check(val);
+      const setError = () =>
+        ctx.addIssue({
+          code: ZodIssueCode.custom,
+          ...message,
+        });
+      if (result instanceof Promise) {
+        return result.then((data) => {
+          if (!data) setError();
+        });
+      }
+
+      if (!result) {
+        setError();
+        return result;
+      }
+    });
+  };
+
+  refinement: <This extends this = this>(
+    check: (arg: Output) => any,
+    refinementData:
+      | MakeErrorData
+      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
+  ) => ZodEffectsType<This> = (check, refinementData) => {
+    return this._refinement((val, ctx) => {
+      if (!check(val)) {
+        ctx.addIssue(
+          typeof refinementData === "function"
+            ? refinementData(val, ctx)
+            : refinementData
+        );
+      }
+    });
+  };
+
+  // _refinement: (refinement: InternalCheck<Output>["refinement"]) => this = (
+  //   refinement
+  // ) => {
+  //   return new (this as any).constructor({
+  //     ...this._def,
+  //     effects: [
+  //       // ...(this._def.effects || []),
+  //       { type: "check", check: refinement },
+  //     ],
+  //   }) as this;
+  // };
+  _refinement<This extends this>(
+    refinement: InternalCheck<Output>["refinement"]
+  ): ZodEffectsType<This> {
+    let returnType;
+    if (this instanceof ZodEffects) {
+      returnType = new ZodEffects({
+        ...this._def,
+        effects: [
+          ...(this._def.effects || []),
+          { type: "refinement", refinement },
+        ],
+      }) as any;
+    } else {
+      returnType = new ZodEffects({
+        schema: this,
+        effects: [{ type: "refinement", refinement }],
+      }) as any;
+    }
+    return returnType;
+  }
+  superRefine = this._refinement;
+
+  constructor(def: Def) {
+    this._def = def;
+    this.transform = this.transform.bind(this) as any;
+    this.default = this.default.bind(this);
+  }
+
+  optional: <This extends this = this>() => ZodOptionalType<This> = () =>
+    ZodOptional.create(this) as any;
+  nullable: <This extends this = this>() => ZodNullableType<This> = () =>
+    ZodNullable.create(this) as any;
+
+  array: () => ZodArray<this> = () => ZodArray.create(this);
+
+  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
+    return ZodUnion.create([this, option]);
+  }
+
+  transform<NewOut, This extends this>(
+    transform: (arg: Output) => NewOut | Promise<NewOut>
+  ): This extends ZodEffects<infer T, any>
+    ? ZodEffects<T, NewOut>
+    : ZodEffects<This, NewOut> {
+    let returnType;
+    if (this instanceof ZodEffects) {
+      returnType = new ZodEffects({
+        ...this._def,
+        effects: [
+          ...(this._def.effects || []),
+          { type: "transform", transform },
+        ],
+      }) as any;
+    } else {
+      returnType = new ZodEffects({
+        schema: this,
+        effects: [{ type: "transform", transform }],
+      }) as any;
+    }
+    return returnType;
+  }
+
+  default<T extends util.noUndefined<Input>, This extends this = this>(
+    def: T
+  ): addDefaultToOptional<ZodOptionalType<This>>;
+  default<T extends () => Input, This extends this = this>(
+    def: T
+  ): addDefaultToOptional<ZodOptionalType<This>>;
+  default(def: any) {
+    const defaultValueFunc = typeof def === "function" ? def : () => def;
+    if (this instanceof ZodOptional) {
+      return new ZodOptional({
+        ...this._def,
+        defaultValue: defaultValueFunc,
+      }) as any;
+    }
+
+    return new ZodOptional({
+      innerType: this,
+      defaultValue: defaultValueFunc,
+    });
+  }
+
+  isOptional: () => boolean = () => this.safeParse(undefined).success;
+  isNullable: () => boolean = () => this.safeParse(null).success;
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodString      //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export interface ZodStringDef extends ZodTypeDef {
+  // validation: {
+  //   uuid?: true;
+  //   custom?: ((val: any) => boolean)[];
+  // };
+  isEmail: { message?: string } | false;
+  isURL: { message?: string } | false;
+  isUUID: { message?: string } | false;
+  minLength: { value: number; message?: string } | null;
+  maxLength: { value: number; message?: string } | null;
+}
+
+// eslint-disable-next-line
+const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
+const uuidRegex = /([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}){1}/i;
+
+export class ZodString extends ZodType<string, ZodStringDef> {
+  _parse(ctx: ParseContext): ParseReturnType<string> {
+    if (ctx.parsedType !== ZodParsedType.string) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.string,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    if (this._def.isEmail && !emailRegex.test(ctx.data)) {
+      ctx.addIssue({
+        validation: "email",
+        code: ZodIssueCode.invalid_string,
+        message: this._def.isEmail.message,
+      });
+    }
+
+    if (this._def.isURL) {
+      try {
+        new URL(ctx.data);
+      } catch {
+        ctx.addIssue({
+          validation: "url",
+          code: ZodIssueCode.invalid_string,
+          message: this._def.isURL.message,
+        });
+      }
+    }
+
+    if (this._def.isUUID && !uuidRegex.test(ctx.data)) {
+      ctx.addIssue({
+        validation: "email",
+        code: ZodIssueCode.invalid_string,
+        message: this._def.isUUID.message,
+      });
+    }
+
+    if (this._def.minLength !== null) {
+      if (ctx.data.length < this._def.minLength.value) {
+        ctx.addIssue({
+          code: ZodIssueCode.too_small,
+          minimum: this._def.minLength.value,
+          type: "string",
+          inclusive: true,
+          message: this._def.minLength.message,
+          // ...errorUtil.errToObj(this._def.minLength.message),
+        });
+      }
+    }
+
+    if (this._def.maxLength !== null) {
+      if (ctx.data.length > this._def.maxLength.value) {
+        ctx.addIssue({
+          code: ZodIssueCode.too_big,
+          maximum: this._def.maxLength.value,
+          type: "string",
+          inclusive: true,
+          message: this._def.maxLength.message,
+          // ...errorUtil.errToObj(this._def.maxLength.message),
+        });
+      }
+    }
+
+    return ctx.data;
+  }
+
+  protected _regex = (
+    regex: RegExp,
+    validation: StringValidation,
+    message?: errorUtil.ErrMessage
+  ) =>
+    this.refinement((data) => regex.test(data), {
+      validation,
+      code: ZodIssueCode.invalid_string,
+      ...errorUtil.errToObj(message),
+    });
+
+  email = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isEmail: errorUtil.errToObj(message),
+    });
+
+  url = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isURL: errorUtil.errToObj(message),
+    });
+
+  uuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isUUID: errorUtil.errToObj(message),
+    });
+
+  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) =>
+    this._regex(regexp, "regex", message);
+
+  min = (minLength: number, message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      minLength: {
+        value: minLength,
+        message: errorUtil.errToObj(message).message,
+      },
+    });
+
+  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      maxLength: {
+        value: maxLength,
+        message: errorUtil.errToObj(message).message,
+      },
+    });
+
+  length(len: number, message?: errorUtil.ErrMessage) {
+    return this.min(len, message).max(len, message);
+  }
+
+  nonempty = (message?: errorUtil.ErrMessage) =>
+    this.min(1, errorUtil.errToObj(message));
+
+  static create = (): ZodString => {
+    return new ZodString({
+      isEmail: false,
+      isURL: false,
+      isUUID: false,
+      minLength: null,
+      maxLength: null,
+    });
+  };
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodNumber      //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export interface ZodNumberDef extends ZodTypeDef {
+  minimum: null | { value: number; inclusive: boolean; message?: string };
+  maximum: null | { value: number; inclusive: boolean; message?: string };
+  isInteger: false | { message?: string };
+}
+
+export class ZodNumber extends ZodType<number, ZodNumberDef> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.number) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.number,
+        received: ctx.parsedType,
+      });
+
+      return INVALID;
+    }
+    if (Number.isNaN(ctx.data)) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.number,
+        received: ZodParsedType.nan,
+      });
+
+      return INVALID;
+    }
+
+    if (this._def.minimum) {
+      const MIN = this._def.minimum;
+      const tooSmall = MIN.inclusive
+        ? ctx.data < MIN.value
+        : ctx.data <= MIN.value;
+      if (tooSmall) {
+        ctx.addIssue({
+          code: ZodIssueCode.too_small,
+          minimum: MIN.value,
+          type: "number",
+          inclusive: MIN.inclusive,
+          message: MIN.message,
+        });
+      }
+    }
+
+    if (this._def.maximum) {
+      const MAX = this._def.maximum;
+      const tooBig = MAX.inclusive
+        ? ctx.data > MAX.value
+        : ctx.data >= MAX.value;
+      if (tooBig) {
+        ctx.addIssue({
+          code: ZodIssueCode.too_big,
+          maximum: MAX.value,
+          type: "number",
+          inclusive: MAX.inclusive,
+          message: MAX.message,
+        });
+      }
+    }
+
+    if (this._def.isInteger) {
+      if (!Number.isInteger(ctx.data)) {
+        ctx.addIssue({
+          code: ZodIssueCode.invalid_type,
+          expected: "integer",
+          received: "float",
+          message: this._def.isInteger.message,
+        });
+      }
+    }
+
+    return ctx.data as number;
+  }
+
+  static create = (): ZodNumber => {
+    return new ZodNumber({
+      minimum: null,
+      maximum: null,
+      isInteger: false,
+    });
+  };
+
+  min = (minimum: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      minimum: {
+        value: minimum,
+        inclusive: true,
+        message: errorUtil.toString(message),
+      },
+    });
+
+  max = (maximum: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      maximum: {
+        value: maximum,
+        inclusive: true,
+        message: errorUtil.toString(message),
+      },
+    });
+
+  int = (message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      isInteger: { message: errorUtil.toString(message) },
+    });
+
+  positive = (message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      minimum: {
+        value: 0,
+        inclusive: false,
+        message: errorUtil.toString(message),
+      },
+    });
+
+  negative = (message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      maximum: {
+        value: 0,
+        inclusive: false,
+        message: errorUtil.toString(message),
+      },
+    });
+
+  nonpositive = (message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      maximum: {
+        value: 0,
+        inclusive: true,
+        message: errorUtil.toString(message),
+      },
+    });
+
+  nonnegative = (message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      minimum: {
+        value: 0,
+        inclusive: true,
+        message: errorUtil.toString(message),
+      },
+    });
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodBigInt      //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export type ZodBigIntDef = ZodTypeDef;
+
+export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.bigint,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    return ctx.data;
+  }
+
+  static create = (): ZodBigInt => {
+    return new ZodBigInt({});
+  };
+}
+
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////                     ///////////
+//////////      ZodBoolean      //////////
+//////////                     ///////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+export type ZodBooleanDef = ZodTypeDef;
+
+export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.boolean,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    return ctx.data;
+  }
+
+  static create = (): ZodBoolean => {
+    return new ZodBoolean({});
+  };
+}
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                     ////////
+//////////      ZodDate        ////////
+//////////                     ////////
+///////////////////////////////////////
+///////////////////////////////////////
+export type ZodDateDef = ZodTypeDef;
+
+export class ZodDate extends ZodType<Date, ZodDateDef> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.date) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.date,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    if (isNaN(ctx.data.getTime())) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_date,
+      });
+
+      return;
+    }
+
+    return new Date((ctx.data as Date).getTime());
+  }
+
+  static create = (): ZodDate => {
+    return new ZodDate({});
+  };
+}
+
+////////////////////////////////////////////
+////////////////////////////////////////////
+//////////                        //////////
+//////////      ZodUndefined      //////////
+//////////                        //////////
+////////////////////////////////////////////
+////////////////////////////////////////////
+export type ZodUndefinedDef = ZodTypeDef;
+
+export class ZodUndefined extends ZodType<undefined> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.undefined,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    return ctx.data;
+  }
+
+  static create = (): ZodUndefined => {
+    return new ZodUndefined({});
+  };
+}
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodNull      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+export type ZodNullDef = ZodTypeDef;
+
+export class ZodNull extends ZodType<null, ZodNullDef> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.null) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.null,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    return ctx.data;
+  }
+  static create = (): ZodNull => {
+    return new ZodNull({});
+  };
+}
+
+//////////////////////////////////////
+//////////////////////////////////////
+//////////                  //////////
+//////////      ZodAny      //////////
+//////////                  //////////
+//////////////////////////////////////
+//////////////////////////////////////
+export type ZodAnyDef = ZodTypeDef;
+
+export class ZodAny extends ZodType<any, ZodAnyDef> {
+  _parse(ctx: ParseContext): any {
+    return ctx.data;
+  }
+  static create = (): ZodAny => {
+    return new ZodAny({});
+  };
+}
+
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////                      //////////
+//////////      ZodUnknown      //////////
+//////////                      //////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+export type ZodUnknownDef = ZodTypeDef;
+
+export class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
+  _parse(ctx: ParseContext): any {
+    return ctx.data;
+  }
+
+  static create = (): ZodUnknown => {
+    return new ZodUnknown({});
+  };
+}
+
+////////////////////////////////////////
+////////////////////////////////////////
+//////////                    //////////
+//////////      ZodNever      //////////
+//////////                    //////////
+////////////////////////////////////////
+////////////////////////////////////////
+export type ZodNeverDef = ZodTypeDef;
+
+export class ZodNever extends ZodType<never, ZodNeverDef> {
+  _parse(ctx: ParseContext): any {
+    ctx.addIssue({
+      code: ZodIssueCode.invalid_type,
+      expected: ZodParsedType.never,
+      received: ctx.parsedType,
+    });
+    return;
+  }
+  static create = (): ZodNever => {
+    return new ZodNever({});
+  };
+}
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodVoid      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+export type ZodVoidDef = ZodTypeDef;
+
+export class ZodVoid extends ZodType<void, ZodVoidDef> {
+  _parse(ctx: ParseContext): any {
+    if (
+      ctx.parsedType !== ZodParsedType.undefined &&
+      ctx.parsedType !== ZodParsedType.null
+    ) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.void,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+    return ctx.data;
+  }
+
+  static create = (): ZodVoid => {
+    return new ZodVoid({});
+  };
+}
+
+////////////////////////////////////////
+////////////////////////////////////////
+//////////                    //////////
+//////////      ZodArray      //////////
+//////////                    //////////
+////////////////////////////////////////
+////////////////////////////////////////
+export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  type: T;
+  minLength: { value: number; message?: string } | null;
+  maxLength: { value: number; message?: string } | null;
+}
+
+const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
+  if (ctx.parsedType !== ZodParsedType.array) {
+    ctx.addIssue({
+      code: ZodIssueCode.invalid_type,
+      expected: ZodParsedType.array,
+      received: ctx.parsedType,
+    });
+
+    return false;
+  }
+
+  if (def.minLength !== null) {
+    if (ctx.data.length < def.minLength.value) {
+      ctx.addIssue({
+        code: ZodIssueCode.too_small,
+        minimum: def.minLength.value,
+        type: "array",
+        inclusive: true,
+        message: def.minLength.message,
+      });
+    }
+  }
+
+  if (def.maxLength !== null) {
+    if (ctx.data.length > def.maxLength.value) {
+      ctx.addIssue({
+        code: ZodIssueCode.too_big,
+        maximum: def.maxLength.value,
+        type: "array",
+        inclusive: true,
+        message: def.maxLength.message,
+      });
+    }
+  }
+
+  return true;
+};
+
+export class ZodArray<T extends ZodTypeAny> extends ZodType<
+  T["_output"][],
+  ZodArrayDef<T>,
+  T["_input"][]
+> {
+  _parse(ctx: ParseContext): any {
+    const result = parseArray(ctx, this._def);
+    if (!result) return;
+
+    return PseudoPromise.all(
+      (ctx.data as any[]).map((item, i) => {
+        return new PseudoPromise().then(() =>
+          this._def.type._parseWithInvalidFallback(item, {
+            ...ctx,
+            path: [...ctx.path, i],
+            parentError: ctx.currentError,
+          })
+        );
+      }) as any
+    );
+  }
+
+  get element() {
+    return this._def.type;
+  }
+
+  min = (minLength: number, message?: errorUtil.ErrMessage): this =>
+    new ZodArray({
+      ...this._def,
+      minLength: { value: minLength, message: errorUtil.toString(message) },
+    }) as any;
+
+  max = (maxLength: number, message?: errorUtil.ErrMessage): this =>
+    new ZodArray({
+      ...this._def,
+      maxLength: { value: maxLength, message: errorUtil.toString(message) },
+    }) as any;
+
+  length = (len: number, message?: errorUtil.ErrMessage): this =>
+    this.min(len, message).max(len, message) as any;
+
+  nonempty: () => ZodNonEmptyArray<T> = () => {
+    return new ZodNonEmptyArray({ ...this._def });
+  };
+
+  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+    return new ZodArray({
+      type: schema,
+      minLength: null,
+      maxLength: null,
+    });
+  };
+}
+
+////////////////////////////////////////////////
+////////////////////////////////////////////////
+//////////                            //////////
+//////////      ZodNonEmptyArray      //////////
+//////////                            //////////
+////////////////////////////////////////////////
+////////////////////////////////////////////////
+export interface ZodNonEmptyArrayDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  type: T;
+  minLength: { value: number; message?: string } | null;
+  maxLength: { value: number; message?: string } | null;
+}
+
+export class ZodNonEmptyArray<T extends ZodTypeAny> extends ZodType<
+  [T["_output"], ...T["_output"][]],
+  ZodNonEmptyArrayDef<T>,
+  [T["_input"], ...T["_input"][]]
+> {
+  _parse(ctx: ParseContext): any {
+    // if (ctx.parsedType !== ZodParsedType.array) {
+    //   ctx.addIssue({
+    //     code: ZodIssueCode.invalid_type,
+    //     expected: ZodParsedType.array,
+    //     received: ctx.parsedType,
+    //   });
+
+    //   return;
+    // }
+
+    const result = parseArray(ctx, this._def);
+    if (!result) return;
+
+    if (ctx.data.length < 1) {
+      ctx.addIssue({
+        code: ZodIssueCode.too_small,
+        minimum: 1,
+        type: "array",
+        inclusive: true,
+        // message: this._def.minLength.message,
+        // ...errorUtil.errToObj(this._def.minLength.message),
+      });
+    }
+
+    return PseudoPromise.all(
+      (ctx.data as any[]).map((item, i) => {
+        return new PseudoPromise().then(() =>
+          this._def.type._parseWithInvalidFallback(item, {
+            ...ctx,
+            path: [...ctx.path, i],
+            parentError: ctx.currentError,
+          })
+        );
+      }) as any
+    );
+  }
+
+  min = (minLength: number, message?: errorUtil.ErrMessage) =>
+    new ZodNonEmptyArray({
+      ...this._def,
+      minLength: { value: minLength, message: errorUtil.toString(message) },
+    });
+
+  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
+    new ZodNonEmptyArray({
+      ...this._def,
+      maxLength: { value: maxLength, message: errorUtil.toString(message) },
+    });
+
+  length = (len: number, message?: errorUtil.ErrMessage) =>
+    this.min(len, message).max(len, message);
+
+  static create = <T extends ZodTypeAny>(schema: T): ZodNonEmptyArray<T> => {
+    return new ZodNonEmptyArray({
+      type: schema,
+      minLength: null,
+      maxLength: null,
+    });
+  };
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodObject      //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export namespace objectUtil {
+  export type extendShape<U extends ZodRawShape, V extends ZodRawShape> = {
+    [k in Exclude<keyof U, keyof V>]: U[k];
+  } &
+    V;
+  export type optionalKeys<T extends object> = {
+    [k in keyof T]: undefined extends T[k] ? k : never;
+  }[keyof T];
+
+  export type requiredKeys<T extends object> = Exclude<
+    keyof T,
+    optionalKeys<T>
+  >;
+
+  export type addQuestionMarks<T extends object> = {
+    [k in optionalKeys<T>]?: T[k];
+  } &
+    { [k in requiredKeys<T>]: T[k] };
+
+  // export type identity<T> = T;
+  // export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
+
+  export type noNeverKeys<T extends ZodRawShape> = {
+    [k in keyof T]: [T[k]] extends [never] ? never : k;
+  }[keyof T];
+
+  export type noNever<T extends ZodRawShape> = util.identity<
+    {
+      [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
+    }
+  >;
+
+  export const mergeShapes = <U extends ZodRawShape, T extends ZodRawShape>(
+    first: U,
+    second: T
+  ): T & U => {
+    // const firstKeys = Object.keys(first);
+    // const secondKeys = Object.keys(second);
+    // const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
+
+    // const sharedShape: any = {};
+    // for (const k of sharedKeys) {
+    //   sharedShape[k] = ZodIntersection.create(first[k], second[k]);
+    // }
+    // return {
+    //   ...(first as object),
+    //   ...(second as object),
+    //   ...sharedShape,
+    // };
+    return {
+      ...first,
+      ...second, // second overwrites first
+    };
+  };
+}
+
+const ExtendFactory = <Def extends ZodObjectDef>(def: Def) => <
+  Augmentation extends ZodRawShape
+>(
+  augmentation: Augmentation
+): ZodObject<
+  {
+    [k in Exclude<
+      keyof ReturnType<Def["shape"]>,
+      keyof Augmentation
+    >]: ReturnType<Def["shape"]>[k];
+  } &
+    { [k in keyof Augmentation]: Augmentation[k] },
+  Def["unknownKeys"],
+  Def["catchall"]
+> => {
+  return new ZodObject({
+    ...def,
+    shape: () => ({
+      ...def.shape(),
+      ...augmentation,
+    }),
+  }) as any;
+};
+
+type UnknownKeysParam = "passthrough" | "strict" | "strip";
+
+export interface ZodObjectDef<
+  T extends ZodRawShape = ZodRawShape,
+  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,
+  Catchall extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  shape: () => T;
+  catchall: Catchall;
+  unknownKeys: UnknownKeys;
+}
+
+export type baseObjectOutputType<Shape extends ZodRawShape> = util.flatten<
+  objectUtil.addQuestionMarks<
+    {
+      [k in keyof Shape]: Shape[k]["_output"];
+    }
+  >
+>;
+
+export type objectOutputType<
+  Shape extends ZodRawShape,
+  Catchall extends ZodTypeAny
+> = ZodTypeAny extends Catchall
+  ? baseObjectOutputType<Shape>
+  : util.flatten<
+      baseObjectOutputType<Shape> & { [k: string]: Catchall["_output"] }
+    >;
+
+export type baseObjectInputType<Shape extends ZodRawShape> = util.flatten<
+  objectUtil.addQuestionMarks<
+    {
+      [k in keyof Shape]: Shape[k]["_input"];
+    }
+  >
+>;
+
+export type objectInputType<
+  Shape extends ZodRawShape,
+  Catchall extends ZodTypeAny
+> = ZodTypeAny extends Catchall
+  ? baseObjectInputType<Shape>
+  : util.flatten<
+      baseObjectInputType<Shape> & { [k: string]: Catchall["_input"] }
+    >;
+
+export class ZodObject<
+  T extends ZodRawShape,
+  UnknownKeys extends UnknownKeysParam = "strip",
+  Catchall extends ZodTypeAny = ZodTypeAny,
+  Output = objectOutputType<T, Catchall>,
+  Input = objectInputType<T, Catchall>
+> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
+  readonly _shape!: T;
+  readonly _unknownKeys!: UnknownKeys;
+  readonly _catchall!: Catchall;
+
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.object) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
+
+    const shape = this._def.shape();
+    const shapeKeys = Object.keys(shape);
+    const dataKeys = Object.keys(ctx.data);
+
+    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+
+    for (const key of shapeKeys) {
+      const keyValidator = shapeKeys.includes(key)
+        ? shape[key]
+        : !(this._def.catchall instanceof ZodNever)
+        ? this._def.catchall
+        : undefined;
+
+      if (!keyValidator) {
+        continue;
+      }
+
+      // if value for key is not set
+      // and schema is optional
+      // don't add the
+      // first check is required to avoid non-enumerable keys
+      if (typeof ctx.data[key] === "undefined" && !dataKeys.includes(key)) {
+        objectPromises[key] = new PseudoPromise()
+          .then(() => {
+            return keyValidator._parseWithInvalidFallback(undefined, {
+              ...ctx,
+              path: [...ctx.path, key],
+              parentError: ctx.currentError,
+            });
+          })
+
+          .then((data) => {
+            if (data === undefined) {
+              // schema is optional
+              // data is not defined
+              // don't explicity add `key: undefined` to outut
+              // this is a feature of PseudoPromises
+              return NOSET;
+            } else {
+              return data;
+            }
+          });
+
+        continue;
+      }
+
+      objectPromises[key] = new PseudoPromise()
+        .then(() => {
+          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
+            ...ctx,
+            path: [...ctx.path, key],
+            parentError: ctx.currentError,
+          });
+        })
+        .then((data) => {
+          return data;
+        });
+    }
+
+    if (this._def.catchall instanceof ZodNever) {
+      const unknownKeys = this._def.unknownKeys;
+
+      if (unknownKeys === "passthrough") {
+        for (const key of extraKeys) {
+          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+        }
+      } else if (unknownKeys === "strict") {
+        if (extraKeys.length > 0) {
+          ctx.addIssue({
+            code: ZodIssueCode.unrecognized_keys,
+            keys: extraKeys,
+          });
+        }
+      } else if (unknownKeys === "strip") {
+      } else {
+        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
+      }
+    } else {
+      // run catchall validation
+      for (const key of extraKeys) {
+        objectPromises[key] = new PseudoPromise().then(() => {
+          const parsedValue = this._def.catchall._parseWithInvalidFallback(
+            ctx.data[key],
+            {
+              ...ctx,
+              path: [...ctx.path, key],
+              parentError: ctx.currentError,
+            }
+          );
+
+          return parsedValue;
+        });
+      }
+    }
+
+    return PseudoPromise.object(objectPromises).then((data) => {
+      return data;
+    });
+  }
+
+  get shape() {
+    return this._def.shape();
+  }
+
+  strict = (): ZodObject<T, "strict", Catchall> =>
+    new ZodObject({
+      ...this._def,
+      unknownKeys: "strict",
+    }) as any;
+
+  strip = (): ZodObject<T, "strip", Catchall> =>
+    new ZodObject({
+      ...this._def,
+      unknownKeys: "strip",
+    }) as any;
+
+  passthrough = (): ZodObject<T, "passthrough", Catchall> =>
+    new ZodObject({
+      ...this._def,
+      unknownKeys: "passthrough",
+    }) as any;
+
+  nonstrict = this.passthrough;
+
+  augment = ExtendFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
+  extend = ExtendFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
+
+  setKey = <Key extends string, Schema extends ZodTypeAny>(
+    key: Key,
+    schema: Schema
+  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> => {
+    return this.augment({ [key]: schema }) as any;
+  };
+
+  /**
+   * Prior to zod@1.0.12 there was a bug in the
+   * inferred type of merged objects. Please
+   * upgrade if you are experiencing issues.
+   */
+  merge: <Incoming extends AnyZodObject>(
+    merging: Incoming
+  ) => ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
+    const mergedShape = objectUtil.mergeShapes(
+      this._def.shape(),
+      merging._def.shape()
+    );
+    const merged: any = new ZodObject({
+      // effects: [], // wipe all refinements
+      unknownKeys: this._def.unknownKeys,
+      catchall: this._def.catchall,
+      shape: () => mergedShape,
+    }) as any;
+    return merged;
+  };
+
+  catchall = <Index extends ZodTypeAny>(
+    index: Index
+  ): ZodObject<T, UnknownKeys, Index> => {
+    return new ZodObject({
+      ...this._def,
+      catchall: index,
+    }) as any;
+  };
+
+  pick = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
+    UnknownKeys,
+    Catchall
+  > => {
+    const shape: any = {};
+    Object.keys(mask).map((key) => {
+      shape[key] = this.shape[key];
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => shape,
+    }) as any;
+  };
+
+  omit = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
+    UnknownKeys,
+    Catchall
+  > => {
+    const shape: any = {};
+    Object.keys(this.shape).map((key) => {
+      if (Object.keys(mask).indexOf(key) === -1) {
+        shape[key] = this.shape[key];
+      }
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => shape,
+    }) as any;
+  };
+
+  partial = (): ZodObject<
+    { [k in keyof T]: ReturnType<T[k]["optional"]> },
+    UnknownKeys,
+    Catchall
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      const fieldSchema = this.shape[key];
+      newShape[key] = fieldSchema.isOptional()
+        ? fieldSchema
+        : fieldSchema.optional();
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
+  deepPartial: () => partialUtil.RootDeepPartial<this> = () => {
+    const newShape: any = {};
+
+    for (const key in this.shape) {
+      const fieldSchema = this.shape[key];
+      if (fieldSchema instanceof ZodObject) {
+        newShape[key] = fieldSchema.isOptional()
+          ? fieldSchema
+          : (fieldSchema.deepPartial() as any).optional();
+      } else {
+        newShape[key] = fieldSchema.isOptional()
+          ? fieldSchema
+          : fieldSchema.optional();
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
+  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+    return new ZodObject({
+      shape: () => shape,
+      unknownKeys: "strip",
+      catchall: ZodNever.create(),
+    }) as any;
+  };
+
+  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+    return new ZodObject({
+      shape,
+      unknownKeys: "strip",
+      catchall: ZodNever.create(),
+    }) as any;
+  };
+}
+
+export type AnyZodObject = ZodObject<any, any, any>;
+
+////////////////////////////////////////
+////////////////////////////////////////
+//////////                    //////////
+//////////      ZodUnion      //////////
+//////////                    //////////
+////////////////////////////////////////
+////////////////////////////////////////
+type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+export interface ZodUnionDef<
+  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+> extends ZodTypeDef {
+  options: T;
+}
+
+// export type toOpts<T> = T extends ZodUnionOptions ? T : never;
+// export type ZodUnionType<
+//   A extends ZodTypeAny,
+//   B extends ZodTypeAny
+// > = A extends ZodUnion<infer AOpts>
+//   ? B extends ZodUnion<infer BOpts>
+//     ? ZodUnion<toOpts<[...AOpts, ...BOpts]>>
+//     : ZodUnion<toOpts<[...AOpts, B]>>
+//   : B extends ZodUnion<infer BOpts>
+//   ? ZodUnion<toOpts<[A, ...BOpts]>>
+//   : ZodUnion<toOpts<[A, B]>>;
+
+export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
+  T[number]["_output"],
+  ZodUnionDef<T>,
+  T[number]["_input"]
+> {
+  _parse(ctx: ParseContext): any {
+    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
+      () => new ZodError([])
+    );
+
+    return PseudoPromise.all(
+      this._def.options.map((opt, _j) => {
+        return new PseudoPromise().then(() => {
+          return opt._parseWithInvalidFallback(ctx.data, {
+            ...ctx,
+            parentError: unionErrors[_j],
+          });
+        });
+      }) as any
+    )
+      .then((unionResults) => {
+        const isValid = !!unionErrors.find((err) => err.isEmpty);
+        const GUESSING = false;
+
+        if (!isValid) {
+          if (!GUESSING) {
+            ctx.addIssue({
+              code: ZodIssueCode.invalid_union,
+              unionErrors,
+            });
+          } else {
+            const nonTypeErrors = unionErrors.filter((err) => {
+              return err.issues[0].code !== "invalid_type";
+            });
+            if (nonTypeErrors.length === 1) {
+              ctx.currentError.addIssues(nonTypeErrors[0].issues);
+            } else {
+              ctx.addIssue({
+                code: ZodIssueCode.invalid_union,
+                unionErrors,
+              });
+            }
+          }
+        }
+
+        return unionResults;
+      })
+      .then((unionResults: any) => {
+        const validIndex = unionErrors.indexOf(
+          unionErrors.find((err) => err.isEmpty)!
+        );
+        return unionResults[validIndex];
+      });
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+    types: T
+  ): ZodUnion<T> => {
+    return new ZodUnion({
+      options: types,
+    });
+  };
+}
+
+////////////////////////////////////////
+////////////////////////////////////////
+//////////                    //////////
+//////////      ZodTuple      //////////
+//////////                    //////////
+////////////////////////////////////////
+////////////////////////////////////////
+export type OutputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
+};
+
+export type InputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
+};
+
+export interface ZodTupleDef<
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
+> extends ZodTypeDef {
+  items: T;
+}
+
+export class ZodTuple<
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
+> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.array) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    if (ctx.data.length > this._def.items.length) {
+      ctx.addIssue({
+        code: ZodIssueCode.too_big,
+        maximum: this._def.items.length,
+        inclusive: true,
+        type: "array",
+      });
+    } else if (ctx.data.length < this._def.items.length) {
+      ctx.addIssue({
+        code: ZodIssueCode.too_small,
+        minimum: this._def.items.length,
+        inclusive: true,
+        type: "array",
+      });
+    }
+
+    const tupleData: any[] = ctx.data;
+
+    return PseudoPromise.all(
+      tupleData.map((item, index) => {
+        const itemParser = this._def.items[index];
+        return new PseudoPromise()
+          .then(() => {
+            return itemParser._parseWithInvalidFallback(item, {
+              ...ctx,
+              path: [...ctx.path, index],
+              parentError: ctx.currentError,
+            });
+          })
+          .then((tupleItem) => {
+            return tupleItem;
+          });
+      }) as any
+    );
+  }
+
+  get items() {
+    return this._def.items;
+  }
+
+  static create = <T extends [ZodTypeAny, ...ZodTypeAny[]] | []>(
+    schemas: T
+  ): ZodTuple<T> => {
+    return new ZodTuple({
+      items: schemas,
+    });
+  };
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodRecord      //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  valueType: Value;
+}
+
+export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
+  Record<string, Value["_output"]>,
+  ZodRecordDef<Value>,
+  Record<string, Value["_input"]>
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.object) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
+    for (const key in ctx.data) {
+      parsedRecordPromises[key] = new PseudoPromise().then(() => {
+        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
+          ...ctx,
+          path: [...ctx.path, key],
+          parentError: ctx.currentError,
+        });
+      });
+    }
+    return PseudoPromise.object(parsedRecordPromises);
+  }
+
+  static create = <Value extends ZodTypeAny = ZodTypeAny>(
+    valueType: Value
+  ): ZodRecord<Value> => {
+    return new ZodRecord({
+      valueType,
+    });
+  };
+}
+
+//////////////////////////////////////
+//////////////////////////////////////
+//////////                  //////////
+//////////      ZodMap      //////////
+//////////                  //////////
+//////////////////////////////////////
+//////////////////////////////////////
+export interface ZodMapDef<
+  Key extends ZodTypeAny = ZodTypeAny,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  valueType: Value;
+  keyType: Key;
+}
+
+export class ZodMap<
+  Key extends ZodTypeAny = ZodTypeAny,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Map<Key["_output"], Value["_output"]>,
+  ZodMapDef<Key, Value>,
+  Map<Key["_input"], Value["_input"]>
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.map) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.map,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const dataMap: Map<unknown, unknown> = ctx.data;
+    const returnedMap = new Map();
+
+    return PseudoPromise.all(
+      [...dataMap.entries()].map(([key, value], index) => {
+        return PseudoPromise.all([
+          new PseudoPromise().then(() => {
+            return this._def.keyType._parseWithInvalidFallback(key, {
+              ...ctx,
+              path: [...ctx.path, index, "key"],
+              parentError: ctx.currentError,
+            });
+          }),
+          new PseudoPromise().then(() => {
+            const mapValue = this._def.valueType._parseWithInvalidFallback(
+              value,
+              {
+                ...ctx,
+                path: [...ctx.path, index, "value"],
+                parentError: ctx.currentError,
+              }
+            );
+
+            return mapValue;
+          }),
+        ]).then((item: any) => {
+          returnedMap.set(item[0], item[1]);
+        });
+      }) as any
+    ).then(() => {
+      return returnedMap;
+    });
+  }
+  static create = <
+    Key extends ZodTypeAny = ZodTypeAny,
+    Value extends ZodTypeAny = ZodTypeAny
+  >(
+    keyType: Key,
+    valueType: Value
+  ): ZodMap<Key, Value> => {
+    return new ZodMap({
+      valueType,
+      keyType,
+    });
+  };
+}
+
+//////////////////////////////////////
+//////////////////////////////////////
+//////////                  //////////
+//////////      ZodSet      //////////
+//////////                  //////////
+//////////////////////////////////////
+//////////////////////////////////////
+export interface ZodSetDef<Value extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  valueType: Value;
+}
+
+export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
+  Set<Value["_output"]>,
+  ZodSetDef<Value>,
+  Set<Value["_input"]>
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.set) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.set,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const dataSet: Set<unknown> = ctx.data;
+    const returnedSet = new Set();
+
+    return PseudoPromise.all(
+      [...dataSet.values()].map((item, i) => {
+        return new PseudoPromise()
+          .then(() =>
+            this._def.valueType._parseWithInvalidFallback(item, {
+              ...ctx,
+              path: [...ctx.path, i],
+              parentError: ctx.currentError,
+            })
+          )
+          .then((item) => {
+            returnedSet.add(item);
+          });
+      }) as any
+    ).then(() => {
+      return returnedSet;
+    });
+  }
+
+  static create = <Value extends ZodTypeAny = ZodTypeAny>(
+    valueType: Value
+  ): ZodSet<Value> => {
+    return new ZodSet({
+      valueType,
+    });
+  };
+}
+
+///////////////////////////////////////////
+///////////////////////////////////////////
+//////////                       //////////
+//////////      ZodFunction      //////////
+//////////                       //////////
+///////////////////////////////////////////
+///////////////////////////////////////////
+export interface ZodFunctionDef<
+  Args extends ZodTuple<any> = ZodTuple<any>,
+  Returns extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  args: Args;
+  returns: Returns;
+}
+
+export type OuterTypeOfFunction<
+  Args extends ZodTuple<any>,
+  Returns extends ZodTypeAny
+> = Args["_input"] extends Array<any>
+  ? (...args: Args["_input"]) => Returns["_output"]
+  : never;
+
+export type InnerTypeOfFunction<
+  Args extends ZodTuple<any>,
+  Returns extends ZodTypeAny
+> = Args["_output"] extends Array<any>
+  ? (...args: Args["_output"]) => Returns["_input"]
+  : never;
+
+export class ZodFunction<
+  Args extends ZodTuple<any>,
+  Returns extends ZodTypeAny
+> extends ZodType<
+  OuterTypeOfFunction<Args, Returns>,
+  ZodFunctionDef<Args, Returns>,
+  InnerTypeOfFunction<Args, Returns>
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.function) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.function,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const isAsyncFunction = this._def.returns instanceof ZodPromise;
+
+    const validatedFunction = (...args: any[]) => {
+      const argsError = new ZodError([]);
+      const returnsError = new ZodError([]);
+      const internalProm = new PseudoPromise()
+        .then(() => {
+          return this._def.args._parseWithInvalidFallback(args as any, {
+            ...ctx,
+            parentError: argsError,
+            async: isAsyncFunction,
+          });
+        })
+        .then((args) => {
+          if (!argsError.isEmpty) {
+            const newError = new ZodError([]);
+            const issue = ctx.makeIssue({
+              code: ZodIssueCode.invalid_arguments,
+              argumentsError: argsError,
+            });
+            newError.addIssue(issue);
+            throw newError;
+          }
+
+          return args;
+        })
+        .then((args) => {
+          return ctx.data(...(args as any));
+        })
+        .then((result) => {
+          return this._def.returns._parseWithInvalidFallback(result, {
+            ...ctx,
+            parentError: returnsError,
+            async: isAsyncFunction,
+          });
+        })
+        .then((result) => {
+          if (!returnsError.isEmpty) {
+            const newError = new ZodError([]);
+            const issue = ctx.makeIssue({
+              code: ZodIssueCode.invalid_return_type,
+              returnTypeError: returnsError,
+            });
+            newError.addIssue(issue);
+            throw newError;
+          }
+          return result;
+        });
+
+      if (isAsyncFunction) {
+        return internalProm.getValueAsync();
+      } else {
+        return internalProm.getValueSync();
+      }
+    };
+    return validatedFunction;
+  }
+
+  args = <Items extends Parameters<typeof ZodTuple["create"]>[0]>(
+    ...items: Items
+  ): ZodFunction<ZodTuple<Items>, Returns> => {
+    return new ZodFunction({
+      ...this._def,
+      args: ZodTuple.create(items),
+    });
+  };
+
+  returns = <NewReturnType extends ZodType<any, any>>(
+    returnType: NewReturnType
+  ): ZodFunction<Args, NewReturnType> => {
+    return new ZodFunction({
+      ...this._def,
+      returns: returnType,
+    });
+  };
+
+  implement = <F extends InnerTypeOfFunction<Args, Returns>>(func: F): F => {
+    const validatedFunc = this.parse(func);
+    return validatedFunc as any;
+  };
+
+  validate = this.implement;
+
+  static create = <
+    T extends ZodTuple<any> = ZodTuple<[]>,
+    U extends ZodTypeAny = ZodUnknown
+  >(
+    args?: T,
+    returns?: U
+  ): ZodFunction<T, U> => {
+    return new ZodFunction({
+      args: args || ZodTuple.create([]),
+      returns: returns || ZodUnknown.create(),
+    }) as any;
+  };
+}
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodLazy      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+export interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  getter: () => T;
+}
+
+export class ZodLazy<T extends ZodTypeAny> extends ZodType<
+  output<T>,
+  ZodLazyDef<T>,
+  input<T>
+> {
+  get schema(): T {
+    return this._def.getter();
+  }
+
+  _parse(ctx: ParseContext): any {
+    const lazySchema = this._def.getter();
+    return PseudoPromise.resolve(
+      lazySchema._parseWithInvalidFallback(ctx.data, {
+        ...ctx,
+        parentError: ctx.currentError,
+      })
+    );
+  }
+
+  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+    return new ZodLazy({
+      getter: getter,
+    });
+  };
+}
+
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////                      //////////
+//////////      ZodLiteral      //////////
+//////////                      //////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+export interface ZodLiteralDef<T extends any = any> extends ZodTypeDef {
+  value: T;
+}
+
+export class ZodLiteral<T extends any> extends ZodType<T, ZodLiteralDef<T>> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.data !== this._def.value) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: this._def.value as any,
+        received: ctx.data,
+      });
+      return;
+    }
+    return ctx.data;
+  }
+
+  static create = <T extends util.Primitive>(value: T): ZodLiteral<T> => {
+    return new ZodLiteral({
+      value: value,
+    });
+  };
+}
+
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodEnum      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+export type ArrayKeys = keyof any[];
+export type Indices<T> = Exclude<keyof T, ArrayKeys>;
+
+type EnumValues = [string, ...string[]];
+
+type Values<T extends EnumValues> = {
+  [k in T[number]]: k;
+};
+
+export interface ZodEnumDef<T extends EnumValues = EnumValues>
+  extends ZodTypeDef {
+  values: T;
+}
+
+export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
+  T[number],
+  ZodEnumDef<T>
+> {
+  _parse(ctx: ParseContext): any {
+    if (this._def.values.indexOf(ctx.data) === -1) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_enum_value,
+        options: this._def.values,
+      });
+      return;
+    }
+    return ctx.data;
+  }
+
+  get options() {
+    return this._def.values;
+  }
+
+  get enum(): Values<T> {
+    const enumValues: any = {};
+    for (const val of this._def.values) {
+      enumValues[val] = val;
+    }
+    return enumValues as any;
+  }
+
+  get Values(): Values<T> {
+    const enumValues: any = {};
+    for (const val of this._def.values) {
+      enumValues[val] = val;
+    }
+    return enumValues as any;
+  }
+
+  get Enum(): Values<T> {
+    const enumValues: any = {};
+    for (const val of this._def.values) {
+      enumValues[val] = val;
+    }
+    return enumValues as any;
+  }
+
+  static create = <U extends string, T extends [U, ...U[]]>(
+    values: T
+  ): ZodEnum<T> => {
+    return new ZodEnum({
+      values: values,
+    }) as any;
+  };
+}
+
+/////////////////////////////////////////////
+/////////////////////////////////////////////
+//////////                         //////////
+//////////      ZodNativeEnum      //////////
+//////////                         //////////
+/////////////////////////////////////////////
+/////////////////////////////////////////////
+export interface ZodNativeEnumDef<T extends EnumLike = EnumLike>
+  extends ZodTypeDef {
+  values: T;
+}
+
+type EnumLike = { [k: string]: string | number; [nu: number]: string };
+
+export class ZodNativeEnum<T extends EnumLike> extends ZodType<
+  T[keyof T],
+  ZodNativeEnumDef<T>
+> {
+  _parse(ctx: ParseContext): any {
+    const nativeEnumValues = util.getValidEnumValues(this._def.values);
+    if (nativeEnumValues.indexOf(ctx.data) === -1) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_enum_value,
+        options: util.objectValues(nativeEnumValues),
+      });
+      return;
+    }
+    return ctx.data;
+  }
+  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+    return new ZodNativeEnum({
+      values: values,
+    });
+  };
+}
+
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////                      //////////
+//////////      ZodPromise      //////////
+//////////                      //////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+export interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  type: T;
+}
+
+export class ZodPromise<T extends ZodTypeAny> extends ZodType<
+  Promise<T["_output"]>,
+  ZodPromiseDef<T>,
+  Promise<T["_input"]>
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
+      ctx.addIssue({
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.promise,
+        received: ctx.parsedType,
+      });
+
+      return;
+    }
+
+    const promisified =
+      ctx.parsedType === ZodParsedType.promise
+        ? ctx.data
+        : Promise.resolve(ctx.data);
+    const promiseError = new ZodError([]);
+    return PseudoPromise.resolve(
+      promisified
+        .then((data: any) => {
+          const value = this._def.type._parseWithInvalidFallback(data, {
+            ...ctx,
+            parentError: promiseError,
+          });
+          return value;
+        })
+        .then((data: any) => {
+          if (!promiseError.isEmpty) {
+            throw promiseError;
+          }
+          return data;
+        })
+    );
+  }
+
+  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+    return new ZodPromise({
+      type: schema,
+    });
+  };
+}
+
+//////////////////////////////////////////////
+//////////////////////////////////////////////
+//////////                          //////////
+//////////      ZodEffects      //////////
+//////////                          //////////
+//////////////////////////////////////////////
+//////////////////////////////////////////////
+export type InternalCheck<T> = {
+  type: "refinement";
+  refinement: (arg: T, ctx: RefinementCtx) => any;
+};
+export type Mod<T> = {
+  type: "transform";
+  transform: (arg: T) => any;
+};
+export type Effect<T> = InternalCheck<T> | Mod<T>;
+
+export interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  schema: T;
+  effects?: Effect<any>[];
+}
+
+export class ZodEffects<
+  T extends ZodTypeAny,
+  Output = T["_type"]
+> extends ZodType<Output, ZodEffectsDef<T>, T["_input"]> {
+  _parse(ctx: ParseContext): any {
+    const isSync = ctx.async === false || this instanceof ZodPromise;
+    const effects = this._def.effects || [];
+    const checkCtx: RefinementCtx = {
+      addIssue: (arg: MakeErrorData) => {
+        ctx.addIssue(arg);
+      },
+      path: ctx.path,
+    };
+
+    // let refinementError: Error | null = null;
+
+    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
+      key;
+      if (!ctx.currentError.isEmpty) throw ctx.currentError;
+      // if (ctx.data === INVALID) throw ctx.currentError;
+      // if (refinementError !== null) throw refinementError;
+      return data;
+    };
+
+    let finalPromise = new PseudoPromise()
+      .then(() => {
+        return this._def.schema._parseWithInvalidFallback(ctx.data, {
+          ...ctx,
+          parentError: ctx.currentError,
+        });
+      })
+      .then(THROW_ERROR_IF_PRESENT("pre-refinement"));
+
+    for (const effect of effects) {
+      if (effect.type === "refinement") {
+        finalPromise = finalPromise
+          .all((data) => {
+            return [
+              PseudoPromise.resolve(data),
+              PseudoPromise.resolve(data).then(() => {
+                const result = effect.refinement(data, checkCtx);
+                // try {
+                //   result = effect.refinement(data, checkCtx);
+                // } catch (err) {
+                //   throw err;
+                //   // if (refinementError === null) refinementError = err;
+                // }
+
+                if (isSync && result instanceof Promise)
+                  throw new Error(
+                    "You can't use .parse() on a schema containing async refinements. Use .parseAsync instead."
+                  );
+                return result;
+              }),
+            ];
+          })
+          .then(([data, _]) => {
+            return data;
+          });
+      } else if (effect.type === "transform") {
+        finalPromise = finalPromise
+          .then(THROW_ERROR_IF_PRESENT("before transform"))
+          .then((data) => {
+            if (!(this instanceof ZodEffects))
+              throw new Error(
+                "Only transformers can contain transformation functions."
+              );
+            const newData = effect.transform(data);
+
+            return newData;
+          })
+          .then((data) => {
+            if (isSync && data instanceof Promise) {
+              throw new Error(
+                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              );
+            }
+            return data;
+          });
+      } else {
+        throw new Error(`Invalid effect type.`);
+      }
+    }
+
+    return finalPromise;
+  }
+
+  constructor(def: ZodEffectsDef<T>) {
+    super(def);
+    if (def.schema instanceof ZodEffects) {
+      throw new Error("ZodEffectss cannot be nested.");
+    }
+  }
+
+  static create = <I extends ZodTypeAny>(
+    schema: I
+  ): ZodEffects<I, I["_output"]> => {
+    const newTx = new ZodEffects({
+      schema,
+    });
+
+    return newTx;
+  };
+}
+
+export { ZodEffects as ZodTransformer };
+
+///////////////////////////////////////////
+///////////////////////////////////////////
+//////////                       //////////
+//////////      ZodOptional      //////////
+//////////                       //////////
+///////////////////////////////////////////
+///////////////////////////////////////////
+export interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  innerType: T;
+  defaultValue: undefined | (() => T["_input"]);
+}
+
+export type addDefaultToOptional<
+  T extends ZodOptional<any, any>
+> = T extends ZodOptional<infer U, any> ? ZodOptional<U, true> : never;
+export type removeDefaultFromOptional<
+  T extends ZodOptional<any, any>
+> = T extends ZodOptional<infer U, any> ? ZodOptional<U, false> : never;
+
+export type ZodOptionalType<T extends ZodTypeAny> = T extends ZodOptional<
+  infer U,
+  infer H
+>
+  ? ZodOptional<U, H>
+  : ZodOptional<T, false>; // no default by default
+
+export class ZodOptional<
+  T extends ZodTypeAny,
+  HasDefault extends boolean = false
+> extends ZodType<
+  HasDefault extends true ? T["_output"] : T["_output"] | undefined,
+  ZodOptionalDef<T>,
+  T["_input"] | undefined
+> {
+  _parse(ctx: ParseContext): any {
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
+      if (this._def.defaultValue !== undefined) {
+        data = this._def.defaultValue();
+      } else {
+        return undefined;
+      }
+    }
+
+    return new PseudoPromise().then(() => {
+      return this._def.innerType._parseWithInvalidFallback(data, {
+        ...ctx,
+        parentError: ctx.currentError,
+      });
+    });
+  }
+
+  unwrap() {
+    return this._def.innerType;
+  }
+
+  removeDefault(): ZodOptional<T, false> {
+    return new ZodOptional({
+      ...this._def,
+      defaultValue: undefined,
+    });
+  }
+
+  static create = <T extends ZodTypeAny>(type: T): ZodOptionalType<T> => {
+    if (type instanceof ZodOptional) return type as any;
+    return new ZodOptional({
+      innerType: type,
+      defaultValue: undefined,
+    }) as any;
+  };
+}
+
+///////////////////////////////////////////
+///////////////////////////////////////////
+//////////                       //////////
+//////////      ZodNullable      //////////
+//////////                       //////////
+///////////////////////////////////////////
+///////////////////////////////////////////
+export interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  innerType: T;
+}
+
+// This type allows for nullable flattening
+export type ZodNullableType<T extends ZodTypeAny> = T extends ZodNullable<
+  infer U
+>
+  ? ZodNullable<U>
+  : ZodNullable<T>;
+
+export class ZodNullable<T extends ZodTypeAny> extends ZodType<
+  T["_output"] | null,
+  ZodNullableDef<T>,
+  T["_input"] | null
+> {
+  _parse(ctx: ParseContext): any {
+    if (ctx.parsedType === ZodParsedType.null) {
+      return null;
+    }
+
+    return new PseudoPromise().then(() => {
+      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
+        ...ctx,
+        parentError: ctx.currentError,
+      });
+    });
+  }
+
+  unwrap() {
+    return this._def.innerType;
+  }
+
+  static create = <T extends ZodTypeAny>(type: T): ZodNullableType<T> => {
+    // An nullable nullable is the original nullable
+    if (type instanceof ZodNullable) return type as any;
+    return new ZodNullable({
+      innerType: type,
+    }) as any;
+  };
+}
+
+export const custom = <T>(
+  check?: (data: unknown) => any,
+  params?: Parameters<ZodTypeAny["refine"]>[1]
+): ZodType<T> => {
+  if (check) return ZodAny.create().refine(check, params);
+  return ZodAny.create();
+};
+
+export { ZodType as Schema, ZodType as ZodSchema };
+
+export const late = {
+  object: ZodObject.lazycreate,
+};
+
+export type ZodFirstPartySchemaTypes =
+  | ZodString
+  | ZodNumber
+  | ZodBigInt
+  | ZodBoolean
+  | ZodDate
+  | ZodUndefined
+  | ZodNull
+  | ZodAny
+  | ZodUnknown
+  | ZodNever
+  | ZodVoid
+  | ZodArray<any>
+  | ZodObject<any>
+  | ZodUnion<any>
+  | ZodTuple
+  | ZodRecord
+  | ZodMap
+  | ZodSet
+  | ZodFunction<any, any>
+  | ZodLazy<any>
+  | ZodLiteral<any>
+  | ZodEnum<any>
+  | ZodEffects<any>
+  | ZodNativeEnum<any>
+  | ZodOptional<any>
+  | ZodNullable<any>
+  | ZodPromise<any>;
+
+const instanceOfType = <T extends new (...args: any[]) => any>(
+  cls: T,
+  params: Parameters<ZodTypeAny["refine"]>[1] = {
+    message: `Input not instance of ${cls.name}`,
+  }
+) => custom<InstanceType<T>>((data) => data instanceof cls, params);
+
+const stringType = ZodString.create;
+const numberType = ZodNumber.create;
+const bigIntType = ZodBigInt.create;
+const booleanType = ZodBoolean.create;
+const dateType = ZodDate.create;
+const undefinedType = ZodUndefined.create;
+const nullType = ZodNull.create;
+const anyType = ZodAny.create;
+const unknownType = ZodUnknown.create;
+const neverType = ZodNever.create;
+const voidType = ZodVoid.create;
+const arrayType = ZodArray.create;
+const objectType = ZodObject.create;
+const unionType = ZodUnion.create;
+const tupleType = ZodTuple.create;
+const recordType = ZodRecord.create;
+const mapType = ZodMap.create;
+const setType = ZodSet.create;
+const functionType = ZodFunction.create;
+const lazyType = ZodLazy.create;
+const literalType = ZodLiteral.create;
+const enumType = ZodEnum.create;
+const nativeEnumType = ZodNativeEnum.create;
+const promiseType = ZodPromise.create;
+const effectsType = ZodEffects.create;
+const optionalType = ZodOptional.create;
+const nullableType = ZodNullable.create;
+const ostring = () => stringType().optional();
+const onumber = () => numberType().optional();
+const oboolean = () => booleanType().optional();
+
+export {
+  anyType as any,
+  arrayType as array,
+  bigIntType as bigint,
+  booleanType as boolean,
+  dateType as date,
+  effectsType as effect,
+  enumType as enum,
+  functionType as function,
+  instanceOfType as instanceof,
+  lazyType as lazy,
+  literalType as literal,
+  mapType as map,
+  nativeEnumType as nativeEnum,
+  neverType as never,
+  nullType as null,
+  nullableType as nullable,
+  numberType as number,
+  objectType as object,
+  oboolean,
+  onumber,
+  optionalType as optional,
+  ostring,
+  promiseType as promise,
+  recordType as record,
+  setType as set,
+  stringType as string,
+  effectsType as transformer,
+  tupleType as tuple,
+  undefinedType as undefined,
+  unionType as union,
+  unknownType as unknown,
+  voidType as void,
+};
diff --git a/src/types/any.ts b/src/types/any.ts
deleted file mode 100644
index a810522f0..000000000
--- a/src/types/any.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodAnyDef extends ZodTypeDef {
-  t: ZodTypes.any;
-}
-
-export class ZodAny extends ZodType<any, ZodAnyDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-  toJSON = () => this._def;
-
-  static create = (): ZodAny => {
-    return new ZodAny({
-      t: ZodTypes.any,
-    });
-  };
-}
diff --git a/src/types/array.ts b/src/types/array.ts
deleted file mode 100644
index 54a7b7060..000000000
--- a/src/types/array.ts
+++ /dev/null
@@ -1,109 +0,0 @@
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-import { ZodIssueCode } from "../ZodError";
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.array;
-  type: T;
-  nonempty: boolean;
-}
-
-export class ZodArray<T extends ZodTypeAny> extends ZodType<
-  T["_output"][],
-  ZodArrayDef<T>,
-  T["_input"][]
-> {
-  toJSON = () => {
-    return {
-      t: this._def.t,
-      nonempty: this._def.nonempty,
-      type: this._def.type.toJSON(),
-    };
-  };
-
-  get element() {
-    return this._def.type;
-  }
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  min = (minLength: number, message?: string | { message?: string }) =>
-    this.refinement((data) => data.length >= minLength, {
-      code: ZodIssueCode.too_small,
-      type: "array",
-      inclusive: true,
-      minimum: minLength,
-      ...(typeof message === "string" ? { message } : message),
-    });
-
-  max = (maxLength: number, message?: string | { message?: string }) =>
-    this.refinement((data) => data.length <= maxLength, {
-      // check: data => data.length <= maxLength,
-      code: ZodIssueCode.too_big,
-      type: "array",
-      inclusive: true,
-      maximum: maxLength,
-      ...(typeof message === "string" ? { message } : message),
-    });
-
-  length = (len: number, message?: string) =>
-    this.min(len, { message }).max(len, { message });
-
-  nonempty: () => ZodNonEmptyArray<T> = () => {
-    return new ZodNonEmptyArray({ ...this._def, nonempty: true });
-  };
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
-    return new ZodArray({
-      t: ZodTypes.array,
-      type: schema,
-      nonempty: false,
-    });
-  };
-}
-
-export class ZodNonEmptyArray<T extends ZodTypeAny> extends ZodType<
-  [T["_output"], ...T["_output"][]],
-  ZodArrayDef<T>,
-  [T["_input"], ...T["_input"][]]
-> {
-  toJSON = () => {
-    return {
-      t: this._def.t,
-      type: this._def.type.toJSON(),
-    };
-  };
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  min = (minLength: number, message?: string | { message?: string }) =>
-    this.refinement((data) => data.length >= minLength, {
-      // check: data => data.length >= minLength,
-      code: ZodIssueCode.too_small,
-      minimum: minLength,
-      type: "array",
-      inclusive: true,
-      ...(typeof message === "string" ? { message } : message),
-    });
-
-  max = (maxLength: number, message?: string | { message?: string }) =>
-    this.refinement((data) => data.length <= maxLength, {
-      // check:
-      code: ZodIssueCode.too_big,
-      maximum: maxLength,
-      type: "array",
-      inclusive: true,
-      ...(typeof message === "string" ? { message } : message),
-    });
-
-  length = (len: number, message?: string) =>
-    this.min(len, { message }).max(len, { message });
-}
diff --git a/src/types/base.ts b/src/types/base.ts
deleted file mode 100644
index 792a052f8..000000000
--- a/src/types/base.ts
+++ /dev/null
@@ -1,400 +0,0 @@
-import { util } from "../helpers/util";
-import { ZodTypes } from "../ZodTypes";
-import { ParseParams, ZodParser } from "../parser";
-import {
-  ZodCustomIssue,
-  ZodError,
-  ZodIssueCode,
-  MakeErrorData,
-} from "../ZodError";
-
-import {
-  ZodArray,
-  ZodNullable,
-  ZodNullableType,
-  ZodOptional,
-  ZodOptionalType,
-  ZodTransformer,
-} from "../index";
-// import { outputSchema } from "../output-schema";
-
-type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
-type InternalCheck<T> = {
-  type: "check";
-  check: (arg: T, ctx: RefinementCtx) => any;
-  // refinementError: (arg: T) => MakeErrorData;
-};
-
-type Mod<T> = {
-  type: "mod";
-  mod: (arg: T) => any;
-  // refinementError: (arg: T) => MakeErrorData;
-};
-
-type Effect<T> = InternalCheck<T> | Mod<T>;
-
-// type Check<T> = {
-//   check: (arg: T) => any;
-//   path?: (string | number)[];
-//   // message?: string;
-//   // params?: {[k:string]:any}
-// } & util.Omit<CustomError, 'code' | 'path'>;
-
-// type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
-// type Check<T> = {
-//   check: (arg: T) => any;
-//   refinementError: (arg: T) => CustomErrorParams;
-// };
-// export function declareZodType() {}
-
-export interface ZodTypeDef {
-  t: ZodTypes;
-  effects?: Effect<any>[];
-  // mods?: Mod<any>[];
-  accepts?: ZodType<any, any>;
-}
-
-export abstract class ZodType<
-  Output,
-  Def extends ZodTypeDef = ZodTypeDef,
-  Input = Output
-> {
-  readonly _type!: Output;
-  readonly _output!: Output;
-  readonly _input!: Input;
-  readonly _def!: Def;
-
-  // get inputSchema(): ZodTypeAny = this;
-  // outputSchema: ZodTypeAny = this;
-  //  = ()=>{
-  //   return this;
-  // }
-  //  outputSchema = () => {
-  //    return this;
-  //  };
-
-  parse: (x: unknown, params?: ParseParams) => Output = ZodParser(this);
-
-  safeParse: (
-    x: unknown,
-    params?: ParseParams
-  ) => { success: true; data: Output } | { success: false; error: ZodError } = (
-    data,
-    params
-  ) => {
-    try {
-      const parsed = this.parse(data, params);
-      return { success: true, data: parsed };
-    } catch (err) {
-      if (err instanceof ZodError) {
-        return { success: false, error: err };
-      }
-      throw err;
-    }
-  };
-
-  parseAsync: (x: unknown, params?: ParseParams) => Promise<Output> = async (
-    value,
-    params
-  ) => {
-    return await this.parse(value, { ...params, async: true });
-  };
-
-  safeParseAsync: (
-    x: unknown,
-    params?: ParseParams
-  ) => Promise<
-    { success: true; data: Output } | { success: false; error: ZodError }
-  > = async (data, params) => {
-    try {
-      const parsed = await this.parseAsync(data, params);
-      return { success: true, data: parsed };
-    } catch (err) {
-      if (err instanceof ZodError) {
-        return { success: false, error: err };
-      }
-      throw err;
-    }
-  };
-
-  spa = this.safeParseAsync;
-
-  // is(u: Input): u is Input {
-  //   try {
-  //     this.parse(u as any);
-  //     return true;
-  //   } catch (err) {
-  //     return false;
-  //   }
-  // }
-
-  // check(u: unknown): u is Input {
-  //   try {
-  //     this.parse(u as any);
-  //     return true;
-  //   } catch (err) {
-  //     return false;
-  //   }
-  // }
-  /** The .is method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
-  is: never;
-
-  /** The .check method has been removed in Zod 3. For details see https://github.com/colinhacks/zod/tree/v3. */
-  check: never;
-
-  refine = <Func extends (arg: Output) => any>(
-    check: Func,
-    message:
-      | string
-      | CustomErrorParams
-      | ((arg: Output) => CustomErrorParams) = "Invalid value."
-  ) => {
-    if (typeof message === "string") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === "function") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    return this._refinement((val, ctx) => {
-      const result = check(val);
-      const setError = () =>
-        ctx.addIssue({
-          code: ZodIssueCode.custom,
-          ...message,
-        });
-      if (result instanceof Promise) {
-        return result.then((data) => {
-          if (!data) setError();
-        });
-      }
-
-      if (!result) {
-        setError();
-        return result;
-      }
-    });
-  };
-
-  refinement = (
-    check: (arg: Output) => any,
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => {
-    return this._refinement((val, ctx) => {
-      if (!check(val)) {
-        ctx.addIssue(
-          typeof refinementData === "function"
-            ? refinementData(val, ctx)
-            : refinementData
-        );
-      }
-    });
-  };
-
-  _refinement: (refinement: InternalCheck<Output>["check"]) => this = (
-    refinement
-  ) => {
-    return new (this as any).constructor({
-      ...this._def,
-      effects: [
-        ...(this._def.effects || []),
-        { type: "check", check: refinement },
-      ],
-    }) as this;
-  };
-
-  constructor(def: Def) {
-    this._def = def;
-    // this.is = this.is.bind(this);
-    // this.check = this.check.bind(this);
-    this.transform = this.transform.bind(this);
-    this.default = this.default.bind(this);
-  }
-
-  abstract toJSON: () => object;
-
-  optional: () => ZodOptionalType<this> = () => ZodOptional.create(this);
-  or = this.optional;
-  nullable: () => ZodNullableType<this> = () => {
-    return ZodNullable.create(this) as any;
-  };
-  array: () => ZodArray<this> = () => ZodArray.create(this);
-
-  // transform<
-  //   This extends this,
-  //   U extends ZodType<any>,
-  //   Tx extends (arg: This["_output"]) => U["_input"] | Promise<U["_input"]>
-  // >(input: U, transformer: Tx): ZodTransformer<This, U>;
-  // transform<
-  //   This extends this,
-  //   Tx extends (
-  //     arg: This["_output"]
-  //   ) => This["_input"] | Promise<This["_input"]>
-  // >(transformer: Tx): ZodTransformer<This, This>;
-  // transform(input: any, transformer?: any) {
-  //   if (transformer) {
-  //     return ZodTransformer.create(this as any, input, transformer) as any;
-  //   }
-  //   return ZodTransformer.create(this as any, outputSchema(this), input) as any;
-  // }
-
-  // default<
-  //   T extends Input = Input,
-  //   Opt extends ReturnType<this["optional"]> = ReturnType<this["optional"]>
-  // >(def: T): ZodTransformer<Opt, this>;
-  // default<
-  //   T extends (arg: this) => Input,
-  //   Opt extends ReturnType<this["optional"]> = ReturnType<this["optional"]>
-  // >(def: T): ZodTransformer<Opt, this>;
-  // default(def: any) {
-  //   return ZodTransformer.create(this.optional(), this, (x: any) => {
-  //     return x === undefined
-  //       ? typeof def === "function"
-  //         ? def(this)
-  //         : def
-  //       : x;
-  //   }) as any;
-  // }
-
-  // transform<This extends this, Out, U extends ZodType<any>>(
-  //   input: U,
-  //   transformer: (arg: Output) => Out | Promise<Out>
-  // ): This extends ZodTransformer<infer T, any>
-  //   ? ZodTransformer<T, Out>
-  //   : ZodTransformer<This, Out>;
-  // transform<Out, This extends this>(
-  //   transformer: (arg: Output) => Out | Promise<Out>
-  // ): This extends ZodTransformer<infer T, any>
-  //   ? ZodTransformer<T, Out>
-  //   : ZodTransformer<This, Out>;
-  transform: <Out, This extends this>(
-    transformer: (arg: Output) => Out | Promise<Out>
-  ) => This extends ZodTransformer<infer T, any>
-    ? ZodTransformer<T, Out>
-    : ZodTransformer<This, Out> = (mod) => {
-    // if(typeof first === "function")
-    // const mod = typeof first === "function" ? first : second;
-    // const newSchema = this.transform(txFunc);
-    // if (!second) return newSchema;
-    // if (typeof mod !== "function")
-    //   throw new Error("Must provide a function to the .transform() method");
-
-    let returnType;
-    if (this instanceof ZodTransformer) {
-      returnType = new (this as any).constructor({
-        ...this._def,
-        effects: [...(this._def.effects || []), { type: "mod", mod }],
-      }) as any;
-    } else {
-      returnType = new ZodTransformer({
-        // ...this._def,
-        t: ZodTypes.transformer,
-        schema: this,
-        effects: [{ type: "mod", mod }],
-      }) as any;
-    }
-    return returnType;
-  };
-
-  //   if (!second) {
-  //     return returnType;
-  //   } else {
-  //     return returnType.refine(
-  //       (val: any) => {
-  //         return first.parse(val);
-  //       },
-  //       { message: "Parsing error!" }
-  //     );
-  //   }
-  // };
-
-  prependMod = <Out>(
-    mod: (arg: Output) => Out | Promise<Out>
-  ): ZodType<Out, Def, Input> => {
-    return new (this as any).constructor({
-      ...this._def,
-      effects: [{ type: "mod", mod }, ...(this._def.effects || [])],
-    }) as any;
-  };
-
-  clearEffects = <Out>(): ZodType<Out, Def, Input> => {
-    return new (this as any).constructor({
-      ...this._def,
-      effects: [],
-    }) as any;
-  };
-
-  setEffects = <Out>(effects: Effect<any>[]): ZodType<Out, Def, Input> => {
-    return new (this as any).constructor({
-      ...this._def,
-      effects,
-    }) as any;
-  };
-
-  default<T extends Input, This extends this = this>(
-    def: T
-  ): ZodTransformer<ZodOptional<This>, Input>;
-  default<T extends (arg: this) => Input, This extends this = this>(
-    def: T
-  ): ZodTransformer<ZodOptional<This>, Input>;
-  // default<
-  //   T extends (arg: this) => Input,
-  //   Opt extends ReturnType<this["optional"]> = ReturnType<this["optional"]>
-  // >(def: T): ZodTransformer<Opt, this>;
-  default(def: any) {
-    return this.optional().transform((val: any) => {
-      const defaultVal = typeof def === "function" ? def(this) : def;
-      return typeof val !== "undefined" ? val : defaultVal;
-    }) as any;
-  }
-
-  isOptional: () => boolean = () => this.safeParse(undefined).success;
-  isNullable: () => boolean = () => this.safeParse(null).success;
-}
-
-export type RefinementCtx = {
-  addIssue: (arg: MakeErrorData) => void;
-  path: (string | number)[];
-};
-
-export type ZodRawShape = { [k: string]: ZodTypeAny };
-
-export type TypeOf<T extends ZodType<any>> = T["_output"];
-export type input<T extends ZodType<any>> = T["_input"];
-export type output<T extends ZodType<any>> = T["_output"];
-export type infer<T extends ZodType<any>> = T["_output"];
-
-export type ZodTypeAny = ZodType<any, any, any>;
diff --git a/src/types/bigint.ts b/src/types/bigint.ts
deleted file mode 100644
index e440fd09d..000000000
--- a/src/types/bigint.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodBigIntDef extends ZodTypeDef {
-  t: ZodTypes.bigint;
-}
-
-export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({
-      t: ZodTypes.bigint,
-    });
-  };
-}
diff --git a/src/types/boolean.ts b/src/types/boolean.ts
deleted file mode 100644
index 9fa2bb543..000000000
--- a/src/types/boolean.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodBooleanDef extends ZodTypeDef {
-  t: ZodTypes.boolean;
-}
-
-export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({
-      t: ZodTypes.boolean,
-    });
-  };
-}
diff --git a/src/types/date.ts b/src/types/date.ts
deleted file mode 100644
index 6122d7494..000000000
--- a/src/types/date.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodDateDef extends ZodTypeDef {
-  t: ZodTypes.date;
-}
-
-export class ZodDate extends ZodType<Date, ZodDateDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-  static create = (): ZodDate => {
-    return new ZodDate({
-      t: ZodTypes.date,
-    });
-  };
-}
diff --git a/src/types/enum.ts b/src/types/enum.ts
deleted file mode 100644
index 1d6ef897f..000000000
--- a/src/types/enum.ts
+++ /dev/null
@@ -1,68 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export type ArrayKeys = keyof any[];
-export type Indices<T> = Exclude<keyof T, ArrayKeys>;
-
-type EnumValues = [string, ...string[]];
-
-type Values<T extends EnumValues> = {
-  [k in T[number]]: k;
-};
-
-export interface ZodEnumDef<T extends EnumValues = EnumValues>
-  extends ZodTypeDef {
-  t: ZodTypes.enum;
-  values: T;
-}
-
-export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
-  T[number],
-  ZodEnumDef<T>
-> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-
-  get options() {
-    return this._def.values;
-  }
-
-  get enum(): Values<T> {
-    const enumValues: any = {};
-    for (const val of this._def.values) {
-      enumValues[val] = val;
-    }
-    return enumValues as any;
-  }
-
-  get Values(): Values<T> {
-    const enumValues: any = {};
-    for (const val of this._def.values) {
-      enumValues[val] = val;
-    }
-    return enumValues as any;
-  }
-
-  get Enum(): Values<T> {
-    const enumValues: any = {};
-    for (const val of this._def.values) {
-      enumValues[val] = val;
-    }
-    return enumValues as any;
-  }
-
-  static create = <U extends string, T extends [U, ...U[]]>(
-    values: T
-  ): ZodEnum<T> => {
-    return new ZodEnum({
-      t: ZodTypes.enum,
-      values: values,
-    }) as any;
-  };
-}
diff --git a/src/types/function.ts b/src/types/function.ts
deleted file mode 100644
index 7d2fb5350..000000000
--- a/src/types/function.ts
+++ /dev/null
@@ -1,92 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-import { ZodTuple } from "./tuple";
-import { ZodUnknown } from "./unknown";
-
-export interface ZodFunctionDef<
-  Args extends ZodTuple<any> = ZodTuple<any>,
-  Returns extends ZodTypeAny = ZodTypeAny
-> extends ZodTypeDef {
-  t: ZodTypes.function;
-  args: Args;
-  returns: Returns;
-}
-
-export type OuterTypeOfFunction<
-  Args extends ZodTuple<any>,
-  Returns extends ZodTypeAny
-> = Args["_input"] extends Array<any>
-  ? (...args: Args["_input"]) => Returns["_output"]
-  : never;
-
-export type InnerTypeOfFunction<
-  Args extends ZodTuple<any>,
-  Returns extends ZodTypeAny
-> = Args["_output"] extends Array<any>
-  ? (...args: Args["_output"]) => Returns["_input"]
-  : never;
-
-// type as df = string extends unknown  ? true : false
-export class ZodFunction<
-  Args extends ZodTuple<any>,
-  Returns extends ZodTypeAny
-> extends ZodType<
-  OuterTypeOfFunction<Args, Returns>,
-  ZodFunctionDef,
-  InnerTypeOfFunction<Args, Returns>
-> {
-  readonly _def!: ZodFunctionDef<Args, Returns>;
-  //  readonly _type!: TypeOfFunction<Args, Returns>;
-
-  args = <Items extends Parameters<typeof ZodTuple["create"]>[0]>(
-    ...items: Items
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
-    return new ZodFunction({
-      ...this._def,
-      args: ZodTuple.create(items),
-    });
-  };
-
-  returns = <NewReturnType extends ZodType<any, any>>(
-    returnType: NewReturnType
-  ): ZodFunction<Args, NewReturnType> => {
-    return new ZodFunction({
-      ...this._def,
-      returns: returnType,
-    });
-  };
-
-  implement = <F extends InnerTypeOfFunction<Args, Returns>>(func: F): F => {
-    const validatedFunc = this.parse(func);
-    return validatedFunc as any;
-  };
-
-  validate = this.implement;
-
-  static create = <
-    T extends ZodTuple<any> = ZodTuple<[]>,
-    U extends ZodTypeAny = ZodUnknown
-  >(
-    args?: T,
-    returns?: U
-  ): ZodFunction<T, U> => {
-    return new ZodFunction({
-      t: ZodTypes.function,
-      args: args || ZodTuple.create([]),
-      returns: returns || ZodUnknown.create(),
-    });
-  };
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => {
-    return {
-      t: this._def.t,
-      args: this._def.args.toJSON(),
-      returns: this._def.returns.toJSON(),
-    };
-  };
-}
diff --git a/src/types/intersection.ts b/src/types/intersection.ts
deleted file mode 100644
index 0259f167c..000000000
--- a/src/types/intersection.ts
+++ /dev/null
@@ -1,44 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodIntersectionDef<
-  T extends ZodTypeAny = ZodTypeAny,
-  U extends ZodTypeAny = ZodTypeAny
-> extends ZodTypeDef {
-  t: ZodTypes.intersection;
-  left: T;
-  right: U;
-}
-
-export class ZodIntersection<
-  T extends ZodTypeAny,
-  U extends ZodTypeAny
-> extends ZodType<
-  T["_output"] & U["_output"],
-  ZodIntersectionDef<T, U>,
-  T["_input"] & U["_input"]
-> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => ({
-    t: this._def.t,
-    left: this._def.left.toJSON(),
-    right: this._def.right.toJSON(),
-  });
-
-  static create = <T extends ZodTypeAny, U extends ZodTypeAny>(
-    left: T,
-    right: U
-  ): ZodIntersection<T, U> => {
-    return new ZodIntersection({
-      t: ZodTypes.intersection,
-      left: left,
-      right: right,
-    });
-  };
-}
diff --git a/src/types/lazy.ts b/src/types/lazy.ts
deleted file mode 100644
index eec55631e..000000000
--- a/src/types/lazy.ts
+++ /dev/null
@@ -1,37 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { input, output, ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.lazy;
-  getter: () => T;
-}
-
-export class ZodLazy<T extends ZodTypeAny> extends ZodType<
-  output<T>,
-  ZodLazyDef<T>,
-  input<T>
-> {
-  get schema(): T {
-    return this._def.getter();
-  }
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => {
-    throw new Error("Can't JSONify recursive structure");
-  };
-
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
-    return new ZodLazy({
-      t: ZodTypes.lazy,
-      getter: getter,
-    });
-  };
-}
diff --git a/src/types/literal.ts b/src/types/literal.ts
deleted file mode 100644
index 03f9081f5..000000000
--- a/src/types/literal.ts
+++ /dev/null
@@ -1,28 +0,0 @@
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-import { Primitive } from "../helpers/primitive";
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-
-type LiteralValue = Primitive;
-
-export interface ZodLiteralDef<T extends any = any> extends ZodTypeDef {
-  t: ZodTypes.literal;
-  value: T;
-}
-
-export class ZodLiteral<T extends any> extends ZodType<T, ZodLiteralDef<T>> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-
-  static create = <T extends LiteralValue>(value: T): ZodLiteral<T> => {
-    return new ZodLiteral({
-      t: ZodTypes.literal,
-      value: value,
-    });
-  };
-}
diff --git a/src/types/map.ts b/src/types/map.ts
deleted file mode 100644
index 1eff6e474..000000000
--- a/src/types/map.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-export interface ZodMapDef<
-  Key extends ZodTypeAny = ZodTypeAny,
-  Value extends ZodTypeAny = ZodTypeAny
-> extends ZodTypeDef {
-  t: ZodTypes.map;
-  valueType: Value;
-  keyType: Key;
-}
-
-export class ZodMap<
-  Key extends ZodTypeAny = ZodTypeAny,
-  Value extends ZodTypeAny = ZodTypeAny
-> extends ZodType<
-  Map<Key["_output"], Value["_output"]>,
-  ZodMapDef<Key, Value>,
-  Map<Key["_input"], Value["_input"]>
-> {
-  readonly _value!: Value;
-
-  toJSON = () => ({
-    t: this._def.t,
-    valueType: this._def.valueType.toJSON(),
-    keyType: this._def.keyType.toJSON(),
-  });
-
-  static create = <
-    Key extends ZodTypeAny = ZodTypeAny,
-    Value extends ZodTypeAny = ZodTypeAny
-  >(
-    keyType: Key,
-    valueType: Value
-  ): ZodMap<Key, Value> => {
-    return new ZodMap({
-      t: ZodTypes.map,
-      valueType,
-      keyType,
-    });
-  };
-}
diff --git a/src/types/nativeEnum.ts b/src/types/nativeEnum.ts
deleted file mode 100644
index df50e0827..000000000
--- a/src/types/nativeEnum.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-
-export interface ZodNativeEnumDef<T extends EnumLike = EnumLike>
-  extends ZodTypeDef {
-  t: ZodTypes.nativeEnum;
-  values: T;
-}
-
-type EnumLike = { [k: string]: string | number; [nu: number]: string };
-
-export class ZodNativeEnum<T extends EnumLike> extends ZodType<
-  T[keyof T],
-  ZodNativeEnumDef<T>
-> {
-  toJSON = () => this._def;
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
-    return new ZodNativeEnum({
-      t: ZodTypes.nativeEnum,
-      values: values,
-    });
-  };
-}
diff --git a/src/types/never.ts b/src/types/never.ts
deleted file mode 100644
index c818dde9f..000000000
--- a/src/types/never.ts
+++ /dev/null
@@ -1,17 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-
-export interface ZodNeverDef extends ZodTypeDef {
-  t: ZodTypes.never;
-}
-
-export class ZodNever extends ZodType<never, ZodNeverDef> {
-  __class = "ZodNever";
-  toJSON = () => this._def;
-
-  static create = (): ZodNever => {
-    return new ZodNever({
-      t: ZodTypes.never,
-    });
-  };
-}
diff --git a/src/types/null.ts b/src/types/null.ts
deleted file mode 100644
index 89e65a189..000000000
--- a/src/types/null.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-// import { ZodUndefined } from './undefined';
-// import { ZodUnion } from './union';
-
-export interface ZodNullDef extends ZodTypeDef {
-  t: ZodTypes.null;
-}
-
-export class ZodNull extends ZodType<null, ZodNullDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-  static create = (): ZodNull => {
-    return new ZodNull({
-      t: ZodTypes.null,
-    });
-  };
-}
diff --git a/src/types/nullable.ts b/src/types/nullable.ts
deleted file mode 100644
index 2d65ff598..000000000
--- a/src/types/nullable.ts
+++ /dev/null
@@ -1,34 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-export interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.nullable;
-  innerType: T;
-}
-
-// This type allows for nullable flattening
-export type ZodNullableType<
-  T extends ZodTypeAny
-> = T extends ZodNullable<ZodTypeAny> ? T : ZodNullable<T>;
-
-export class ZodNullable<
-  T extends ZodTypeAny
-  //  Output extends T['_output'] | null = T['_output'] | null,
-  //  Input extends T['_input'] | null = T['_input'] | null
-> extends ZodType<T["_output"] | null, ZodNullableDef<T>, T["_input"] | null> {
-  // An nullable nullable is the original nullable
-  // nullable: () => ZodNullableType<this> = () => this as ZodNullableType<this>;
-  toJSON = () => ({
-    t: this._def.t,
-    innerType: this._def.innerType.toJSON(),
-  });
-
-  static create = <T extends ZodTypeAny>(type: T): ZodNullableType<T> => {
-    if (type instanceof ZodNullable) return type as ZodNullableType<T>;
-    return new ZodNullable({
-      t: ZodTypes.nullable,
-      innerType: type,
-    }) as ZodNullableType<T>;
-  };
-}
diff --git a/src/types/number.ts b/src/types/number.ts
deleted file mode 100644
index 8279c9c98..000000000
--- a/src/types/number.ts
+++ /dev/null
@@ -1,86 +0,0 @@
-import { errorUtil } from "../helpers/errorUtil";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-import { ZodIssueCode } from "../ZodError";
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-
-export interface ZodNumberDef extends ZodTypeDef {
-  t: ZodTypes.number;
-}
-
-export class ZodNumber extends ZodType<number, ZodNumberDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = () => this._def;
-  static create = (): ZodNumber => {
-    return new ZodNumber({
-      t: ZodTypes.number,
-    });
-  };
-
-  min = (minimum: number, message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data >= minimum, {
-      code: ZodIssueCode.too_small,
-      minimum,
-      type: "number",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-
-  max = (maximum: number, message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data <= maximum, {
-      code: ZodIssueCode.too_big,
-      maximum,
-      type: "number",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-
-  int = (message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => Number.isInteger(data), {
-      code: ZodIssueCode.invalid_type,
-      expected: "integer",
-      received: "number",
-      ...errorUtil.errToObj(message),
-    });
-
-  positive = (message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data > 0, {
-      code: ZodIssueCode.too_small,
-      minimum: 0,
-      type: "number",
-      inclusive: false,
-      ...errorUtil.errToObj(message),
-    });
-
-  negative = (message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data < 0, {
-      code: ZodIssueCode.too_big,
-      maximum: 0,
-      type: "number",
-      inclusive: false,
-      ...errorUtil.errToObj(message),
-    });
-
-  nonpositive = (message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data <= 0, {
-      code: ZodIssueCode.too_big,
-      maximum: 0,
-      type: "number",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-
-  nonnegative = (message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data >= 0, {
-      code: ZodIssueCode.too_small,
-      minimum: 0,
-      type: "number",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-}
diff --git a/src/types/object.ts b/src/types/object.ts
deleted file mode 100644
index 5741c0e34..000000000
--- a/src/types/object.ts
+++ /dev/null
@@ -1,426 +0,0 @@
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-import { objectUtil } from "../helpers/objectUtil";
-// import { mergeShapes } from "../helpers/objectUtil/merge";
-import { partialUtil } from "../helpers/partialUtil";
-import { Scalars } from "../helpers/primitive";
-import { isScalar } from "../isScalar";
-import { ZodTypes } from "../ZodTypes";
-import { ZodRawShape, ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-import { ZodNever } from "./never";
-
-export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-  Second extends AnyZodObject
->(
-  second: Second
-): ZodObject<
-  First["_shape"] & Second["_shape"],
-  First["_unknownKeys"],
-  First["_catchall"]
-  // MergeObjectParams<First['_params'], Second['_params']>,
-  // First['_input'] & Second['_input'],
-  // First['_output'] & Second['_output']
-> => {
-  const mergedShape = objectUtil.mergeShapes(
-    first._def.shape(),
-    second._def.shape()
-  );
-  const merged: any = new ZodObject({
-    t: ZodTypes.object,
-    effects: [...(first._def.effects || []), ...(second._def.effects || [])],
-    unknownKeys: first._def.unknownKeys,
-    catchall: first._def.catchall,
-    // params: {
-    //   strict: first.params.strict && second.params.strict,
-    // },
-    shape: () => mergedShape,
-  }) as any;
-  return merged;
-};
-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
-  Augmentation extends ZodRawShape
->(
-  augmentation: Augmentation
-): ZodObject<
-  {
-    [k in Exclude<
-      keyof ReturnType<Def["shape"]>,
-      keyof Augmentation
-    >]: ReturnType<Def["shape"]>[k];
-  } &
-    { [k in keyof Augmentation]: Augmentation[k] },
-  Def["unknownKeys"],
-  Def["catchall"]
-> => {
-  return new ZodObject({
-    ...def,
-    shape: () => ({
-      ...def.shape(),
-      ...augmentation,
-    }),
-  }) as any;
-};
-
-type UnknownKeysParam = "passthrough" | "strict" | "strip";
-
-export interface ZodObjectDef<
-  T extends ZodRawShape = ZodRawShape,
-  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,
-  Catchall extends ZodTypeAny = ZodTypeAny
-  // Params extends ZodObjectParams = ZodObjectParams
-> extends ZodTypeDef {
-  t: ZodTypes.object;
-  shape: () => T;
-  catchall: Catchall;
-  unknownKeys: UnknownKeys;
-  // params: Params;
-}
-
-export type baseObjectOutputType<
-  Shape extends ZodRawShape
-  // Catchall extends ZodTypeAny
-> = objectUtil.flatten<
-  objectUtil.addQuestionMarks<
-    {
-      [k in keyof Shape]: Shape[k]["_output"];
-    }
-  > //{ [k: string]: Catchall['_output'] }
->;
-
-export type objectOutputType<
-  Shape extends ZodRawShape,
-  Catchall extends ZodTypeAny
-> = ZodTypeAny extends Catchall
-  ? baseObjectOutputType<Shape>
-  : objectUtil.flatten<
-      baseObjectOutputType<Shape> & { [k: string]: Catchall["_output"] }
-    >;
-
-export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<
-  objectUtil.addQuestionMarks<
-    {
-      [k in keyof Shape]: Shape[k]["_input"];
-    }
-  >
->;
-
-export type objectInputType<
-  Shape extends ZodRawShape,
-  Catchall extends ZodTypeAny
-> = ZodTypeAny extends Catchall
-  ? baseObjectInputType<Shape>
-  : objectUtil.flatten<
-      baseObjectInputType<Shape> & { [k: string]: Catchall["_input"] }
-    >;
-
-const objectDefToJson = (def: ZodObjectDef<any, any>) => ({
-  t: def.t,
-  shape: Object.assign(
-    {},
-    ...Object.keys(def.shape()).map((k) => ({
-      [k]: def.shape()[k].toJSON(),
-    }))
-  ),
-});
-
-// interface ZodObjectParams {
-//   strict: boolean;
-// }
-
-// type SetKey<
-//   Target extends object,
-//   Key extends string,
-//   Value extends any
-// > = objectUtil.Flatten<
-//   { [k in Exclude<keyof Target, Key>]: Target[k] } & { [k in Key]: Value }
-// >;
-
-// type makeKeysRequired<T extends ZodObject<any, any, any>> = T extends ZodObject<
-//   infer U,
-//   infer P,
-//   infer C
-// >
-//   ? ZodObject<objectUtil.NoNever<{ [k in keyof U]: makeRequired<U[k]> }>, P, C>
-//   : never;
-
-// type makeRequired<T extends ZodType<any>> = T extends ZodUnion<infer U>
-//   ? U extends [infer Y, ZodUndefined]
-//     ? Y
-//     : U extends [ZodUndefined, infer Z]
-//     ? Z
-//     : T
-//   : T;
-
-// type ZodObjectType<
-//   T extends ZodRawShape,
-//   Params extends ZodObjectParams
-// > = Params['strict'] extends true
-//   ? objectUtil.ObjectType<T>
-//   : objectUtil.Flatten<objectUtil.ObjectType<T> & { [k: string]: any }>;
-
-export class ZodObject<
-  T extends ZodRawShape,
-  UnknownKeys extends UnknownKeysParam = "strip",
-  Catchall extends ZodTypeAny = ZodTypeAny,
-  // Params extends ZodObjectParams = { strict: true },
-  // Type extends ZodObjectType<T, Params> = ZodObjectType<T, Params>
-  Output = objectOutputType<T, Catchall>,
-  Input = objectInputType<T, Catchall>
-> extends ZodType<
-  //  objectUtil.objectOutputType<T, UnknownKeys, Catchall>,
-  Output,
-  ZodObjectDef<T, UnknownKeys, Catchall>,
-  Input
-> {
-  readonly _shape!: T;
-  readonly _unknownKeys!: UnknownKeys;
-  readonly _catchall!: Catchall;
-
-  get shape() {
-    return this._def.shape();
-  }
-
-  // get params() {
-  //   return this._def.params;
-  // }
-
-  //  get t() {
-  //    return this;
-  //  }
-
-  toJSON = () => objectDefToJson(this._def);
-
-  strict = (): ZodObject<T, "strict", Catchall> =>
-    new ZodObject({
-      ...this._def,
-      unknownKeys: "strict",
-    });
-
-  strip = (): ZodObject<T, "strip", Catchall> =>
-    new ZodObject({
-      ...this._def,
-      unknownKeys: "strip",
-    });
-
-  passthrough = (): ZodObject<T, "passthrough", Catchall> =>
-    new ZodObject({
-      ...this._def,
-      unknownKeys: "passthrough",
-    });
-
-  nonstrict = this.passthrough;
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  augment = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
-  extend = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
-
-  setKey = <Key extends string, Schema extends ZodTypeAny>(
-    key: Key,
-    schema: Schema
-  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> => {
-    return this.augment({ [key]: schema }) as any;
-  };
-
-  /**
-   * Prior to zod@1.0.12 there was a bug in the
-   * inferred type of merged objects. Please
-   * upgrade if you are experiencing issues.
-   */
-  merge: <Incoming extends AnyZodObject>(
-    other: Incoming
-  ) => ZodObject<
-    T & Incoming["_shape"],
-    UnknownKeys,
-    Catchall
-    // objectUtil.MergeObjectParams<Params, MergeUnknownKeys>
-  > = mergeObjects(this as any) as any;
-
-  catchall = <Index extends ZodTypeAny>(
-    index: Index
-  ): ZodObject<
-    T,
-    UnknownKeys,
-    Index
-    // objectUtil.MergeObjectParams<Params, MergeUnknownKeys>
-  > => {
-    return new ZodObject({
-      ...this._def,
-      // unknownKeys: 'passthrough',
-      catchall: index,
-    });
-  };
-
-  pick = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
-    UnknownKeys,
-    Catchall
-  > => {
-    const shape: any = {};
-    Object.keys(mask).map((key) => {
-      shape[key] = this.shape[key];
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => shape,
-    });
-  };
-
-  omit = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
-    UnknownKeys,
-    Catchall
-  > => {
-    const shape: any = {};
-    Object.keys(this.shape).map((key) => {
-      if (Object.keys(mask).indexOf(key) === -1) {
-        shape[key] = this.shape[key];
-      }
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => shape,
-    });
-  };
-
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k]["optional"]> },
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    });
-  };
-
-  // require: <This extends this>() => makeKeysRequired<This> = () => {
-  //   const newShape: any = {};
-  //   for (const key in this.shape) {
-  //     const val = this.shape[key];
-  //     if (val instanceof ZodUnion) {
-  //       const options = (val as ZodUnion<any>)._def.options;
-  //       if (options.length === 2) {
-  //         // .length === 2;
-  //         if (options[0] instanceof ZodUndefined) {
-  //           newShape[key] = options[1];
-  //         } else if (options[1] instanceof ZodUndefined) {
-  //           newShape[key] = options[0];
-  //         }
-  //       } else {
-  //         newShape[key] = val;
-  //       }
-  //     } else {
-  //       newShape[key] = val;
-  //     }
-  //   }
-  //   return new ZodObject({
-  //     ...this._def,
-  //     shape: () => newShape,
-  //   }) as any;
-  // };
-
-  primitives = (): ZodObject<
-    objectUtil.NoNever<
-      {
-        [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? T[k] : never;
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    for (const key in this.shape) {
-      if (isScalar(this.shape[key])) {
-        newShape[key] = this.shape[key];
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    });
-  };
-
-  nonprimitives = (): ZodObject<
-    objectUtil.NoNever<
-      {
-        [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? never : T[k];
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    for (const key in this.shape) {
-      if (!isScalar(this.shape[key])) {
-        newShape[key] = this.shape[key];
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    });
-  };
-
-  deepPartial: () => partialUtil.RootDeepPartial<this> = () => {
-    const newShape: any = {};
-
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      if (fieldSchema instanceof ZodObject) {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : (fieldSchema.deepPartial() as any).optional();
-      } else {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : fieldSchema.optional();
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
-  };
-
-  // keyof: ()=>ZodEnum<{[k in T]: k}>
-
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
-    return new ZodObject({
-      t: ZodTypes.object,
-      shape: () => shape,
-      unknownKeys: "strip",
-      catchall: ZodNever.create(),
-      //  params: {
-      //    strict: true,
-      //  },
-    }) as any;
-  };
-
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
-    return new ZodObject({
-      t: ZodTypes.object,
-      shape,
-      unknownKeys: "strip",
-      catchall: ZodNever.create(),
-    }) as any;
-  };
-}
-
-export type AnyZodObject = ZodObject<any, any, any>;
diff --git a/src/types/optional.ts b/src/types/optional.ts
deleted file mode 100644
index fb44080a3..000000000
--- a/src/types/optional.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-export interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.optional;
-  innerType: T;
-}
-
-// This type allows for optional flattening
-export type ZodOptionalType<
-  T extends ZodTypeAny
-> = T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
-
-export class ZodOptional<T extends ZodTypeAny> extends ZodType<
-  T["_output"] | undefined,
-  ZodOptionalDef<T>,
-  T["_input"] | undefined
-> {
-  // An optional optional is the original optional
-  // optional: () => ZodOptionalType<this> = () => this as ZodOptionalType<this>;
-  toJSON = () => ({
-    t: this._def.t,
-    innerType: this._def.innerType.toJSON(),
-  });
-
-  static create = <T extends ZodTypeAny>(type: T): ZodOptionalType<T> => {
-    if (type instanceof ZodOptional) return type as ZodOptionalType<T>;
-
-    return new ZodOptional({
-      t: ZodTypes.optional,
-      innerType: type,
-    }) as ZodOptionalType<T>;
-  };
-}
diff --git a/src/types/promise.ts b/src/types/promise.ts
deleted file mode 100644
index b5f3469c6..000000000
--- a/src/types/promise.ts
+++ /dev/null
@@ -1,36 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.promise;
-  type: T;
-}
-
-export class ZodPromise<T extends ZodTypeAny> extends ZodType<
-  Promise<T["_output"]>,
-  ZodPromiseDef<T>,
-  Promise<T["_input"]>
-> {
-  toJSON = () => {
-    return {
-      t: this._def.t,
-      type: this._def.type.toJSON(),
-    };
-  };
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
-    return new ZodPromise({
-      t: ZodTypes.promise,
-      type: schema,
-    });
-  };
-}
diff --git a/src/types/record.ts b/src/types/record.ts
deleted file mode 100644
index df1c72734..000000000
--- a/src/types/record.ts
+++ /dev/null
@@ -1,38 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.record;
-  valueType: Value;
-}
-
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value["_output"]>, // { [k in keyof T]: T[k]['_type'] },
-  ZodRecordDef<Value>,
-  Record<string, Value["_input"]>
-> {
-  readonly _value!: Value;
-
-  toJSON = () => ({
-    t: this._def.t,
-    valueType: this._def.valueType.toJSON(),
-  });
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
-    return new ZodRecord({
-      t: ZodTypes.record,
-      valueType,
-    });
-  };
-}
diff --git a/src/types/string.ts b/src/types/string.ts
deleted file mode 100644
index 435d71a06..000000000
--- a/src/types/string.ts
+++ /dev/null
@@ -1,97 +0,0 @@
-import { errorUtil } from "../helpers/errorUtil";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-import { StringValidation, ZodIssueCode } from "../ZodError";
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-
-export interface ZodStringDef extends ZodTypeDef {
-  t: ZodTypes.string;
-  validation: {
-    uuid?: true;
-    custom?: ((val: any) => boolean)[];
-  };
-}
-
-// eslint-disable-next-line
-const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
-const uuidRegex = /([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}){1}/i;
-
-export class ZodString extends ZodType<string, ZodStringDef> {
-  inputSchema = this;
-  outputSchema = this;
-
-  toJSON = () => this._def;
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data.length >= minLength, {
-      code: ZodIssueCode.too_small,
-      minimum: minLength,
-      type: "string",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    this.refinement((data) => data.length <= maxLength, {
-      code: ZodIssueCode.too_big,
-      maximum: maxLength,
-      type: "string",
-      inclusive: true,
-      ...errorUtil.errToObj(message),
-    });
-
-  length(len: number, message?: errorUtil.ErrMessage) {
-    return this.min(len, message).max(len, message);
-  }
-
-  protected _regex = (
-    regex: RegExp,
-    validation: StringValidation,
-    message?: errorUtil.ErrMessage
-  ) =>
-    this.refinement((data) => regex.test(data), {
-      validation,
-      code: ZodIssueCode.invalid_string,
-
-      ...errorUtil.errToObj(message),
-    });
-
-  email = (message?: errorUtil.ErrMessage) =>
-    this._regex(emailRegex, "email", message);
-
-  url = (message?: errorUtil.ErrMessage) =>
-    this.refinement(
-      (data) => {
-        try {
-          new URL(data);
-          return true;
-        } catch {
-          return false;
-        }
-      },
-      {
-        code: ZodIssueCode.invalid_string,
-        validation: "url",
-        ...errorUtil.errToObj(message),
-      }
-    );
-
-  // url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
-
-  uuid = (message?: errorUtil.ErrMessage) =>
-    this._regex(uuidRegex, "uuid", message);
-
-  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) =>
-    this._regex(regexp, "regex", message);
-
-  nonempty = (message?: errorUtil.ErrMessage) =>
-    this.min(1, errorUtil.errToObj(message));
-
-  static create = (): ZodString => {
-    return new ZodString({
-      t: ZodTypes.string,
-      validation: {},
-    });
-  };
-}
diff --git a/src/types/transformer.ts b/src/types/transformer.ts
deleted file mode 100644
index f949a25cd..000000000
--- a/src/types/transformer.ts
+++ /dev/null
@@ -1,66 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodTransformerDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  t: ZodTypes.transformer;
-  schema: T;
-  // transforms: (arg: T["_output"]) => U["_input"];
-}
-
-export class ZodTransformer<
-  T extends ZodTypeAny,
-  Output = T["_type"]
-> extends ZodType<Output, ZodTransformerDef<T>, T["_input"]> {
-  toJSON = () => ({
-    t: this._def.t,
-    schema: this._def.schema.toJSON(),
-  });
-
-  constructor(def: ZodTransformerDef<T>) {
-    super(def);
-    if (def.schema instanceof ZodTransformer) {
-      throw new Error("ZodTransformers cannot be nested.");
-    }
-  }
-
-  /** You can't use the .default method on transformers! */
-  default: (..._args: any[]) => never = (..._args: any[]) => {
-    throw new Error(
-      "You can't use the default method on a ZodTransformer instance."
-    );
-  };
-
-  // static create = <I extends ZodTypeAny, O extends ZodTypeAny, Out>(
-  static create = <I extends ZodTypeAny>(
-    schema: I
-    // outputSchema?: O,
-    // tx?: (arg: I["_output"]) => Out | Promise<Out>
-  ): ZodTransformer<I, I["_output"]> => {
-    // if (schema instanceof ZodTransformer) {
-    //   throw new Error("Can't nest transformers inside each other.");
-    // }
-    const newTx = new ZodTransformer({
-      t: ZodTypes.transformer,
-      schema,
-    });
-
-    // if (outputSchema && tx) {
-    //   console.warn(
-    //     `Calling transform() with three arguments is deprecated and not recommended.`
-    //   );
-    //   newTx = newTx.transform(tx).transform((val) => outputSchema.parse);
-    // }
-    return newTx;
-  };
-
-  // mod: <NewOut>(
-  //   arg: (curr: Output) => NewOut | Promise<NewOut>
-  // ) => ZodTransformer<T, NewOut> = (arg) => {
-  //   return this.mod(arg);
-  // };
-}
diff --git a/src/types/tuple.ts b/src/types/tuple.ts
deleted file mode 100644
index 2d71c2e5d..000000000
--- a/src/types/tuple.ts
+++ /dev/null
@@ -1,76 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-// import { objectUtil } from '../helpers/objectUtil';
-// import { ZodUnion } from './union';
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-
-// export type identity<T> = T;
-// export type flatten<T extends [any, ...any[]]> = identity<
-//   { [k in keyof T]: T[k] }
-// >;
-// type tupleOptionalKeys<T extends [any, ...any[]]> = {
-//   [k in keyof T]?: undefined extends T[k] ? T[k] : unknown;
-// }; //[keyof T];
-
-// type tupleRequiredKeys<T extends [any, ...any[]]> = {
-//   [k in keyof T]: undefined extends T[k] ? unknown : T[k];
-// };
-
-// export type addTupleQuestionMarks<T extends [any, ...any[]]> = flatten<
-//   tupleOptionalKeys<T> & tupleRequiredKeys<T>
-// >;
-
-// export type addTupleQuestionMarks<T extends [any, ...any[]]> = {
-//   [k in tupleOptionalKeys<T>]?: T[k];
-// } &
-//   { [k in tupleRequiredKeys<T>]: T[k] };
-
-// type test = [string, number | undefined]
-// type t2 = tupleOptionalKeys<test>;
-// type t3 = tupleRequiredKeys<test>;
-// type t4 = addTupleQuestionMarks<test>;
-// const x:t4 = ['asdf'];
-// type t5 = string & unknown;
-
-export type OutputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
-};
-
-export type InputTypeOfTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
-};
-
-export interface ZodTupleDef<
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodTypeDef {
-  t: ZodTypes.tuple;
-  items: T;
-}
-
-export class ZodTuple<
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
-  toJSON = () => ({
-    t: this._def.t,
-    items: (this._def.items as any[]).map((item) => item.toJSON()),
-  });
-
-  get items() {
-    return this._def.items;
-  }
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  static create = <T extends [ZodTypeAny, ...ZodTypeAny[]] | []>(
-    schemas: T
-  ): ZodTuple<T> => {
-    return new ZodTuple({
-      t: ZodTypes.tuple,
-      items: schemas,
-    });
-  };
-}
diff --git a/src/types/undefined.ts b/src/types/undefined.ts
deleted file mode 100644
index 40635e62b..000000000
--- a/src/types/undefined.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-// import { ZodUnion } from './union';
-// import { ZodNull } from './null';
-
-export interface ZodUndefinedDef extends ZodTypeDef {
-  t: ZodTypes.undefined;
-}
-
-export class ZodUndefined extends ZodType<undefined> {
-  toJSON = () => this._def;
-
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({
-      t: ZodTypes.undefined,
-    });
-  };
-}
diff --git a/src/types/union.ts b/src/types/union.ts
deleted file mode 100644
index 2f7cff341..000000000
--- a/src/types/union.ts
+++ /dev/null
@@ -1,46 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef, ZodTypeAny } from "./base";
-
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-
-export interface ZodUnionDef<
-  T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]] = [
-    ZodTypeAny,
-    ZodTypeAny,
-    ...ZodTypeAny[]
-  ]
-> extends ZodTypeDef {
-  t: ZodTypes.union;
-  options: T;
-}
-
-export class ZodUnion<
-  T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<T[number]["_output"], ZodUnionDef<T>, T[number]["_input"]> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-
-  toJSON = (): object => ({
-    t: this._def.t,
-    options: this._def.options.map((x) => x.toJSON()),
-  });
-
-  get options() {
-    return this._def.options;
-  }
-
-  // distribute = <F extends (arg: T[number]) => ZodTypeAny>(f: F): ZodUnion<{ [k in keyof T]: ReturnType<F> }> => {
-  //   return ZodUnion.create(this._def.options.map(f) as any);
-  // };
-
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
-    types: T
-  ): ZodUnion<T> => {
-    return new ZodUnion({
-      t: ZodTypes.union,
-      options: types,
-    });
-  };
-}
diff --git a/src/types/unknown.ts b/src/types/unknown.ts
deleted file mode 100644
index 10ca4a972..000000000
--- a/src/types/unknown.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodUnknownDef extends ZodTypeDef {
-  t: ZodTypes.unknown;
-}
-
-export class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-  toJSON = () => this._def;
-
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({
-      t: ZodTypes.unknown,
-    });
-  };
-}
diff --git a/src/types/void.ts b/src/types/void.ts
deleted file mode 100644
index b17881ae5..000000000
--- a/src/types/void.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { ZodTypes } from "../ZodTypes";
-import { ZodType, ZodTypeDef } from "./base";
-// import { ZodUndefined } from './undefined';
-// import { ZodNull } from './null';
-// import { ZodUnion } from './union';
-
-export interface ZodVoidDef extends ZodTypeDef {
-  t: ZodTypes.void;
-}
-
-export class ZodVoid extends ZodType<void, ZodVoidDef> {
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-  toJSON = () => this._def;
-
-  static create = (): ZodVoid => {
-    return new ZodVoid({
-      t: ZodTypes.void,
-    });
-  };
-}
diff --git a/tsconfig.base.json b/tsconfig.base.json
index 3f77547de..60ecd93dc 100644
--- a/tsconfig.base.json
+++ b/tsconfig.base.json
@@ -8,7 +8,7 @@
       "dom"
     ],
     "target": "es5",
-    "removeComments": true,
+    "removeComments": false,
     "declaration": true,
     "esModuleInterop": true,
     "sourceMap": true,
diff --git a/tsconfig.cjs.json b/tsconfig.cjs.json
index 4d489f588..bab1d539f 100644
--- a/tsconfig.cjs.json
+++ b/tsconfig.cjs.json
@@ -6,7 +6,6 @@
   },
   "exclude": [
     "./src/**/__tests__",
-    "./src/__tests__/**/*",
     "./src/playground.ts"
   ]
 }
\ No newline at end of file
diff --git a/tsconfig.json b/tsconfig.json
index ffcbb9477..b84c26ae2 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -1,3 +1,3 @@
 {
   "extends": "./tsconfig.base.json"
-}
+}
\ No newline at end of file
diff --git a/yarn.lock b/yarn.lock
index fbd15a466..cc273540f 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -1835,6 +1835,18 @@ eslint-plugin-simple-import-sort@^7.0.0:
   resolved "https://registry.yarnpkg.com/eslint-plugin-simple-import-sort/-/eslint-plugin-simple-import-sort-7.0.0.tgz#a1dad262f46d2184a90095a60c66fef74727f0f8"
   integrity sha512-U3vEDB5zhYPNfxT5TYR7u01dboFZp+HNpnGhkDB2g/2E4wZ/g1Q9Ton8UwCLfRV9yAKyYqDh62oHOamvkFxsvw==
 
+eslint-plugin-unused-imports@^1.1.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/eslint-plugin-unused-imports/-/eslint-plugin-unused-imports-1.1.0.tgz#4236063175c83f99cef42ea339a66679d75be19a"
+  integrity sha512-4SLYlkCwAbudvKDKZqn/3KjHlKAoorTxnP7AkAMMXkz59pQCBUjKPEaDv5pQ7fOyfDvLPCJKLowCcTl6HXcCuA==
+  dependencies:
+    eslint-rule-composer "^0.3.0"
+
+eslint-rule-composer@^0.3.0:
+  version "0.3.0"
+  resolved "https://registry.yarnpkg.com/eslint-rule-composer/-/eslint-rule-composer-0.3.0.tgz#79320c927b0c5c0d3d3d2b76c8b4a488f25bbaf9"
+  integrity sha512-bt+Sh8CtDmn2OajxvNO+BX7Wn4CIWMpTRm3MaiKPCQcnnlm0CS2mhui6QaoeQugs+3Kj2ESKEEGJUdVafwhiCg==
+
 eslint-scope@^5.0.0, eslint-scope@^5.1.1:
   version "5.1.1"
   resolved "https://registry.yarnpkg.com/eslint-scope/-/eslint-scope-5.1.1.tgz#e786e59a66cb92b3f6c1fb0d508aab174848f48c"
