diff --git a/README.md b/README.md
index 3bdcb7cac..5e6436704 100644
--- a/README.md
+++ b/README.md
@@ -89,9 +89,9 @@
   - [Cyclical data](#cyclical-objects)
 - [Promises](#promises)
 - [Instanceof](#instanceof)
-- [Functions](#function-schemas)
+- [Functions](#functions)
 - [Preprocess](#preprocess)
-- [Custom](#custom)
+- [Custom](#custom-schemas)
 - [Schema methods](#schema-methods)
   - [.parse](#parse)
   - [.parseAsync](#parseasync)
@@ -1534,7 +1534,7 @@ TestSchema.parse(new Test()); // passes
 TestSchema.parse("blob"); // throws
 ```
 
-## Function schemas
+## Functions
 
 Zod also lets you define "function schemas". This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and "business logic".
 
@@ -1980,7 +1980,8 @@ const Strings = z.string().transform((val, ctx) => {
 Transforms and refinements can be interleaved. These will be executed in the order they are declared.
 
 ```ts
-const nameToGreeting = z.string()
+const nameToGreeting = z
+  .string()
   .transform((val) => val.toUpperCase())
   .refine((val) => val.length > 15)
   .transform((val) => `Hello ${val}`)
@@ -2124,7 +2125,9 @@ z.union([z.string(), z.number()]);
 A convenience method for creating intersection types.
 
 ```ts
-const nameAndAge = z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }
+const nameAndAge = z
+  .object({ name: z.string() })
+  .and(z.object({ age: z.number() })); // { name: string } & { age: number }
 
 // equivalent to
 z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));
diff --git a/deno/lib/README.md b/deno/lib/README.md
index 3bdcb7cac..5e6436704 100644
--- a/deno/lib/README.md
+++ b/deno/lib/README.md
@@ -89,9 +89,9 @@
   - [Cyclical data](#cyclical-objects)
 - [Promises](#promises)
 - [Instanceof](#instanceof)
-- [Functions](#function-schemas)
+- [Functions](#functions)
 - [Preprocess](#preprocess)
-- [Custom](#custom)
+- [Custom](#custom-schemas)
 - [Schema methods](#schema-methods)
   - [.parse](#parse)
   - [.parseAsync](#parseasync)
@@ -1534,7 +1534,7 @@ TestSchema.parse(new Test()); // passes
 TestSchema.parse("blob"); // throws
 ```
 
-## Function schemas
+## Functions
 
 Zod also lets you define "function schemas". This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and "business logic".
 
@@ -1980,7 +1980,8 @@ const Strings = z.string().transform((val, ctx) => {
 Transforms and refinements can be interleaved. These will be executed in the order they are declared.
 
 ```ts
-const nameToGreeting = z.string()
+const nameToGreeting = z
+  .string()
   .transform((val) => val.toUpperCase())
   .refine((val) => val.length > 15)
   .transform((val) => `Hello ${val}`)
@@ -2124,7 +2125,9 @@ z.union([z.string(), z.number()]);
 A convenience method for creating intersection types.
 
 ```ts
-const nameAndAge = z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }
+const nameAndAge = z
+  .object({ name: z.string() })
+  .and(z.object({ age: z.number() })); // { name: string } & { age: number }
 
 // equivalent to
 z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));
diff --git a/deno/lib/__tests__/catch.test.ts b/deno/lib/__tests__/catch.test.ts
index b2910a0dc..892ca12f0 100644
--- a/deno/lib/__tests__/catch.test.ts
+++ b/deno/lib/__tests__/catch.test.ts
@@ -9,6 +9,16 @@ test("basic catch", () => {
   expect(z.string().catch("default").parse(undefined)).toBe("default");
 });
 
+test("catch fn does not run when parsing succeeds", () => {
+  let isCalled = false;
+  const cb = () => {
+    isCalled = true;
+    return "asdf";
+  };
+  expect(z.string().catch(cb).parse("test")).toBe("test");
+  expect(isCalled).toEqual(false);
+});
+
 test("basic catch async", async () => {
   const result = await z.string().catch("default").parseAsync(1243);
   expect(result).toBe("default");
diff --git a/deno/lib/__tests__/string.test.ts b/deno/lib/__tests__/string.test.ts
index 4d5d20529..2fe0ced86 100644
--- a/deno/lib/__tests__/string.test.ts
+++ b/deno/lib/__tests__/string.test.ts
@@ -192,16 +192,19 @@ test("trim", () => {
 
 test("datetime", () => {
   const a = z.string().datetime({});
-  expect(a.isDatetime()).toEqual(true);
+  expect(a.isDatetime).toEqual(true);
 
   const b = z.string().datetime({ offset: true });
-  expect(b.isDatetime()).toEqual(true);
+  expect(b.isDatetime).toEqual(true);
 
   const c = z.string().datetime({ precision: 3 });
-  expect(c.isDatetime()).toEqual(true);
+  expect(c.isDatetime).toEqual(true);
 
   const d = z.string().datetime({ offset: true, precision: 0 });
-  expect(d.isDatetime()).toEqual(true);
+  expect(d.isDatetime).toEqual(true);
+
+  const { isDatetime } = z.string().datetime();
+  expect(isDatetime).toEqual(true);
 });
 
 test("datetime parsing", () => {
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index ee260df65..fc83977fd 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -847,7 +847,7 @@ export class ZodString extends ZodType<string, ZodStringDef> {
       checks: [...this._def.checks, { kind: "trim" }],
     });
 
-  isDatetime() {
+  get isDatetime() {
     return !!this._def.checks.find((ch) => ch.kind === "datetime");
   }
 
@@ -2469,7 +2469,7 @@ export type ZodDiscriminatedUnionOption<Discriminator extends string> =
 
 export interface ZodDiscriminatedUnionDef<
   Discriminator extends string,
-  Options extends ZodDiscriminatedUnionOption<any>[]
+  Options extends ZodDiscriminatedUnionOption<any>[] = ZodDiscriminatedUnionOption<any>[]
 > extends ZodTypeDef {
   discriminator: Discriminator;
   options: Options;
@@ -4076,17 +4076,17 @@ export class ZodCatch<T extends ZodTypeAny> extends ZodType<
 
     if (isAsync(result)) {
       return result.then((result) => {
-        const defaultValue = this._def.defaultValue();
         return {
           status: "valid",
-          value: result.status === "valid" ? result.value : defaultValue,
+          value:
+            result.status === "valid" ? result.value : this._def.defaultValue(),
         };
       });
     } else {
-      const defaultValue = this._def.defaultValue();
       return {
         status: "valid",
-        value: result.status === "valid" ? result.value : defaultValue,
+        value:
+          result.status === "valid" ? result.value : this._def.defaultValue(),
       };
     }
   }
diff --git a/package.json b/package.json
index 9058dc63b..997b2599f 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.20.0",
+  "version": "3.20.1",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./index.d.ts",
diff --git a/playground.ts b/playground.ts
index a512dcd78..77cb8e37e 100644
--- a/playground.ts
+++ b/playground.ts
@@ -1 +1,7 @@
 import { z } from "./src";
+
+const schema = z.object({
+  birth_date: z.date().optional(),
+});
+
+schema.parse({});
diff --git a/src/__tests__/catch.test.ts b/src/__tests__/catch.test.ts
index 22c2e348d..99615f2f1 100644
--- a/src/__tests__/catch.test.ts
+++ b/src/__tests__/catch.test.ts
@@ -8,6 +8,16 @@ test("basic catch", () => {
   expect(z.string().catch("default").parse(undefined)).toBe("default");
 });
 
+test("catch fn does not run when parsing succeeds", () => {
+  let isCalled = false;
+  const cb = () => {
+    isCalled = true;
+    return "asdf";
+  };
+  expect(z.string().catch(cb).parse("test")).toBe("test");
+  expect(isCalled).toEqual(false);
+});
+
 test("basic catch async", async () => {
   const result = await z.string().catch("default").parseAsync(1243);
   expect(result).toBe("default");
diff --git a/src/__tests__/string.test.ts b/src/__tests__/string.test.ts
index 425250595..0e9536e83 100644
--- a/src/__tests__/string.test.ts
+++ b/src/__tests__/string.test.ts
@@ -191,16 +191,19 @@ test("trim", () => {
 
 test("datetime", () => {
   const a = z.string().datetime({});
-  expect(a.isDatetime()).toEqual(true);
+  expect(a.isDatetime).toEqual(true);
 
   const b = z.string().datetime({ offset: true });
-  expect(b.isDatetime()).toEqual(true);
+  expect(b.isDatetime).toEqual(true);
 
   const c = z.string().datetime({ precision: 3 });
-  expect(c.isDatetime()).toEqual(true);
+  expect(c.isDatetime).toEqual(true);
 
   const d = z.string().datetime({ offset: true, precision: 0 });
-  expect(d.isDatetime()).toEqual(true);
+  expect(d.isDatetime).toEqual(true);
+
+  const { isDatetime } = z.string().datetime();
+  expect(isDatetime).toEqual(true);
 });
 
 test("datetime parsing", () => {
diff --git a/src/types.ts b/src/types.ts
index 15c0b7d72..6d9d8f369 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -847,7 +847,7 @@ export class ZodString extends ZodType<string, ZodStringDef> {
       checks: [...this._def.checks, { kind: "trim" }],
     });
 
-  isDatetime() {
+  get isDatetime() {
     return !!this._def.checks.find((ch) => ch.kind === "datetime");
   }
 
@@ -2469,7 +2469,7 @@ export type ZodDiscriminatedUnionOption<Discriminator extends string> =
 
 export interface ZodDiscriminatedUnionDef<
   Discriminator extends string,
-  Options extends ZodDiscriminatedUnionOption<any>[]
+  Options extends ZodDiscriminatedUnionOption<any>[] = ZodDiscriminatedUnionOption<any>[]
 > extends ZodTypeDef {
   discriminator: Discriminator;
   options: Options;
@@ -4076,17 +4076,17 @@ export class ZodCatch<T extends ZodTypeAny> extends ZodType<
 
     if (isAsync(result)) {
       return result.then((result) => {
-        const defaultValue = this._def.defaultValue();
         return {
           status: "valid",
-          value: result.status === "valid" ? result.value : defaultValue,
+          value:
+            result.status === "valid" ? result.value : this._def.defaultValue(),
         };
       });
     } else {
-      const defaultValue = this._def.defaultValue();
       return {
         status: "valid",
-        value: result.status === "valid" ? result.value : defaultValue,
+        value:
+          result.status === "valid" ? result.value : this._def.defaultValue(),
       };
     }
   }
