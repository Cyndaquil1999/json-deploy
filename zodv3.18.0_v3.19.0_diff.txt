diff --git a/README.md b/README.md
index 52507bd30..ed05f56c8 100644
--- a/README.md
+++ b/README.md
@@ -63,7 +63,7 @@
 - [Nullables](#nullables)
 - [Objects](#objects)
   - [.shape](#shape)
-  - [.enum](#enum)
+  - [.keyof](#keyof)
   - [.extend](#extend)
   - [.merge](#merge)
   - [.pick/.omit](#pickomit)
@@ -90,7 +90,6 @@
 - [Instanceof](#instanceof)
 - [Function schemas](#function-schemas)
 - [Preprocess](#preprocess)
-- [Branded types](#branded-types)
 - [Schema methods](#schema-methods)
   - [.parse](#parse)
   - [.parseAsync](#parseasync)
@@ -107,6 +106,7 @@
   - [.promise](#promise)
   - [.or](#or)
   - [.and](#and)
+  - [.brand](#brand)
 - [Guides and concepts](#guides-and-concepts)
   - [Type inference](#type-inference)
   - [Writing generic functions](#writing-generic-functions)
@@ -306,9 +306,9 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`tRPC`](https://github.com/trpc/trpc): Build end-to-end typesafe APIs without GraphQL.
 - [`ts-to-zod`](https://github.com/fabien0102/ts-to-zod): Convert TypeScript definitions into Zod schemas.
 - [`zod-to-ts`](https://github.com/sachinraja/zod-to-ts): Generate TypeScript definitions from Zod schemas.
-- [`@anatine/zod-openapi`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-openapi): Converts a Zod schema to an OpenAPI v3.x `SchemaObject`.
-- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/Marak/Faker.js).
-- [`@anatine/zod-nestjs`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-nestjs): Helper methods for using Zod in a NestJS project.
+- [`@anatine/zod-openapi`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-openapi): Converts a Zod schema to an OpenAPI v3.x `SchemaObject`.
+- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/Marak/Faker.js).
+- [`@anatine/zod-nestjs`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-nestjs): Helper methods for using Zod in a NestJS project.
 - [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.
 - [`zod-fast-check`](https://github.com/DavidTimms/zod-fast-check): Generate `fast-check` arbitraries from Zod schemas.
 - [`zod-endpoints`](https://github.com/flock-community/zod-endpoints): Contract-first strictly typed endpoints with Zod. OpenAPI compatible.
@@ -330,6 +330,7 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`remix-domains`](https://github.com/SeasonedSoftware/remix-domains/): Improves end-to-end type safety in [Remix](https://remix.run/) by leveraging Zod to parse the framework's inputs such as FormData, URLSearchParams, etc.
 - [`@zodios/core`](https://github.com/ecyrbe/zodios): A typescript API client with runtime and compile time validation backed by axios and zod.
 - [`@runtyping/zod`](https://github.com/johngeorgewright/runtyping/tree/master/packages/zod): Generate zod from static types & JSON schema.
+- [`slonik`](https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference): Node.js Postgres client with strong Zod integration
 
 #### Form integrations
 
@@ -603,7 +604,7 @@ dateSchema.safeParse(new Date("1/12/22")); // success: true
 dateSchema.safeParse("2022-01-12T00:00:00.000Z"); // success: true
 ```
 
-## Zod enums
+## Zod enums-
 
 ```ts
 const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
@@ -799,7 +800,7 @@ Dog.shape.age; // => number schema
 
 ### `.keyof`
 
-Use `.key` to create a `ZodEnum` schema from the keys of an object schema.
+Use `.keyof` to create a `ZodEnum` schema from the keys of an object schema.
 
 ```ts
 const keySchema = Dog.keyof();
@@ -1073,6 +1074,14 @@ type Athlete = z.infer<typeof athleteSchema>;
 // type Athlete = [string, number, { pointsScored: number }]
 ```
 
+A variadic ("rest") argument can be added with the `.rest` method.
+
+```ts
+const variadicTuple = z.tuple([z.string()]).rest(z.number());
+const result = variadicTuple.parse(["hello", 1, 2, 3]);
+// => [string, ...number[]];
+```
+
 ## Unions
 
 Zod includes a built-in `z.union` method for composing "OR" types.
@@ -1683,34 +1692,33 @@ const Strings = z.array(z.string()).superRefine((val, ctx) => {
 });
 ```
 
-You can add as many issues as you like. If `ctx.addIssue` is NOT called during the execution of the function, validation passes.
+You can add as many issues as you like. If `ctx.addIssue` is _not_ called during the execution of the function, validation passes.
 
 Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` you can create any issue of any code. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).
 
 #### Abort early
 
-By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to _abort early_ to prevent later refinements from being executed. To achieve this, pass the `fatal` flag to `ctx.addIssue`:
+By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to _abort early_ to prevent later refinements from being executed. To achieve this, pass the `fatal` flag to `ctx.addIssue` and return `z.NEVER`.
 
 ```ts
-const Strings = z
-  .number()
-  .superRefine((val, ctx) => {
-    if (val < 10) {
-      ctx.addIssue({
-        code: z.ZodIssueCode.custom,
-        message: "foo",
-        fatal: true,
-      });
-    }
-  })
-  .superRefine((val, ctx) => {
-    if (val !== " ") {
-      ctx.addIssue({
-        code: z.ZodIssueCode.custom,
-        message: "bar",
-      });
-    }
-  });
+const schema = z.number().superRefine((val, ctx) => {
+  if (val < 10) {
+    ctx.addIssue({
+      code: z.ZodIssueCode.custom,
+      message: "should be >= 10",
+      fatal: true,
+    });
+
+    return z.NEVER;
+  }
+
+  if (val !== 12) {
+    ctx.addIssue({
+      code: z.ZodIssueCode.custom,
+      message: "should be twelve",
+    });
+  }
+});
 ```
 
 ### `.transform`
@@ -1749,6 +1757,12 @@ const Strings = z.string().transform((val, ctx) => {
       code: z.ZodIssueCode.custom,
       message: "Not a number",
     });
+
+    // This is a special symbol you can use to
+    // return early from the transform function.
+    // It has type `never` so it does not affect the
+    // inferred return type.
+    return z.NEVER;
   }
   return parsed;
 });
diff --git a/deno/lib/README.md b/deno/lib/README.md
index 52507bd30..ed05f56c8 100644
--- a/deno/lib/README.md
+++ b/deno/lib/README.md
@@ -63,7 +63,7 @@
 - [Nullables](#nullables)
 - [Objects](#objects)
   - [.shape](#shape)
-  - [.enum](#enum)
+  - [.keyof](#keyof)
   - [.extend](#extend)
   - [.merge](#merge)
   - [.pick/.omit](#pickomit)
@@ -90,7 +90,6 @@
 - [Instanceof](#instanceof)
 - [Function schemas](#function-schemas)
 - [Preprocess](#preprocess)
-- [Branded types](#branded-types)
 - [Schema methods](#schema-methods)
   - [.parse](#parse)
   - [.parseAsync](#parseasync)
@@ -107,6 +106,7 @@
   - [.promise](#promise)
   - [.or](#or)
   - [.and](#and)
+  - [.brand](#brand)
 - [Guides and concepts](#guides-and-concepts)
   - [Type inference](#type-inference)
   - [Writing generic functions](#writing-generic-functions)
@@ -306,9 +306,9 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`tRPC`](https://github.com/trpc/trpc): Build end-to-end typesafe APIs without GraphQL.
 - [`ts-to-zod`](https://github.com/fabien0102/ts-to-zod): Convert TypeScript definitions into Zod schemas.
 - [`zod-to-ts`](https://github.com/sachinraja/zod-to-ts): Generate TypeScript definitions from Zod schemas.
-- [`@anatine/zod-openapi`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-openapi): Converts a Zod schema to an OpenAPI v3.x `SchemaObject`.
-- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/Marak/Faker.js).
-- [`@anatine/zod-nestjs`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-nestjs): Helper methods for using Zod in a NestJS project.
+- [`@anatine/zod-openapi`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-openapi): Converts a Zod schema to an OpenAPI v3.x `SchemaObject`.
+- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/Marak/Faker.js).
+- [`@anatine/zod-nestjs`](https://github.com/anatine/zod-plugins/tree/main/packages/zod-nestjs): Helper methods for using Zod in a NestJS project.
 - [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.
 - [`zod-fast-check`](https://github.com/DavidTimms/zod-fast-check): Generate `fast-check` arbitraries from Zod schemas.
 - [`zod-endpoints`](https://github.com/flock-community/zod-endpoints): Contract-first strictly typed endpoints with Zod. OpenAPI compatible.
@@ -330,6 +330,7 @@ There are a growing number of tools that are built atop or support Zod natively!
 - [`remix-domains`](https://github.com/SeasonedSoftware/remix-domains/): Improves end-to-end type safety in [Remix](https://remix.run/) by leveraging Zod to parse the framework's inputs such as FormData, URLSearchParams, etc.
 - [`@zodios/core`](https://github.com/ecyrbe/zodios): A typescript API client with runtime and compile time validation backed by axios and zod.
 - [`@runtyping/zod`](https://github.com/johngeorgewright/runtyping/tree/master/packages/zod): Generate zod from static types & JSON schema.
+- [`slonik`](https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference): Node.js Postgres client with strong Zod integration
 
 #### Form integrations
 
@@ -603,7 +604,7 @@ dateSchema.safeParse(new Date("1/12/22")); // success: true
 dateSchema.safeParse("2022-01-12T00:00:00.000Z"); // success: true
 ```
 
-## Zod enums
+## Zod enums-
 
 ```ts
 const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
@@ -799,7 +800,7 @@ Dog.shape.age; // => number schema
 
 ### `.keyof`
 
-Use `.key` to create a `ZodEnum` schema from the keys of an object schema.
+Use `.keyof` to create a `ZodEnum` schema from the keys of an object schema.
 
 ```ts
 const keySchema = Dog.keyof();
@@ -1073,6 +1074,14 @@ type Athlete = z.infer<typeof athleteSchema>;
 // type Athlete = [string, number, { pointsScored: number }]
 ```
 
+A variadic ("rest") argument can be added with the `.rest` method.
+
+```ts
+const variadicTuple = z.tuple([z.string()]).rest(z.number());
+const result = variadicTuple.parse(["hello", 1, 2, 3]);
+// => [string, ...number[]];
+```
+
 ## Unions
 
 Zod includes a built-in `z.union` method for composing "OR" types.
@@ -1683,34 +1692,33 @@ const Strings = z.array(z.string()).superRefine((val, ctx) => {
 });
 ```
 
-You can add as many issues as you like. If `ctx.addIssue` is NOT called during the execution of the function, validation passes.
+You can add as many issues as you like. If `ctx.addIssue` is _not_ called during the execution of the function, validation passes.
 
 Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` you can create any issue of any code. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).
 
 #### Abort early
 
-By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to _abort early_ to prevent later refinements from being executed. To achieve this, pass the `fatal` flag to `ctx.addIssue`:
+By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to _abort early_ to prevent later refinements from being executed. To achieve this, pass the `fatal` flag to `ctx.addIssue` and return `z.NEVER`.
 
 ```ts
-const Strings = z
-  .number()
-  .superRefine((val, ctx) => {
-    if (val < 10) {
-      ctx.addIssue({
-        code: z.ZodIssueCode.custom,
-        message: "foo",
-        fatal: true,
-      });
-    }
-  })
-  .superRefine((val, ctx) => {
-    if (val !== " ") {
-      ctx.addIssue({
-        code: z.ZodIssueCode.custom,
-        message: "bar",
-      });
-    }
-  });
+const schema = z.number().superRefine((val, ctx) => {
+  if (val < 10) {
+    ctx.addIssue({
+      code: z.ZodIssueCode.custom,
+      message: "should be >= 10",
+      fatal: true,
+    });
+
+    return z.NEVER;
+  }
+
+  if (val !== 12) {
+    ctx.addIssue({
+      code: z.ZodIssueCode.custom,
+      message: "should be twelve",
+    });
+  }
+});
 ```
 
 ### `.transform`
@@ -1749,6 +1757,12 @@ const Strings = z.string().transform((val, ctx) => {
       code: z.ZodIssueCode.custom,
       message: "Not a number",
     });
+
+    // This is a special symbol you can use to
+    // return early from the transform function.
+    // It has type `never` so it does not affect the
+    // inferred return type.
+    return z.NEVER;
   }
   return parsed;
 });
diff --git a/deno/lib/ZodError.ts b/deno/lib/ZodError.ts
index b5739a2f8..26075791f 100644
--- a/deno/lib/ZodError.ts
+++ b/deno/lib/ZodError.ts
@@ -1,5 +1,4 @@
 import type { TypeOf, ZodType } from "./index.ts";
-import { jsonStringifyReplacer } from "./helpers/parseUtil.ts";
 import { Primitive } from "./helpers/typeAliases.ts";
 import { util, ZodParsedType } from "./helpers/util.ts";
 
@@ -251,7 +250,7 @@ export class ZodError<T = any> extends Error {
     return this.message;
   }
   get message() {
-    return JSON.stringify(this.issues, jsonStringifyReplacer, 2);
+    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
   }
 
   get isEmpty(): boolean {
@@ -299,134 +298,12 @@ export type IssueData = stripPath<ZodIssueOptionalMessage> & {
 };
 export type MakeErrorData = IssueData;
 
-type ErrorMapCtx = {
+export type ErrorMapCtx = {
   defaultError: string;
   data: any;
 };
 
-export type ZodErrorMap = typeof defaultErrorMap;
-export const defaultErrorMap = (
+export type ZodErrorMap = (
   issue: ZodIssueOptionalMessage,
   _ctx: ErrorMapCtx
-): { message: string } => {
-  let message: string;
-  switch (issue.code) {
-    case ZodIssueCode.invalid_type:
-      if (issue.received === ZodParsedType.undefined) {
-        message = "Required";
-      } else {
-        message = `Expected ${issue.expected}, received ${issue.received}`;
-      }
-      break;
-    case ZodIssueCode.invalid_literal:
-      message = `Invalid literal value, expected ${JSON.stringify(
-        issue.expected,
-        jsonStringifyReplacer
-      )}`;
-      break;
-    case ZodIssueCode.unrecognized_keys:
-      message = `Unrecognized key(s) in object: ${util.joinValues(
-        issue.keys,
-        ", "
-      )}`;
-      break;
-    case ZodIssueCode.invalid_union:
-      message = `Invalid input`;
-      break;
-    case ZodIssueCode.invalid_union_discriminator:
-      message = `Invalid discriminator value. Expected ${util.joinValues(
-        issue.options
-      )}`;
-      break;
-    case ZodIssueCode.invalid_enum_value:
-      message = `Invalid enum value. Expected ${util.joinValues(
-        issue.options
-      )}, received '${issue.received}'`;
-      break;
-    case ZodIssueCode.invalid_arguments:
-      message = `Invalid function arguments`;
-      break;
-    case ZodIssueCode.invalid_return_type:
-      message = `Invalid function return type`;
-      break;
-    case ZodIssueCode.invalid_date:
-      message = `Invalid date`;
-      break;
-    case ZodIssueCode.invalid_string:
-      if (typeof issue.validation === "object") {
-        if ("startsWith" in issue.validation) {
-          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
-        } else if ("endsWith" in issue.validation) {
-          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
-        } else {
-          util.assertNever(issue.validation);
-        }
-      } else if (issue.validation !== "regex") {
-        message = `Invalid ${issue.validation}`;
-      } else {
-        message = "Invalid";
-      }
-      break;
-    case ZodIssueCode.too_small:
-      if (issue.type === "array")
-        message = `Array must contain ${
-          issue.inclusive ? `at least` : `more than`
-        } ${issue.minimum} element(s)`;
-      else if (issue.type === "string")
-        message = `String must contain ${
-          issue.inclusive ? `at least` : `over`
-        } ${issue.minimum} character(s)`;
-      else if (issue.type === "number")
-        message = `Number must be greater than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${issue.minimum}`;
-      else if (issue.type === "date")
-        message = `Date must be greater than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${new Date(issue.minimum)}`;
-      else message = "Invalid input";
-      break;
-    case ZodIssueCode.too_big:
-      if (issue.type === "array")
-        message = `Array must contain ${
-          issue.inclusive ? `at most` : `less than`
-        } ${issue.maximum} element(s)`;
-      else if (issue.type === "string")
-        message = `String must contain ${
-          issue.inclusive ? `at most` : `under`
-        } ${issue.maximum} character(s)`;
-      else if (issue.type === "number")
-        message = `Number must be less than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${issue.maximum}`;
-      else if (issue.type === "date")
-        message = `Date must be smaller than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${new Date(issue.maximum)}`;
-      else message = "Invalid input";
-      break;
-    case ZodIssueCode.custom:
-      message = `Invalid input`;
-      break;
-    case ZodIssueCode.invalid_intersection_types:
-      message = `Intersection results could not be merged`;
-      break;
-    case ZodIssueCode.not_multiple_of:
-      message = `Number must be a multiple of ${issue.multipleOf}`;
-      break;
-    default:
-      message = _ctx.defaultError;
-      util.assertNever(issue);
-  }
-  return { message };
-};
-
-let overrideErrorMap = defaultErrorMap;
-
-export function setErrorMap(map: ZodErrorMap) {
-  overrideErrorMap = map;
-}
-
-export function getErrorMap() {
-  return overrideErrorMap;
-}
+) => { message: string };
diff --git a/deno/lib/__tests__/function.test.ts b/deno/lib/__tests__/function.test.ts
index ac522d03d..4737afb72 100644
--- a/deno/lib/__tests__/function.test.ts
+++ b/deno/lib/__tests__/function.test.ts
@@ -110,6 +110,8 @@ test("output validation error", () => {
   expect(checker).toThrow();
 });
 
+z.function(z.tuple([z.string()])).args()._def.args;
+
 test("special function error codes", () => {
   const checker = z
     .function(z.tuple([z.string()]), z.boolean())
diff --git a/deno/lib/__tests__/instanceof.test.ts b/deno/lib/__tests__/instanceof.test.ts
index 3b8428436..93b501a84 100644
--- a/deno/lib/__tests__/instanceof.test.ts
+++ b/deno/lib/__tests__/instanceof.test.ts
@@ -8,13 +8,20 @@ import * as z from "../index.ts";
 test("instanceof", async () => {
   class Test {}
   class Subtest extends Test {}
+  abstract class AbstractBar {
+    constructor(public val: string) {}
+  }
+  class Bar extends AbstractBar {}
 
   const TestSchema = z.instanceof(Test);
   const SubtestSchema = z.instanceof(Subtest);
+  const BarSchema = z.instanceof(Bar);
 
   TestSchema.parse(new Test());
   TestSchema.parse(new Subtest());
   SubtestSchema.parse(new Subtest());
+  const bar = BarSchema.parse(new Bar("asdf"));
+  expect(bar.val).toEqual("asdf");
 
   await expect(() => SubtestSchema.parse(new Test())).toThrow(
     /Input not instance of Subtest/
diff --git a/deno/lib/__tests__/object.test.ts b/deno/lib/__tests__/object.test.ts
index 6b32541c9..200678dd3 100644
--- a/deno/lib/__tests__/object.test.ts
+++ b/deno/lib/__tests__/object.test.ts
@@ -365,3 +365,26 @@ test("constructor key", () => {
   type Example = z.infer<typeof Example>;
   util.assertEqual<keyof Example, "prop" | "opt" | "arr">(true);
 });
+
+test("unknownkeys merging", () => {
+  // This one is "strict"
+  const schemaA = z
+    .object({
+      a: z.string(),
+    })
+    .strict();
+
+  // This one is "strip"
+  const schemaB = z
+    .object({
+      b: z.string(),
+    })
+    .catchall(z.string());
+
+  const mergedSchema = schemaA.merge(schemaB);
+  type mergedSchema = typeof mergedSchema;
+  util.assertEqual<mergedSchema["_def"]["unknownKeys"], "strip">(true);
+  expect(mergedSchema._def.unknownKeys).toEqual("strip");
+  util.assertEqual<mergedSchema["_def"]["catchall"], z.ZodString>(true);
+  expect(mergedSchema._def.catchall instanceof z.ZodString).toEqual(true);
+});
diff --git a/deno/lib/__tests__/transformer.test.ts b/deno/lib/__tests__/transformer.test.ts
index db1e72d00..5d7760780 100644
--- a/deno/lib/__tests__/transformer.test.ts
+++ b/deno/lib/__tests__/transformer.test.ts
@@ -74,6 +74,25 @@ test("transform ctx.addIssue with parseAsync", async () => {
   });
 });
 
+test("z.NEVER in transform", async () => {
+  const foo = z
+    .number()
+    .optional()
+    .transform((val, ctx) => {
+      if (!val) {
+        ctx.addIssue({ code: z.ZodIssueCode.custom, message: "bad" });
+        return z.NEVER;
+      }
+      return val;
+    });
+  type foo = z.infer<typeof foo>;
+  util.assertEqual<foo, number>(true);
+  const arg = foo.safeParse(undefined);
+  if (!arg.success) {
+    expect(arg.error.issues[0].message).toEqual("bad");
+  }
+});
+
 test("basic transformations", () => {
   const r1 = z
     .string()
diff --git a/deno/lib/errors.ts b/deno/lib/errors.ts
new file mode 100644
index 000000000..f3d1a17e9
--- /dev/null
+++ b/deno/lib/errors.ts
@@ -0,0 +1,13 @@
+import defaultErrorMap from "./locales/en.ts";
+import type { ZodErrorMap } from "./ZodError.ts";
+
+let overrideErrorMap = defaultErrorMap;
+export { defaultErrorMap };
+
+export function setErrorMap(map: ZodErrorMap) {
+  overrideErrorMap = map;
+}
+
+export function getErrorMap() {
+  return overrideErrorMap;
+}
diff --git a/deno/lib/external.ts b/deno/lib/external.ts
index 700b626ac..42772455c 100644
--- a/deno/lib/external.ts
+++ b/deno/lib/external.ts
@@ -1,3 +1,4 @@
+export * from "./errors.ts";
 export * from "./helpers/parseUtil.ts";
 export * from "./helpers/typeAliases.ts";
 export { getParsedType, ZodParsedType } from "./helpers/util.ts";
diff --git a/deno/lib/helpers/parseUtil.ts b/deno/lib/helpers/parseUtil.ts
index 78c8531d7..8be51d97c 100644
--- a/deno/lib/helpers/parseUtil.ts
+++ b/deno/lib/helpers/parseUtil.ts
@@ -1,5 +1,6 @@
+import { getErrorMap } from "../errors.ts";
+import defaultErrorMap from "../locales/en.ts";
 import type { IssueData, ZodErrorMap, ZodIssue } from "../ZodError.ts";
-import { defaultErrorMap, getErrorMap } from "../ZodError.ts";
 import type { ZodParsedType } from "./util.ts";
 
 export const makeIssue = (params: {
@@ -175,10 +176,3 @@ export const isAsync = <T>(
   x: ParseReturnType<T>
 ): x is AsyncParseReturnType<T> =>
   typeof Promise !== undefined && x instanceof Promise;
-
-export const jsonStringifyReplacer = (_: string, value: any): any => {
-  if (typeof value === "bigint") {
-    return value.toString();
-  }
-  return value;
-};
diff --git a/deno/lib/helpers/util.ts b/deno/lib/helpers/util.ts
index 0fb14668e..bcc2d4251 100644
--- a/deno/lib/helpers/util.ts
+++ b/deno/lib/helpers/util.ts
@@ -84,6 +84,13 @@ export namespace util {
       .map((val) => (typeof val === "string" ? `'${val}'` : val))
       .join(separator);
   }
+
+  export const jsonStringifyReplacer = (_: string, value: any): any => {
+    if (typeof value === "bigint") {
+      return value.toString();
+    }
+    return value;
+  };
 }
 
 export const ZodParsedType = util.arrayToEnum([
diff --git a/deno/lib/locales/en.ts b/deno/lib/locales/en.ts
new file mode 100644
index 000000000..513bb554d
--- /dev/null
+++ b/deno/lib/locales/en.ts
@@ -0,0 +1,117 @@
+import { util, ZodParsedType } from "../helpers/util.ts";
+import { ZodErrorMap, ZodIssueCode } from "../ZodError.ts";
+
+const errorMap: ZodErrorMap = (issue, _ctx) => {
+  let message: string;
+  switch (issue.code) {
+    case ZodIssueCode.invalid_type:
+      if (issue.received === ZodParsedType.undefined) {
+        message = "Required";
+      } else {
+        message = `Expected ${issue.expected}, received ${issue.received}`;
+      }
+      break;
+    case ZodIssueCode.invalid_literal:
+      message = `Invalid literal value, expected ${JSON.stringify(
+        issue.expected,
+        util.jsonStringifyReplacer
+      )}`;
+      break;
+    case ZodIssueCode.unrecognized_keys:
+      message = `Unrecognized key(s) in object: ${util.joinValues(
+        issue.keys,
+        ", "
+      )}`;
+      break;
+    case ZodIssueCode.invalid_union:
+      message = `Invalid input`;
+      break;
+    case ZodIssueCode.invalid_union_discriminator:
+      message = `Invalid discriminator value. Expected ${util.joinValues(
+        issue.options
+      )}`;
+      break;
+    case ZodIssueCode.invalid_enum_value:
+      message = `Invalid enum value. Expected ${util.joinValues(
+        issue.options
+      )}, received '${issue.received}'`;
+      break;
+    case ZodIssueCode.invalid_arguments:
+      message = `Invalid function arguments`;
+      break;
+    case ZodIssueCode.invalid_return_type:
+      message = `Invalid function return type`;
+      break;
+    case ZodIssueCode.invalid_date:
+      message = `Invalid date`;
+      break;
+    case ZodIssueCode.invalid_string:
+      if (typeof issue.validation === "object") {
+        if ("startsWith" in issue.validation) {
+          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
+        } else if ("endsWith" in issue.validation) {
+          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
+        } else {
+          util.assertNever(issue.validation);
+        }
+      } else if (issue.validation !== "regex") {
+        message = `Invalid ${issue.validation}`;
+      } else {
+        message = "Invalid";
+      }
+      break;
+    case ZodIssueCode.too_small:
+      if (issue.type === "array")
+        message = `Array must contain ${
+          issue.inclusive ? `at least` : `more than`
+        } ${issue.minimum} element(s)`;
+      else if (issue.type === "string")
+        message = `String must contain ${
+          issue.inclusive ? `at least` : `over`
+        } ${issue.minimum} character(s)`;
+      else if (issue.type === "number")
+        message = `Number must be greater than ${
+          issue.inclusive ? `or equal to ` : ``
+        }${issue.minimum}`;
+      else if (issue.type === "date")
+        message = `Date must be greater than ${
+          issue.inclusive ? `or equal to ` : ``
+        }${new Date(issue.minimum)}`;
+      else message = "Invalid input";
+      break;
+    case ZodIssueCode.too_big:
+      if (issue.type === "array")
+        message = `Array must contain ${
+          issue.inclusive ? `at most` : `less than`
+        } ${issue.maximum} element(s)`;
+      else if (issue.type === "string")
+        message = `String must contain ${
+          issue.inclusive ? `at most` : `under`
+        } ${issue.maximum} character(s)`;
+      else if (issue.type === "number")
+        message = `Number must be less than ${
+          issue.inclusive ? `or equal to ` : ``
+        }${issue.maximum}`;
+      else if (issue.type === "date")
+        message = `Date must be smaller than ${
+          issue.inclusive ? `or equal to ` : ``
+        }${new Date(issue.maximum)}`;
+      else message = "Invalid input";
+      break;
+    case ZodIssueCode.custom:
+      message = `Invalid input`;
+      break;
+    case ZodIssueCode.invalid_intersection_types:
+      message = `Intersection results could not be merged`;
+      break;
+    case ZodIssueCode.not_multiple_of:
+      message = `Number must be a multiple of ${issue.multipleOf}`;
+      break;
+    default:
+      message = _ctx.defaultError;
+      util.assertNever(issue);
+  }
+  return { message };
+};
+
+export default errorMap;
diff --git a/deno/lib/types.ts b/deno/lib/types.ts
index 69b5a60d2..13f6eaaa9 100644
--- a/deno/lib/types.ts
+++ b/deno/lib/types.ts
@@ -1,3 +1,4 @@
+import { defaultErrorMap, getErrorMap } from "./errors.ts";
 import { enumUtil } from "./helpers/enumUtil.ts";
 import { errorUtil } from "./helpers/errorUtil.ts";
 import {
@@ -23,8 +24,6 @@ import { partialUtil } from "./helpers/partialUtil.ts";
 import { Primitive } from "./helpers/typeAliases.ts";
 import { getParsedType, util, ZodParsedType } from "./helpers/util.ts";
 import {
-  defaultErrorMap,
-  getErrorMap,
   IssueData,
   StringValidation,
   ZodCustomIssue,
@@ -111,7 +110,7 @@ function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
   const { errorMap, invalid_type_error, required_error, description } = params;
   if (errorMap && (invalid_type_error || required_error)) {
     throw new Error(
-      `Can't use "invalid" or "required" in conjunction with custom error map.`
+      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
     );
   }
   if (errorMap) return { errorMap: errorMap, description };
@@ -278,7 +277,7 @@ export abstract class ZodType<
     check: (arg: Output) => unknown,
     message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
   ): ZodEffects<this, Output, Input> {
-    const getIssueProperties: any = (val: Output) => {
+    const getIssueProperties = (val: Output) => {
       if (typeof message === "string" || typeof message === "undefined") {
         return { message };
       } else if (typeof message === "function") {
@@ -1820,8 +1819,8 @@ export class ZodObject<
   ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
   ZodObject<
     extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
-    UnknownKeys,
-    Catchall
+    Incoming["_def"]["unknownKeys"],
+    Incoming["_def"]["catchall"]
   > {
     // const mergedShape = objectUtil.mergeShapes(
     //   this._def.shape(),
@@ -2457,6 +2456,10 @@ export interface ZodTupleDef<
   typeName: ZodFirstPartyTypeKind.ZodTuple;
 }
 
+export type AnyZodTuple = ZodTuple<
+  [ZodTypeAny, ...ZodTypeAny[]] | [],
+  ZodTypeAny | null
+>;
 export class ZodTuple<
   T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
   Rest extends ZodTypeAny | null = null
@@ -2533,6 +2536,9 @@ export class ZodTuple<
     schemas: T,
     params?: RawCreateParams
   ): ZodTuple<T, null> => {
+    if (!Array.isArray(schemas)) {
+      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
+    }
     return new ZodTuple({
       items: schemas,
       typeName: ZodFirstPartyTypeKind.ZodTuple,
@@ -3033,23 +3039,32 @@ export class ZodFunction<
 
   validate = this.implement;
 
-  static create = <
-    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
+  static create(): ZodFunction<ZodTuple<[], ZodUnknown>, ZodUnknown>;
+  static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>>(
+    args: T
+  ): ZodFunction<T, ZodUnknown>;
+  static create<T extends AnyZodTuple, U extends ZodTypeAny>(
+    args: T,
+    returns: U
+  ): ZodFunction<T, U>;
+  static create<
+    T extends AnyZodTuple = ZodTuple<[], ZodUnknown>,
     U extends ZodTypeAny = ZodUnknown
-  >(
-    args?: T,
-    returns?: U,
+  >(args: T, returns: U, params?: RawCreateParams): ZodFunction<T, U>;
+  static create(
+    args?: AnyZodTuple,
+    returns?: ZodTypeAny,
     params?: RawCreateParams
-  ): ZodFunction<T, U> => {
+  ) {
     return new ZodFunction({
       args: (args
-        ? args.rest(ZodUnknown.create())
+        ? args
         : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
       returns: returns || ZodUnknown.create(),
       typeName: ZodFirstPartyTypeKind.ZodFunction,
       ...processCreateParams(params),
     }) as any;
-  };
+  }
 }
 
 ///////////////////////////////////////
@@ -3857,6 +3872,12 @@ export type ZodFirstPartySchemaTypes =
   | ZodPromise<any>
   | ZodBranded<any, any>;
 
+// new approach that works for abstract classes
+// but required TS 4.4+
+// abstract class Class {
+//   constructor(..._: any[]) {}
+// }
+// const instanceOfType = <T extends typeof Class>(
 const instanceOfType = <T extends new (...args: any[]) => any>(
   cls: T,
   params: Parameters<ZodTypeAny["refine"]>[1] = {
@@ -3939,3 +3960,5 @@ export {
   unknownType as unknown,
   voidType as void,
 };
+
+export const NEVER = INVALID as never;
diff --git a/package.json b/package.json
index e17ea2922..bb0235fce 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zod",
-  "version": "3.18.0",
+  "version": "3.19.0",
   "description": "TypeScript-first schema declaration and validation library with static type inference",
   "main": "./lib/index.js",
   "types": "./index.d.ts",
@@ -12,7 +12,8 @@
       "import": "./lib/index.mjs",
       "types": "./index.d.ts"
     },
-    "./package.json": "./package.json"
+    "./package.json": "./package.json",
+    "./locales/*": "./lib/locales/*"
   },
   "files": [
     "/lib",
diff --git a/src/ZodError.ts b/src/ZodError.ts
index 7ddee45e3..e1cc51c60 100644
--- a/src/ZodError.ts
+++ b/src/ZodError.ts
@@ -1,5 +1,4 @@
 import type { TypeOf, ZodType } from ".";
-import { jsonStringifyReplacer } from "./helpers/parseUtil";
 import { Primitive } from "./helpers/typeAliases";
 import { util, ZodParsedType } from "./helpers/util";
 
@@ -251,7 +250,7 @@ export class ZodError<T = any> extends Error {
     return this.message;
   }
   get message() {
-    return JSON.stringify(this.issues, jsonStringifyReplacer, 2);
+    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
   }
 
   get isEmpty(): boolean {
@@ -299,134 +298,12 @@ export type IssueData = stripPath<ZodIssueOptionalMessage> & {
 };
 export type MakeErrorData = IssueData;
 
-type ErrorMapCtx = {
+export type ErrorMapCtx = {
   defaultError: string;
   data: any;
 };
 
-export type ZodErrorMap = typeof defaultErrorMap;
-export const defaultErrorMap = (
+export type ZodErrorMap = (
   issue: ZodIssueOptionalMessage,
   _ctx: ErrorMapCtx
-): { message: string } => {
-  let message: string;
-  switch (issue.code) {
-    case ZodIssueCode.invalid_type:
-      if (issue.received === ZodParsedType.undefined) {
-        message = "Required";
-      } else {
-        message = `Expected ${issue.expected}, received ${issue.received}`;
-      }
-      break;
-    case ZodIssueCode.invalid_literal:
-      message = `Invalid literal value, expected ${JSON.stringify(
-        issue.expected,
-        jsonStringifyReplacer
-      )}`;
-      break;
-    case ZodIssueCode.unrecognized_keys:
-      message = `Unrecognized key(s) in object: ${util.joinValues(
-        issue.keys,
-        ", "
-      )}`;
-      break;
-    case ZodIssueCode.invalid_union:
-      message = `Invalid input`;
-      break;
-    case ZodIssueCode.invalid_union_discriminator:
-      message = `Invalid discriminator value. Expected ${util.joinValues(
-        issue.options
-      )}`;
-      break;
-    case ZodIssueCode.invalid_enum_value:
-      message = `Invalid enum value. Expected ${util.joinValues(
-        issue.options
-      )}, received '${issue.received}'`;
-      break;
-    case ZodIssueCode.invalid_arguments:
-      message = `Invalid function arguments`;
-      break;
-    case ZodIssueCode.invalid_return_type:
-      message = `Invalid function return type`;
-      break;
-    case ZodIssueCode.invalid_date:
-      message = `Invalid date`;
-      break;
-    case ZodIssueCode.invalid_string:
-      if (typeof issue.validation === "object") {
-        if ("startsWith" in issue.validation) {
-          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
-        } else if ("endsWith" in issue.validation) {
-          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
-        } else {
-          util.assertNever(issue.validation);
-        }
-      } else if (issue.validation !== "regex") {
-        message = `Invalid ${issue.validation}`;
-      } else {
-        message = "Invalid";
-      }
-      break;
-    case ZodIssueCode.too_small:
-      if (issue.type === "array")
-        message = `Array must contain ${
-          issue.inclusive ? `at least` : `more than`
-        } ${issue.minimum} element(s)`;
-      else if (issue.type === "string")
-        message = `String must contain ${
-          issue.inclusive ? `at least` : `over`
-        } ${issue.minimum} character(s)`;
-      else if (issue.type === "number")
-        message = `Number must be greater than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${issue.minimum}`;
-      else if (issue.type === "date")
-        message = `Date must be greater than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${new Date(issue.minimum)}`;
-      else message = "Invalid input";
-      break;
-    case ZodIssueCode.too_big:
-      if (issue.type === "array")
-        message = `Array must contain ${
-          issue.inclusive ? `at most` : `less than`
-        } ${issue.maximum} element(s)`;
-      else if (issue.type === "string")
-        message = `String must contain ${
-          issue.inclusive ? `at most` : `under`
-        } ${issue.maximum} character(s)`;
-      else if (issue.type === "number")
-        message = `Number must be less than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${issue.maximum}`;
-      else if (issue.type === "date")
-        message = `Date must be smaller than ${
-          issue.inclusive ? `or equal to ` : ``
-        }${new Date(issue.maximum)}`;
-      else message = "Invalid input";
-      break;
-    case ZodIssueCode.custom:
-      message = `Invalid input`;
-      break;
-    case ZodIssueCode.invalid_intersection_types:
-      message = `Intersection results could not be merged`;
-      break;
-    case ZodIssueCode.not_multiple_of:
-      message = `Number must be a multiple of ${issue.multipleOf}`;
-      break;
-    default:
-      message = _ctx.defaultError;
-      util.assertNever(issue);
-  }
-  return { message };
-};
-
-let overrideErrorMap = defaultErrorMap;
-
-export function setErrorMap(map: ZodErrorMap) {
-  overrideErrorMap = map;
-}
-
-export function getErrorMap() {
-  return overrideErrorMap;
-}
+) => { message: string };
diff --git a/src/__tests__/function.test.ts b/src/__tests__/function.test.ts
index 8010f3de1..3767e867c 100644
--- a/src/__tests__/function.test.ts
+++ b/src/__tests__/function.test.ts
@@ -109,6 +109,8 @@ test("output validation error", () => {
   expect(checker).toThrow();
 });
 
+z.function(z.tuple([z.string()])).args()._def.args;
+
 test("special function error codes", () => {
   const checker = z
     .function(z.tuple([z.string()]), z.boolean())
diff --git a/src/__tests__/instanceof.test.ts b/src/__tests__/instanceof.test.ts
index f6f743f28..0839322bb 100644
--- a/src/__tests__/instanceof.test.ts
+++ b/src/__tests__/instanceof.test.ts
@@ -7,13 +7,20 @@ import * as z from "../index";
 test("instanceof", async () => {
   class Test {}
   class Subtest extends Test {}
+  abstract class AbstractBar {
+    constructor(public val: string) {}
+  }
+  class Bar extends AbstractBar {}
 
   const TestSchema = z.instanceof(Test);
   const SubtestSchema = z.instanceof(Subtest);
+  const BarSchema = z.instanceof(Bar);
 
   TestSchema.parse(new Test());
   TestSchema.parse(new Subtest());
   SubtestSchema.parse(new Subtest());
+  const bar = BarSchema.parse(new Bar("asdf"));
+  expect(bar.val).toEqual("asdf");
 
   await expect(() => SubtestSchema.parse(new Test())).toThrow(
     /Input not instance of Subtest/
diff --git a/src/__tests__/object.test.ts b/src/__tests__/object.test.ts
index 17e636989..c4d2fe1f8 100644
--- a/src/__tests__/object.test.ts
+++ b/src/__tests__/object.test.ts
@@ -364,3 +364,26 @@ test("constructor key", () => {
   type Example = z.infer<typeof Example>;
   util.assertEqual<keyof Example, "prop" | "opt" | "arr">(true);
 });
+
+test("unknownkeys merging", () => {
+  // This one is "strict"
+  const schemaA = z
+    .object({
+      a: z.string(),
+    })
+    .strict();
+
+  // This one is "strip"
+  const schemaB = z
+    .object({
+      b: z.string(),
+    })
+    .catchall(z.string());
+
+  const mergedSchema = schemaA.merge(schemaB);
+  type mergedSchema = typeof mergedSchema;
+  util.assertEqual<mergedSchema["_def"]["unknownKeys"], "strip">(true);
+  expect(mergedSchema._def.unknownKeys).toEqual("strip");
+  util.assertEqual<mergedSchema["_def"]["catchall"], z.ZodString>(true);
+  expect(mergedSchema._def.catchall instanceof z.ZodString).toEqual(true);
+});
diff --git a/src/__tests__/transformer.test.ts b/src/__tests__/transformer.test.ts
index 398c465b8..45fba26a6 100644
--- a/src/__tests__/transformer.test.ts
+++ b/src/__tests__/transformer.test.ts
@@ -73,6 +73,25 @@ test("transform ctx.addIssue with parseAsync", async () => {
   });
 });
 
+test("z.NEVER in transform", async () => {
+  const foo = z
+    .number()
+    .optional()
+    .transform((val, ctx) => {
+      if (!val) {
+        ctx.addIssue({ code: z.ZodIssueCode.custom, message: "bad" });
+        return z.NEVER;
+      }
+      return val;
+    });
+  type foo = z.infer<typeof foo>;
+  util.assertEqual<foo, number>(true);
+  const arg = foo.safeParse(undefined);
+  if (!arg.success) {
+    expect(arg.error.issues[0].message).toEqual("bad");
+  }
+});
+
 test("basic transformations", () => {
   const r1 = z
     .string()
diff --git a/src/errors.ts b/src/errors.ts
new file mode 100644
index 000000000..17e7404b8
--- /dev/null
+++ b/src/errors.ts
@@ -0,0 +1,13 @@
+import defaultErrorMap from "./locales/en";
+import type { ZodErrorMap } from "./ZodError";
+
+let overrideErrorMap = defaultErrorMap;
+export { defaultErrorMap };
+
+export function setErrorMap(map: ZodErrorMap) {
+  overrideErrorMap = map;
+}
+
+export function getErrorMap() {
+  return overrideErrorMap;
+}
diff --git a/src/external.ts b/src/external.ts
index 9da2ca5ce..a2d8aeda2 100644
--- a/src/external.ts
+++ b/src/external.ts
@@ -1,3 +1,4 @@
+export * from "./errors";
 export * from "./helpers/parseUtil";
 export * from "./helpers/typeAliases";
 export { getParsedType, ZodParsedType } from "./helpers/util";
diff --git a/src/helpers/parseUtil.ts b/src/helpers/parseUtil.ts
index 7df8c0b02..3edd467e9 100644
--- a/src/helpers/parseUtil.ts
+++ b/src/helpers/parseUtil.ts
@@ -1,5 +1,6 @@
+import { getErrorMap } from "../errors";
+import defaultErrorMap from "../locales/en";
 import type { IssueData, ZodErrorMap, ZodIssue } from "../ZodError";
-import { defaultErrorMap, getErrorMap } from "../ZodError";
 import type { ZodParsedType } from "./util";
 
 export const makeIssue = (params: {
@@ -175,10 +176,3 @@ export const isAsync = <T>(
   x: ParseReturnType<T>
 ): x is AsyncParseReturnType<T> =>
   typeof Promise !== undefined && x instanceof Promise;
-
-export const jsonStringifyReplacer = (_: string, value: any): any => {
-  if (typeof value === "bigint") {
-    return value.toString();
-  }
-  return value;
-};
diff --git a/src/helpers/util.ts b/src/helpers/util.ts
index 0fb14668e..bcc2d4251 100644
--- a/src/helpers/util.ts
+++ b/src/helpers/util.ts
@@ -84,6 +84,13 @@ export namespace util {
       .map((val) => (typeof val === "string" ? `'${val}'` : val))
       .join(separator);
   }
+
+  export const jsonStringifyReplacer = (_: string, value: any): any => {
+    if (typeof value === "bigint") {
+      return value.toString();
+    }
+    return value;
+  };
 }
 
 export const ZodParsedType = util.arrayToEnum([
diff --git a/src/locales/en.ts b/src/locales/en.ts
new file mode 100644
index 000000000..b8b9e7036
--- /dev/null
+++ b/src/locales/en.ts
@@ -0,0 +1,117 @@
+import { util, ZodParsedType } from "../helpers/util";
+import { ZodErrorMap, ZodIssueCode } from "../ZodError";
+
+const errorMap: ZodErrorMap = (issue, _ctx) => {
+  let message: string;
+  switch (issue.code) {
+    case ZodIssueCode.invalid_type:
+      if (issue.received === ZodParsedType.undefined) {
+        message = "Required";
+      } else {
+        message = `Expected ${issue.expected}, received ${issue.received}`;
+      }
+      break;
+    case ZodIssueCode.invalid_literal:
+      message = `Invalid literal value, expected ${JSON.stringify(
+        issue.expected,
+        util.jsonStringifyReplacer
+      )}`;
+      break;
+    case ZodIssueCode.unrecognized_keys:
+      message = `Unrecognized key(s) in object: ${util.joinValues(
+        issue.keys,
+        ", "
+      )}`;
+      break;
+    case ZodIssueCode.invalid_union:
+      message = `Invalid input`;
+      break;
+    case ZodIssueCode.invalid_union_discriminator:
+      message = `Invalid discriminator value. Expected ${util.joinValues(
+        issue.options
+      )}`;
+      break;
+    case ZodIssueCode.invalid_enum_value:
+      message = `Invalid enum value. Expected ${util.joinValues(
+        issue.options
+      )}, received '${issue.received}'`;
+      break;
+    case ZodIssueCode.invalid_arguments:
+      message = `Invalid function arguments`;
+      break;
+    case ZodIssueCode.invalid_return_type:
+      message = `Invalid function return type`;
+      break;
+    case ZodIssueCode.invalid_date:
+      message = `Invalid date`;
+      break;
+    case ZodIssueCode.invalid_string:
+      if (typeof issue.validation === "object") {
+        if ("startsWith" in issue.validation) {
+          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
+        } else if ("endsWith" in issue.validation) {
+          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
+        } else {
+          util.assertNever(issue.validation);
+        }
+      } else if (issue.validation !== "regex") {
+        message = `Invalid ${issue.validation}`;
+      } else {
+        message = "Invalid";
+      }
+      break;
+    case ZodIssueCode.too_small:
+      if (issue.type === "array")
+        message = `Array must contain ${
+          issue.inclusive ? `at least` : `more than`
+        } ${issue.minimum} element(s)`;
+      else if (issue.type === "string")
+        message = `String must contain ${
+          issue.inclusive ? `at least` : `over`
+        } ${issue.minimum} character(s)`;
+      else if (issue.type === "number")
+        message = `Number must be greater than ${
+          issue.inclusive ? `or equal to ` : ``
+        }${issue.minimum}`;
+      else if (issue.type === "date")
+        message = `Date must be greater than ${
+          issue.inclusive ? `or equal to ` : ``
+        }${new Date(issue.minimum)}`;
+      else message = "Invalid input";
+      break;
+    case ZodIssueCode.too_big:
+      if (issue.type === "array")
+        message = `Array must contain ${
+          issue.inclusive ? `at most` : `less than`
+        } ${issue.maximum} element(s)`;
+      else if (issue.type === "string")
+        message = `String must contain ${
+          issue.inclusive ? `at most` : `under`
+        } ${issue.maximum} character(s)`;
+      else if (issue.type === "number")
+        message = `Number must be less than ${
+          issue.inclusive ? `or equal to ` : ``
+        }${issue.maximum}`;
+      else if (issue.type === "date")
+        message = `Date must be smaller than ${
+          issue.inclusive ? `or equal to ` : ``
+        }${new Date(issue.maximum)}`;
+      else message = "Invalid input";
+      break;
+    case ZodIssueCode.custom:
+      message = `Invalid input`;
+      break;
+    case ZodIssueCode.invalid_intersection_types:
+      message = `Intersection results could not be merged`;
+      break;
+    case ZodIssueCode.not_multiple_of:
+      message = `Number must be a multiple of ${issue.multipleOf}`;
+      break;
+    default:
+      message = _ctx.defaultError;
+      util.assertNever(issue);
+  }
+  return { message };
+};
+
+export default errorMap;
diff --git a/src/types.ts b/src/types.ts
index af635eefc..1d4badcdd 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -1,3 +1,4 @@
+import { defaultErrorMap, getErrorMap } from "./errors";
 import { enumUtil } from "./helpers/enumUtil";
 import { errorUtil } from "./helpers/errorUtil";
 import {
@@ -23,8 +24,6 @@ import { partialUtil } from "./helpers/partialUtil";
 import { Primitive } from "./helpers/typeAliases";
 import { getParsedType, util, ZodParsedType } from "./helpers/util";
 import {
-  defaultErrorMap,
-  getErrorMap,
   IssueData,
   StringValidation,
   ZodCustomIssue,
@@ -111,7 +110,7 @@ function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
   const { errorMap, invalid_type_error, required_error, description } = params;
   if (errorMap && (invalid_type_error || required_error)) {
     throw new Error(
-      `Can't use "invalid" or "required" in conjunction with custom error map.`
+      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
     );
   }
   if (errorMap) return { errorMap: errorMap, description };
@@ -278,7 +277,7 @@ export abstract class ZodType<
     check: (arg: Output) => unknown,
     message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
   ): ZodEffects<this, Output, Input> {
-    const getIssueProperties: any = (val: Output) => {
+    const getIssueProperties = (val: Output) => {
       if (typeof message === "string" || typeof message === "undefined") {
         return { message };
       } else if (typeof message === "function") {
@@ -1820,8 +1819,8 @@ export class ZodObject<
   ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
   ZodObject<
     extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
-    UnknownKeys,
-    Catchall
+    Incoming["_def"]["unknownKeys"],
+    Incoming["_def"]["catchall"]
   > {
     // const mergedShape = objectUtil.mergeShapes(
     //   this._def.shape(),
@@ -2457,6 +2456,10 @@ export interface ZodTupleDef<
   typeName: ZodFirstPartyTypeKind.ZodTuple;
 }
 
+export type AnyZodTuple = ZodTuple<
+  [ZodTypeAny, ...ZodTypeAny[]] | [],
+  ZodTypeAny | null
+>;
 export class ZodTuple<
   T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
   Rest extends ZodTypeAny | null = null
@@ -2533,6 +2536,9 @@ export class ZodTuple<
     schemas: T,
     params?: RawCreateParams
   ): ZodTuple<T, null> => {
+    if (!Array.isArray(schemas)) {
+      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
+    }
     return new ZodTuple({
       items: schemas,
       typeName: ZodFirstPartyTypeKind.ZodTuple,
@@ -3033,23 +3039,32 @@ export class ZodFunction<
 
   validate = this.implement;
 
-  static create = <
-    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
+  static create(): ZodFunction<ZodTuple<[], ZodUnknown>, ZodUnknown>;
+  static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>>(
+    args: T
+  ): ZodFunction<T, ZodUnknown>;
+  static create<T extends AnyZodTuple, U extends ZodTypeAny>(
+    args: T,
+    returns: U
+  ): ZodFunction<T, U>;
+  static create<
+    T extends AnyZodTuple = ZodTuple<[], ZodUnknown>,
     U extends ZodTypeAny = ZodUnknown
-  >(
-    args?: T,
-    returns?: U,
+  >(args: T, returns: U, params?: RawCreateParams): ZodFunction<T, U>;
+  static create(
+    args?: AnyZodTuple,
+    returns?: ZodTypeAny,
     params?: RawCreateParams
-  ): ZodFunction<T, U> => {
+  ) {
     return new ZodFunction({
       args: (args
-        ? args.rest(ZodUnknown.create())
+        ? args
         : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
       returns: returns || ZodUnknown.create(),
       typeName: ZodFirstPartyTypeKind.ZodFunction,
       ...processCreateParams(params),
     }) as any;
-  };
+  }
 }
 
 ///////////////////////////////////////
@@ -3857,6 +3872,12 @@ export type ZodFirstPartySchemaTypes =
   | ZodPromise<any>
   | ZodBranded<any, any>;
 
+// new approach that works for abstract classes
+// but required TS 4.4+
+// abstract class Class {
+//   constructor(..._: any[]) {}
+// }
+// const instanceOfType = <T extends typeof Class>(
 const instanceOfType = <T extends new (...args: any[]) => any>(
   cls: T,
   params: Parameters<ZodTypeAny["refine"]>[1] = {
@@ -3939,3 +3960,5 @@ export {
   unknownType as unknown,
   voidType as void,
 };
+
+export const NEVER = INVALID as never;
